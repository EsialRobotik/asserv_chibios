
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <_vectors>:
 8000000:	20000800 	.word	0x20000800
 8000004:	08000321 	.word	0x08000321
 8000008:	08000323 	.word	0x08000323
 800000c:	08000323 	.word	0x08000323
 8000010:	08000323 	.word	0x08000323
 8000014:	08000323 	.word	0x08000323
 8000018:	08000323 	.word	0x08000323
 800001c:	08000323 	.word	0x08000323
 8000020:	08000323 	.word	0x08000323
 8000024:	08000323 	.word	0x08000323
 8000028:	08000323 	.word	0x08000323
 800002c:	08008ef1 	.word	0x08008ef1
 8000030:	08000323 	.word	0x08000323
 8000034:	08000323 	.word	0x08000323
 8000038:	08000323 	.word	0x08000323
 800003c:	08000323 	.word	0x08000323
 8000040:	08000323 	.word	0x08000323
 8000044:	08000323 	.word	0x08000323
 8000048:	08000323 	.word	0x08000323
 800004c:	08000323 	.word	0x08000323
 8000050:	08000323 	.word	0x08000323
 8000054:	08000323 	.word	0x08000323
 8000058:	08000323 	.word	0x08000323
 800005c:	08000323 	.word	0x08000323
 8000060:	08000323 	.word	0x08000323
 8000064:	08000323 	.word	0x08000323
 8000068:	08000323 	.word	0x08000323
 800006c:	08000323 	.word	0x08000323
 8000070:	08000323 	.word	0x08000323
 8000074:	08000323 	.word	0x08000323
 8000078:	08000323 	.word	0x08000323
 800007c:	08000323 	.word	0x08000323
 8000080:	08000323 	.word	0x08000323
 8000084:	08000323 	.word	0x08000323
 8000088:	08000323 	.word	0x08000323
 800008c:	08000323 	.word	0x08000323
 8000090:	08000323 	.word	0x08000323
 8000094:	08000323 	.word	0x08000323
 8000098:	08000323 	.word	0x08000323
 800009c:	08000323 	.word	0x08000323
 80000a0:	08000323 	.word	0x08000323
 80000a4:	08000323 	.word	0x08000323
 80000a8:	08000323 	.word	0x08000323
 80000ac:	08000323 	.word	0x08000323
 80000b0:	08000323 	.word	0x08000323
 80000b4:	08000323 	.word	0x08000323
 80000b8:	08006f21 	.word	0x08006f21
 80000bc:	08000323 	.word	0x08000323
 80000c0:	08000323 	.word	0x08000323
 80000c4:	08000323 	.word	0x08000323
 80000c8:	08000323 	.word	0x08000323
 80000cc:	08000323 	.word	0x08000323
 80000d0:	08000323 	.word	0x08000323
 80000d4:	08000323 	.word	0x08000323
 80000d8:	08006bf1 	.word	0x08006bf1
 80000dc:	08000323 	.word	0x08000323
 80000e0:	08000323 	.word	0x08000323
 80000e4:	08000323 	.word	0x08000323
 80000e8:	08000323 	.word	0x08000323
 80000ec:	08000323 	.word	0x08000323
 80000f0:	08006f01 	.word	0x08006f01
 80000f4:	08000323 	.word	0x08000323
 80000f8:	08006ee1 	.word	0x08006ee1
 80000fc:	08000323 	.word	0x08000323
 8000100:	08000323 	.word	0x08000323
 8000104:	08000323 	.word	0x08000323
 8000108:	08006fa1 	.word	0x08006fa1
 800010c:	08000323 	.word	0x08000323
 8000110:	08000323 	.word	0x08000323
 8000114:	08000323 	.word	0x08000323
 8000118:	08000323 	.word	0x08000323
 800011c:	08000323 	.word	0x08000323
 8000120:	08000323 	.word	0x08000323
 8000124:	08000323 	.word	0x08000323
 8000128:	08000323 	.word	0x08000323
 800012c:	08000323 	.word	0x08000323
 8000130:	08000323 	.word	0x08000323
 8000134:	08000323 	.word	0x08000323
 8000138:	08000323 	.word	0x08000323
 800013c:	08000323 	.word	0x08000323
 8000140:	08000323 	.word	0x08000323
 8000144:	08000323 	.word	0x08000323
 8000148:	08000323 	.word	0x08000323
 800014c:	08000323 	.word	0x08000323
 8000150:	08000323 	.word	0x08000323
 8000154:	08000323 	.word	0x08000323
 8000158:	08000323 	.word	0x08000323
 800015c:	08000323 	.word	0x08000323
 8000160:	08000323 	.word	0x08000323
 8000164:	08000323 	.word	0x08000323
 8000168:	08000323 	.word	0x08000323
 800016c:	08000323 	.word	0x08000323
 8000170:	08000323 	.word	0x08000323
 8000174:	08005c91 	.word	0x08005c91
 8000178:	08000323 	.word	0x08000323
 800017c:	08000323 	.word	0x08000323
 8000180:	08000323 	.word	0x08000323
 8000184:	08000323 	.word	0x08000323
 8000188:	08000323 	.word	0x08000323
 800018c:	08000323 	.word	0x08000323
 8000190:	08000323 	.word	0x08000323
 8000194:	08000323 	.word	0x08000323
 8000198:	08000323 	.word	0x08000323
 800019c:	08000323 	.word	0x08000323
 80001a0:	08000323 	.word	0x08000323
 80001a4:	08000323 	.word	0x08000323
 80001a8:	08000323 	.word	0x08000323
 80001ac:	08000323 	.word	0x08000323
 80001b0:	08000323 	.word	0x08000323
 80001b4:	08000323 	.word	0x08000323
 80001b8:	08000323 	.word	0x08000323
 80001bc:	08000323 	.word	0x08000323
 80001c0:	08000323 	.word	0x08000323
 80001c4:	08000323 	.word	0x08000323
 80001c8:	08000323 	.word	0x08000323
 80001cc:	08000323 	.word	0x08000323
 80001d0:	08000323 	.word	0x08000323
 80001d4:	08000323 	.word	0x08000323
 80001d8:	08000323 	.word	0x08000323
 80001dc:	08000323 	.word	0x08000323

Disassembly of section .text:

08000200 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 8000200:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 8000202:	4839      	ldr	r0, [pc, #228]	; (80002e8 <endfiniloop+0x6>)
                msr     MSP, r0
 8000204:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 8000208:	4838      	ldr	r0, [pc, #224]	; (80002ec <endfiniloop+0xa>)
                msr     PSP, r0
 800020a:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 800020e:	4838      	ldr	r0, [pc, #224]	; (80002f0 <endfiniloop+0xe>)
                movw    r1, #SCB_VTOR & 0xFFFF
 8000210:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 8000214:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 8000218:	6008      	str	r0, [r1, #0]
#endif

#if CRT0_INIT_FPU == TRUE
                /* FPU FPCCR initialization.*/
                movw    r0, #CRT0_FPCCR_INIT & 0xFFFF
 800021a:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_FPCCR_INIT >> 16
 800021e:	f2cc 0000 	movt	r0, #49152	; 0xc000
                movw    r1, #SCB_FPCCR & 0xFFFF
 8000222:	f64e 7134 	movw	r1, #61236	; 0xef34
                movt    r1, #SCB_FPCCR >> 16
 8000226:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 800022a:	6008      	str	r0, [r1, #0]
                dsb
 800022c:	f3bf 8f4f 	dsb	sy
                isb
 8000230:	f3bf 8f6f 	isb	sy

                /* CPACR initialization.*/
                movw    r0, #CRT0_CPACR_INIT & 0xFFFF
 8000234:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_CPACR_INIT >> 16
 8000238:	f2c0 00f0 	movt	r0, #240	; 0xf0
                movw    r1, #SCB_CPACR & 0xFFFF
 800023c:	f64e 5188 	movw	r1, #60808	; 0xed88
                movt    r1, #SCB_CPACR >> 16
 8000240:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 8000244:	6008      	str	r0, [r1, #0]
                dsb
 8000246:	f3bf 8f4f 	dsb	sy
                isb
 800024a:	f3bf 8f6f 	isb	sy

                /* FPU FPSCR initially cleared.*/
                mov     r0, #0
 800024e:	f04f 0000 	mov.w	r0, #0
                vmsr    FPSCR, r0
 8000252:	eee1 0a10 	vmsr	fpscr, r0

                /* FPU FPDSCR initially cleared.*/
                movw    r1, #SCB_FPDSCR & 0xFFFF
 8000256:	f64e 713c 	movw	r1, #61244	; 0xef3c
                movt    r1, #SCB_FPDSCR >> 16
 800025a:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 800025e:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA
 8000260:	2006      	movs	r0, #6
#else
                movs    r0, #CRT0_CONTROL_INIT
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 8000262:	f380 8814 	msr	CONTROL, r0
                isb
 8000266:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 800026a:	f003 f939 	bl	80034e0 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 800026e:	f006 fc7f 	bl	8006b70 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8000272:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000276:	491f      	ldr	r1, [pc, #124]	; (80002f4 <endfiniloop+0x12>)
                ldr     r2, =__main_stack_end__
 8000278:	4a1b      	ldr	r2, [pc, #108]	; (80002e8 <endfiniloop+0x6>)

0800027a <msloop>:
msloop:
                cmp     r1, r2
 800027a:	4291      	cmp	r1, r2
                itt     lo
 800027c:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800027e:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000282:	e7fa      	bcc.n	800027a <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000284:	491c      	ldr	r1, [pc, #112]	; (80002f8 <endfiniloop+0x16>)
                ldr     r2, =__process_stack_end__
 8000286:	4a19      	ldr	r2, [pc, #100]	; (80002ec <endfiniloop+0xa>)

08000288 <psloop>:
psloop:
                cmp     r1, r2
 8000288:	4291      	cmp	r1, r2
                itt     lo
 800028a:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800028c:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8000290:	e7fa      	bcc.n	8000288 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 8000292:	491a      	ldr	r1, [pc, #104]	; (80002fc <endfiniloop+0x1a>)
                ldr     r2, =_data_start
 8000294:	4a1a      	ldr	r2, [pc, #104]	; (8000300 <endfiniloop+0x1e>)
                ldr     r3, =_data_end
 8000296:	4b1b      	ldr	r3, [pc, #108]	; (8000304 <endfiniloop+0x22>)

08000298 <dloop>:
dloop:
                cmp     r2, r3
 8000298:	429a      	cmp	r2, r3
                ittt    lo
 800029a:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 800029c:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 80002a0:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 80002a4:	e7f8      	bcc.n	8000298 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 80002a6:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 80002a8:	4917      	ldr	r1, [pc, #92]	; (8000308 <endfiniloop+0x26>)
                ldr     r2, =_bss_end
 80002aa:	4a18      	ldr	r2, [pc, #96]	; (800030c <endfiniloop+0x2a>)

080002ac <bloop>:
bloop:
                cmp     r1, r2
 80002ac:	4291      	cmp	r1, r2
                itt     lo
 80002ae:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80002b0:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 80002b4:	e7fa      	bcc.n	80002ac <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 80002b6:	f003 f8e3 	bl	8003480 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 80002ba:	f003 f909 	bl	80034d0 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 80002be:	4c14      	ldr	r4, [pc, #80]	; (8000310 <endfiniloop+0x2e>)
                ldr     r5, =__init_array_end
 80002c0:	4d14      	ldr	r5, [pc, #80]	; (8000314 <endfiniloop+0x32>)

080002c2 <initloop>:
initloop:
                cmp     r4, r5
 80002c2:	42ac      	cmp	r4, r5
                bge     endinitloop
 80002c4:	da03      	bge.n	80002ce <endinitloop>
                ldr     r1, [r4], #4
 80002c6:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 80002ca:	4788      	blx	r1
                b       initloop
 80002cc:	e7f9      	b.n	80002c2 <initloop>

080002ce <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 80002ce:	f00c fa07 	bl	800c6e0 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 80002d2:	4c11      	ldr	r4, [pc, #68]	; (8000318 <endfiniloop+0x36>)
                ldr     r5, =__fini_array_end
 80002d4:	4d11      	ldr	r5, [pc, #68]	; (800031c <endfiniloop+0x3a>)

080002d6 <finiloop>:
finiloop:
                cmp     r4, r5
 80002d6:	42ac      	cmp	r4, r5
                bge     endfiniloop
 80002d8:	da03      	bge.n	80002e2 <endfiniloop>
                ldr     r1, [r4], #4
 80002da:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 80002de:	4788      	blx	r1
                b       finiloop
 80002e0:	e7f9      	b.n	80002d6 <finiloop>

080002e2 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 80002e2:	f003 b8ed 	b.w	80034c0 <__default_exit>
 80002e6:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 80002e8:	20000800 	.word	0x20000800
                ldr     r0, =__process_stack_end__
 80002ec:	20001c00 	.word	0x20001c00
                ldr     r0, =_vectors
 80002f0:	08000000 	.word	0x08000000
                ldr     r1, =__main_stack_base__
 80002f4:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 80002f8:	20000800 	.word	0x20000800
                ldr     r1, =_textdata_start
 80002fc:	08011154 	.word	0x08011154
                ldr     r2, =_data_start
 8000300:	20001c00 	.word	0x20001c00
                ldr     r3, =_data_end
 8000304:	200025b4 	.word	0x200025b4
                ldr     r1, =_bss_start
 8000308:	200025b8 	.word	0x200025b8
                ldr     r2, =_bss_end
 800030c:	20003e50 	.word	0x20003e50
                ldr     r4, =__init_array_start
 8000310:	080001e0 	.word	0x080001e0
                ldr     r5, =__init_array_end
 8000314:	080001e4 	.word	0x080001e4
                ldr     r4, =__fini_array_start
 8000318:	080001e4 	.word	0x080001e4
                ldr     r5, =__fini_array_end
 800031c:	080001e4 	.word	0x080001e4

08000320 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 8000320:	e76e      	b.n	8000200 <_crt0_entry>

08000322 <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 8000322:	f000 f800 	bl	8000326 <_unhandled_exception>

08000326 <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 8000326:	e7fe      	b.n	8000326 <_unhandled_exception>

08000328 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8000328:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
 800032c:	ed2d 8a10 	vpush	{s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 8000330:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 8000334:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 8000336:	469d      	mov	sp, r3
#else
                ldr     sp, [r0, #CONTEXT_OFFSET]
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
 8000338:	ecbd 8a10 	vpop	{s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 800033c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000340 <_port_thread_start>:
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 8000340:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 8000342:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 8000346:	4628      	mov	r0, r5
                blx     r4
 8000348:	47a0      	blx	r4
#if defined(_CHIBIOS_RT_CONF_)
                movs    r0, #0              /* MSG_OK */
 800034a:	2000      	movs	r0, #0
                bl      chThdExit
 800034c:	f00b fbb0 	bl	800bab0 <chThdExit>

08000350 <_port_switch_from_isr>:
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
 8000350:	f00b f8be 	bl	800b4d0 <chSchDoReschedule>

08000354 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 8000354:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 8000356:	e7fe      	b.n	8000356 <_port_exit_from_isr+0x2>

08000358 <selfrel_offset31>:
 8000358:	6803      	ldr	r3, [r0, #0]
 800035a:	005a      	lsls	r2, r3, #1
 800035c:	bf4c      	ite	mi
 800035e:	f043 4300 	orrmi.w	r3, r3, #2147483648	; 0x80000000
 8000362:	f023 4300 	bicpl.w	r3, r3, #2147483648	; 0x80000000
 8000366:	4418      	add	r0, r3
 8000368:	4770      	bx	lr
 800036a:	bf00      	nop

0800036c <search_EIT_table>:
 800036c:	b361      	cbz	r1, 80003c8 <search_EIT_table+0x5c>
 800036e:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000372:	f101 3aff 	add.w	sl, r1, #4294967295	; 0xffffffff
 8000376:	4690      	mov	r8, r2
 8000378:	4606      	mov	r6, r0
 800037a:	46d1      	mov	r9, sl
 800037c:	2700      	movs	r7, #0
 800037e:	eb07 0409 	add.w	r4, r7, r9
 8000382:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
 8000386:	1064      	asrs	r4, r4, #1
 8000388:	00e5      	lsls	r5, r4, #3
 800038a:	1971      	adds	r1, r6, r5
 800038c:	4608      	mov	r0, r1
 800038e:	f7ff ffe3 	bl	8000358 <selfrel_offset31>
 8000392:	45a2      	cmp	sl, r4
 8000394:	4683      	mov	fp, r0
 8000396:	f105 0008 	add.w	r0, r5, #8
 800039a:	4430      	add	r0, r6
 800039c:	d009      	beq.n	80003b2 <search_EIT_table+0x46>
 800039e:	f7ff ffdb 	bl	8000358 <selfrel_offset31>
 80003a2:	45c3      	cmp	fp, r8
 80003a4:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
 80003a8:	d805      	bhi.n	80003b6 <search_EIT_table+0x4a>
 80003aa:	4540      	cmp	r0, r8
 80003ac:	d209      	bcs.n	80003c2 <search_EIT_table+0x56>
 80003ae:	1c67      	adds	r7, r4, #1
 80003b0:	e7e5      	b.n	800037e <search_EIT_table+0x12>
 80003b2:	45c3      	cmp	fp, r8
 80003b4:	d905      	bls.n	80003c2 <search_EIT_table+0x56>
 80003b6:	42a7      	cmp	r7, r4
 80003b8:	d002      	beq.n	80003c0 <search_EIT_table+0x54>
 80003ba:	f104 39ff 	add.w	r9, r4, #4294967295	; 0xffffffff
 80003be:	e7de      	b.n	800037e <search_EIT_table+0x12>
 80003c0:	2100      	movs	r1, #0
 80003c2:	4608      	mov	r0, r1
 80003c4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80003c8:	4608      	mov	r0, r1
 80003ca:	4770      	bx	lr

080003cc <__gnu_unwind_get_pr_addr>:
 80003cc:	2801      	cmp	r0, #1
 80003ce:	d007      	beq.n	80003e0 <__gnu_unwind_get_pr_addr+0x14>
 80003d0:	2802      	cmp	r0, #2
 80003d2:	d007      	beq.n	80003e4 <__gnu_unwind_get_pr_addr+0x18>
 80003d4:	4b04      	ldr	r3, [pc, #16]	; (80003e8 <__gnu_unwind_get_pr_addr+0x1c>)
 80003d6:	2800      	cmp	r0, #0
 80003d8:	bf0c      	ite	eq
 80003da:	4618      	moveq	r0, r3
 80003dc:	2000      	movne	r0, #0
 80003de:	4770      	bx	lr
 80003e0:	4802      	ldr	r0, [pc, #8]	; (80003ec <__gnu_unwind_get_pr_addr+0x20>)
 80003e2:	4770      	bx	lr
 80003e4:	4802      	ldr	r0, [pc, #8]	; (80003f0 <__gnu_unwind_get_pr_addr+0x24>)
 80003e6:	4770      	bx	lr
 80003e8:	08000ad9 	.word	0x08000ad9
 80003ec:	08000add 	.word	0x08000add
 80003f0:	08000ae1 	.word	0x08000ae1

080003f4 <get_eit_entry>:
 80003f4:	b530      	push	{r4, r5, lr}
 80003f6:	4b24      	ldr	r3, [pc, #144]	; (8000488 <get_eit_entry+0x94>)
 80003f8:	b083      	sub	sp, #12
 80003fa:	4604      	mov	r4, r0
 80003fc:	1e8d      	subs	r5, r1, #2
 80003fe:	b37b      	cbz	r3, 8000460 <get_eit_entry+0x6c>
 8000400:	a901      	add	r1, sp, #4
 8000402:	4628      	mov	r0, r5
 8000404:	f3af 8000 	nop.w
 8000408:	b320      	cbz	r0, 8000454 <get_eit_entry+0x60>
 800040a:	9901      	ldr	r1, [sp, #4]
 800040c:	462a      	mov	r2, r5
 800040e:	f7ff ffad 	bl	800036c <search_EIT_table>
 8000412:	4601      	mov	r1, r0
 8000414:	b1f0      	cbz	r0, 8000454 <get_eit_entry+0x60>
 8000416:	f7ff ff9f 	bl	8000358 <selfrel_offset31>
 800041a:	684b      	ldr	r3, [r1, #4]
 800041c:	64a0      	str	r0, [r4, #72]	; 0x48
 800041e:	2b01      	cmp	r3, #1
 8000420:	d012      	beq.n	8000448 <get_eit_entry+0x54>
 8000422:	2b00      	cmp	r3, #0
 8000424:	f101 0004 	add.w	r0, r1, #4
 8000428:	db20      	blt.n	800046c <get_eit_entry+0x78>
 800042a:	f7ff ff95 	bl	8000358 <selfrel_offset31>
 800042e:	2300      	movs	r3, #0
 8000430:	64e0      	str	r0, [r4, #76]	; 0x4c
 8000432:	6523      	str	r3, [r4, #80]	; 0x50
 8000434:	6803      	ldr	r3, [r0, #0]
 8000436:	2b00      	cmp	r3, #0
 8000438:	db1c      	blt.n	8000474 <get_eit_entry+0x80>
 800043a:	f7ff ff8d 	bl	8000358 <selfrel_offset31>
 800043e:	2300      	movs	r3, #0
 8000440:	6120      	str	r0, [r4, #16]
 8000442:	4618      	mov	r0, r3
 8000444:	b003      	add	sp, #12
 8000446:	bd30      	pop	{r4, r5, pc}
 8000448:	2300      	movs	r3, #0
 800044a:	6123      	str	r3, [r4, #16]
 800044c:	2305      	movs	r3, #5
 800044e:	4618      	mov	r0, r3
 8000450:	b003      	add	sp, #12
 8000452:	bd30      	pop	{r4, r5, pc}
 8000454:	2300      	movs	r3, #0
 8000456:	6123      	str	r3, [r4, #16]
 8000458:	2309      	movs	r3, #9
 800045a:	4618      	mov	r0, r3
 800045c:	b003      	add	sp, #12
 800045e:	bd30      	pop	{r4, r5, pc}
 8000460:	490a      	ldr	r1, [pc, #40]	; (800048c <get_eit_entry+0x98>)
 8000462:	480b      	ldr	r0, [pc, #44]	; (8000490 <get_eit_entry+0x9c>)
 8000464:	1a09      	subs	r1, r1, r0
 8000466:	10c9      	asrs	r1, r1, #3
 8000468:	9101      	str	r1, [sp, #4]
 800046a:	e7cf      	b.n	800040c <get_eit_entry+0x18>
 800046c:	2301      	movs	r3, #1
 800046e:	64e0      	str	r0, [r4, #76]	; 0x4c
 8000470:	6523      	str	r3, [r4, #80]	; 0x50
 8000472:	e7df      	b.n	8000434 <get_eit_entry+0x40>
 8000474:	f3c3 6003 	ubfx	r0, r3, #24, #4
 8000478:	f7ff ffa8 	bl	80003cc <__gnu_unwind_get_pr_addr>
 800047c:	2800      	cmp	r0, #0
 800047e:	6120      	str	r0, [r4, #16]
 8000480:	bf14      	ite	ne
 8000482:	2300      	movne	r3, #0
 8000484:	2309      	moveq	r3, #9
 8000486:	e7dc      	b.n	8000442 <get_eit_entry+0x4e>
 8000488:	00000000 	.word	0x00000000
 800048c:	08011154 	.word	0x08011154
 8000490:	08010f9c 	.word	0x08010f9c

08000494 <restore_non_core_regs>:
 8000494:	6803      	ldr	r3, [r0, #0]
 8000496:	07da      	lsls	r2, r3, #31
 8000498:	b510      	push	{r4, lr}
 800049a:	4604      	mov	r4, r0
 800049c:	d406      	bmi.n	80004ac <restore_non_core_regs+0x18>
 800049e:	079b      	lsls	r3, r3, #30
 80004a0:	f100 0048 	add.w	r0, r0, #72	; 0x48
 80004a4:	d509      	bpl.n	80004ba <restore_non_core_regs+0x26>
 80004a6:	f000 fc59 	bl	8000d5c <__gnu_Unwind_Restore_VFP_D>
 80004aa:	6823      	ldr	r3, [r4, #0]
 80004ac:	0759      	lsls	r1, r3, #29
 80004ae:	d509      	bpl.n	80004c4 <restore_non_core_regs+0x30>
 80004b0:	071a      	lsls	r2, r3, #28
 80004b2:	d50e      	bpl.n	80004d2 <restore_non_core_regs+0x3e>
 80004b4:	06db      	lsls	r3, r3, #27
 80004b6:	d513      	bpl.n	80004e0 <restore_non_core_regs+0x4c>
 80004b8:	bd10      	pop	{r4, pc}
 80004ba:	f000 fc47 	bl	8000d4c <__gnu_Unwind_Restore_VFP>
 80004be:	6823      	ldr	r3, [r4, #0]
 80004c0:	0759      	lsls	r1, r3, #29
 80004c2:	d4f5      	bmi.n	80004b0 <restore_non_core_regs+0x1c>
 80004c4:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
 80004c8:	f000 fc50 	bl	8000d6c <__gnu_Unwind_Restore_VFP_D_16_to_31>
 80004cc:	6823      	ldr	r3, [r4, #0]
 80004ce:	071a      	lsls	r2, r3, #28
 80004d0:	d4f0      	bmi.n	80004b4 <restore_non_core_regs+0x20>
 80004d2:	f504 70a8 	add.w	r0, r4, #336	; 0x150
 80004d6:	f000 fc51 	bl	8000d7c <__gnu_Unwind_Restore_WMMXD>
 80004da:	6823      	ldr	r3, [r4, #0]
 80004dc:	06db      	lsls	r3, r3, #27
 80004de:	d4eb      	bmi.n	80004b8 <restore_non_core_regs+0x24>
 80004e0:	f504 70e8 	add.w	r0, r4, #464	; 0x1d0
 80004e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80004e8:	f000 bc8c 	b.w	8000e04 <__gnu_Unwind_Restore_WMMXC>

080004ec <_Unwind_decode_typeinfo_ptr.isra.0>:
 80004ec:	6803      	ldr	r3, [r0, #0]
 80004ee:	b10b      	cbz	r3, 80004f4 <_Unwind_decode_typeinfo_ptr.isra.0+0x8>
 80004f0:	4418      	add	r0, r3
 80004f2:	4770      	bx	lr
 80004f4:	4618      	mov	r0, r3
 80004f6:	4770      	bx	lr

080004f8 <__gnu_unwind_24bit.isra.1>:
 80004f8:	2009      	movs	r0, #9
 80004fa:	4770      	bx	lr

080004fc <_Unwind_DebugHook>:
 80004fc:	4770      	bx	lr
 80004fe:	bf00      	nop

08000500 <unwind_phase2>:
 8000500:	b570      	push	{r4, r5, r6, lr}
 8000502:	4604      	mov	r4, r0
 8000504:	460d      	mov	r5, r1
 8000506:	e008      	b.n	800051a <unwind_phase2+0x1a>
 8000508:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 800050a:	6163      	str	r3, [r4, #20]
 800050c:	462a      	mov	r2, r5
 800050e:	6923      	ldr	r3, [r4, #16]
 8000510:	4621      	mov	r1, r4
 8000512:	2001      	movs	r0, #1
 8000514:	4798      	blx	r3
 8000516:	2808      	cmp	r0, #8
 8000518:	d108      	bne.n	800052c <unwind_phase2+0x2c>
 800051a:	6c29      	ldr	r1, [r5, #64]	; 0x40
 800051c:	4620      	mov	r0, r4
 800051e:	f7ff ff69 	bl	80003f4 <get_eit_entry>
 8000522:	4606      	mov	r6, r0
 8000524:	2800      	cmp	r0, #0
 8000526:	d0ef      	beq.n	8000508 <unwind_phase2+0x8>
 8000528:	f000 fe84 	bl	8001234 <abort>
 800052c:	2807      	cmp	r0, #7
 800052e:	d1fb      	bne.n	8000528 <unwind_phase2+0x28>
 8000530:	4630      	mov	r0, r6
 8000532:	6c29      	ldr	r1, [r5, #64]	; 0x40
 8000534:	f7ff ffe2 	bl	80004fc <_Unwind_DebugHook>
 8000538:	1d28      	adds	r0, r5, #4
 800053a:	f000 fbfb 	bl	8000d34 <__restore_core_regs>
 800053e:	bf00      	nop

08000540 <unwind_phase2_forced>:
 8000540:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000544:	1d0c      	adds	r4, r1, #4
 8000546:	4606      	mov	r6, r0
 8000548:	4617      	mov	r7, r2
 800054a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800054c:	f5ad 7d72 	sub.w	sp, sp, #968	; 0x3c8
 8000550:	ad03      	add	r5, sp, #12
 8000552:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8000554:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000556:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8000558:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800055a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800055c:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 8000560:	ac02      	add	r4, sp, #8
 8000562:	f8d6 800c 	ldr.w	r8, [r6, #12]
 8000566:	f8d6 9018 	ldr.w	r9, [r6, #24]
 800056a:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
 800056e:	2300      	movs	r3, #0
 8000570:	4630      	mov	r0, r6
 8000572:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8000574:	6023      	str	r3, [r4, #0]
 8000576:	f7ff ff3d 	bl	80003f4 <get_eit_entry>
 800057a:	2f00      	cmp	r7, #0
 800057c:	4605      	mov	r5, r0
 800057e:	bf14      	ite	ne
 8000580:	270a      	movne	r7, #10
 8000582:	2709      	moveq	r7, #9
 8000584:	b17d      	cbz	r5, 80005a6 <unwind_phase2_forced+0x66>
 8000586:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000588:	f047 0110 	orr.w	r1, r7, #16
 800058c:	e88d 0210 	stmia.w	sp, {r4, r9}
 8000590:	4632      	mov	r2, r6
 8000592:	6463      	str	r3, [r4, #68]	; 0x44
 8000594:	2001      	movs	r0, #1
 8000596:	4633      	mov	r3, r6
 8000598:	47c0      	blx	r8
 800059a:	bb78      	cbnz	r0, 80005fc <unwind_phase2_forced+0xbc>
 800059c:	4628      	mov	r0, r5
 800059e:	f50d 7d72 	add.w	sp, sp, #968	; 0x3c8
 80005a2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80005a6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80005a8:	6173      	str	r3, [r6, #20]
 80005aa:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
 80005ae:	4621      	mov	r1, r4
 80005b0:	a87a      	add	r0, sp, #488	; 0x1e8
 80005b2:	f001 f90d 	bl	80017d0 <memcpy>
 80005b6:	6933      	ldr	r3, [r6, #16]
 80005b8:	aa7a      	add	r2, sp, #488	; 0x1e8
 80005ba:	4631      	mov	r1, r6
 80005bc:	4638      	mov	r0, r7
 80005be:	4798      	blx	r3
 80005c0:	9b88      	ldr	r3, [sp, #544]	; 0x220
 80005c2:	4682      	mov	sl, r0
 80005c4:	e88d 0210 	stmia.w	sp, {r4, r9}
 80005c8:	4639      	mov	r1, r7
 80005ca:	6463      	str	r3, [r4, #68]	; 0x44
 80005cc:	4632      	mov	r2, r6
 80005ce:	4633      	mov	r3, r6
 80005d0:	2001      	movs	r0, #1
 80005d2:	47c0      	blx	r8
 80005d4:	b990      	cbnz	r0, 80005fc <unwind_phase2_forced+0xbc>
 80005d6:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
 80005da:	a97a      	add	r1, sp, #488	; 0x1e8
 80005dc:	4620      	mov	r0, r4
 80005de:	f001 f8f7 	bl	80017d0 <memcpy>
 80005e2:	f1ba 0f08 	cmp.w	sl, #8
 80005e6:	d106      	bne.n	80005f6 <unwind_phase2_forced+0xb6>
 80005e8:	6c21      	ldr	r1, [r4, #64]	; 0x40
 80005ea:	4630      	mov	r0, r6
 80005ec:	f7ff ff02 	bl	80003f4 <get_eit_entry>
 80005f0:	2709      	movs	r7, #9
 80005f2:	4605      	mov	r5, r0
 80005f4:	e7c6      	b.n	8000584 <unwind_phase2_forced+0x44>
 80005f6:	f1ba 0f07 	cmp.w	sl, #7
 80005fa:	d004      	beq.n	8000606 <unwind_phase2_forced+0xc6>
 80005fc:	2009      	movs	r0, #9
 80005fe:	f50d 7d72 	add.w	sp, sp, #968	; 0x3c8
 8000602:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000606:	4628      	mov	r0, r5
 8000608:	6c21      	ldr	r1, [r4, #64]	; 0x40
 800060a:	f7ff ff77 	bl	80004fc <_Unwind_DebugHook>
 800060e:	a803      	add	r0, sp, #12
 8000610:	f000 fb90 	bl	8000d34 <__restore_core_regs>

08000614 <_Unwind_GetCFA>:
 8000614:	6c40      	ldr	r0, [r0, #68]	; 0x44
 8000616:	4770      	bx	lr

08000618 <__gnu_Unwind_RaiseException>:
 8000618:	b5f0      	push	{r4, r5, r6, r7, lr}
 800061a:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 800061c:	640b      	str	r3, [r1, #64]	; 0x40
 800061e:	1d0e      	adds	r6, r1, #4
 8000620:	460f      	mov	r7, r1
 8000622:	4604      	mov	r4, r0
 8000624:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8000626:	b0f9      	sub	sp, #484	; 0x1e4
 8000628:	ad01      	add	r5, sp, #4
 800062a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800062c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800062e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8000630:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8000632:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8000634:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 8000638:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 800063c:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
 8000640:	9600      	str	r6, [sp, #0]
 8000642:	e006      	b.n	8000652 <__gnu_Unwind_RaiseException+0x3a>
 8000644:	6923      	ldr	r3, [r4, #16]
 8000646:	466a      	mov	r2, sp
 8000648:	4621      	mov	r1, r4
 800064a:	4798      	blx	r3
 800064c:	2808      	cmp	r0, #8
 800064e:	4605      	mov	r5, r0
 8000650:	d108      	bne.n	8000664 <__gnu_Unwind_RaiseException+0x4c>
 8000652:	9910      	ldr	r1, [sp, #64]	; 0x40
 8000654:	4620      	mov	r0, r4
 8000656:	f7ff fecd 	bl	80003f4 <get_eit_entry>
 800065a:	2800      	cmp	r0, #0
 800065c:	d0f2      	beq.n	8000644 <__gnu_Unwind_RaiseException+0x2c>
 800065e:	2009      	movs	r0, #9
 8000660:	b079      	add	sp, #484	; 0x1e4
 8000662:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000664:	4668      	mov	r0, sp
 8000666:	f7ff ff15 	bl	8000494 <restore_non_core_regs>
 800066a:	2d06      	cmp	r5, #6
 800066c:	d1f7      	bne.n	800065e <__gnu_Unwind_RaiseException+0x46>
 800066e:	4639      	mov	r1, r7
 8000670:	4620      	mov	r0, r4
 8000672:	f7ff ff45 	bl	8000500 <unwind_phase2>
 8000676:	bf00      	nop

08000678 <__gnu_Unwind_ForcedUnwind>:
 8000678:	b430      	push	{r4, r5}
 800067a:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
 800067c:	60c1      	str	r1, [r0, #12]
 800067e:	6182      	str	r2, [r0, #24]
 8000680:	4619      	mov	r1, r3
 8000682:	641d      	str	r5, [r3, #64]	; 0x40
 8000684:	2200      	movs	r2, #0
 8000686:	bc30      	pop	{r4, r5}
 8000688:	e75a      	b.n	8000540 <unwind_phase2_forced>
 800068a:	bf00      	nop

0800068c <__gnu_Unwind_Resume>:
 800068c:	b570      	push	{r4, r5, r6, lr}
 800068e:	68c6      	ldr	r6, [r0, #12]
 8000690:	6943      	ldr	r3, [r0, #20]
 8000692:	640b      	str	r3, [r1, #64]	; 0x40
 8000694:	b126      	cbz	r6, 80006a0 <__gnu_Unwind_Resume+0x14>
 8000696:	2201      	movs	r2, #1
 8000698:	f7ff ff52 	bl	8000540 <unwind_phase2_forced>
 800069c:	f000 fdca 	bl	8001234 <abort>
 80006a0:	6903      	ldr	r3, [r0, #16]
 80006a2:	460a      	mov	r2, r1
 80006a4:	4604      	mov	r4, r0
 80006a6:	460d      	mov	r5, r1
 80006a8:	4601      	mov	r1, r0
 80006aa:	2002      	movs	r0, #2
 80006ac:	4798      	blx	r3
 80006ae:	2807      	cmp	r0, #7
 80006b0:	d007      	beq.n	80006c2 <__gnu_Unwind_Resume+0x36>
 80006b2:	2808      	cmp	r0, #8
 80006b4:	d103      	bne.n	80006be <__gnu_Unwind_Resume+0x32>
 80006b6:	4629      	mov	r1, r5
 80006b8:	4620      	mov	r0, r4
 80006ba:	f7ff ff21 	bl	8000500 <unwind_phase2>
 80006be:	f000 fdb9 	bl	8001234 <abort>
 80006c2:	4630      	mov	r0, r6
 80006c4:	6c29      	ldr	r1, [r5, #64]	; 0x40
 80006c6:	f7ff ff19 	bl	80004fc <_Unwind_DebugHook>
 80006ca:	1d28      	adds	r0, r5, #4
 80006cc:	f000 fb32 	bl	8000d34 <__restore_core_regs>

080006d0 <__gnu_Unwind_Resume_or_Rethrow>:
 80006d0:	68c2      	ldr	r2, [r0, #12]
 80006d2:	b11a      	cbz	r2, 80006dc <__gnu_Unwind_Resume_or_Rethrow+0xc>
 80006d4:	6bca      	ldr	r2, [r1, #60]	; 0x3c
 80006d6:	640a      	str	r2, [r1, #64]	; 0x40
 80006d8:	2200      	movs	r2, #0
 80006da:	e731      	b.n	8000540 <unwind_phase2_forced>
 80006dc:	e79c      	b.n	8000618 <__gnu_Unwind_RaiseException>
 80006de:	bf00      	nop

080006e0 <_Unwind_Complete>:
 80006e0:	4770      	bx	lr
 80006e2:	bf00      	nop

080006e4 <_Unwind_DeleteException>:
 80006e4:	6883      	ldr	r3, [r0, #8]
 80006e6:	b113      	cbz	r3, 80006ee <_Unwind_DeleteException+0xa>
 80006e8:	4601      	mov	r1, r0
 80006ea:	2001      	movs	r0, #1
 80006ec:	4718      	bx	r3
 80006ee:	4770      	bx	lr

080006f0 <_Unwind_VRS_Get>:
 80006f0:	b500      	push	{lr}
 80006f2:	2904      	cmp	r1, #4
 80006f4:	d807      	bhi.n	8000706 <_Unwind_VRS_Get+0x16>
 80006f6:	e8df f001 	tbb	[pc, r1]
 80006fa:	0903      	.short	0x0903
 80006fc:	0906      	.short	0x0906
 80006fe:	09          	.byte	0x09
 80006ff:	00          	.byte	0x00
 8000700:	b90b      	cbnz	r3, 8000706 <_Unwind_VRS_Get+0x16>
 8000702:	2a0f      	cmp	r2, #15
 8000704:	d905      	bls.n	8000712 <_Unwind_VRS_Get+0x22>
 8000706:	2002      	movs	r0, #2
 8000708:	f85d fb04 	ldr.w	pc, [sp], #4
 800070c:	2001      	movs	r0, #1
 800070e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000712:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8000716:	4618      	mov	r0, r3
 8000718:	6853      	ldr	r3, [r2, #4]
 800071a:	9a01      	ldr	r2, [sp, #4]
 800071c:	6013      	str	r3, [r2, #0]
 800071e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000722:	bf00      	nop

08000724 <_Unwind_GetGR>:
 8000724:	b510      	push	{r4, lr}
 8000726:	b084      	sub	sp, #16
 8000728:	2300      	movs	r3, #0
 800072a:	ac03      	add	r4, sp, #12
 800072c:	460a      	mov	r2, r1
 800072e:	9400      	str	r4, [sp, #0]
 8000730:	4619      	mov	r1, r3
 8000732:	f7ff ffdd 	bl	80006f0 <_Unwind_VRS_Get>
 8000736:	9803      	ldr	r0, [sp, #12]
 8000738:	b004      	add	sp, #16
 800073a:	bd10      	pop	{r4, pc}

0800073c <_Unwind_VRS_Set>:
 800073c:	b500      	push	{lr}
 800073e:	2904      	cmp	r1, #4
 8000740:	d807      	bhi.n	8000752 <_Unwind_VRS_Set+0x16>
 8000742:	e8df f001 	tbb	[pc, r1]
 8000746:	0903      	.short	0x0903
 8000748:	0906      	.short	0x0906
 800074a:	09          	.byte	0x09
 800074b:	00          	.byte	0x00
 800074c:	b90b      	cbnz	r3, 8000752 <_Unwind_VRS_Set+0x16>
 800074e:	2a0f      	cmp	r2, #15
 8000750:	d905      	bls.n	800075e <_Unwind_VRS_Set+0x22>
 8000752:	2002      	movs	r0, #2
 8000754:	f85d fb04 	ldr.w	pc, [sp], #4
 8000758:	2001      	movs	r0, #1
 800075a:	f85d fb04 	ldr.w	pc, [sp], #4
 800075e:	9901      	ldr	r1, [sp, #4]
 8000760:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8000764:	6809      	ldr	r1, [r1, #0]
 8000766:	6051      	str	r1, [r2, #4]
 8000768:	4618      	mov	r0, r3
 800076a:	f85d fb04 	ldr.w	pc, [sp], #4
 800076e:	bf00      	nop

08000770 <_Unwind_SetGR>:
 8000770:	b510      	push	{r4, lr}
 8000772:	b084      	sub	sp, #16
 8000774:	ac04      	add	r4, sp, #16
 8000776:	2300      	movs	r3, #0
 8000778:	f844 2d04 	str.w	r2, [r4, #-4]!
 800077c:	460a      	mov	r2, r1
 800077e:	9400      	str	r4, [sp, #0]
 8000780:	4619      	mov	r1, r3
 8000782:	f7ff ffdb 	bl	800073c <_Unwind_VRS_Set>
 8000786:	b004      	add	sp, #16
 8000788:	bd10      	pop	{r4, pc}
 800078a:	bf00      	nop

0800078c <__gnu_Unwind_Backtrace>:
 800078c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800078e:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8000790:	6413      	str	r3, [r2, #64]	; 0x40
 8000792:	1d15      	adds	r5, r2, #4
 8000794:	4607      	mov	r7, r0
 8000796:	460e      	mov	r6, r1
 8000798:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800079a:	f5ad 7d0f 	sub.w	sp, sp, #572	; 0x23c
 800079e:	ac17      	add	r4, sp, #92	; 0x5c
 80007a0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80007a2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80007a4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80007a6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80007a8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80007aa:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 80007ae:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 80007b2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 80007b6:	9516      	str	r5, [sp, #88]	; 0x58
 80007b8:	e010      	b.n	80007dc <__gnu_Unwind_Backtrace+0x50>
 80007ba:	a816      	add	r0, sp, #88	; 0x58
 80007bc:	f7ff ffd8 	bl	8000770 <_Unwind_SetGR>
 80007c0:	4631      	mov	r1, r6
 80007c2:	a816      	add	r0, sp, #88	; 0x58
 80007c4:	47b8      	blx	r7
 80007c6:	aa16      	add	r2, sp, #88	; 0x58
 80007c8:	4669      	mov	r1, sp
 80007ca:	b978      	cbnz	r0, 80007ec <__gnu_Unwind_Backtrace+0x60>
 80007cc:	9b04      	ldr	r3, [sp, #16]
 80007ce:	2008      	movs	r0, #8
 80007d0:	4798      	blx	r3
 80007d2:	2805      	cmp	r0, #5
 80007d4:	4604      	mov	r4, r0
 80007d6:	d00a      	beq.n	80007ee <__gnu_Unwind_Backtrace+0x62>
 80007d8:	2809      	cmp	r0, #9
 80007da:	d007      	beq.n	80007ec <__gnu_Unwind_Backtrace+0x60>
 80007dc:	9926      	ldr	r1, [sp, #152]	; 0x98
 80007de:	4668      	mov	r0, sp
 80007e0:	f7ff fe08 	bl	80003f4 <get_eit_entry>
 80007e4:	466a      	mov	r2, sp
 80007e6:	210c      	movs	r1, #12
 80007e8:	2800      	cmp	r0, #0
 80007ea:	d0e6      	beq.n	80007ba <__gnu_Unwind_Backtrace+0x2e>
 80007ec:	2409      	movs	r4, #9
 80007ee:	a816      	add	r0, sp, #88	; 0x58
 80007f0:	f7ff fe50 	bl	8000494 <restore_non_core_regs>
 80007f4:	4620      	mov	r0, r4
 80007f6:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
 80007fa:	bdf0      	pop	{r4, r5, r6, r7, pc}

080007fc <__gnu_unwind_pr_common>:
 80007fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000800:	460d      	mov	r5, r1
 8000802:	6cc9      	ldr	r1, [r1, #76]	; 0x4c
 8000804:	b08b      	sub	sp, #44	; 0x2c
 8000806:	1d0c      	adds	r4, r1, #4
 8000808:	6809      	ldr	r1, [r1, #0]
 800080a:	9107      	str	r1, [sp, #28]
 800080c:	4691      	mov	r9, r2
 800080e:	9408      	str	r4, [sp, #32]
 8000810:	f000 0b03 	and.w	fp, r0, #3
 8000814:	461e      	mov	r6, r3
 8000816:	2b00      	cmp	r3, #0
 8000818:	d164      	bne.n	80008e4 <__gnu_unwind_pr_common+0xe8>
 800081a:	0209      	lsls	r1, r1, #8
 800081c:	2303      	movs	r3, #3
 800081e:	9107      	str	r1, [sp, #28]
 8000820:	f88d 6025 	strb.w	r6, [sp, #37]	; 0x25
 8000824:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
 8000828:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 800082a:	f1bb 0f02 	cmp.w	fp, #2
 800082e:	bf08      	it	eq
 8000830:	6bac      	ldreq	r4, [r5, #56]	; 0x38
 8000832:	f013 0301 	ands.w	r3, r3, #1
 8000836:	d143      	bne.n	80008c0 <__gnu_unwind_pr_common+0xc4>
 8000838:	f000 0008 	and.w	r0, r0, #8
 800083c:	b2c2      	uxtb	r2, r0
 800083e:	9203      	str	r2, [sp, #12]
 8000840:	9301      	str	r3, [sp, #4]
 8000842:	6827      	ldr	r7, [r4, #0]
 8000844:	2f00      	cmp	r7, #0
 8000846:	d03d      	beq.n	80008c4 <__gnu_unwind_pr_common+0xc8>
 8000848:	2e02      	cmp	r6, #2
 800084a:	d047      	beq.n	80008dc <__gnu_unwind_pr_common+0xe0>
 800084c:	8827      	ldrh	r7, [r4, #0]
 800084e:	f8b4 8002 	ldrh.w	r8, [r4, #2]
 8000852:	3404      	adds	r4, #4
 8000854:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8000856:	f028 0a01 	bic.w	sl, r8, #1
 800085a:	210f      	movs	r1, #15
 800085c:	4648      	mov	r0, r9
 800085e:	449a      	add	sl, r3
 8000860:	f7ff ff60 	bl	8000724 <_Unwind_GetGR>
 8000864:	4582      	cmp	sl, r0
 8000866:	d837      	bhi.n	80008d8 <__gnu_unwind_pr_common+0xdc>
 8000868:	f027 0301 	bic.w	r3, r7, #1
 800086c:	449a      	add	sl, r3
 800086e:	4550      	cmp	r0, sl
 8000870:	bf2c      	ite	cs
 8000872:	2000      	movcs	r0, #0
 8000874:	2001      	movcc	r0, #1
 8000876:	ea4f 0848 	mov.w	r8, r8, lsl #1
 800087a:	f008 0802 	and.w	r8, r8, #2
 800087e:	f007 0701 	and.w	r7, r7, #1
 8000882:	ea48 0807 	orr.w	r8, r8, r7
 8000886:	f1b8 0f01 	cmp.w	r8, #1
 800088a:	d041      	beq.n	8000910 <__gnu_unwind_pr_common+0x114>
 800088c:	d338      	bcc.n	8000900 <__gnu_unwind_pr_common+0x104>
 800088e:	f1b8 0f02 	cmp.w	r8, #2
 8000892:	d11d      	bne.n	80008d0 <__gnu_unwind_pr_common+0xd4>
 8000894:	6823      	ldr	r3, [r4, #0]
 8000896:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 800089a:	9202      	str	r2, [sp, #8]
 800089c:	f1bb 0f00 	cmp.w	fp, #0
 80008a0:	d179      	bne.n	8000996 <__gnu_unwind_pr_common+0x19a>
 80008a2:	b130      	cbz	r0, 80008b2 <__gnu_unwind_pr_common+0xb6>
 80008a4:	9903      	ldr	r1, [sp, #12]
 80008a6:	2900      	cmp	r1, #0
 80008a8:	f000 8081 	beq.w	80009ae <__gnu_unwind_pr_common+0x1b2>
 80008ac:	2a00      	cmp	r2, #0
 80008ae:	f000 80a8 	beq.w	8000a02 <__gnu_unwind_pr_common+0x206>
 80008b2:	2b00      	cmp	r3, #0
 80008b4:	db79      	blt.n	80009aa <__gnu_unwind_pr_common+0x1ae>
 80008b6:	9b02      	ldr	r3, [sp, #8]
 80008b8:	3301      	adds	r3, #1
 80008ba:	eb04 0483 	add.w	r4, r4, r3, lsl #2
 80008be:	e7c0      	b.n	8000842 <__gnu_unwind_pr_common+0x46>
 80008c0:	2300      	movs	r3, #0
 80008c2:	9301      	str	r3, [sp, #4]
 80008c4:	2e02      	cmp	r6, #2
 80008c6:	dd40      	ble.n	800094a <__gnu_unwind_pr_common+0x14e>
 80008c8:	f7ff fe16 	bl	80004f8 <__gnu_unwind_24bit.isra.1>
 80008cc:	2800      	cmp	r0, #0
 80008ce:	d042      	beq.n	8000956 <__gnu_unwind_pr_common+0x15a>
 80008d0:	2009      	movs	r0, #9
 80008d2:	b00b      	add	sp, #44	; 0x2c
 80008d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80008d8:	2000      	movs	r0, #0
 80008da:	e7cc      	b.n	8000876 <__gnu_unwind_pr_common+0x7a>
 80008dc:	f8d4 8004 	ldr.w	r8, [r4, #4]
 80008e0:	3408      	adds	r4, #8
 80008e2:	e7b7      	b.n	8000854 <__gnu_unwind_pr_common+0x58>
 80008e4:	2b02      	cmp	r3, #2
 80008e6:	dc9f      	bgt.n	8000828 <__gnu_unwind_pr_common+0x2c>
 80008e8:	0c0b      	lsrs	r3, r1, #16
 80008ea:	b2da      	uxtb	r2, r3
 80008ec:	0409      	lsls	r1, r1, #16
 80008ee:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
 80008f2:	2302      	movs	r3, #2
 80008f4:	eb04 0482 	add.w	r4, r4, r2, lsl #2
 80008f8:	9107      	str	r1, [sp, #28]
 80008fa:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
 80008fe:	e793      	b.n	8000828 <__gnu_unwind_pr_common+0x2c>
 8000900:	f1bb 0f00 	cmp.w	fp, #0
 8000904:	d002      	beq.n	800090c <__gnu_unwind_pr_common+0x110>
 8000906:	2800      	cmp	r0, #0
 8000908:	f040 80b0 	bne.w	8000a6c <__gnu_unwind_pr_common+0x270>
 800090c:	3404      	adds	r4, #4
 800090e:	e798      	b.n	8000842 <__gnu_unwind_pr_common+0x46>
 8000910:	f1bb 0f00 	cmp.w	fp, #0
 8000914:	d126      	bne.n	8000964 <__gnu_unwind_pr_common+0x168>
 8000916:	b1b0      	cbz	r0, 8000946 <__gnu_unwind_pr_common+0x14a>
 8000918:	e894 000c 	ldmia.w	r4, {r2, r3}
 800091c:	1c99      	adds	r1, r3, #2
 800091e:	ea4f 72d2 	mov.w	r2, r2, lsr #31
 8000922:	d0d5      	beq.n	80008d0 <__gnu_unwind_pr_common+0xd4>
 8000924:	f105 0158 	add.w	r1, r5, #88	; 0x58
 8000928:	3301      	adds	r3, #1
 800092a:	9106      	str	r1, [sp, #24]
 800092c:	f000 8094 	beq.w	8000a58 <__gnu_unwind_pr_common+0x25c>
 8000930:	1d20      	adds	r0, r4, #4
 8000932:	f7ff fddb 	bl	80004ec <_Unwind_decode_typeinfo_ptr.isra.0>
 8000936:	ab06      	add	r3, sp, #24
 8000938:	4601      	mov	r1, r0
 800093a:	4628      	mov	r0, r5
 800093c:	f00d fb2a 	bl	800df94 <__cxa_type_match>
 8000940:	2800      	cmp	r0, #0
 8000942:	f040 80b8 	bne.w	8000ab6 <__gnu_unwind_pr_common+0x2ba>
 8000946:	3408      	adds	r4, #8
 8000948:	e77b      	b.n	8000842 <__gnu_unwind_pr_common+0x46>
 800094a:	a907      	add	r1, sp, #28
 800094c:	4648      	mov	r0, r9
 800094e:	f000 faf3 	bl	8000f38 <__gnu_unwind_execute>
 8000952:	2800      	cmp	r0, #0
 8000954:	d1bc      	bne.n	80008d0 <__gnu_unwind_pr_common+0xd4>
 8000956:	9b01      	ldr	r3, [sp, #4]
 8000958:	2b00      	cmp	r3, #0
 800095a:	d15c      	bne.n	8000a16 <__gnu_unwind_pr_common+0x21a>
 800095c:	2008      	movs	r0, #8
 800095e:	b00b      	add	sp, #44	; 0x2c
 8000960:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000964:	210d      	movs	r1, #13
 8000966:	4648      	mov	r0, r9
 8000968:	6a2f      	ldr	r7, [r5, #32]
 800096a:	f7ff fedb 	bl	8000724 <_Unwind_GetGR>
 800096e:	4287      	cmp	r7, r0
 8000970:	d1e9      	bne.n	8000946 <__gnu_unwind_pr_common+0x14a>
 8000972:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8000974:	429c      	cmp	r4, r3
 8000976:	d1e6      	bne.n	8000946 <__gnu_unwind_pr_common+0x14a>
 8000978:	4620      	mov	r0, r4
 800097a:	f7ff fced 	bl	8000358 <selfrel_offset31>
 800097e:	210f      	movs	r1, #15
 8000980:	4602      	mov	r2, r0
 8000982:	4648      	mov	r0, r9
 8000984:	f7ff fef4 	bl	8000770 <_Unwind_SetGR>
 8000988:	4648      	mov	r0, r9
 800098a:	462a      	mov	r2, r5
 800098c:	2100      	movs	r1, #0
 800098e:	f7ff feef 	bl	8000770 <_Unwind_SetGR>
 8000992:	2007      	movs	r0, #7
 8000994:	e79d      	b.n	80008d2 <__gnu_unwind_pr_common+0xd6>
 8000996:	210d      	movs	r1, #13
 8000998:	4648      	mov	r0, r9
 800099a:	6a2f      	ldr	r7, [r5, #32]
 800099c:	f7ff fec2 	bl	8000724 <_Unwind_GetGR>
 80009a0:	4287      	cmp	r7, r0
 80009a2:	d048      	beq.n	8000a36 <__gnu_unwind_pr_common+0x23a>
 80009a4:	6823      	ldr	r3, [r4, #0]
 80009a6:	2b00      	cmp	r3, #0
 80009a8:	da85      	bge.n	80008b6 <__gnu_unwind_pr_common+0xba>
 80009aa:	3404      	adds	r4, #4
 80009ac:	e783      	b.n	80008b6 <__gnu_unwind_pr_common+0xba>
 80009ae:	9b02      	ldr	r3, [sp, #8]
 80009b0:	b33b      	cbz	r3, 8000a02 <__gnu_unwind_pr_common+0x206>
 80009b2:	f105 0358 	add.w	r3, r5, #88	; 0x58
 80009b6:	1d27      	adds	r7, r4, #4
 80009b8:	f8cd b010 	str.w	fp, [sp, #16]
 80009bc:	f8dd 800c 	ldr.w	r8, [sp, #12]
 80009c0:	f8dd a008 	ldr.w	sl, [sp, #8]
 80009c4:	9605      	str	r6, [sp, #20]
 80009c6:	46a3      	mov	fp, r4
 80009c8:	461c      	mov	r4, r3
 80009ca:	e002      	b.n	80009d2 <__gnu_unwind_pr_common+0x1d6>
 80009cc:	45b2      	cmp	sl, r6
 80009ce:	46b0      	mov	r8, r6
 80009d0:	d016      	beq.n	8000a00 <__gnu_unwind_pr_common+0x204>
 80009d2:	4638      	mov	r0, r7
 80009d4:	9406      	str	r4, [sp, #24]
 80009d6:	f7ff fd89 	bl	80004ec <_Unwind_decode_typeinfo_ptr.isra.0>
 80009da:	ab06      	add	r3, sp, #24
 80009dc:	4601      	mov	r1, r0
 80009de:	2200      	movs	r2, #0
 80009e0:	4628      	mov	r0, r5
 80009e2:	f00d fad7 	bl	800df94 <__cxa_type_match>
 80009e6:	f108 0601 	add.w	r6, r8, #1
 80009ea:	3704      	adds	r7, #4
 80009ec:	2800      	cmp	r0, #0
 80009ee:	d0ed      	beq.n	80009cc <__gnu_unwind_pr_common+0x1d0>
 80009f0:	9b02      	ldr	r3, [sp, #8]
 80009f2:	9e05      	ldr	r6, [sp, #20]
 80009f4:	4543      	cmp	r3, r8
 80009f6:	465c      	mov	r4, fp
 80009f8:	f8dd b010 	ldr.w	fp, [sp, #16]
 80009fc:	d1d2      	bne.n	80009a4 <__gnu_unwind_pr_common+0x1a8>
 80009fe:	e000      	b.n	8000a02 <__gnu_unwind_pr_common+0x206>
 8000a00:	465c      	mov	r4, fp
 8000a02:	4648      	mov	r0, r9
 8000a04:	210d      	movs	r1, #13
 8000a06:	f7ff fe8d 	bl	8000724 <_Unwind_GetGR>
 8000a0a:	9b06      	ldr	r3, [sp, #24]
 8000a0c:	6228      	str	r0, [r5, #32]
 8000a0e:	62ac      	str	r4, [r5, #40]	; 0x28
 8000a10:	626b      	str	r3, [r5, #36]	; 0x24
 8000a12:	2006      	movs	r0, #6
 8000a14:	e75d      	b.n	80008d2 <__gnu_unwind_pr_common+0xd6>
 8000a16:	210f      	movs	r1, #15
 8000a18:	4648      	mov	r0, r9
 8000a1a:	f7ff fe83 	bl	8000724 <_Unwind_GetGR>
 8000a1e:	210e      	movs	r1, #14
 8000a20:	4602      	mov	r2, r0
 8000a22:	4648      	mov	r0, r9
 8000a24:	f7ff fea4 	bl	8000770 <_Unwind_SetGR>
 8000a28:	4648      	mov	r0, r9
 8000a2a:	4a2a      	ldr	r2, [pc, #168]	; (8000ad4 <__gnu_unwind_pr_common+0x2d8>)
 8000a2c:	210f      	movs	r1, #15
 8000a2e:	f7ff fe9f 	bl	8000770 <_Unwind_SetGR>
 8000a32:	2007      	movs	r0, #7
 8000a34:	e74d      	b.n	80008d2 <__gnu_unwind_pr_common+0xd6>
 8000a36:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8000a38:	429c      	cmp	r4, r3
 8000a3a:	d1b3      	bne.n	80009a4 <__gnu_unwind_pr_common+0x1a8>
 8000a3c:	2204      	movs	r2, #4
 8000a3e:	2700      	movs	r7, #0
 8000a40:	18a3      	adds	r3, r4, r2
 8000a42:	9902      	ldr	r1, [sp, #8]
 8000a44:	62a9      	str	r1, [r5, #40]	; 0x28
 8000a46:	62ef      	str	r7, [r5, #44]	; 0x2c
 8000a48:	632a      	str	r2, [r5, #48]	; 0x30
 8000a4a:	636b      	str	r3, [r5, #52]	; 0x34
 8000a4c:	6823      	ldr	r3, [r4, #0]
 8000a4e:	42bb      	cmp	r3, r7
 8000a50:	db1f      	blt.n	8000a92 <__gnu_unwind_pr_common+0x296>
 8000a52:	2301      	movs	r3, #1
 8000a54:	9301      	str	r3, [sp, #4]
 8000a56:	e72e      	b.n	80008b6 <__gnu_unwind_pr_common+0xba>
 8000a58:	4648      	mov	r0, r9
 8000a5a:	210d      	movs	r1, #13
 8000a5c:	f7ff fe62 	bl	8000724 <_Unwind_GetGR>
 8000a60:	6228      	str	r0, [r5, #32]
 8000a62:	9b06      	ldr	r3, [sp, #24]
 8000a64:	626b      	str	r3, [r5, #36]	; 0x24
 8000a66:	62ac      	str	r4, [r5, #40]	; 0x28
 8000a68:	2006      	movs	r0, #6
 8000a6a:	e732      	b.n	80008d2 <__gnu_unwind_pr_common+0xd6>
 8000a6c:	4620      	mov	r0, r4
 8000a6e:	f7ff fc73 	bl	8000358 <selfrel_offset31>
 8000a72:	3404      	adds	r4, #4
 8000a74:	4606      	mov	r6, r0
 8000a76:	63ac      	str	r4, [r5, #56]	; 0x38
 8000a78:	4628      	mov	r0, r5
 8000a7a:	f00d fae3 	bl	800e044 <__cxa_begin_cleanup>
 8000a7e:	2800      	cmp	r0, #0
 8000a80:	f43f af26 	beq.w	80008d0 <__gnu_unwind_pr_common+0xd4>
 8000a84:	4648      	mov	r0, r9
 8000a86:	4632      	mov	r2, r6
 8000a88:	210f      	movs	r1, #15
 8000a8a:	f7ff fe71 	bl	8000770 <_Unwind_SetGR>
 8000a8e:	2007      	movs	r0, #7
 8000a90:	e71f      	b.n	80008d2 <__gnu_unwind_pr_common+0xd6>
 8000a92:	4608      	mov	r0, r1
 8000a94:	3001      	adds	r0, #1
 8000a96:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 8000a9a:	f7ff fc5d 	bl	8000358 <selfrel_offset31>
 8000a9e:	210f      	movs	r1, #15
 8000aa0:	4602      	mov	r2, r0
 8000aa2:	4648      	mov	r0, r9
 8000aa4:	f7ff fe64 	bl	8000770 <_Unwind_SetGR>
 8000aa8:	4648      	mov	r0, r9
 8000aaa:	462a      	mov	r2, r5
 8000aac:	4639      	mov	r1, r7
 8000aae:	f7ff fe5f 	bl	8000770 <_Unwind_SetGR>
 8000ab2:	2007      	movs	r0, #7
 8000ab4:	e70d      	b.n	80008d2 <__gnu_unwind_pr_common+0xd6>
 8000ab6:	4607      	mov	r7, r0
 8000ab8:	210d      	movs	r1, #13
 8000aba:	4648      	mov	r0, r9
 8000abc:	f7ff fe32 	bl	8000724 <_Unwind_GetGR>
 8000ac0:	2f02      	cmp	r7, #2
 8000ac2:	6228      	str	r0, [r5, #32]
 8000ac4:	d1cd      	bne.n	8000a62 <__gnu_unwind_pr_common+0x266>
 8000ac6:	462b      	mov	r3, r5
 8000ac8:	9a06      	ldr	r2, [sp, #24]
 8000aca:	f843 2f2c 	str.w	r2, [r3, #44]!
 8000ace:	626b      	str	r3, [r5, #36]	; 0x24
 8000ad0:	e7c9      	b.n	8000a66 <__gnu_unwind_pr_common+0x26a>
 8000ad2:	bf00      	nop
 8000ad4:	0800e175 	.word	0x0800e175

08000ad8 <__aeabi_unwind_cpp_pr0>:
 8000ad8:	2300      	movs	r3, #0
 8000ada:	e68f      	b.n	80007fc <__gnu_unwind_pr_common>

08000adc <__aeabi_unwind_cpp_pr1>:
 8000adc:	2301      	movs	r3, #1
 8000ade:	e68d      	b.n	80007fc <__gnu_unwind_pr_common>

08000ae0 <__aeabi_unwind_cpp_pr2>:
 8000ae0:	2302      	movs	r3, #2
 8000ae2:	e68b      	b.n	80007fc <__gnu_unwind_pr_common>

08000ae4 <_Unwind_VRS_Pop>:
 8000ae4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000ae6:	4604      	mov	r4, r0
 8000ae8:	b0c5      	sub	sp, #276	; 0x114
 8000aea:	2904      	cmp	r1, #4
 8000aec:	d80d      	bhi.n	8000b0a <_Unwind_VRS_Pop+0x26>
 8000aee:	e8df f001 	tbb	[pc, r1]
 8000af2:	0357      	.short	0x0357
 8000af4:	310c      	.short	0x310c
 8000af6:	0f          	.byte	0x0f
 8000af7:	00          	.byte	0x00
 8000af8:	2b01      	cmp	r3, #1
 8000afa:	ea4f 4612 	mov.w	r6, r2, lsr #16
 8000afe:	b295      	uxth	r5, r2
 8000b00:	d166      	bne.n	8000bd0 <_Unwind_VRS_Pop+0xec>
 8000b02:	1972      	adds	r2, r6, r5
 8000b04:	2a10      	cmp	r2, #16
 8000b06:	f240 809f 	bls.w	8000c48 <_Unwind_VRS_Pop+0x164>
 8000b0a:	2002      	movs	r0, #2
 8000b0c:	b045      	add	sp, #276	; 0x114
 8000b0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000b10:	2b00      	cmp	r3, #0
 8000b12:	d1fa      	bne.n	8000b0a <_Unwind_VRS_Pop+0x26>
 8000b14:	2a10      	cmp	r2, #16
 8000b16:	d8f8      	bhi.n	8000b0a <_Unwind_VRS_Pop+0x26>
 8000b18:	6823      	ldr	r3, [r4, #0]
 8000b1a:	06d8      	lsls	r0, r3, #27
 8000b1c:	f100 80c9 	bmi.w	8000cb2 <_Unwind_VRS_Pop+0x1ce>
 8000b20:	ae22      	add	r6, sp, #136	; 0x88
 8000b22:	4630      	mov	r0, r6
 8000b24:	9201      	str	r2, [sp, #4]
 8000b26:	f000 f977 	bl	8000e18 <__gnu_Unwind_Save_WMMXC>
 8000b2a:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8000b2c:	9a01      	ldr	r2, [sp, #4]
 8000b2e:	2300      	movs	r3, #0
 8000b30:	2501      	movs	r5, #1
 8000b32:	fa05 f103 	lsl.w	r1, r5, r3
 8000b36:	4211      	tst	r1, r2
 8000b38:	d003      	beq.n	8000b42 <_Unwind_VRS_Pop+0x5e>
 8000b3a:	6801      	ldr	r1, [r0, #0]
 8000b3c:	f846 1023 	str.w	r1, [r6, r3, lsl #2]
 8000b40:	3004      	adds	r0, #4
 8000b42:	3301      	adds	r3, #1
 8000b44:	2b04      	cmp	r3, #4
 8000b46:	d1f4      	bne.n	8000b32 <_Unwind_VRS_Pop+0x4e>
 8000b48:	63a0      	str	r0, [r4, #56]	; 0x38
 8000b4a:	4630      	mov	r0, r6
 8000b4c:	f000 f95a 	bl	8000e04 <__gnu_Unwind_Restore_WMMXC>
 8000b50:	2000      	movs	r0, #0
 8000b52:	e7db      	b.n	8000b0c <_Unwind_VRS_Pop+0x28>
 8000b54:	2b03      	cmp	r3, #3
 8000b56:	d1d8      	bne.n	8000b0a <_Unwind_VRS_Pop+0x26>
 8000b58:	0c15      	lsrs	r5, r2, #16
 8000b5a:	b297      	uxth	r7, r2
 8000b5c:	19eb      	adds	r3, r5, r7
 8000b5e:	2b10      	cmp	r3, #16
 8000b60:	d8d3      	bhi.n	8000b0a <_Unwind_VRS_Pop+0x26>
 8000b62:	6823      	ldr	r3, [r4, #0]
 8000b64:	071e      	lsls	r6, r3, #28
 8000b66:	f100 80b8 	bmi.w	8000cda <_Unwind_VRS_Pop+0x1f6>
 8000b6a:	ae22      	add	r6, sp, #136	; 0x88
 8000b6c:	4630      	mov	r0, r6
 8000b6e:	007f      	lsls	r7, r7, #1
 8000b70:	f000 f926 	bl	8000dc0 <__gnu_Unwind_Save_WMMXD>
 8000b74:	eb06 02c5 	add.w	r2, r6, r5, lsl #3
 8000b78:	1e7b      	subs	r3, r7, #1
 8000b7a:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 8000b7c:	b157      	cbz	r7, 8000b94 <_Unwind_VRS_Pop+0xb0>
 8000b7e:	3a04      	subs	r2, #4
 8000b80:	4629      	mov	r1, r5
 8000b82:	f851 0b04 	ldr.w	r0, [r1], #4
 8000b86:	f842 0f04 	str.w	r0, [r2, #4]!
 8000b8a:	3b01      	subs	r3, #1
 8000b8c:	1c58      	adds	r0, r3, #1
 8000b8e:	d1f8      	bne.n	8000b82 <_Unwind_VRS_Pop+0x9e>
 8000b90:	eb05 0587 	add.w	r5, r5, r7, lsl #2
 8000b94:	4630      	mov	r0, r6
 8000b96:	63a5      	str	r5, [r4, #56]	; 0x38
 8000b98:	f000 f8f0 	bl	8000d7c <__gnu_Unwind_Restore_WMMXD>
 8000b9c:	2000      	movs	r0, #0
 8000b9e:	e7b5      	b.n	8000b0c <_Unwind_VRS_Pop+0x28>
 8000ba0:	2b00      	cmp	r3, #0
 8000ba2:	d1b2      	bne.n	8000b0a <_Unwind_VRS_Pop+0x26>
 8000ba4:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 8000ba6:	b297      	uxth	r7, r2
 8000ba8:	1d20      	adds	r0, r4, #4
 8000baa:	2601      	movs	r6, #1
 8000bac:	fa06 f103 	lsl.w	r1, r6, r3
 8000bb0:	4239      	tst	r1, r7
 8000bb2:	f103 0301 	add.w	r3, r3, #1
 8000bb6:	d002      	beq.n	8000bbe <_Unwind_VRS_Pop+0xda>
 8000bb8:	6829      	ldr	r1, [r5, #0]
 8000bba:	6001      	str	r1, [r0, #0]
 8000bbc:	3504      	adds	r5, #4
 8000bbe:	2b10      	cmp	r3, #16
 8000bc0:	f100 0004 	add.w	r0, r0, #4
 8000bc4:	d1f2      	bne.n	8000bac <_Unwind_VRS_Pop+0xc8>
 8000bc6:	f412 5000 	ands.w	r0, r2, #8192	; 0x2000
 8000bca:	d13b      	bne.n	8000c44 <_Unwind_VRS_Pop+0x160>
 8000bcc:	63a5      	str	r5, [r4, #56]	; 0x38
 8000bce:	e79d      	b.n	8000b0c <_Unwind_VRS_Pop+0x28>
 8000bd0:	2b05      	cmp	r3, #5
 8000bd2:	d19a      	bne.n	8000b0a <_Unwind_VRS_Pop+0x26>
 8000bd4:	1977      	adds	r7, r6, r5
 8000bd6:	2f20      	cmp	r7, #32
 8000bd8:	d897      	bhi.n	8000b0a <_Unwind_VRS_Pop+0x26>
 8000bda:	2e0f      	cmp	r6, #15
 8000bdc:	d965      	bls.n	8000caa <_Unwind_VRS_Pop+0x1c6>
 8000bde:	462f      	mov	r7, r5
 8000be0:	2d00      	cmp	r5, #0
 8000be2:	d148      	bne.n	8000c76 <_Unwind_VRS_Pop+0x192>
 8000be4:	462a      	mov	r2, r5
 8000be6:	2700      	movs	r7, #0
 8000be8:	2a00      	cmp	r2, #0
 8000bea:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8000bec:	dd71      	ble.n	8000cd2 <_Unwind_VRS_Pop+0x1ee>
 8000bee:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
 8000bf2:	4601      	mov	r1, r0
 8000bf4:	a844      	add	r0, sp, #272	; 0x110
 8000bf6:	eb00 00c6 	add.w	r0, r0, r6, lsl #3
 8000bfa:	388c      	subs	r0, #140	; 0x8c
 8000bfc:	f851 5b04 	ldr.w	r5, [r1], #4
 8000c00:	f840 5f04 	str.w	r5, [r0, #4]!
 8000c04:	4291      	cmp	r1, r2
 8000c06:	d1f9      	bne.n	8000bfc <_Unwind_VRS_Pop+0x118>
 8000c08:	4608      	mov	r0, r1
 8000c0a:	b197      	cbz	r7, 8000c32 <_Unwind_VRS_Pop+0x14e>
 8000c0c:	2e10      	cmp	r6, #16
 8000c0e:	4632      	mov	r2, r6
 8000c10:	a944      	add	r1, sp, #272	; 0x110
 8000c12:	bf38      	it	cc
 8000c14:	2210      	movcc	r2, #16
 8000c16:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
 8000c1a:	f5a2 72c4 	sub.w	r2, r2, #392	; 0x188
 8000c1e:	0079      	lsls	r1, r7, #1
 8000c20:	3a04      	subs	r2, #4
 8000c22:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8000c26:	f850 5b04 	ldr.w	r5, [r0], #4
 8000c2a:	f842 5f04 	str.w	r5, [r2, #4]!
 8000c2e:	4281      	cmp	r1, r0
 8000c30:	d1f9      	bne.n	8000c26 <_Unwind_VRS_Pop+0x142>
 8000c32:	2b01      	cmp	r3, #1
 8000c34:	d047      	beq.n	8000cc6 <_Unwind_VRS_Pop+0x1e2>
 8000c36:	2e0f      	cmp	r6, #15
 8000c38:	63a1      	str	r1, [r4, #56]	; 0x38
 8000c3a:	d932      	bls.n	8000ca2 <_Unwind_VRS_Pop+0x1be>
 8000c3c:	b117      	cbz	r7, 8000c44 <_Unwind_VRS_Pop+0x160>
 8000c3e:	a802      	add	r0, sp, #8
 8000c40:	f000 f894 	bl	8000d6c <__gnu_Unwind_Restore_VFP_D_16_to_31>
 8000c44:	2000      	movs	r0, #0
 8000c46:	e761      	b.n	8000b0c <_Unwind_VRS_Pop+0x28>
 8000c48:	2e0f      	cmp	r6, #15
 8000c4a:	f63f af5e 	bhi.w	8000b0a <_Unwind_VRS_Pop+0x26>
 8000c4e:	2700      	movs	r7, #0
 8000c50:	6822      	ldr	r2, [r4, #0]
 8000c52:	07d1      	lsls	r1, r2, #31
 8000c54:	d50d      	bpl.n	8000c72 <_Unwind_VRS_Pop+0x18e>
 8000c56:	f022 0101 	bic.w	r1, r2, #1
 8000c5a:	2b05      	cmp	r3, #5
 8000c5c:	6021      	str	r1, [r4, #0]
 8000c5e:	9301      	str	r3, [sp, #4]
 8000c60:	4620      	mov	r0, r4
 8000c62:	d052      	beq.n	8000d0a <_Unwind_VRS_Pop+0x226>
 8000c64:	f022 0203 	bic.w	r2, r2, #3
 8000c68:	f840 2b48 	str.w	r2, [r0], #72
 8000c6c:	f000 f872 	bl	8000d54 <__gnu_Unwind_Save_VFP>
 8000c70:	9b01      	ldr	r3, [sp, #4]
 8000c72:	2f00      	cmp	r7, #0
 8000c74:	d051      	beq.n	8000d1a <_Unwind_VRS_Pop+0x236>
 8000c76:	6822      	ldr	r2, [r4, #0]
 8000c78:	0751      	lsls	r1, r2, #29
 8000c7a:	d436      	bmi.n	8000cea <_Unwind_VRS_Pop+0x206>
 8000c7c:	2b01      	cmp	r3, #1
 8000c7e:	d03e      	beq.n	8000cfe <_Unwind_VRS_Pop+0x21a>
 8000c80:	2e0f      	cmp	r6, #15
 8000c82:	d806      	bhi.n	8000c92 <_Unwind_VRS_Pop+0x1ae>
 8000c84:	a822      	add	r0, sp, #136	; 0x88
 8000c86:	9301      	str	r3, [sp, #4]
 8000c88:	f000 f86c 	bl	8000d64 <__gnu_Unwind_Save_VFP_D>
 8000c8c:	9b01      	ldr	r3, [sp, #4]
 8000c8e:	2f00      	cmp	r7, #0
 8000c90:	d0a8      	beq.n	8000be4 <_Unwind_VRS_Pop+0x100>
 8000c92:	a802      	add	r0, sp, #8
 8000c94:	9301      	str	r3, [sp, #4]
 8000c96:	f000 f86d 	bl	8000d74 <__gnu_Unwind_Save_VFP_D_16_to_31>
 8000c9a:	9b01      	ldr	r3, [sp, #4]
 8000c9c:	f1c6 0210 	rsb	r2, r6, #16
 8000ca0:	e7a2      	b.n	8000be8 <_Unwind_VRS_Pop+0x104>
 8000ca2:	a822      	add	r0, sp, #136	; 0x88
 8000ca4:	f000 f85a 	bl	8000d5c <__gnu_Unwind_Restore_VFP_D>
 8000ca8:	e7c8      	b.n	8000c3c <_Unwind_VRS_Pop+0x158>
 8000caa:	2f10      	cmp	r7, #16
 8000cac:	d9cf      	bls.n	8000c4e <_Unwind_VRS_Pop+0x16a>
 8000cae:	3f10      	subs	r7, #16
 8000cb0:	e7ce      	b.n	8000c50 <_Unwind_VRS_Pop+0x16c>
 8000cb2:	f023 0310 	bic.w	r3, r3, #16
 8000cb6:	6023      	str	r3, [r4, #0]
 8000cb8:	f504 70e8 	add.w	r0, r4, #464	; 0x1d0
 8000cbc:	9201      	str	r2, [sp, #4]
 8000cbe:	f000 f8ab 	bl	8000e18 <__gnu_Unwind_Save_WMMXC>
 8000cc2:	9a01      	ldr	r2, [sp, #4]
 8000cc4:	e72c      	b.n	8000b20 <_Unwind_VRS_Pop+0x3c>
 8000cc6:	3104      	adds	r1, #4
 8000cc8:	63a1      	str	r1, [r4, #56]	; 0x38
 8000cca:	a822      	add	r0, sp, #136	; 0x88
 8000ccc:	f000 f83e 	bl	8000d4c <__gnu_Unwind_Restore_VFP>
 8000cd0:	e7b8      	b.n	8000c44 <_Unwind_VRS_Pop+0x160>
 8000cd2:	2f00      	cmp	r7, #0
 8000cd4:	d19a      	bne.n	8000c0c <_Unwind_VRS_Pop+0x128>
 8000cd6:	4601      	mov	r1, r0
 8000cd8:	e7ab      	b.n	8000c32 <_Unwind_VRS_Pop+0x14e>
 8000cda:	f023 0308 	bic.w	r3, r3, #8
 8000cde:	6023      	str	r3, [r4, #0]
 8000ce0:	f504 70a8 	add.w	r0, r4, #336	; 0x150
 8000ce4:	f000 f86c 	bl	8000dc0 <__gnu_Unwind_Save_WMMXD>
 8000ce8:	e73f      	b.n	8000b6a <_Unwind_VRS_Pop+0x86>
 8000cea:	4620      	mov	r0, r4
 8000cec:	f022 0204 	bic.w	r2, r2, #4
 8000cf0:	f840 2bd0 	str.w	r2, [r0], #208
 8000cf4:	9301      	str	r3, [sp, #4]
 8000cf6:	f000 f83d 	bl	8000d74 <__gnu_Unwind_Save_VFP_D_16_to_31>
 8000cfa:	9b01      	ldr	r3, [sp, #4]
 8000cfc:	e7be      	b.n	8000c7c <_Unwind_VRS_Pop+0x198>
 8000cfe:	a822      	add	r0, sp, #136	; 0x88
 8000d00:	9301      	str	r3, [sp, #4]
 8000d02:	f000 f827 	bl	8000d54 <__gnu_Unwind_Save_VFP>
 8000d06:	9b01      	ldr	r3, [sp, #4]
 8000d08:	e7c8      	b.n	8000c9c <_Unwind_VRS_Pop+0x1b8>
 8000d0a:	f041 0102 	orr.w	r1, r1, #2
 8000d0e:	f840 1b48 	str.w	r1, [r0], #72
 8000d12:	f000 f827 	bl	8000d64 <__gnu_Unwind_Save_VFP_D>
 8000d16:	9b01      	ldr	r3, [sp, #4]
 8000d18:	e7ab      	b.n	8000c72 <_Unwind_VRS_Pop+0x18e>
 8000d1a:	2b01      	cmp	r3, #1
 8000d1c:	d003      	beq.n	8000d26 <_Unwind_VRS_Pop+0x242>
 8000d1e:	2e0f      	cmp	r6, #15
 8000d20:	f63f af60 	bhi.w	8000be4 <_Unwind_VRS_Pop+0x100>
 8000d24:	e7ae      	b.n	8000c84 <_Unwind_VRS_Pop+0x1a0>
 8000d26:	a822      	add	r0, sp, #136	; 0x88
 8000d28:	9301      	str	r3, [sp, #4]
 8000d2a:	f000 f813 	bl	8000d54 <__gnu_Unwind_Save_VFP>
 8000d2e:	9b01      	ldr	r3, [sp, #4]
 8000d30:	e758      	b.n	8000be4 <_Unwind_VRS_Pop+0x100>
 8000d32:	bf00      	nop

08000d34 <__restore_core_regs>:
 8000d34:	f100 0134 	add.w	r1, r0, #52	; 0x34
 8000d38:	e891 0038 	ldmia.w	r1, {r3, r4, r5}
 8000d3c:	469c      	mov	ip, r3
 8000d3e:	46a6      	mov	lr, r4
 8000d40:	f84c 5d04 	str.w	r5, [ip, #-4]!
 8000d44:	e890 0fff 	ldmia.w	r0, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp}
 8000d48:	46e5      	mov	sp, ip
 8000d4a:	bd00      	pop	{pc}

08000d4c <__gnu_Unwind_Restore_VFP>:
 8000d4c:	ec90 0b21 	fldmiax	r0, {d0-d15}	;@ Deprecated
 8000d50:	4770      	bx	lr
 8000d52:	bf00      	nop

08000d54 <__gnu_Unwind_Save_VFP>:
 8000d54:	ec80 0b21 	fstmiax	r0, {d0-d15}	;@ Deprecated
 8000d58:	4770      	bx	lr
 8000d5a:	bf00      	nop

08000d5c <__gnu_Unwind_Restore_VFP_D>:
 8000d5c:	ec90 0b20 	vldmia	r0, {d0-d15}
 8000d60:	4770      	bx	lr
 8000d62:	bf00      	nop

08000d64 <__gnu_Unwind_Save_VFP_D>:
 8000d64:	ec80 0b20 	vstmia	r0, {d0-d15}
 8000d68:	4770      	bx	lr
 8000d6a:	bf00      	nop

08000d6c <__gnu_Unwind_Restore_VFP_D_16_to_31>:
 8000d6c:	ecd0 0b20 	vldmia	r0, {d16-d31}
 8000d70:	4770      	bx	lr
 8000d72:	bf00      	nop

08000d74 <__gnu_Unwind_Save_VFP_D_16_to_31>:
 8000d74:	ecc0 0b20 	vstmia	r0, {d16-d31}
 8000d78:	4770      	bx	lr
 8000d7a:	bf00      	nop

08000d7c <__gnu_Unwind_Restore_WMMXD>:
 8000d7c:	ecf0 0102 	ldfe	f0, [r0], #8
 8000d80:	ecf0 1102 	ldfe	f1, [r0], #8
 8000d84:	ecf0 2102 	ldfe	f2, [r0], #8
 8000d88:	ecf0 3102 	ldfe	f3, [r0], #8
 8000d8c:	ecf0 4102 	ldfe	f4, [r0], #8
 8000d90:	ecf0 5102 	ldfe	f5, [r0], #8
 8000d94:	ecf0 6102 	ldfe	f6, [r0], #8
 8000d98:	ecf0 7102 	ldfe	f7, [r0], #8
 8000d9c:	ecf0 8102 	ldfp	f0, [r0], #8
 8000da0:	ecf0 9102 	ldfp	f1, [r0], #8
 8000da4:	ecf0 a102 	ldfp	f2, [r0], #8
 8000da8:	ecf0 b102 	ldfp	f3, [r0], #8
 8000dac:	ecf0 c102 	ldfp	f4, [r0], #8
 8000db0:	ecf0 d102 	ldfp	f5, [r0], #8
 8000db4:	ecf0 e102 	ldfp	f6, [r0], #8
 8000db8:	ecf0 f102 	ldfp	f7, [r0], #8
 8000dbc:	4770      	bx	lr
 8000dbe:	bf00      	nop

08000dc0 <__gnu_Unwind_Save_WMMXD>:
 8000dc0:	ece0 0102 	stfe	f0, [r0], #8
 8000dc4:	ece0 1102 	stfe	f1, [r0], #8
 8000dc8:	ece0 2102 	stfe	f2, [r0], #8
 8000dcc:	ece0 3102 	stfe	f3, [r0], #8
 8000dd0:	ece0 4102 	stfe	f4, [r0], #8
 8000dd4:	ece0 5102 	stfe	f5, [r0], #8
 8000dd8:	ece0 6102 	stfe	f6, [r0], #8
 8000ddc:	ece0 7102 	stfe	f7, [r0], #8
 8000de0:	ece0 8102 	stfp	f0, [r0], #8
 8000de4:	ece0 9102 	stfp	f1, [r0], #8
 8000de8:	ece0 a102 	stfp	f2, [r0], #8
 8000dec:	ece0 b102 	stfp	f3, [r0], #8
 8000df0:	ece0 c102 	stfp	f4, [r0], #8
 8000df4:	ece0 d102 	stfp	f5, [r0], #8
 8000df8:	ece0 e102 	stfp	f6, [r0], #8
 8000dfc:	ece0 f102 	stfp	f7, [r0], #8
 8000e00:	4770      	bx	lr
 8000e02:	bf00      	nop

08000e04 <__gnu_Unwind_Restore_WMMXC>:
 8000e04:	fcb0 8101 	ldc2	1, cr8, [r0], #4
 8000e08:	fcb0 9101 	ldc2	1, cr9, [r0], #4
 8000e0c:	fcb0 a101 	ldc2	1, cr10, [r0], #4
 8000e10:	fcb0 b101 	ldc2	1, cr11, [r0], #4
 8000e14:	4770      	bx	lr
 8000e16:	bf00      	nop

08000e18 <__gnu_Unwind_Save_WMMXC>:
 8000e18:	fca0 8101 	stc2	1, cr8, [r0], #4
 8000e1c:	fca0 9101 	stc2	1, cr9, [r0], #4
 8000e20:	fca0 a101 	stc2	1, cr10, [r0], #4
 8000e24:	fca0 b101 	stc2	1, cr11, [r0], #4
 8000e28:	4770      	bx	lr
 8000e2a:	bf00      	nop

08000e2c <_Unwind_RaiseException>:
 8000e2c:	46ec      	mov	ip, sp
 8000e2e:	b500      	push	{lr}
 8000e30:	e92d 5000 	stmdb	sp!, {ip, lr}
 8000e34:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8000e38:	f04f 0300 	mov.w	r3, #0
 8000e3c:	e92d 000c 	stmdb	sp!, {r2, r3}
 8000e40:	a901      	add	r1, sp, #4
 8000e42:	f7ff fbe9 	bl	8000618 <__gnu_Unwind_RaiseException>
 8000e46:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 8000e4a:	b012      	add	sp, #72	; 0x48
 8000e4c:	4770      	bx	lr
 8000e4e:	bf00      	nop

08000e50 <_Unwind_Resume>:
 8000e50:	46ec      	mov	ip, sp
 8000e52:	b500      	push	{lr}
 8000e54:	e92d 5000 	stmdb	sp!, {ip, lr}
 8000e58:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8000e5c:	f04f 0300 	mov.w	r3, #0
 8000e60:	e92d 000c 	stmdb	sp!, {r2, r3}
 8000e64:	a901      	add	r1, sp, #4
 8000e66:	f7ff fc11 	bl	800068c <__gnu_Unwind_Resume>
 8000e6a:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 8000e6e:	b012      	add	sp, #72	; 0x48
 8000e70:	4770      	bx	lr
 8000e72:	bf00      	nop

08000e74 <_Unwind_Resume_or_Rethrow>:
 8000e74:	46ec      	mov	ip, sp
 8000e76:	b500      	push	{lr}
 8000e78:	e92d 5000 	stmdb	sp!, {ip, lr}
 8000e7c:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8000e80:	f04f 0300 	mov.w	r3, #0
 8000e84:	e92d 000c 	stmdb	sp!, {r2, r3}
 8000e88:	a901      	add	r1, sp, #4
 8000e8a:	f7ff fc21 	bl	80006d0 <__gnu_Unwind_Resume_or_Rethrow>
 8000e8e:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 8000e92:	b012      	add	sp, #72	; 0x48
 8000e94:	4770      	bx	lr
 8000e96:	bf00      	nop

08000e98 <_Unwind_ForcedUnwind>:
 8000e98:	46ec      	mov	ip, sp
 8000e9a:	b500      	push	{lr}
 8000e9c:	e92d 5000 	stmdb	sp!, {ip, lr}
 8000ea0:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8000ea4:	f04f 0300 	mov.w	r3, #0
 8000ea8:	e92d 000c 	stmdb	sp!, {r2, r3}
 8000eac:	ab01      	add	r3, sp, #4
 8000eae:	f7ff fbe3 	bl	8000678 <__gnu_Unwind_ForcedUnwind>
 8000eb2:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 8000eb6:	b012      	add	sp, #72	; 0x48
 8000eb8:	4770      	bx	lr
 8000eba:	bf00      	nop

08000ebc <_Unwind_Backtrace>:
 8000ebc:	46ec      	mov	ip, sp
 8000ebe:	b500      	push	{lr}
 8000ec0:	e92d 5000 	stmdb	sp!, {ip, lr}
 8000ec4:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8000ec8:	f04f 0300 	mov.w	r3, #0
 8000ecc:	e92d 000c 	stmdb	sp!, {r2, r3}
 8000ed0:	aa01      	add	r2, sp, #4
 8000ed2:	f7ff fc5b 	bl	800078c <__gnu_Unwind_Backtrace>
 8000ed6:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 8000eda:	b012      	add	sp, #72	; 0x48
 8000edc:	4770      	bx	lr
 8000ede:	bf00      	nop

08000ee0 <next_unwind_byte>:
 8000ee0:	7a03      	ldrb	r3, [r0, #8]
 8000ee2:	b91b      	cbnz	r3, 8000eec <next_unwind_byte+0xc>
 8000ee4:	7a43      	ldrb	r3, [r0, #9]
 8000ee6:	b943      	cbnz	r3, 8000efa <next_unwind_byte+0x1a>
 8000ee8:	20b0      	movs	r0, #176	; 0xb0
 8000eea:	4770      	bx	lr
 8000eec:	1e5a      	subs	r2, r3, #1
 8000eee:	6803      	ldr	r3, [r0, #0]
 8000ef0:	7202      	strb	r2, [r0, #8]
 8000ef2:	021a      	lsls	r2, r3, #8
 8000ef4:	6002      	str	r2, [r0, #0]
 8000ef6:	0e18      	lsrs	r0, r3, #24
 8000ef8:	4770      	bx	lr
 8000efa:	6842      	ldr	r2, [r0, #4]
 8000efc:	3b01      	subs	r3, #1
 8000efe:	b410      	push	{r4}
 8000f00:	7243      	strb	r3, [r0, #9]
 8000f02:	6813      	ldr	r3, [r2, #0]
 8000f04:	2103      	movs	r1, #3
 8000f06:	1d14      	adds	r4, r2, #4
 8000f08:	7201      	strb	r1, [r0, #8]
 8000f0a:	021a      	lsls	r2, r3, #8
 8000f0c:	6044      	str	r4, [r0, #4]
 8000f0e:	6002      	str	r2, [r0, #0]
 8000f10:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000f14:	0e18      	lsrs	r0, r3, #24
 8000f16:	4770      	bx	lr

08000f18 <_Unwind_GetGR.constprop.0>:
 8000f18:	b500      	push	{lr}
 8000f1a:	b085      	sub	sp, #20
 8000f1c:	aa03      	add	r2, sp, #12
 8000f1e:	2300      	movs	r3, #0
 8000f20:	9200      	str	r2, [sp, #0]
 8000f22:	4619      	mov	r1, r3
 8000f24:	220c      	movs	r2, #12
 8000f26:	f7ff fbe3 	bl	80006f0 <_Unwind_VRS_Get>
 8000f2a:	9803      	ldr	r0, [sp, #12]
 8000f2c:	b005      	add	sp, #20
 8000f2e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000f32:	bf00      	nop

08000f34 <unwind_UCB_from_context>:
 8000f34:	e7f0      	b.n	8000f18 <_Unwind_GetGR.constprop.0>
 8000f36:	bf00      	nop

08000f38 <__gnu_unwind_execute>:
 8000f38:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8000f3c:	4606      	mov	r6, r0
 8000f3e:	b085      	sub	sp, #20
 8000f40:	460d      	mov	r5, r1
 8000f42:	f04f 0800 	mov.w	r8, #0
 8000f46:	4628      	mov	r0, r5
 8000f48:	f7ff ffca 	bl	8000ee0 <next_unwind_byte>
 8000f4c:	28b0      	cmp	r0, #176	; 0xb0
 8000f4e:	4604      	mov	r4, r0
 8000f50:	f000 80b4 	beq.w	80010bc <__gnu_unwind_execute+0x184>
 8000f54:	f020 037f 	bic.w	r3, r0, #127	; 0x7f
 8000f58:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 8000f5c:	d020      	beq.n	8000fa0 <__gnu_unwind_execute+0x68>
 8000f5e:	f000 03f0 	and.w	r3, r0, #240	; 0xf0
 8000f62:	2b80      	cmp	r3, #128	; 0x80
 8000f64:	d07a      	beq.n	800105c <__gnu_unwind_execute+0x124>
 8000f66:	2b90      	cmp	r3, #144	; 0x90
 8000f68:	d035      	beq.n	8000fd6 <__gnu_unwind_execute+0x9e>
 8000f6a:	2ba0      	cmp	r3, #160	; 0xa0
 8000f6c:	d048      	beq.n	8001000 <__gnu_unwind_execute+0xc8>
 8000f6e:	2bb0      	cmp	r3, #176	; 0xb0
 8000f70:	d05c      	beq.n	800102c <__gnu_unwind_execute+0xf4>
 8000f72:	2bc0      	cmp	r3, #192	; 0xc0
 8000f74:	f000 8089 	beq.w	800108a <__gnu_unwind_execute+0x152>
 8000f78:	f000 03f8 	and.w	r3, r0, #248	; 0xf8
 8000f7c:	2bd0      	cmp	r3, #208	; 0xd0
 8000f7e:	d10b      	bne.n	8000f98 <__gnu_unwind_execute+0x60>
 8000f80:	f000 0207 	and.w	r2, r0, #7
 8000f84:	3201      	adds	r2, #1
 8000f86:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8000f8a:	2305      	movs	r3, #5
 8000f8c:	2101      	movs	r1, #1
 8000f8e:	4630      	mov	r0, r6
 8000f90:	f7ff fda8 	bl	8000ae4 <_Unwind_VRS_Pop>
 8000f94:	2800      	cmp	r0, #0
 8000f96:	d0d6      	beq.n	8000f46 <__gnu_unwind_execute+0xe>
 8000f98:	2009      	movs	r0, #9
 8000f9a:	b005      	add	sp, #20
 8000f9c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8000fa0:	f10d 090c 	add.w	r9, sp, #12
 8000fa4:	4619      	mov	r1, r3
 8000fa6:	0087      	lsls	r7, r0, #2
 8000fa8:	f8cd 9000 	str.w	r9, [sp]
 8000fac:	220d      	movs	r2, #13
 8000fae:	4630      	mov	r0, r6
 8000fb0:	f7ff fb9e 	bl	80006f0 <_Unwind_VRS_Get>
 8000fb4:	b2ff      	uxtb	r7, r7
 8000fb6:	9b03      	ldr	r3, [sp, #12]
 8000fb8:	f8cd 9000 	str.w	r9, [sp]
 8000fbc:	3704      	adds	r7, #4
 8000fbe:	0660      	lsls	r0, r4, #25
 8000fc0:	bf4c      	ite	mi
 8000fc2:	1bdf      	submi	r7, r3, r7
 8000fc4:	18ff      	addpl	r7, r7, r3
 8000fc6:	2300      	movs	r3, #0
 8000fc8:	4619      	mov	r1, r3
 8000fca:	220d      	movs	r2, #13
 8000fcc:	4630      	mov	r0, r6
 8000fce:	9703      	str	r7, [sp, #12]
 8000fd0:	f7ff fbb4 	bl	800073c <_Unwind_VRS_Set>
 8000fd4:	e7b7      	b.n	8000f46 <__gnu_unwind_execute+0xe>
 8000fd6:	f000 030d 	and.w	r3, r0, #13
 8000fda:	2b0d      	cmp	r3, #13
 8000fdc:	d0dc      	beq.n	8000f98 <__gnu_unwind_execute+0x60>
 8000fde:	af03      	add	r7, sp, #12
 8000fe0:	2300      	movs	r3, #0
 8000fe2:	f000 020f 	and.w	r2, r0, #15
 8000fe6:	4619      	mov	r1, r3
 8000fe8:	9700      	str	r7, [sp, #0]
 8000fea:	4630      	mov	r0, r6
 8000fec:	f7ff fb80 	bl	80006f0 <_Unwind_VRS_Get>
 8000ff0:	2300      	movs	r3, #0
 8000ff2:	9700      	str	r7, [sp, #0]
 8000ff4:	4619      	mov	r1, r3
 8000ff6:	220d      	movs	r2, #13
 8000ff8:	4630      	mov	r0, r6
 8000ffa:	f7ff fb9f 	bl	800073c <_Unwind_VRS_Set>
 8000ffe:	e7a2      	b.n	8000f46 <__gnu_unwind_execute+0xe>
 8001000:	43c2      	mvns	r2, r0
 8001002:	f44f 637f 	mov.w	r3, #4080	; 0xff0
 8001006:	f002 0207 	and.w	r2, r2, #7
 800100a:	fa43 f202 	asr.w	r2, r3, r2
 800100e:	0701      	lsls	r1, r0, #28
 8001010:	ea02 0203 	and.w	r2, r2, r3
 8001014:	f04f 0300 	mov.w	r3, #0
 8001018:	bf48      	it	mi
 800101a:	f442 4280 	orrmi.w	r2, r2, #16384	; 0x4000
 800101e:	4619      	mov	r1, r3
 8001020:	4630      	mov	r0, r6
 8001022:	f7ff fd5f 	bl	8000ae4 <_Unwind_VRS_Pop>
 8001026:	2800      	cmp	r0, #0
 8001028:	d1b6      	bne.n	8000f98 <__gnu_unwind_execute+0x60>
 800102a:	e78c      	b.n	8000f46 <__gnu_unwind_execute+0xe>
 800102c:	28b1      	cmp	r0, #177	; 0xb1
 800102e:	d04a      	beq.n	80010c6 <__gnu_unwind_execute+0x18e>
 8001030:	28b2      	cmp	r0, #178	; 0xb2
 8001032:	d053      	beq.n	80010dc <__gnu_unwind_execute+0x1a4>
 8001034:	28b3      	cmp	r0, #179	; 0xb3
 8001036:	f000 8081 	beq.w	800113c <__gnu_unwind_execute+0x204>
 800103a:	f000 03fc 	and.w	r3, r0, #252	; 0xfc
 800103e:	2bb4      	cmp	r3, #180	; 0xb4
 8001040:	d0aa      	beq.n	8000f98 <__gnu_unwind_execute+0x60>
 8001042:	f000 0207 	and.w	r2, r0, #7
 8001046:	3201      	adds	r2, #1
 8001048:	2301      	movs	r3, #1
 800104a:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 800104e:	4619      	mov	r1, r3
 8001050:	4630      	mov	r0, r6
 8001052:	f7ff fd47 	bl	8000ae4 <_Unwind_VRS_Pop>
 8001056:	2800      	cmp	r0, #0
 8001058:	d19e      	bne.n	8000f98 <__gnu_unwind_execute+0x60>
 800105a:	e774      	b.n	8000f46 <__gnu_unwind_execute+0xe>
 800105c:	4628      	mov	r0, r5
 800105e:	f7ff ff3f 	bl	8000ee0 <next_unwind_byte>
 8001062:	0224      	lsls	r4, r4, #8
 8001064:	4320      	orrs	r0, r4
 8001066:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 800106a:	d095      	beq.n	8000f98 <__gnu_unwind_execute+0x60>
 800106c:	0104      	lsls	r4, r0, #4
 800106e:	2300      	movs	r3, #0
 8001070:	b2a2      	uxth	r2, r4
 8001072:	4619      	mov	r1, r3
 8001074:	4630      	mov	r0, r6
 8001076:	f7ff fd35 	bl	8000ae4 <_Unwind_VRS_Pop>
 800107a:	2800      	cmp	r0, #0
 800107c:	d18c      	bne.n	8000f98 <__gnu_unwind_execute+0x60>
 800107e:	f414 4f00 	tst.w	r4, #32768	; 0x8000
 8001082:	bf18      	it	ne
 8001084:	f04f 0801 	movne.w	r8, #1
 8001088:	e75d      	b.n	8000f46 <__gnu_unwind_execute+0xe>
 800108a:	28c6      	cmp	r0, #198	; 0xc6
 800108c:	d062      	beq.n	8001154 <__gnu_unwind_execute+0x21c>
 800108e:	28c7      	cmp	r0, #199	; 0xc7
 8001090:	d06c      	beq.n	800116c <__gnu_unwind_execute+0x234>
 8001092:	f000 03f8 	and.w	r3, r0, #248	; 0xf8
 8001096:	2bc0      	cmp	r3, #192	; 0xc0
 8001098:	d07b      	beq.n	8001192 <__gnu_unwind_execute+0x25a>
 800109a:	28c8      	cmp	r0, #200	; 0xc8
 800109c:	f000 8091 	beq.w	80011c2 <__gnu_unwind_execute+0x28a>
 80010a0:	28c9      	cmp	r0, #201	; 0xc9
 80010a2:	f47f af79 	bne.w	8000f98 <__gnu_unwind_execute+0x60>
 80010a6:	4628      	mov	r0, r5
 80010a8:	f7ff ff1a 	bl	8000ee0 <next_unwind_byte>
 80010ac:	0302      	lsls	r2, r0, #12
 80010ae:	f000 000f 	and.w	r0, r0, #15
 80010b2:	f402 2270 	and.w	r2, r2, #983040	; 0xf0000
 80010b6:	3001      	adds	r0, #1
 80010b8:	4302      	orrs	r2, r0
 80010ba:	e766      	b.n	8000f8a <__gnu_unwind_execute+0x52>
 80010bc:	f1b8 0f00 	cmp.w	r8, #0
 80010c0:	d06e      	beq.n	80011a0 <__gnu_unwind_execute+0x268>
 80010c2:	2000      	movs	r0, #0
 80010c4:	e769      	b.n	8000f9a <__gnu_unwind_execute+0x62>
 80010c6:	4628      	mov	r0, r5
 80010c8:	f7ff ff0a 	bl	8000ee0 <next_unwind_byte>
 80010cc:	4602      	mov	r2, r0
 80010ce:	2800      	cmp	r0, #0
 80010d0:	f43f af62 	beq.w	8000f98 <__gnu_unwind_execute+0x60>
 80010d4:	f010 03f0 	ands.w	r3, r0, #240	; 0xf0
 80010d8:	d0b9      	beq.n	800104e <__gnu_unwind_execute+0x116>
 80010da:	e75d      	b.n	8000f98 <__gnu_unwind_execute+0x60>
 80010dc:	2300      	movs	r3, #0
 80010de:	f10d 090c 	add.w	r9, sp, #12
 80010e2:	220d      	movs	r2, #13
 80010e4:	4619      	mov	r1, r3
 80010e6:	f8cd 9000 	str.w	r9, [sp]
 80010ea:	4630      	mov	r0, r6
 80010ec:	f7ff fb00 	bl	80006f0 <_Unwind_VRS_Get>
 80010f0:	4628      	mov	r0, r5
 80010f2:	f7ff fef5 	bl	8000ee0 <next_unwind_byte>
 80010f6:	0602      	lsls	r2, r0, #24
 80010f8:	f04f 0402 	mov.w	r4, #2
 80010fc:	d50c      	bpl.n	8001118 <__gnu_unwind_execute+0x1e0>
 80010fe:	9b03      	ldr	r3, [sp, #12]
 8001100:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 8001104:	40a0      	lsls	r0, r4
 8001106:	4403      	add	r3, r0
 8001108:	4628      	mov	r0, r5
 800110a:	9303      	str	r3, [sp, #12]
 800110c:	f7ff fee8 	bl	8000ee0 <next_unwind_byte>
 8001110:	0603      	lsls	r3, r0, #24
 8001112:	f104 0407 	add.w	r4, r4, #7
 8001116:	d4f2      	bmi.n	80010fe <__gnu_unwind_execute+0x1c6>
 8001118:	9b03      	ldr	r3, [sp, #12]
 800111a:	f8cd 9000 	str.w	r9, [sp]
 800111e:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 8001122:	fa00 f204 	lsl.w	r2, r0, r4
 8001126:	f503 7401 	add.w	r4, r3, #516	; 0x204
 800112a:	2300      	movs	r3, #0
 800112c:	4414      	add	r4, r2
 800112e:	4619      	mov	r1, r3
 8001130:	220d      	movs	r2, #13
 8001132:	4630      	mov	r0, r6
 8001134:	9403      	str	r4, [sp, #12]
 8001136:	f7ff fb01 	bl	800073c <_Unwind_VRS_Set>
 800113a:	e704      	b.n	8000f46 <__gnu_unwind_execute+0xe>
 800113c:	4628      	mov	r0, r5
 800113e:	f7ff fecf 	bl	8000ee0 <next_unwind_byte>
 8001142:	0301      	lsls	r1, r0, #12
 8001144:	f000 000f 	and.w	r0, r0, #15
 8001148:	f401 2170 	and.w	r1, r1, #983040	; 0xf0000
 800114c:	1c42      	adds	r2, r0, #1
 800114e:	2301      	movs	r3, #1
 8001150:	430a      	orrs	r2, r1
 8001152:	e77c      	b.n	800104e <__gnu_unwind_execute+0x116>
 8001154:	4628      	mov	r0, r5
 8001156:	f7ff fec3 	bl	8000ee0 <next_unwind_byte>
 800115a:	0301      	lsls	r1, r0, #12
 800115c:	f000 000f 	and.w	r0, r0, #15
 8001160:	f401 2170 	and.w	r1, r1, #983040	; 0xf0000
 8001164:	1c42      	adds	r2, r0, #1
 8001166:	2303      	movs	r3, #3
 8001168:	430a      	orrs	r2, r1
 800116a:	e770      	b.n	800104e <__gnu_unwind_execute+0x116>
 800116c:	4628      	mov	r0, r5
 800116e:	f7ff feb7 	bl	8000ee0 <next_unwind_byte>
 8001172:	4602      	mov	r2, r0
 8001174:	2800      	cmp	r0, #0
 8001176:	f43f af0f 	beq.w	8000f98 <__gnu_unwind_execute+0x60>
 800117a:	f010 03f0 	ands.w	r3, r0, #240	; 0xf0
 800117e:	f47f af0b 	bne.w	8000f98 <__gnu_unwind_execute+0x60>
 8001182:	2104      	movs	r1, #4
 8001184:	4630      	mov	r0, r6
 8001186:	f7ff fcad 	bl	8000ae4 <_Unwind_VRS_Pop>
 800118a:	2800      	cmp	r0, #0
 800118c:	f47f af04 	bne.w	8000f98 <__gnu_unwind_execute+0x60>
 8001190:	e6d9      	b.n	8000f46 <__gnu_unwind_execute+0xe>
 8001192:	f000 020f 	and.w	r2, r0, #15
 8001196:	3201      	adds	r2, #1
 8001198:	2303      	movs	r3, #3
 800119a:	f442 2220 	orr.w	r2, r2, #655360	; 0xa0000
 800119e:	e756      	b.n	800104e <__gnu_unwind_execute+0x116>
 80011a0:	ac03      	add	r4, sp, #12
 80011a2:	4643      	mov	r3, r8
 80011a4:	220e      	movs	r2, #14
 80011a6:	4641      	mov	r1, r8
 80011a8:	9400      	str	r4, [sp, #0]
 80011aa:	4630      	mov	r0, r6
 80011ac:	f7ff faa0 	bl	80006f0 <_Unwind_VRS_Get>
 80011b0:	9400      	str	r4, [sp, #0]
 80011b2:	4630      	mov	r0, r6
 80011b4:	4643      	mov	r3, r8
 80011b6:	220f      	movs	r2, #15
 80011b8:	4641      	mov	r1, r8
 80011ba:	f7ff fabf 	bl	800073c <_Unwind_VRS_Set>
 80011be:	4640      	mov	r0, r8
 80011c0:	e6eb      	b.n	8000f9a <__gnu_unwind_execute+0x62>
 80011c2:	4628      	mov	r0, r5
 80011c4:	f7ff fe8c 	bl	8000ee0 <next_unwind_byte>
 80011c8:	f000 02f0 	and.w	r2, r0, #240	; 0xf0
 80011cc:	f000 030f 	and.w	r3, r0, #15
 80011d0:	3210      	adds	r2, #16
 80011d2:	3301      	adds	r3, #1
 80011d4:	ea43 3202 	orr.w	r2, r3, r2, lsl #12
 80011d8:	e6d7      	b.n	8000f8a <__gnu_unwind_execute+0x52>
 80011da:	bf00      	nop

080011dc <__gnu_unwind_frame>:
 80011dc:	b510      	push	{r4, lr}
 80011de:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 80011e0:	b084      	sub	sp, #16
 80011e2:	685a      	ldr	r2, [r3, #4]
 80011e4:	2003      	movs	r0, #3
 80011e6:	f88d 000c 	strb.w	r0, [sp, #12]
 80011ea:	79dc      	ldrb	r4, [r3, #7]
 80011ec:	f88d 400d 	strb.w	r4, [sp, #13]
 80011f0:	0212      	lsls	r2, r2, #8
 80011f2:	3308      	adds	r3, #8
 80011f4:	4608      	mov	r0, r1
 80011f6:	a901      	add	r1, sp, #4
 80011f8:	9201      	str	r2, [sp, #4]
 80011fa:	9302      	str	r3, [sp, #8]
 80011fc:	f7ff fe9c 	bl	8000f38 <__gnu_unwind_execute>
 8001200:	b004      	add	sp, #16
 8001202:	bd10      	pop	{r4, pc}

08001204 <_Unwind_GetRegionStart>:
 8001204:	b508      	push	{r3, lr}
 8001206:	f7ff fe95 	bl	8000f34 <unwind_UCB_from_context>
 800120a:	6c80      	ldr	r0, [r0, #72]	; 0x48
 800120c:	bd08      	pop	{r3, pc}
 800120e:	bf00      	nop

08001210 <_Unwind_GetLanguageSpecificData>:
 8001210:	b508      	push	{r3, lr}
 8001212:	f7ff fe8f 	bl	8000f34 <unwind_UCB_from_context>
 8001216:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8001218:	79d8      	ldrb	r0, [r3, #7]
 800121a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800121e:	3008      	adds	r0, #8
 8001220:	bd08      	pop	{r3, pc}
 8001222:	bf00      	nop

08001224 <_Unwind_GetTextRelBase>:
 8001224:	b508      	push	{r3, lr}
 8001226:	f000 f805 	bl	8001234 <abort>
 800122a:	bf00      	nop

0800122c <_Unwind_GetDataRelBase>:
 800122c:	b508      	push	{r3, lr}
 800122e:	f7ff fff9 	bl	8001224 <_Unwind_GetTextRelBase>
 8001232:	bf00      	nop

08001234 <abort>:
 8001234:	b508      	push	{r3, lr}
 8001236:	2006      	movs	r0, #6
 8001238:	f000 fc44 	bl	8001ac4 <raise>
 800123c:	2001      	movs	r0, #1
 800123e:	f00b fb57 	bl	800c8f0 <_exit>
 8001242:	bf00      	nop

08001244 <malloc>:
 8001244:	4b02      	ldr	r3, [pc, #8]	; (8001250 <malloc+0xc>)
 8001246:	4601      	mov	r1, r0
 8001248:	6818      	ldr	r0, [r3, #0]
 800124a:	f000 b80b 	b.w	8001264 <_malloc_r>
 800124e:	bf00      	nop
 8001250:	20002010 	.word	0x20002010

08001254 <free>:
 8001254:	4b02      	ldr	r3, [pc, #8]	; (8001260 <free+0xc>)
 8001256:	4601      	mov	r1, r0
 8001258:	6818      	ldr	r0, [r3, #0]
 800125a:	f000 be2d 	b.w	8001eb8 <_free_r>
 800125e:	bf00      	nop
 8001260:	20002010 	.word	0x20002010

08001264 <_malloc_r>:
 8001264:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001268:	f101 050b 	add.w	r5, r1, #11
 800126c:	2d16      	cmp	r5, #22
 800126e:	b083      	sub	sp, #12
 8001270:	4606      	mov	r6, r0
 8001272:	f240 809f 	bls.w	80013b4 <_malloc_r+0x150>
 8001276:	f035 0507 	bics.w	r5, r5, #7
 800127a:	f100 80bf 	bmi.w	80013fc <_malloc_r+0x198>
 800127e:	42a9      	cmp	r1, r5
 8001280:	f200 80bc 	bhi.w	80013fc <_malloc_r+0x198>
 8001284:	f000 fb8c 	bl	80019a0 <__malloc_lock>
 8001288:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
 800128c:	f0c0 8299 	bcc.w	80017c2 <_malloc_r+0x55e>
 8001290:	0a6b      	lsrs	r3, r5, #9
 8001292:	f000 80ba 	beq.w	800140a <_malloc_r+0x1a6>
 8001296:	2b04      	cmp	r3, #4
 8001298:	f200 8187 	bhi.w	80015aa <_malloc_r+0x346>
 800129c:	09a8      	lsrs	r0, r5, #6
 800129e:	f100 0e39 	add.w	lr, r0, #57	; 0x39
 80012a2:	ea4f 034e 	mov.w	r3, lr, lsl #1
 80012a6:	3038      	adds	r0, #56	; 0x38
 80012a8:	4fc6      	ldr	r7, [pc, #792]	; (80015c4 <_malloc_r+0x360>)
 80012aa:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 80012ae:	f1a3 0108 	sub.w	r1, r3, #8
 80012b2:	685c      	ldr	r4, [r3, #4]
 80012b4:	42a1      	cmp	r1, r4
 80012b6:	d107      	bne.n	80012c8 <_malloc_r+0x64>
 80012b8:	e0ac      	b.n	8001414 <_malloc_r+0x1b0>
 80012ba:	2a00      	cmp	r2, #0
 80012bc:	f280 80ac 	bge.w	8001418 <_malloc_r+0x1b4>
 80012c0:	68e4      	ldr	r4, [r4, #12]
 80012c2:	42a1      	cmp	r1, r4
 80012c4:	f000 80a6 	beq.w	8001414 <_malloc_r+0x1b0>
 80012c8:	6863      	ldr	r3, [r4, #4]
 80012ca:	f023 0303 	bic.w	r3, r3, #3
 80012ce:	1b5a      	subs	r2, r3, r5
 80012d0:	2a0f      	cmp	r2, #15
 80012d2:	ddf2      	ble.n	80012ba <_malloc_r+0x56>
 80012d4:	49bb      	ldr	r1, [pc, #748]	; (80015c4 <_malloc_r+0x360>)
 80012d6:	693c      	ldr	r4, [r7, #16]
 80012d8:	f101 0e08 	add.w	lr, r1, #8
 80012dc:	4574      	cmp	r4, lr
 80012de:	f000 81af 	beq.w	8001640 <_malloc_r+0x3dc>
 80012e2:	6863      	ldr	r3, [r4, #4]
 80012e4:	f023 0303 	bic.w	r3, r3, #3
 80012e8:	1b5a      	subs	r2, r3, r5
 80012ea:	2a0f      	cmp	r2, #15
 80012ec:	f300 8195 	bgt.w	800161a <_malloc_r+0x3b6>
 80012f0:	2a00      	cmp	r2, #0
 80012f2:	f8c1 e014 	str.w	lr, [r1, #20]
 80012f6:	f8c1 e010 	str.w	lr, [r1, #16]
 80012fa:	f280 809e 	bge.w	800143a <_malloc_r+0x1d6>
 80012fe:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8001302:	f080 8163 	bcs.w	80015cc <_malloc_r+0x368>
 8001306:	08db      	lsrs	r3, r3, #3
 8001308:	f103 0c01 	add.w	ip, r3, #1
 800130c:	2201      	movs	r2, #1
 800130e:	109b      	asrs	r3, r3, #2
 8001310:	fa02 f303 	lsl.w	r3, r2, r3
 8001314:	684a      	ldr	r2, [r1, #4]
 8001316:	f851 803c 	ldr.w	r8, [r1, ip, lsl #3]
 800131a:	f8c4 8008 	str.w	r8, [r4, #8]
 800131e:	eb01 09cc 	add.w	r9, r1, ip, lsl #3
 8001322:	431a      	orrs	r2, r3
 8001324:	f1a9 0308 	sub.w	r3, r9, #8
 8001328:	60e3      	str	r3, [r4, #12]
 800132a:	604a      	str	r2, [r1, #4]
 800132c:	f841 403c 	str.w	r4, [r1, ip, lsl #3]
 8001330:	f8c8 400c 	str.w	r4, [r8, #12]
 8001334:	1083      	asrs	r3, r0, #2
 8001336:	2401      	movs	r4, #1
 8001338:	409c      	lsls	r4, r3
 800133a:	4294      	cmp	r4, r2
 800133c:	f200 808a 	bhi.w	8001454 <_malloc_r+0x1f0>
 8001340:	4214      	tst	r4, r2
 8001342:	d106      	bne.n	8001352 <_malloc_r+0xee>
 8001344:	f020 0003 	bic.w	r0, r0, #3
 8001348:	0064      	lsls	r4, r4, #1
 800134a:	4214      	tst	r4, r2
 800134c:	f100 0004 	add.w	r0, r0, #4
 8001350:	d0fa      	beq.n	8001348 <_malloc_r+0xe4>
 8001352:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
 8001356:	46cc      	mov	ip, r9
 8001358:	4680      	mov	r8, r0
 800135a:	f8dc 100c 	ldr.w	r1, [ip, #12]
 800135e:	458c      	cmp	ip, r1
 8001360:	d107      	bne.n	8001372 <_malloc_r+0x10e>
 8001362:	e16f      	b.n	8001644 <_malloc_r+0x3e0>
 8001364:	2a00      	cmp	r2, #0
 8001366:	f280 817d 	bge.w	8001664 <_malloc_r+0x400>
 800136a:	68c9      	ldr	r1, [r1, #12]
 800136c:	458c      	cmp	ip, r1
 800136e:	f000 8169 	beq.w	8001644 <_malloc_r+0x3e0>
 8001372:	684b      	ldr	r3, [r1, #4]
 8001374:	f023 0303 	bic.w	r3, r3, #3
 8001378:	1b5a      	subs	r2, r3, r5
 800137a:	2a0f      	cmp	r2, #15
 800137c:	ddf2      	ble.n	8001364 <_malloc_r+0x100>
 800137e:	460c      	mov	r4, r1
 8001380:	f8d1 c00c 	ldr.w	ip, [r1, #12]
 8001384:	f854 8f08 	ldr.w	r8, [r4, #8]!
 8001388:	194b      	adds	r3, r1, r5
 800138a:	f045 0501 	orr.w	r5, r5, #1
 800138e:	604d      	str	r5, [r1, #4]
 8001390:	f042 0101 	orr.w	r1, r2, #1
 8001394:	f8c8 c00c 	str.w	ip, [r8, #12]
 8001398:	4630      	mov	r0, r6
 800139a:	f8cc 8008 	str.w	r8, [ip, #8]
 800139e:	617b      	str	r3, [r7, #20]
 80013a0:	613b      	str	r3, [r7, #16]
 80013a2:	f8c3 e00c 	str.w	lr, [r3, #12]
 80013a6:	f8c3 e008 	str.w	lr, [r3, #8]
 80013aa:	6059      	str	r1, [r3, #4]
 80013ac:	509a      	str	r2, [r3, r2]
 80013ae:	f000 faf9 	bl	80019a4 <__malloc_unlock>
 80013b2:	e01f      	b.n	80013f4 <_malloc_r+0x190>
 80013b4:	2910      	cmp	r1, #16
 80013b6:	d821      	bhi.n	80013fc <_malloc_r+0x198>
 80013b8:	f000 faf2 	bl	80019a0 <__malloc_lock>
 80013bc:	2510      	movs	r5, #16
 80013be:	2306      	movs	r3, #6
 80013c0:	2002      	movs	r0, #2
 80013c2:	4f80      	ldr	r7, [pc, #512]	; (80015c4 <_malloc_r+0x360>)
 80013c4:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 80013c8:	f1a3 0208 	sub.w	r2, r3, #8
 80013cc:	685c      	ldr	r4, [r3, #4]
 80013ce:	4294      	cmp	r4, r2
 80013d0:	f000 8141 	beq.w	8001656 <_malloc_r+0x3f2>
 80013d4:	6863      	ldr	r3, [r4, #4]
 80013d6:	68e1      	ldr	r1, [r4, #12]
 80013d8:	68a5      	ldr	r5, [r4, #8]
 80013da:	f023 0303 	bic.w	r3, r3, #3
 80013de:	4423      	add	r3, r4
 80013e0:	4630      	mov	r0, r6
 80013e2:	685a      	ldr	r2, [r3, #4]
 80013e4:	60e9      	str	r1, [r5, #12]
 80013e6:	f042 0201 	orr.w	r2, r2, #1
 80013ea:	608d      	str	r5, [r1, #8]
 80013ec:	605a      	str	r2, [r3, #4]
 80013ee:	f000 fad9 	bl	80019a4 <__malloc_unlock>
 80013f2:	3408      	adds	r4, #8
 80013f4:	4620      	mov	r0, r4
 80013f6:	b003      	add	sp, #12
 80013f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80013fc:	2400      	movs	r4, #0
 80013fe:	230c      	movs	r3, #12
 8001400:	4620      	mov	r0, r4
 8001402:	6033      	str	r3, [r6, #0]
 8001404:	b003      	add	sp, #12
 8001406:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800140a:	2380      	movs	r3, #128	; 0x80
 800140c:	f04f 0e40 	mov.w	lr, #64	; 0x40
 8001410:	203f      	movs	r0, #63	; 0x3f
 8001412:	e749      	b.n	80012a8 <_malloc_r+0x44>
 8001414:	4670      	mov	r0, lr
 8001416:	e75d      	b.n	80012d4 <_malloc_r+0x70>
 8001418:	4423      	add	r3, r4
 800141a:	68e1      	ldr	r1, [r4, #12]
 800141c:	685a      	ldr	r2, [r3, #4]
 800141e:	68a5      	ldr	r5, [r4, #8]
 8001420:	f042 0201 	orr.w	r2, r2, #1
 8001424:	60e9      	str	r1, [r5, #12]
 8001426:	4630      	mov	r0, r6
 8001428:	608d      	str	r5, [r1, #8]
 800142a:	605a      	str	r2, [r3, #4]
 800142c:	f000 faba 	bl	80019a4 <__malloc_unlock>
 8001430:	3408      	adds	r4, #8
 8001432:	4620      	mov	r0, r4
 8001434:	b003      	add	sp, #12
 8001436:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800143a:	4423      	add	r3, r4
 800143c:	4630      	mov	r0, r6
 800143e:	685a      	ldr	r2, [r3, #4]
 8001440:	f042 0201 	orr.w	r2, r2, #1
 8001444:	605a      	str	r2, [r3, #4]
 8001446:	f000 faad 	bl	80019a4 <__malloc_unlock>
 800144a:	3408      	adds	r4, #8
 800144c:	4620      	mov	r0, r4
 800144e:	b003      	add	sp, #12
 8001450:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001454:	68bc      	ldr	r4, [r7, #8]
 8001456:	6863      	ldr	r3, [r4, #4]
 8001458:	f023 0803 	bic.w	r8, r3, #3
 800145c:	45a8      	cmp	r8, r5
 800145e:	d304      	bcc.n	800146a <_malloc_r+0x206>
 8001460:	ebc5 0308 	rsb	r3, r5, r8
 8001464:	2b0f      	cmp	r3, #15
 8001466:	f300 8090 	bgt.w	800158a <_malloc_r+0x326>
 800146a:	f8df 915c 	ldr.w	r9, [pc, #348]	; 80015c8 <_malloc_r+0x364>
 800146e:	f8d7 3408 	ldr.w	r3, [r7, #1032]	; 0x408
 8001472:	f8d9 2000 	ldr.w	r2, [r9]
 8001476:	3301      	adds	r3, #1
 8001478:	eb04 0a08 	add.w	sl, r4, r8
 800147c:	442a      	add	r2, r5
 800147e:	f000 815c 	beq.w	800173a <_malloc_r+0x4d6>
 8001482:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8001486:	320f      	adds	r2, #15
 8001488:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
 800148c:	f022 020f 	bic.w	r2, r2, #15
 8001490:	4611      	mov	r1, r2
 8001492:	4630      	mov	r0, r6
 8001494:	9201      	str	r2, [sp, #4]
 8001496:	f007 fa5b 	bl	8008950 <_sbrk_r>
 800149a:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800149e:	4683      	mov	fp, r0
 80014a0:	9a01      	ldr	r2, [sp, #4]
 80014a2:	f000 8154 	beq.w	800174e <_malloc_r+0x4ea>
 80014a6:	4582      	cmp	sl, r0
 80014a8:	f200 80f8 	bhi.w	800169c <_malloc_r+0x438>
 80014ac:	f8d9 1004 	ldr.w	r1, [r9, #4]
 80014b0:	45da      	cmp	sl, fp
 80014b2:	4411      	add	r1, r2
 80014b4:	f8c9 1004 	str.w	r1, [r9, #4]
 80014b8:	f000 814e 	beq.w	8001758 <_malloc_r+0x4f4>
 80014bc:	f8d7 3408 	ldr.w	r3, [r7, #1032]	; 0x408
 80014c0:	4840      	ldr	r0, [pc, #256]	; (80015c4 <_malloc_r+0x360>)
 80014c2:	3301      	adds	r3, #1
 80014c4:	bf1b      	ittet	ne
 80014c6:	ebca 0a0b 	rsbne	sl, sl, fp
 80014ca:	4451      	addne	r1, sl
 80014cc:	f8c0 b408 	streq.w	fp, [r0, #1032]	; 0x408
 80014d0:	f8c9 1004 	strne.w	r1, [r9, #4]
 80014d4:	f01b 0107 	ands.w	r1, fp, #7
 80014d8:	f000 8112 	beq.w	8001700 <_malloc_r+0x49c>
 80014dc:	f1c1 0308 	rsb	r3, r1, #8
 80014e0:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
 80014e4:	449b      	add	fp, r3
 80014e6:	3108      	adds	r1, #8
 80014e8:	eb0b 0302 	add.w	r3, fp, r2
 80014ec:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80014f0:	ebc3 0a01 	rsb	sl, r3, r1
 80014f4:	4651      	mov	r1, sl
 80014f6:	4630      	mov	r0, r6
 80014f8:	f007 fa2a 	bl	8008950 <_sbrk_r>
 80014fc:	1c43      	adds	r3, r0, #1
 80014fe:	f000 813c 	beq.w	800177a <_malloc_r+0x516>
 8001502:	ebcb 0300 	rsb	r3, fp, r0
 8001506:	4453      	add	r3, sl
 8001508:	f043 0301 	orr.w	r3, r3, #1
 800150c:	f8d9 1004 	ldr.w	r1, [r9, #4]
 8001510:	f8c7 b008 	str.w	fp, [r7, #8]
 8001514:	4451      	add	r1, sl
 8001516:	42bc      	cmp	r4, r7
 8001518:	f8cb 3004 	str.w	r3, [fp, #4]
 800151c:	f8c9 1004 	str.w	r1, [r9, #4]
 8001520:	f8df a0a4 	ldr.w	sl, [pc, #164]	; 80015c8 <_malloc_r+0x364>
 8001524:	d016      	beq.n	8001554 <_malloc_r+0x2f0>
 8001526:	f1b8 0f0f 	cmp.w	r8, #15
 800152a:	f240 80f7 	bls.w	800171c <_malloc_r+0x4b8>
 800152e:	6862      	ldr	r2, [r4, #4]
 8001530:	f1a8 030c 	sub.w	r3, r8, #12
 8001534:	f023 0307 	bic.w	r3, r3, #7
 8001538:	18e0      	adds	r0, r4, r3
 800153a:	f002 0201 	and.w	r2, r2, #1
 800153e:	f04f 0e05 	mov.w	lr, #5
 8001542:	431a      	orrs	r2, r3
 8001544:	2b0f      	cmp	r3, #15
 8001546:	6062      	str	r2, [r4, #4]
 8001548:	f8c0 e004 	str.w	lr, [r0, #4]
 800154c:	f8c0 e008 	str.w	lr, [r0, #8]
 8001550:	f200 8117 	bhi.w	8001782 <_malloc_r+0x51e>
 8001554:	f8d9 302c 	ldr.w	r3, [r9, #44]	; 0x2c
 8001558:	4a1b      	ldr	r2, [pc, #108]	; (80015c8 <_malloc_r+0x364>)
 800155a:	68bc      	ldr	r4, [r7, #8]
 800155c:	4299      	cmp	r1, r3
 800155e:	f8d9 3030 	ldr.w	r3, [r9, #48]	; 0x30
 8001562:	bf88      	it	hi
 8001564:	62d1      	strhi	r1, [r2, #44]	; 0x2c
 8001566:	4a18      	ldr	r2, [pc, #96]	; (80015c8 <_malloc_r+0x364>)
 8001568:	4299      	cmp	r1, r3
 800156a:	bf88      	it	hi
 800156c:	6311      	strhi	r1, [r2, #48]	; 0x30
 800156e:	6862      	ldr	r2, [r4, #4]
 8001570:	f022 0203 	bic.w	r2, r2, #3
 8001574:	4295      	cmp	r5, r2
 8001576:	eba2 0305 	sub.w	r3, r2, r5
 800157a:	d801      	bhi.n	8001580 <_malloc_r+0x31c>
 800157c:	2b0f      	cmp	r3, #15
 800157e:	dc04      	bgt.n	800158a <_malloc_r+0x326>
 8001580:	4630      	mov	r0, r6
 8001582:	f000 fa0f 	bl	80019a4 <__malloc_unlock>
 8001586:	2400      	movs	r4, #0
 8001588:	e734      	b.n	80013f4 <_malloc_r+0x190>
 800158a:	1962      	adds	r2, r4, r5
 800158c:	f043 0301 	orr.w	r3, r3, #1
 8001590:	f045 0501 	orr.w	r5, r5, #1
 8001594:	6065      	str	r5, [r4, #4]
 8001596:	4630      	mov	r0, r6
 8001598:	60ba      	str	r2, [r7, #8]
 800159a:	6053      	str	r3, [r2, #4]
 800159c:	f000 fa02 	bl	80019a4 <__malloc_unlock>
 80015a0:	3408      	adds	r4, #8
 80015a2:	4620      	mov	r0, r4
 80015a4:	b003      	add	sp, #12
 80015a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80015aa:	2b14      	cmp	r3, #20
 80015ac:	d969      	bls.n	8001682 <_malloc_r+0x41e>
 80015ae:	2b54      	cmp	r3, #84	; 0x54
 80015b0:	f200 809c 	bhi.w	80016ec <_malloc_r+0x488>
 80015b4:	0b28      	lsrs	r0, r5, #12
 80015b6:	f100 0e6f 	add.w	lr, r0, #111	; 0x6f
 80015ba:	ea4f 034e 	mov.w	r3, lr, lsl #1
 80015be:	306e      	adds	r0, #110	; 0x6e
 80015c0:	e672      	b.n	80012a8 <_malloc_r+0x44>
 80015c2:	bf00      	nop
 80015c4:	20001c00 	.word	0x20001c00
 80015c8:	200025b8 	.word	0x200025b8
 80015cc:	0a5a      	lsrs	r2, r3, #9
 80015ce:	2a04      	cmp	r2, #4
 80015d0:	d95e      	bls.n	8001690 <_malloc_r+0x42c>
 80015d2:	2a14      	cmp	r2, #20
 80015d4:	f200 80b3 	bhi.w	800173e <_malloc_r+0x4da>
 80015d8:	f102 015c 	add.w	r1, r2, #92	; 0x5c
 80015dc:	0049      	lsls	r1, r1, #1
 80015de:	325b      	adds	r2, #91	; 0x5b
 80015e0:	eb07 0c81 	add.w	ip, r7, r1, lsl #2
 80015e4:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
 80015e8:	f8df 81e0 	ldr.w	r8, [pc, #480]	; 80017cc <_malloc_r+0x568>
 80015ec:	f1ac 0c08 	sub.w	ip, ip, #8
 80015f0:	458c      	cmp	ip, r1
 80015f2:	f000 8088 	beq.w	8001706 <_malloc_r+0x4a2>
 80015f6:	684a      	ldr	r2, [r1, #4]
 80015f8:	f022 0203 	bic.w	r2, r2, #3
 80015fc:	4293      	cmp	r3, r2
 80015fe:	d202      	bcs.n	8001606 <_malloc_r+0x3a2>
 8001600:	6889      	ldr	r1, [r1, #8]
 8001602:	458c      	cmp	ip, r1
 8001604:	d1f7      	bne.n	80015f6 <_malloc_r+0x392>
 8001606:	f8d1 c00c 	ldr.w	ip, [r1, #12]
 800160a:	687a      	ldr	r2, [r7, #4]
 800160c:	f8c4 c00c 	str.w	ip, [r4, #12]
 8001610:	60a1      	str	r1, [r4, #8]
 8001612:	f8cc 4008 	str.w	r4, [ip, #8]
 8001616:	60cc      	str	r4, [r1, #12]
 8001618:	e68c      	b.n	8001334 <_malloc_r+0xd0>
 800161a:	1963      	adds	r3, r4, r5
 800161c:	f042 0701 	orr.w	r7, r2, #1
 8001620:	f045 0501 	orr.w	r5, r5, #1
 8001624:	6065      	str	r5, [r4, #4]
 8001626:	4630      	mov	r0, r6
 8001628:	614b      	str	r3, [r1, #20]
 800162a:	610b      	str	r3, [r1, #16]
 800162c:	f8c3 e00c 	str.w	lr, [r3, #12]
 8001630:	f8c3 e008 	str.w	lr, [r3, #8]
 8001634:	605f      	str	r7, [r3, #4]
 8001636:	509a      	str	r2, [r3, r2]
 8001638:	3408      	adds	r4, #8
 800163a:	f000 f9b3 	bl	80019a4 <__malloc_unlock>
 800163e:	e6d9      	b.n	80013f4 <_malloc_r+0x190>
 8001640:	684a      	ldr	r2, [r1, #4]
 8001642:	e677      	b.n	8001334 <_malloc_r+0xd0>
 8001644:	f108 0801 	add.w	r8, r8, #1
 8001648:	f018 0f03 	tst.w	r8, #3
 800164c:	f10c 0c08 	add.w	ip, ip, #8
 8001650:	f47f ae83 	bne.w	800135a <_malloc_r+0xf6>
 8001654:	e030      	b.n	80016b8 <_malloc_r+0x454>
 8001656:	68dc      	ldr	r4, [r3, #12]
 8001658:	42a3      	cmp	r3, r4
 800165a:	bf08      	it	eq
 800165c:	3002      	addeq	r0, #2
 800165e:	f43f ae39 	beq.w	80012d4 <_malloc_r+0x70>
 8001662:	e6b7      	b.n	80013d4 <_malloc_r+0x170>
 8001664:	440b      	add	r3, r1
 8001666:	460c      	mov	r4, r1
 8001668:	685a      	ldr	r2, [r3, #4]
 800166a:	68c9      	ldr	r1, [r1, #12]
 800166c:	f854 5f08 	ldr.w	r5, [r4, #8]!
 8001670:	f042 0201 	orr.w	r2, r2, #1
 8001674:	605a      	str	r2, [r3, #4]
 8001676:	4630      	mov	r0, r6
 8001678:	60e9      	str	r1, [r5, #12]
 800167a:	608d      	str	r5, [r1, #8]
 800167c:	f000 f992 	bl	80019a4 <__malloc_unlock>
 8001680:	e6b8      	b.n	80013f4 <_malloc_r+0x190>
 8001682:	f103 0e5c 	add.w	lr, r3, #92	; 0x5c
 8001686:	f103 005b 	add.w	r0, r3, #91	; 0x5b
 800168a:	ea4f 034e 	mov.w	r3, lr, lsl #1
 800168e:	e60b      	b.n	80012a8 <_malloc_r+0x44>
 8001690:	099a      	lsrs	r2, r3, #6
 8001692:	f102 0139 	add.w	r1, r2, #57	; 0x39
 8001696:	0049      	lsls	r1, r1, #1
 8001698:	3238      	adds	r2, #56	; 0x38
 800169a:	e7a1      	b.n	80015e0 <_malloc_r+0x37c>
 800169c:	42bc      	cmp	r4, r7
 800169e:	4b4b      	ldr	r3, [pc, #300]	; (80017cc <_malloc_r+0x568>)
 80016a0:	f43f af04 	beq.w	80014ac <_malloc_r+0x248>
 80016a4:	689c      	ldr	r4, [r3, #8]
 80016a6:	6862      	ldr	r2, [r4, #4]
 80016a8:	f022 0203 	bic.w	r2, r2, #3
 80016ac:	e762      	b.n	8001574 <_malloc_r+0x310>
 80016ae:	f859 3908 	ldr.w	r3, [r9], #-8
 80016b2:	4599      	cmp	r9, r3
 80016b4:	f040 8083 	bne.w	80017be <_malloc_r+0x55a>
 80016b8:	f010 0f03 	tst.w	r0, #3
 80016bc:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
 80016c0:	d1f5      	bne.n	80016ae <_malloc_r+0x44a>
 80016c2:	687b      	ldr	r3, [r7, #4]
 80016c4:	ea23 0304 	bic.w	r3, r3, r4
 80016c8:	607b      	str	r3, [r7, #4]
 80016ca:	0064      	lsls	r4, r4, #1
 80016cc:	429c      	cmp	r4, r3
 80016ce:	f63f aec1 	bhi.w	8001454 <_malloc_r+0x1f0>
 80016d2:	2c00      	cmp	r4, #0
 80016d4:	f43f aebe 	beq.w	8001454 <_malloc_r+0x1f0>
 80016d8:	421c      	tst	r4, r3
 80016da:	4640      	mov	r0, r8
 80016dc:	f47f ae39 	bne.w	8001352 <_malloc_r+0xee>
 80016e0:	0064      	lsls	r4, r4, #1
 80016e2:	421c      	tst	r4, r3
 80016e4:	f100 0004 	add.w	r0, r0, #4
 80016e8:	d0fa      	beq.n	80016e0 <_malloc_r+0x47c>
 80016ea:	e632      	b.n	8001352 <_malloc_r+0xee>
 80016ec:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 80016f0:	d818      	bhi.n	8001724 <_malloc_r+0x4c0>
 80016f2:	0be8      	lsrs	r0, r5, #15
 80016f4:	f100 0e78 	add.w	lr, r0, #120	; 0x78
 80016f8:	ea4f 034e 	mov.w	r3, lr, lsl #1
 80016fc:	3077      	adds	r0, #119	; 0x77
 80016fe:	e5d3      	b.n	80012a8 <_malloc_r+0x44>
 8001700:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8001704:	e6f0      	b.n	80014e8 <_malloc_r+0x284>
 8001706:	2101      	movs	r1, #1
 8001708:	f8d8 3004 	ldr.w	r3, [r8, #4]
 800170c:	1092      	asrs	r2, r2, #2
 800170e:	fa01 f202 	lsl.w	r2, r1, r2
 8001712:	431a      	orrs	r2, r3
 8001714:	f8c8 2004 	str.w	r2, [r8, #4]
 8001718:	4661      	mov	r1, ip
 800171a:	e777      	b.n	800160c <_malloc_r+0x3a8>
 800171c:	2301      	movs	r3, #1
 800171e:	f8cb 3004 	str.w	r3, [fp, #4]
 8001722:	e72d      	b.n	8001580 <_malloc_r+0x31c>
 8001724:	f240 5254 	movw	r2, #1364	; 0x554
 8001728:	4293      	cmp	r3, r2
 800172a:	d821      	bhi.n	8001770 <_malloc_r+0x50c>
 800172c:	0ca8      	lsrs	r0, r5, #18
 800172e:	f100 0e7d 	add.w	lr, r0, #125	; 0x7d
 8001732:	ea4f 034e 	mov.w	r3, lr, lsl #1
 8001736:	307c      	adds	r0, #124	; 0x7c
 8001738:	e5b6      	b.n	80012a8 <_malloc_r+0x44>
 800173a:	3210      	adds	r2, #16
 800173c:	e6a8      	b.n	8001490 <_malloc_r+0x22c>
 800173e:	2a54      	cmp	r2, #84	; 0x54
 8001740:	d827      	bhi.n	8001792 <_malloc_r+0x52e>
 8001742:	0b1a      	lsrs	r2, r3, #12
 8001744:	f102 016f 	add.w	r1, r2, #111	; 0x6f
 8001748:	0049      	lsls	r1, r1, #1
 800174a:	326e      	adds	r2, #110	; 0x6e
 800174c:	e748      	b.n	80015e0 <_malloc_r+0x37c>
 800174e:	68bc      	ldr	r4, [r7, #8]
 8001750:	6862      	ldr	r2, [r4, #4]
 8001752:	f022 0203 	bic.w	r2, r2, #3
 8001756:	e70d      	b.n	8001574 <_malloc_r+0x310>
 8001758:	f3ca 030b 	ubfx	r3, sl, #0, #12
 800175c:	2b00      	cmp	r3, #0
 800175e:	f47f aead 	bne.w	80014bc <_malloc_r+0x258>
 8001762:	eb08 0302 	add.w	r3, r8, r2
 8001766:	68ba      	ldr	r2, [r7, #8]
 8001768:	f043 0301 	orr.w	r3, r3, #1
 800176c:	6053      	str	r3, [r2, #4]
 800176e:	e6f1      	b.n	8001554 <_malloc_r+0x2f0>
 8001770:	23fe      	movs	r3, #254	; 0xfe
 8001772:	f04f 0e7f 	mov.w	lr, #127	; 0x7f
 8001776:	207e      	movs	r0, #126	; 0x7e
 8001778:	e596      	b.n	80012a8 <_malloc_r+0x44>
 800177a:	2301      	movs	r3, #1
 800177c:	f04f 0a00 	mov.w	sl, #0
 8001780:	e6c4      	b.n	800150c <_malloc_r+0x2a8>
 8001782:	f104 0108 	add.w	r1, r4, #8
 8001786:	4630      	mov	r0, r6
 8001788:	f000 fb96 	bl	8001eb8 <_free_r>
 800178c:	f8da 1004 	ldr.w	r1, [sl, #4]
 8001790:	e6e0      	b.n	8001554 <_malloc_r+0x2f0>
 8001792:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 8001796:	d805      	bhi.n	80017a4 <_malloc_r+0x540>
 8001798:	0bda      	lsrs	r2, r3, #15
 800179a:	f102 0178 	add.w	r1, r2, #120	; 0x78
 800179e:	0049      	lsls	r1, r1, #1
 80017a0:	3277      	adds	r2, #119	; 0x77
 80017a2:	e71d      	b.n	80015e0 <_malloc_r+0x37c>
 80017a4:	f240 5154 	movw	r1, #1364	; 0x554
 80017a8:	428a      	cmp	r2, r1
 80017aa:	d805      	bhi.n	80017b8 <_malloc_r+0x554>
 80017ac:	0c9a      	lsrs	r2, r3, #18
 80017ae:	f102 017d 	add.w	r1, r2, #125	; 0x7d
 80017b2:	0049      	lsls	r1, r1, #1
 80017b4:	327c      	adds	r2, #124	; 0x7c
 80017b6:	e713      	b.n	80015e0 <_malloc_r+0x37c>
 80017b8:	21fe      	movs	r1, #254	; 0xfe
 80017ba:	227e      	movs	r2, #126	; 0x7e
 80017bc:	e710      	b.n	80015e0 <_malloc_r+0x37c>
 80017be:	687b      	ldr	r3, [r7, #4]
 80017c0:	e783      	b.n	80016ca <_malloc_r+0x466>
 80017c2:	08e8      	lsrs	r0, r5, #3
 80017c4:	1c43      	adds	r3, r0, #1
 80017c6:	005b      	lsls	r3, r3, #1
 80017c8:	e5fb      	b.n	80013c2 <_malloc_r+0x15e>
 80017ca:	bf00      	nop
 80017cc:	20001c00 	.word	0x20001c00

080017d0 <memcpy>:
 80017d0:	4684      	mov	ip, r0
 80017d2:	ea41 0300 	orr.w	r3, r1, r0
 80017d6:	f013 0303 	ands.w	r3, r3, #3
 80017da:	d16d      	bne.n	80018b8 <memcpy+0xe8>
 80017dc:	3a40      	subs	r2, #64	; 0x40
 80017de:	d341      	bcc.n	8001864 <memcpy+0x94>
 80017e0:	f851 3b04 	ldr.w	r3, [r1], #4
 80017e4:	f840 3b04 	str.w	r3, [r0], #4
 80017e8:	f851 3b04 	ldr.w	r3, [r1], #4
 80017ec:	f840 3b04 	str.w	r3, [r0], #4
 80017f0:	f851 3b04 	ldr.w	r3, [r1], #4
 80017f4:	f840 3b04 	str.w	r3, [r0], #4
 80017f8:	f851 3b04 	ldr.w	r3, [r1], #4
 80017fc:	f840 3b04 	str.w	r3, [r0], #4
 8001800:	f851 3b04 	ldr.w	r3, [r1], #4
 8001804:	f840 3b04 	str.w	r3, [r0], #4
 8001808:	f851 3b04 	ldr.w	r3, [r1], #4
 800180c:	f840 3b04 	str.w	r3, [r0], #4
 8001810:	f851 3b04 	ldr.w	r3, [r1], #4
 8001814:	f840 3b04 	str.w	r3, [r0], #4
 8001818:	f851 3b04 	ldr.w	r3, [r1], #4
 800181c:	f840 3b04 	str.w	r3, [r0], #4
 8001820:	f851 3b04 	ldr.w	r3, [r1], #4
 8001824:	f840 3b04 	str.w	r3, [r0], #4
 8001828:	f851 3b04 	ldr.w	r3, [r1], #4
 800182c:	f840 3b04 	str.w	r3, [r0], #4
 8001830:	f851 3b04 	ldr.w	r3, [r1], #4
 8001834:	f840 3b04 	str.w	r3, [r0], #4
 8001838:	f851 3b04 	ldr.w	r3, [r1], #4
 800183c:	f840 3b04 	str.w	r3, [r0], #4
 8001840:	f851 3b04 	ldr.w	r3, [r1], #4
 8001844:	f840 3b04 	str.w	r3, [r0], #4
 8001848:	f851 3b04 	ldr.w	r3, [r1], #4
 800184c:	f840 3b04 	str.w	r3, [r0], #4
 8001850:	f851 3b04 	ldr.w	r3, [r1], #4
 8001854:	f840 3b04 	str.w	r3, [r0], #4
 8001858:	f851 3b04 	ldr.w	r3, [r1], #4
 800185c:	f840 3b04 	str.w	r3, [r0], #4
 8001860:	3a40      	subs	r2, #64	; 0x40
 8001862:	d2bd      	bcs.n	80017e0 <memcpy+0x10>
 8001864:	3230      	adds	r2, #48	; 0x30
 8001866:	d311      	bcc.n	800188c <memcpy+0xbc>
 8001868:	f851 3b04 	ldr.w	r3, [r1], #4
 800186c:	f840 3b04 	str.w	r3, [r0], #4
 8001870:	f851 3b04 	ldr.w	r3, [r1], #4
 8001874:	f840 3b04 	str.w	r3, [r0], #4
 8001878:	f851 3b04 	ldr.w	r3, [r1], #4
 800187c:	f840 3b04 	str.w	r3, [r0], #4
 8001880:	f851 3b04 	ldr.w	r3, [r1], #4
 8001884:	f840 3b04 	str.w	r3, [r0], #4
 8001888:	3a10      	subs	r2, #16
 800188a:	d2ed      	bcs.n	8001868 <memcpy+0x98>
 800188c:	320c      	adds	r2, #12
 800188e:	d305      	bcc.n	800189c <memcpy+0xcc>
 8001890:	f851 3b04 	ldr.w	r3, [r1], #4
 8001894:	f840 3b04 	str.w	r3, [r0], #4
 8001898:	3a04      	subs	r2, #4
 800189a:	d2f9      	bcs.n	8001890 <memcpy+0xc0>
 800189c:	3204      	adds	r2, #4
 800189e:	d008      	beq.n	80018b2 <memcpy+0xe2>
 80018a0:	07d2      	lsls	r2, r2, #31
 80018a2:	bf1c      	itt	ne
 80018a4:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80018a8:	f800 3b01 	strbne.w	r3, [r0], #1
 80018ac:	d301      	bcc.n	80018b2 <memcpy+0xe2>
 80018ae:	880b      	ldrh	r3, [r1, #0]
 80018b0:	8003      	strh	r3, [r0, #0]
 80018b2:	4660      	mov	r0, ip
 80018b4:	4770      	bx	lr
 80018b6:	bf00      	nop
 80018b8:	2a08      	cmp	r2, #8
 80018ba:	d313      	bcc.n	80018e4 <memcpy+0x114>
 80018bc:	078b      	lsls	r3, r1, #30
 80018be:	d08d      	beq.n	80017dc <memcpy+0xc>
 80018c0:	f010 0303 	ands.w	r3, r0, #3
 80018c4:	d08a      	beq.n	80017dc <memcpy+0xc>
 80018c6:	f1c3 0304 	rsb	r3, r3, #4
 80018ca:	1ad2      	subs	r2, r2, r3
 80018cc:	07db      	lsls	r3, r3, #31
 80018ce:	bf1c      	itt	ne
 80018d0:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80018d4:	f800 3b01 	strbne.w	r3, [r0], #1
 80018d8:	d380      	bcc.n	80017dc <memcpy+0xc>
 80018da:	f831 3b02 	ldrh.w	r3, [r1], #2
 80018de:	f820 3b02 	strh.w	r3, [r0], #2
 80018e2:	e77b      	b.n	80017dc <memcpy+0xc>
 80018e4:	3a04      	subs	r2, #4
 80018e6:	d3d9      	bcc.n	800189c <memcpy+0xcc>
 80018e8:	3a01      	subs	r2, #1
 80018ea:	f811 3b01 	ldrb.w	r3, [r1], #1
 80018ee:	f800 3b01 	strb.w	r3, [r0], #1
 80018f2:	d2f9      	bcs.n	80018e8 <memcpy+0x118>
 80018f4:	780b      	ldrb	r3, [r1, #0]
 80018f6:	7003      	strb	r3, [r0, #0]
 80018f8:	784b      	ldrb	r3, [r1, #1]
 80018fa:	7043      	strb	r3, [r0, #1]
 80018fc:	788b      	ldrb	r3, [r1, #2]
 80018fe:	7083      	strb	r3, [r0, #2]
 8001900:	4660      	mov	r0, ip
 8001902:	4770      	bx	lr

08001904 <memset>:
 8001904:	b470      	push	{r4, r5, r6}
 8001906:	0784      	lsls	r4, r0, #30
 8001908:	d046      	beq.n	8001998 <memset+0x94>
 800190a:	1e54      	subs	r4, r2, #1
 800190c:	2a00      	cmp	r2, #0
 800190e:	d041      	beq.n	8001994 <memset+0x90>
 8001910:	b2cd      	uxtb	r5, r1
 8001912:	4603      	mov	r3, r0
 8001914:	e002      	b.n	800191c <memset+0x18>
 8001916:	1e62      	subs	r2, r4, #1
 8001918:	b3e4      	cbz	r4, 8001994 <memset+0x90>
 800191a:	4614      	mov	r4, r2
 800191c:	f803 5b01 	strb.w	r5, [r3], #1
 8001920:	079a      	lsls	r2, r3, #30
 8001922:	d1f8      	bne.n	8001916 <memset+0x12>
 8001924:	2c03      	cmp	r4, #3
 8001926:	d92e      	bls.n	8001986 <memset+0x82>
 8001928:	b2cd      	uxtb	r5, r1
 800192a:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 800192e:	2c0f      	cmp	r4, #15
 8001930:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8001934:	d919      	bls.n	800196a <memset+0x66>
 8001936:	f103 0210 	add.w	r2, r3, #16
 800193a:	4626      	mov	r6, r4
 800193c:	3e10      	subs	r6, #16
 800193e:	2e0f      	cmp	r6, #15
 8001940:	f842 5c10 	str.w	r5, [r2, #-16]
 8001944:	f842 5c0c 	str.w	r5, [r2, #-12]
 8001948:	f842 5c08 	str.w	r5, [r2, #-8]
 800194c:	f842 5c04 	str.w	r5, [r2, #-4]
 8001950:	f102 0210 	add.w	r2, r2, #16
 8001954:	d8f2      	bhi.n	800193c <memset+0x38>
 8001956:	f1a4 0210 	sub.w	r2, r4, #16
 800195a:	f022 020f 	bic.w	r2, r2, #15
 800195e:	f004 040f 	and.w	r4, r4, #15
 8001962:	3210      	adds	r2, #16
 8001964:	2c03      	cmp	r4, #3
 8001966:	4413      	add	r3, r2
 8001968:	d90d      	bls.n	8001986 <memset+0x82>
 800196a:	461e      	mov	r6, r3
 800196c:	4622      	mov	r2, r4
 800196e:	3a04      	subs	r2, #4
 8001970:	2a03      	cmp	r2, #3
 8001972:	f846 5b04 	str.w	r5, [r6], #4
 8001976:	d8fa      	bhi.n	800196e <memset+0x6a>
 8001978:	1f22      	subs	r2, r4, #4
 800197a:	f022 0203 	bic.w	r2, r2, #3
 800197e:	3204      	adds	r2, #4
 8001980:	4413      	add	r3, r2
 8001982:	f004 0403 	and.w	r4, r4, #3
 8001986:	b12c      	cbz	r4, 8001994 <memset+0x90>
 8001988:	b2c9      	uxtb	r1, r1
 800198a:	441c      	add	r4, r3
 800198c:	f803 1b01 	strb.w	r1, [r3], #1
 8001990:	42a3      	cmp	r3, r4
 8001992:	d1fb      	bne.n	800198c <memset+0x88>
 8001994:	bc70      	pop	{r4, r5, r6}
 8001996:	4770      	bx	lr
 8001998:	4614      	mov	r4, r2
 800199a:	4603      	mov	r3, r0
 800199c:	e7c2      	b.n	8001924 <memset+0x20>
 800199e:	bf00      	nop

080019a0 <__malloc_lock>:
 80019a0:	4770      	bx	lr
 80019a2:	bf00      	nop

080019a4 <__malloc_unlock>:
 80019a4:	4770      	bx	lr
 80019a6:	bf00      	nop

080019a8 <_init_signal_r>:
 80019a8:	b538      	push	{r3, r4, r5, lr}
 80019aa:	f8d0 42dc 	ldr.w	r4, [r0, #732]	; 0x2dc
 80019ae:	b10c      	cbz	r4, 80019b4 <_init_signal_r+0xc>
 80019b0:	2000      	movs	r0, #0
 80019b2:	bd38      	pop	{r3, r4, r5, pc}
 80019b4:	2180      	movs	r1, #128	; 0x80
 80019b6:	4605      	mov	r5, r0
 80019b8:	f7ff fc54 	bl	8001264 <_malloc_r>
 80019bc:	f8c5 02dc 	str.w	r0, [r5, #732]	; 0x2dc
 80019c0:	b150      	cbz	r0, 80019d8 <_init_signal_r+0x30>
 80019c2:	4623      	mov	r3, r4
 80019c4:	4622      	mov	r2, r4
 80019c6:	e001      	b.n	80019cc <_init_signal_r+0x24>
 80019c8:	f8d5 02dc 	ldr.w	r0, [r5, #732]	; 0x2dc
 80019cc:	50c2      	str	r2, [r0, r3]
 80019ce:	3304      	adds	r3, #4
 80019d0:	2b80      	cmp	r3, #128	; 0x80
 80019d2:	d1f9      	bne.n	80019c8 <_init_signal_r+0x20>
 80019d4:	2000      	movs	r0, #0
 80019d6:	bd38      	pop	{r3, r4, r5, pc}
 80019d8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80019dc:	bd38      	pop	{r3, r4, r5, pc}
 80019de:	bf00      	nop

080019e0 <_signal_r>:
 80019e0:	291f      	cmp	r1, #31
 80019e2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80019e4:	d80a      	bhi.n	80019fc <_signal_r+0x1c>
 80019e6:	f8d0 42dc 	ldr.w	r4, [r0, #732]	; 0x2dc
 80019ea:	4607      	mov	r7, r0
 80019ec:	4616      	mov	r6, r2
 80019ee:	460d      	mov	r5, r1
 80019f0:	b14c      	cbz	r4, 8001a06 <_signal_r+0x26>
 80019f2:	f854 0025 	ldr.w	r0, [r4, r5, lsl #2]
 80019f6:	f844 6025 	str.w	r6, [r4, r5, lsl #2]
 80019fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80019fc:	2216      	movs	r2, #22
 80019fe:	6002      	str	r2, [r0, #0]
 8001a00:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001a04:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001a06:	f7ff ffcf 	bl	80019a8 <_init_signal_r>
 8001a0a:	b910      	cbnz	r0, 8001a12 <_signal_r+0x32>
 8001a0c:	f8d7 42dc 	ldr.w	r4, [r7, #732]	; 0x2dc
 8001a10:	e7ef      	b.n	80019f2 <_signal_r+0x12>
 8001a12:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001a16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001a18 <_raise_r>:
 8001a18:	291f      	cmp	r1, #31
 8001a1a:	b538      	push	{r3, r4, r5, lr}
 8001a1c:	d822      	bhi.n	8001a64 <_raise_r+0x4c>
 8001a1e:	f8d0 22dc 	ldr.w	r2, [r0, #732]	; 0x2dc
 8001a22:	4605      	mov	r5, r0
 8001a24:	460c      	mov	r4, r1
 8001a26:	b19a      	cbz	r2, 8001a50 <_raise_r+0x38>
 8001a28:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8001a2c:	b183      	cbz	r3, 8001a50 <_raise_r+0x38>
 8001a2e:	2b01      	cmp	r3, #1
 8001a30:	d00c      	beq.n	8001a4c <_raise_r+0x34>
 8001a32:	1c59      	adds	r1, r3, #1
 8001a34:	d006      	beq.n	8001a44 <_raise_r+0x2c>
 8001a36:	2500      	movs	r5, #0
 8001a38:	4620      	mov	r0, r4
 8001a3a:	f842 5024 	str.w	r5, [r2, r4, lsl #2]
 8001a3e:	4798      	blx	r3
 8001a40:	4628      	mov	r0, r5
 8001a42:	bd38      	pop	{r3, r4, r5, pc}
 8001a44:	2316      	movs	r3, #22
 8001a46:	6003      	str	r3, [r0, #0]
 8001a48:	2001      	movs	r0, #1
 8001a4a:	bd38      	pop	{r3, r4, r5, pc}
 8001a4c:	2000      	movs	r0, #0
 8001a4e:	bd38      	pop	{r3, r4, r5, pc}
 8001a50:	4628      	mov	r0, r5
 8001a52:	f000 f869 	bl	8001b28 <_getpid_r>
 8001a56:	4622      	mov	r2, r4
 8001a58:	4601      	mov	r1, r0
 8001a5a:	4628      	mov	r0, r5
 8001a5c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8001a60:	f000 b84e 	b.w	8001b00 <_kill_r>
 8001a64:	2316      	movs	r3, #22
 8001a66:	6003      	str	r3, [r0, #0]
 8001a68:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001a6c:	bd38      	pop	{r3, r4, r5, pc}
 8001a6e:	bf00      	nop

08001a70 <__sigtramp_r>:
 8001a70:	291f      	cmp	r1, #31
 8001a72:	d820      	bhi.n	8001ab6 <__sigtramp_r+0x46>
 8001a74:	b538      	push	{r3, r4, r5, lr}
 8001a76:	f8d0 32dc 	ldr.w	r3, [r0, #732]	; 0x2dc
 8001a7a:	4605      	mov	r5, r0
 8001a7c:	460c      	mov	r4, r1
 8001a7e:	b1a3      	cbz	r3, 8001aaa <__sigtramp_r+0x3a>
 8001a80:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
 8001a84:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8001a88:	b16a      	cbz	r2, 8001aa6 <__sigtramp_r+0x36>
 8001a8a:	1c51      	adds	r1, r2, #1
 8001a8c:	d009      	beq.n	8001aa2 <__sigtramp_r+0x32>
 8001a8e:	2a01      	cmp	r2, #1
 8001a90:	d005      	beq.n	8001a9e <__sigtramp_r+0x2e>
 8001a92:	2500      	movs	r5, #0
 8001a94:	4620      	mov	r0, r4
 8001a96:	601d      	str	r5, [r3, #0]
 8001a98:	4790      	blx	r2
 8001a9a:	4628      	mov	r0, r5
 8001a9c:	bd38      	pop	{r3, r4, r5, pc}
 8001a9e:	2003      	movs	r0, #3
 8001aa0:	bd38      	pop	{r3, r4, r5, pc}
 8001aa2:	2002      	movs	r0, #2
 8001aa4:	bd38      	pop	{r3, r4, r5, pc}
 8001aa6:	2001      	movs	r0, #1
 8001aa8:	bd38      	pop	{r3, r4, r5, pc}
 8001aaa:	f7ff ff7d 	bl	80019a8 <_init_signal_r>
 8001aae:	b928      	cbnz	r0, 8001abc <__sigtramp_r+0x4c>
 8001ab0:	f8d5 32dc 	ldr.w	r3, [r5, #732]	; 0x2dc
 8001ab4:	e7e4      	b.n	8001a80 <__sigtramp_r+0x10>
 8001ab6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001aba:	4770      	bx	lr
 8001abc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001ac0:	bd38      	pop	{r3, r4, r5, pc}
 8001ac2:	bf00      	nop

08001ac4 <raise>:
 8001ac4:	4b02      	ldr	r3, [pc, #8]	; (8001ad0 <raise+0xc>)
 8001ac6:	4601      	mov	r1, r0
 8001ac8:	6818      	ldr	r0, [r3, #0]
 8001aca:	f7ff bfa5 	b.w	8001a18 <_raise_r>
 8001ace:	bf00      	nop
 8001ad0:	20002010 	.word	0x20002010

08001ad4 <signal>:
 8001ad4:	4b02      	ldr	r3, [pc, #8]	; (8001ae0 <signal+0xc>)
 8001ad6:	460a      	mov	r2, r1
 8001ad8:	4601      	mov	r1, r0
 8001ada:	6818      	ldr	r0, [r3, #0]
 8001adc:	f7ff bf80 	b.w	80019e0 <_signal_r>
 8001ae0:	20002010 	.word	0x20002010

08001ae4 <_init_signal>:
 8001ae4:	4b01      	ldr	r3, [pc, #4]	; (8001aec <_init_signal+0x8>)
 8001ae6:	6818      	ldr	r0, [r3, #0]
 8001ae8:	f7ff bf5e 	b.w	80019a8 <_init_signal_r>
 8001aec:	20002010 	.word	0x20002010

08001af0 <__sigtramp>:
 8001af0:	4b02      	ldr	r3, [pc, #8]	; (8001afc <__sigtramp+0xc>)
 8001af2:	4601      	mov	r1, r0
 8001af4:	6818      	ldr	r0, [r3, #0]
 8001af6:	f7ff bfbb 	b.w	8001a70 <__sigtramp_r>
 8001afa:	bf00      	nop
 8001afc:	20002010 	.word	0x20002010

08001b00 <_kill_r>:
 8001b00:	b538      	push	{r3, r4, r5, lr}
 8001b02:	460b      	mov	r3, r1
 8001b04:	4c07      	ldr	r4, [pc, #28]	; (8001b24 <_kill_r+0x24>)
 8001b06:	4605      	mov	r5, r0
 8001b08:	4611      	mov	r1, r2
 8001b0a:	4618      	mov	r0, r3
 8001b0c:	2300      	movs	r3, #0
 8001b0e:	6023      	str	r3, [r4, #0]
 8001b10:	f00a fede 	bl	800c8d0 <_kill>
 8001b14:	1c43      	adds	r3, r0, #1
 8001b16:	d000      	beq.n	8001b1a <_kill_r+0x1a>
 8001b18:	bd38      	pop	{r3, r4, r5, pc}
 8001b1a:	6823      	ldr	r3, [r4, #0]
 8001b1c:	2b00      	cmp	r3, #0
 8001b1e:	d0fb      	beq.n	8001b18 <_kill_r+0x18>
 8001b20:	602b      	str	r3, [r5, #0]
 8001b22:	bd38      	pop	{r3, r4, r5, pc}
 8001b24:	20003e4c 	.word	0x20003e4c

08001b28 <_getpid_r>:
 8001b28:	f00a beda 	b.w	800c8e0 <_getpid>
	...
 8001b40:	eba2 0003 	sub.w	r0, r2, r3
 8001b44:	4770      	bx	lr
 8001b46:	bf00      	nop

08001b48 <strcmp>:
 8001b48:	7802      	ldrb	r2, [r0, #0]
 8001b4a:	780b      	ldrb	r3, [r1, #0]
 8001b4c:	2a01      	cmp	r2, #1
 8001b4e:	bf28      	it	cs
 8001b50:	429a      	cmpcs	r2, r3
 8001b52:	d1f5      	bne.n	8001b40 <_getpid_r+0x18>
 8001b54:	e96d 4504 	strd	r4, r5, [sp, #-16]!
 8001b58:	ea40 0401 	orr.w	r4, r0, r1
 8001b5c:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8001b60:	f06f 0c00 	mvn.w	ip, #0
 8001b64:	ea4f 7244 	mov.w	r2, r4, lsl #29
 8001b68:	b312      	cbz	r2, 8001bb0 <strcmp+0x68>
 8001b6a:	ea80 0401 	eor.w	r4, r0, r1
 8001b6e:	f014 0f07 	tst.w	r4, #7
 8001b72:	d16a      	bne.n	8001c4a <strcmp+0x102>
 8001b74:	f000 0407 	and.w	r4, r0, #7
 8001b78:	f020 0007 	bic.w	r0, r0, #7
 8001b7c:	f004 0503 	and.w	r5, r4, #3
 8001b80:	f021 0107 	bic.w	r1, r1, #7
 8001b84:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 8001b88:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 8001b8c:	f014 0f04 	tst.w	r4, #4
 8001b90:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8001b94:	fa0c f405 	lsl.w	r4, ip, r5
 8001b98:	ea62 0204 	orn	r2, r2, r4
 8001b9c:	ea66 0604 	orn	r6, r6, r4
 8001ba0:	d00a      	beq.n	8001bb8 <strcmp+0x70>
 8001ba2:	ea63 0304 	orn	r3, r3, r4
 8001ba6:	4662      	mov	r2, ip
 8001ba8:	ea67 0704 	orn	r7, r7, r4
 8001bac:	4666      	mov	r6, ip
 8001bae:	e003      	b.n	8001bb8 <strcmp+0x70>
 8001bb0:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 8001bb4:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8001bb8:	fa82 f54c 	uadd8	r5, r2, ip
 8001bbc:	ea82 0406 	eor.w	r4, r2, r6
 8001bc0:	faa4 f48c 	sel	r4, r4, ip
 8001bc4:	bb6c      	cbnz	r4, 8001c22 <strcmp+0xda>
 8001bc6:	fa83 f54c 	uadd8	r5, r3, ip
 8001bca:	ea83 0507 	eor.w	r5, r3, r7
 8001bce:	faa5 f58c 	sel	r5, r5, ip
 8001bd2:	b995      	cbnz	r5, 8001bfa <strcmp+0xb2>
 8001bd4:	e950 2302 	ldrd	r2, r3, [r0, #-8]
 8001bd8:	e951 6702 	ldrd	r6, r7, [r1, #-8]
 8001bdc:	fa82 f54c 	uadd8	r5, r2, ip
 8001be0:	ea82 0406 	eor.w	r4, r2, r6
 8001be4:	faa4 f48c 	sel	r4, r4, ip
 8001be8:	fa83 f54c 	uadd8	r5, r3, ip
 8001bec:	ea83 0507 	eor.w	r5, r3, r7
 8001bf0:	faa5 f58c 	sel	r5, r5, ip
 8001bf4:	4325      	orrs	r5, r4
 8001bf6:	d0db      	beq.n	8001bb0 <strcmp+0x68>
 8001bf8:	b99c      	cbnz	r4, 8001c22 <strcmp+0xda>
 8001bfa:	ba2d      	rev	r5, r5
 8001bfc:	fab5 f485 	clz	r4, r5
 8001c00:	f024 0407 	bic.w	r4, r4, #7
 8001c04:	fa27 f104 	lsr.w	r1, r7, r4
 8001c08:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8001c0c:	fa23 f304 	lsr.w	r3, r3, r4
 8001c10:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8001c14:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8001c18:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8001c1c:	eba0 0001 	sub.w	r0, r0, r1
 8001c20:	4770      	bx	lr
 8001c22:	ba24      	rev	r4, r4
 8001c24:	fab4 f484 	clz	r4, r4
 8001c28:	f024 0407 	bic.w	r4, r4, #7
 8001c2c:	fa26 f104 	lsr.w	r1, r6, r4
 8001c30:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8001c34:	fa22 f204 	lsr.w	r2, r2, r4
 8001c38:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 8001c3c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8001c40:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8001c44:	eba0 0001 	sub.w	r0, r0, r1
 8001c48:	4770      	bx	lr
 8001c4a:	f014 0f03 	tst.w	r4, #3
 8001c4e:	d13c      	bne.n	8001cca <strcmp+0x182>
 8001c50:	f010 0403 	ands.w	r4, r0, #3
 8001c54:	d128      	bne.n	8001ca8 <strcmp+0x160>
 8001c56:	f850 2b08 	ldr.w	r2, [r0], #8
 8001c5a:	f851 3b08 	ldr.w	r3, [r1], #8
 8001c5e:	fa82 f54c 	uadd8	r5, r2, ip
 8001c62:	ea82 0503 	eor.w	r5, r2, r3
 8001c66:	faa5 f58c 	sel	r5, r5, ip
 8001c6a:	b95d      	cbnz	r5, 8001c84 <strcmp+0x13c>
 8001c6c:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8001c70:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8001c74:	fa82 f54c 	uadd8	r5, r2, ip
 8001c78:	ea82 0503 	eor.w	r5, r2, r3
 8001c7c:	faa5 f58c 	sel	r5, r5, ip
 8001c80:	2d00      	cmp	r5, #0
 8001c82:	d0e8      	beq.n	8001c56 <strcmp+0x10e>
 8001c84:	ba2d      	rev	r5, r5
 8001c86:	fab5 f485 	clz	r4, r5
 8001c8a:	f024 0407 	bic.w	r4, r4, #7
 8001c8e:	fa23 f104 	lsr.w	r1, r3, r4
 8001c92:	fa22 f204 	lsr.w	r2, r2, r4
 8001c96:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 8001c9a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8001c9e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8001ca2:	eba0 0001 	sub.w	r0, r0, r1
 8001ca6:	4770      	bx	lr
 8001ca8:	ea4f 04c4 	mov.w	r4, r4, lsl #3
 8001cac:	f020 0003 	bic.w	r0, r0, #3
 8001cb0:	f850 2b08 	ldr.w	r2, [r0], #8
 8001cb4:	f021 0103 	bic.w	r1, r1, #3
 8001cb8:	f851 3b08 	ldr.w	r3, [r1], #8
 8001cbc:	fa0c f404 	lsl.w	r4, ip, r4
 8001cc0:	ea62 0204 	orn	r2, r2, r4
 8001cc4:	ea63 0304 	orn	r3, r3, r4
 8001cc8:	e7c9      	b.n	8001c5e <strcmp+0x116>
 8001cca:	f010 0403 	ands.w	r4, r0, #3
 8001cce:	d01a      	beq.n	8001d06 <strcmp+0x1be>
 8001cd0:	eba1 0104 	sub.w	r1, r1, r4
 8001cd4:	f020 0003 	bic.w	r0, r0, #3
 8001cd8:	07e4      	lsls	r4, r4, #31
 8001cda:	f850 2b04 	ldr.w	r2, [r0], #4
 8001cde:	d006      	beq.n	8001cee <strcmp+0x1a6>
 8001ce0:	d20f      	bcs.n	8001d02 <strcmp+0x1ba>
 8001ce2:	788b      	ldrb	r3, [r1, #2]
 8001ce4:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
 8001ce8:	1ae4      	subs	r4, r4, r3
 8001cea:	d106      	bne.n	8001cfa <strcmp+0x1b2>
 8001cec:	b12b      	cbz	r3, 8001cfa <strcmp+0x1b2>
 8001cee:	78cb      	ldrb	r3, [r1, #3]
 8001cf0:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
 8001cf4:	1ae4      	subs	r4, r4, r3
 8001cf6:	d100      	bne.n	8001cfa <strcmp+0x1b2>
 8001cf8:	b91b      	cbnz	r3, 8001d02 <strcmp+0x1ba>
 8001cfa:	4620      	mov	r0, r4
 8001cfc:	f85d 4b10 	ldr.w	r4, [sp], #16
 8001d00:	4770      	bx	lr
 8001d02:	f101 0104 	add.w	r1, r1, #4
 8001d06:	f850 2b04 	ldr.w	r2, [r0], #4
 8001d0a:	07cc      	lsls	r4, r1, #31
 8001d0c:	f021 0103 	bic.w	r1, r1, #3
 8001d10:	f851 3b04 	ldr.w	r3, [r1], #4
 8001d14:	d848      	bhi.n	8001da8 <strcmp+0x260>
 8001d16:	d224      	bcs.n	8001d62 <strcmp+0x21a>
 8001d18:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
 8001d1c:	fa82 f54c 	uadd8	r5, r2, ip
 8001d20:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
 8001d24:	faa5 f58c 	sel	r5, r5, ip
 8001d28:	d10a      	bne.n	8001d40 <strcmp+0x1f8>
 8001d2a:	b965      	cbnz	r5, 8001d46 <strcmp+0x1fe>
 8001d2c:	f851 3b04 	ldr.w	r3, [r1], #4
 8001d30:	ea84 0402 	eor.w	r4, r4, r2
 8001d34:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
 8001d38:	d10e      	bne.n	8001d58 <strcmp+0x210>
 8001d3a:	f850 2b04 	ldr.w	r2, [r0], #4
 8001d3e:	e7eb      	b.n	8001d18 <strcmp+0x1d0>
 8001d40:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8001d44:	e055      	b.n	8001df2 <strcmp+0x2aa>
 8001d46:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
 8001d4a:	d14d      	bne.n	8001de8 <strcmp+0x2a0>
 8001d4c:	7808      	ldrb	r0, [r1, #0]
 8001d4e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8001d52:	f1c0 0000 	rsb	r0, r0, #0
 8001d56:	4770      	bx	lr
 8001d58:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8001d5c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8001d60:	e047      	b.n	8001df2 <strcmp+0x2aa>
 8001d62:	ea02 441c 	and.w	r4, r2, ip, lsr #16
 8001d66:	fa82 f54c 	uadd8	r5, r2, ip
 8001d6a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
 8001d6e:	faa5 f58c 	sel	r5, r5, ip
 8001d72:	d10a      	bne.n	8001d8a <strcmp+0x242>
 8001d74:	b965      	cbnz	r5, 8001d90 <strcmp+0x248>
 8001d76:	f851 3b04 	ldr.w	r3, [r1], #4
 8001d7a:	ea84 0402 	eor.w	r4, r4, r2
 8001d7e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
 8001d82:	d10c      	bne.n	8001d9e <strcmp+0x256>
 8001d84:	f850 2b04 	ldr.w	r2, [r0], #4
 8001d88:	e7eb      	b.n	8001d62 <strcmp+0x21a>
 8001d8a:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8001d8e:	e030      	b.n	8001df2 <strcmp+0x2aa>
 8001d90:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
 8001d94:	d128      	bne.n	8001de8 <strcmp+0x2a0>
 8001d96:	880b      	ldrh	r3, [r1, #0]
 8001d98:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8001d9c:	e029      	b.n	8001df2 <strcmp+0x2aa>
 8001d9e:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8001da2:	ea03 431c 	and.w	r3, r3, ip, lsr #16
 8001da6:	e024      	b.n	8001df2 <strcmp+0x2aa>
 8001da8:	f002 04ff 	and.w	r4, r2, #255	; 0xff
 8001dac:	fa82 f54c 	uadd8	r5, r2, ip
 8001db0:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
 8001db4:	faa5 f58c 	sel	r5, r5, ip
 8001db8:	d10a      	bne.n	8001dd0 <strcmp+0x288>
 8001dba:	b965      	cbnz	r5, 8001dd6 <strcmp+0x28e>
 8001dbc:	f851 3b04 	ldr.w	r3, [r1], #4
 8001dc0:	ea84 0402 	eor.w	r4, r4, r2
 8001dc4:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
 8001dc8:	d109      	bne.n	8001dde <strcmp+0x296>
 8001dca:	f850 2b04 	ldr.w	r2, [r0], #4
 8001dce:	e7eb      	b.n	8001da8 <strcmp+0x260>
 8001dd0:	ea4f 6313 	mov.w	r3, r3, lsr #24
 8001dd4:	e00d      	b.n	8001df2 <strcmp+0x2aa>
 8001dd6:	f015 0fff 	tst.w	r5, #255	; 0xff
 8001dda:	d105      	bne.n	8001de8 <strcmp+0x2a0>
 8001ddc:	680b      	ldr	r3, [r1, #0]
 8001dde:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8001de2:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8001de6:	e004      	b.n	8001df2 <strcmp+0x2aa>
 8001de8:	f04f 0000 	mov.w	r0, #0
 8001dec:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8001df0:	4770      	bx	lr
 8001df2:	ba12      	rev	r2, r2
 8001df4:	ba1b      	rev	r3, r3
 8001df6:	fa82 f44c 	uadd8	r4, r2, ip
 8001dfa:	ea82 0403 	eor.w	r4, r2, r3
 8001dfe:	faa4 f58c 	sel	r5, r4, ip
 8001e02:	fab5 f485 	clz	r4, r5
 8001e06:	fa02 f204 	lsl.w	r2, r2, r4
 8001e0a:	fa03 f304 	lsl.w	r3, r3, r4
 8001e0e:	ea4f 6012 	mov.w	r0, r2, lsr #24
 8001e12:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8001e16:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
 8001e1a:	4770      	bx	lr

08001e1c <_malloc_trim_r>:
 8001e1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001e1e:	4f23      	ldr	r7, [pc, #140]	; (8001eac <_malloc_trim_r+0x90>)
 8001e20:	460c      	mov	r4, r1
 8001e22:	4606      	mov	r6, r0
 8001e24:	f7ff fdbc 	bl	80019a0 <__malloc_lock>
 8001e28:	68bb      	ldr	r3, [r7, #8]
 8001e2a:	685d      	ldr	r5, [r3, #4]
 8001e2c:	f025 0503 	bic.w	r5, r5, #3
 8001e30:	1b29      	subs	r1, r5, r4
 8001e32:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
 8001e36:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
 8001e3a:	f021 010f 	bic.w	r1, r1, #15
 8001e3e:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
 8001e42:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 8001e46:	db07      	blt.n	8001e58 <_malloc_trim_r+0x3c>
 8001e48:	2100      	movs	r1, #0
 8001e4a:	4630      	mov	r0, r6
 8001e4c:	f006 fd80 	bl	8008950 <_sbrk_r>
 8001e50:	68bb      	ldr	r3, [r7, #8]
 8001e52:	442b      	add	r3, r5
 8001e54:	4298      	cmp	r0, r3
 8001e56:	d004      	beq.n	8001e62 <_malloc_trim_r+0x46>
 8001e58:	4630      	mov	r0, r6
 8001e5a:	f7ff fda3 	bl	80019a4 <__malloc_unlock>
 8001e5e:	2000      	movs	r0, #0
 8001e60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001e62:	4261      	negs	r1, r4
 8001e64:	4630      	mov	r0, r6
 8001e66:	f006 fd73 	bl	8008950 <_sbrk_r>
 8001e6a:	3001      	adds	r0, #1
 8001e6c:	d00d      	beq.n	8001e8a <_malloc_trim_r+0x6e>
 8001e6e:	4b10      	ldr	r3, [pc, #64]	; (8001eb0 <_malloc_trim_r+0x94>)
 8001e70:	68ba      	ldr	r2, [r7, #8]
 8001e72:	6819      	ldr	r1, [r3, #0]
 8001e74:	1b2d      	subs	r5, r5, r4
 8001e76:	f045 0501 	orr.w	r5, r5, #1
 8001e7a:	4630      	mov	r0, r6
 8001e7c:	1b09      	subs	r1, r1, r4
 8001e7e:	6055      	str	r5, [r2, #4]
 8001e80:	6019      	str	r1, [r3, #0]
 8001e82:	f7ff fd8f 	bl	80019a4 <__malloc_unlock>
 8001e86:	2001      	movs	r0, #1
 8001e88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001e8a:	2100      	movs	r1, #0
 8001e8c:	4630      	mov	r0, r6
 8001e8e:	f006 fd5f 	bl	8008950 <_sbrk_r>
 8001e92:	68ba      	ldr	r2, [r7, #8]
 8001e94:	1a83      	subs	r3, r0, r2
 8001e96:	2b0f      	cmp	r3, #15
 8001e98:	ddde      	ble.n	8001e58 <_malloc_trim_r+0x3c>
 8001e9a:	4c06      	ldr	r4, [pc, #24]	; (8001eb4 <_malloc_trim_r+0x98>)
 8001e9c:	4904      	ldr	r1, [pc, #16]	; (8001eb0 <_malloc_trim_r+0x94>)
 8001e9e:	6824      	ldr	r4, [r4, #0]
 8001ea0:	f043 0301 	orr.w	r3, r3, #1
 8001ea4:	1b00      	subs	r0, r0, r4
 8001ea6:	6053      	str	r3, [r2, #4]
 8001ea8:	6008      	str	r0, [r1, #0]
 8001eaa:	e7d5      	b.n	8001e58 <_malloc_trim_r+0x3c>
 8001eac:	20001c00 	.word	0x20001c00
 8001eb0:	200025bc 	.word	0x200025bc
 8001eb4:	20002008 	.word	0x20002008

08001eb8 <_free_r>:
 8001eb8:	2900      	cmp	r1, #0
 8001eba:	d045      	beq.n	8001f48 <_free_r+0x90>
 8001ebc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001ec0:	460d      	mov	r5, r1
 8001ec2:	4680      	mov	r8, r0
 8001ec4:	f7ff fd6c 	bl	80019a0 <__malloc_lock>
 8001ec8:	f855 7c04 	ldr.w	r7, [r5, #-4]
 8001ecc:	496a      	ldr	r1, [pc, #424]	; (8002078 <_free_r+0x1c0>)
 8001ece:	f027 0301 	bic.w	r3, r7, #1
 8001ed2:	f1a5 0408 	sub.w	r4, r5, #8
 8001ed6:	18e2      	adds	r2, r4, r3
 8001ed8:	688e      	ldr	r6, [r1, #8]
 8001eda:	6850      	ldr	r0, [r2, #4]
 8001edc:	42b2      	cmp	r2, r6
 8001ede:	f020 0003 	bic.w	r0, r0, #3
 8001ee2:	d062      	beq.n	8001faa <_free_r+0xf2>
 8001ee4:	07fe      	lsls	r6, r7, #31
 8001ee6:	6050      	str	r0, [r2, #4]
 8001ee8:	d40b      	bmi.n	8001f02 <_free_r+0x4a>
 8001eea:	f855 7c08 	ldr.w	r7, [r5, #-8]
 8001eee:	1be4      	subs	r4, r4, r7
 8001ef0:	f101 0e08 	add.w	lr, r1, #8
 8001ef4:	68a5      	ldr	r5, [r4, #8]
 8001ef6:	4575      	cmp	r5, lr
 8001ef8:	443b      	add	r3, r7
 8001efa:	d06f      	beq.n	8001fdc <_free_r+0x124>
 8001efc:	68e7      	ldr	r7, [r4, #12]
 8001efe:	60ef      	str	r7, [r5, #12]
 8001f00:	60bd      	str	r5, [r7, #8]
 8001f02:	1815      	adds	r5, r2, r0
 8001f04:	686d      	ldr	r5, [r5, #4]
 8001f06:	07ed      	lsls	r5, r5, #31
 8001f08:	d542      	bpl.n	8001f90 <_free_r+0xd8>
 8001f0a:	f043 0201 	orr.w	r2, r3, #1
 8001f0e:	6062      	str	r2, [r4, #4]
 8001f10:	50e3      	str	r3, [r4, r3]
 8001f12:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8001f16:	d218      	bcs.n	8001f4a <_free_r+0x92>
 8001f18:	08db      	lsrs	r3, r3, #3
 8001f1a:	1c5a      	adds	r2, r3, #1
 8001f1c:	684d      	ldr	r5, [r1, #4]
 8001f1e:	f851 7032 	ldr.w	r7, [r1, r2, lsl #3]
 8001f22:	60a7      	str	r7, [r4, #8]
 8001f24:	2001      	movs	r0, #1
 8001f26:	109b      	asrs	r3, r3, #2
 8001f28:	fa00 f303 	lsl.w	r3, r0, r3
 8001f2c:	eb01 00c2 	add.w	r0, r1, r2, lsl #3
 8001f30:	431d      	orrs	r5, r3
 8001f32:	3808      	subs	r0, #8
 8001f34:	60e0      	str	r0, [r4, #12]
 8001f36:	604d      	str	r5, [r1, #4]
 8001f38:	f841 4032 	str.w	r4, [r1, r2, lsl #3]
 8001f3c:	60fc      	str	r4, [r7, #12]
 8001f3e:	4640      	mov	r0, r8
 8001f40:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8001f44:	f7ff bd2e 	b.w	80019a4 <__malloc_unlock>
 8001f48:	4770      	bx	lr
 8001f4a:	0a5a      	lsrs	r2, r3, #9
 8001f4c:	2a04      	cmp	r2, #4
 8001f4e:	d853      	bhi.n	8001ff8 <_free_r+0x140>
 8001f50:	099a      	lsrs	r2, r3, #6
 8001f52:	f102 0739 	add.w	r7, r2, #57	; 0x39
 8001f56:	007f      	lsls	r7, r7, #1
 8001f58:	f102 0538 	add.w	r5, r2, #56	; 0x38
 8001f5c:	eb01 0087 	add.w	r0, r1, r7, lsl #2
 8001f60:	f851 2027 	ldr.w	r2, [r1, r7, lsl #2]
 8001f64:	4944      	ldr	r1, [pc, #272]	; (8002078 <_free_r+0x1c0>)
 8001f66:	3808      	subs	r0, #8
 8001f68:	4290      	cmp	r0, r2
 8001f6a:	d04d      	beq.n	8002008 <_free_r+0x150>
 8001f6c:	6851      	ldr	r1, [r2, #4]
 8001f6e:	f021 0103 	bic.w	r1, r1, #3
 8001f72:	428b      	cmp	r3, r1
 8001f74:	d202      	bcs.n	8001f7c <_free_r+0xc4>
 8001f76:	6892      	ldr	r2, [r2, #8]
 8001f78:	4290      	cmp	r0, r2
 8001f7a:	d1f7      	bne.n	8001f6c <_free_r+0xb4>
 8001f7c:	68d0      	ldr	r0, [r2, #12]
 8001f7e:	60e0      	str	r0, [r4, #12]
 8001f80:	60a2      	str	r2, [r4, #8]
 8001f82:	6084      	str	r4, [r0, #8]
 8001f84:	60d4      	str	r4, [r2, #12]
 8001f86:	4640      	mov	r0, r8
 8001f88:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8001f8c:	f7ff bd0a 	b.w	80019a4 <__malloc_unlock>
 8001f90:	6895      	ldr	r5, [r2, #8]
 8001f92:	4f3a      	ldr	r7, [pc, #232]	; (800207c <_free_r+0x1c4>)
 8001f94:	42bd      	cmp	r5, r7
 8001f96:	4403      	add	r3, r0
 8001f98:	d03f      	beq.n	800201a <_free_r+0x162>
 8001f9a:	68d0      	ldr	r0, [r2, #12]
 8001f9c:	60e8      	str	r0, [r5, #12]
 8001f9e:	f043 0201 	orr.w	r2, r3, #1
 8001fa2:	6085      	str	r5, [r0, #8]
 8001fa4:	6062      	str	r2, [r4, #4]
 8001fa6:	50e3      	str	r3, [r4, r3]
 8001fa8:	e7b3      	b.n	8001f12 <_free_r+0x5a>
 8001faa:	07ff      	lsls	r7, r7, #31
 8001fac:	4403      	add	r3, r0
 8001fae:	d407      	bmi.n	8001fc0 <_free_r+0x108>
 8001fb0:	f855 2c08 	ldr.w	r2, [r5, #-8]
 8001fb4:	1aa4      	subs	r4, r4, r2
 8001fb6:	4413      	add	r3, r2
 8001fb8:	68a0      	ldr	r0, [r4, #8]
 8001fba:	68e2      	ldr	r2, [r4, #12]
 8001fbc:	60c2      	str	r2, [r0, #12]
 8001fbe:	6090      	str	r0, [r2, #8]
 8001fc0:	4a2f      	ldr	r2, [pc, #188]	; (8002080 <_free_r+0x1c8>)
 8001fc2:	6812      	ldr	r2, [r2, #0]
 8001fc4:	f043 0001 	orr.w	r0, r3, #1
 8001fc8:	4293      	cmp	r3, r2
 8001fca:	6060      	str	r0, [r4, #4]
 8001fcc:	608c      	str	r4, [r1, #8]
 8001fce:	d3b6      	bcc.n	8001f3e <_free_r+0x86>
 8001fd0:	4b2c      	ldr	r3, [pc, #176]	; (8002084 <_free_r+0x1cc>)
 8001fd2:	4640      	mov	r0, r8
 8001fd4:	6819      	ldr	r1, [r3, #0]
 8001fd6:	f7ff ff21 	bl	8001e1c <_malloc_trim_r>
 8001fda:	e7b0      	b.n	8001f3e <_free_r+0x86>
 8001fdc:	1811      	adds	r1, r2, r0
 8001fde:	6849      	ldr	r1, [r1, #4]
 8001fe0:	07c9      	lsls	r1, r1, #31
 8001fe2:	d444      	bmi.n	800206e <_free_r+0x1b6>
 8001fe4:	6891      	ldr	r1, [r2, #8]
 8001fe6:	68d2      	ldr	r2, [r2, #12]
 8001fe8:	60ca      	str	r2, [r1, #12]
 8001fea:	4403      	add	r3, r0
 8001fec:	f043 0001 	orr.w	r0, r3, #1
 8001ff0:	6091      	str	r1, [r2, #8]
 8001ff2:	6060      	str	r0, [r4, #4]
 8001ff4:	50e3      	str	r3, [r4, r3]
 8001ff6:	e7a2      	b.n	8001f3e <_free_r+0x86>
 8001ff8:	2a14      	cmp	r2, #20
 8001ffa:	d817      	bhi.n	800202c <_free_r+0x174>
 8001ffc:	f102 075c 	add.w	r7, r2, #92	; 0x5c
 8002000:	007f      	lsls	r7, r7, #1
 8002002:	f102 055b 	add.w	r5, r2, #91	; 0x5b
 8002006:	e7a9      	b.n	8001f5c <_free_r+0xa4>
 8002008:	10aa      	asrs	r2, r5, #2
 800200a:	684b      	ldr	r3, [r1, #4]
 800200c:	2501      	movs	r5, #1
 800200e:	fa05 f202 	lsl.w	r2, r5, r2
 8002012:	4313      	orrs	r3, r2
 8002014:	604b      	str	r3, [r1, #4]
 8002016:	4602      	mov	r2, r0
 8002018:	e7b1      	b.n	8001f7e <_free_r+0xc6>
 800201a:	f043 0201 	orr.w	r2, r3, #1
 800201e:	614c      	str	r4, [r1, #20]
 8002020:	610c      	str	r4, [r1, #16]
 8002022:	60e5      	str	r5, [r4, #12]
 8002024:	60a5      	str	r5, [r4, #8]
 8002026:	6062      	str	r2, [r4, #4]
 8002028:	50e3      	str	r3, [r4, r3]
 800202a:	e788      	b.n	8001f3e <_free_r+0x86>
 800202c:	2a54      	cmp	r2, #84	; 0x54
 800202e:	d806      	bhi.n	800203e <_free_r+0x186>
 8002030:	0b1a      	lsrs	r2, r3, #12
 8002032:	f102 076f 	add.w	r7, r2, #111	; 0x6f
 8002036:	007f      	lsls	r7, r7, #1
 8002038:	f102 056e 	add.w	r5, r2, #110	; 0x6e
 800203c:	e78e      	b.n	8001f5c <_free_r+0xa4>
 800203e:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 8002042:	d806      	bhi.n	8002052 <_free_r+0x19a>
 8002044:	0bda      	lsrs	r2, r3, #15
 8002046:	f102 0778 	add.w	r7, r2, #120	; 0x78
 800204a:	007f      	lsls	r7, r7, #1
 800204c:	f102 0577 	add.w	r5, r2, #119	; 0x77
 8002050:	e784      	b.n	8001f5c <_free_r+0xa4>
 8002052:	f240 5054 	movw	r0, #1364	; 0x554
 8002056:	4282      	cmp	r2, r0
 8002058:	d806      	bhi.n	8002068 <_free_r+0x1b0>
 800205a:	0c9a      	lsrs	r2, r3, #18
 800205c:	f102 077d 	add.w	r7, r2, #125	; 0x7d
 8002060:	007f      	lsls	r7, r7, #1
 8002062:	f102 057c 	add.w	r5, r2, #124	; 0x7c
 8002066:	e779      	b.n	8001f5c <_free_r+0xa4>
 8002068:	27fe      	movs	r7, #254	; 0xfe
 800206a:	257e      	movs	r5, #126	; 0x7e
 800206c:	e776      	b.n	8001f5c <_free_r+0xa4>
 800206e:	f043 0201 	orr.w	r2, r3, #1
 8002072:	6062      	str	r2, [r4, #4]
 8002074:	50e3      	str	r3, [r4, r3]
 8002076:	e762      	b.n	8001f3e <_free_r+0x86>
 8002078:	20001c00 	.word	0x20001c00
 800207c:	20001c08 	.word	0x20001c08
 8002080:	2000200c 	.word	0x2000200c
 8002084:	200025b8 	.word	0x200025b8

08002088 <memcmp>:
 8002088:	2a03      	cmp	r2, #3
 800208a:	b470      	push	{r4, r5, r6}
 800208c:	d926      	bls.n	80020dc <memcmp+0x54>
 800208e:	ea40 0301 	orr.w	r3, r0, r1
 8002092:	079b      	lsls	r3, r3, #30
 8002094:	d011      	beq.n	80020ba <memcmp+0x32>
 8002096:	7804      	ldrb	r4, [r0, #0]
 8002098:	780d      	ldrb	r5, [r1, #0]
 800209a:	42ac      	cmp	r4, r5
 800209c:	d122      	bne.n	80020e4 <memcmp+0x5c>
 800209e:	4402      	add	r2, r0
 80020a0:	1c43      	adds	r3, r0, #1
 80020a2:	e005      	b.n	80020b0 <memcmp+0x28>
 80020a4:	f813 4b01 	ldrb.w	r4, [r3], #1
 80020a8:	f811 5f01 	ldrb.w	r5, [r1, #1]!
 80020ac:	42ac      	cmp	r4, r5
 80020ae:	d119      	bne.n	80020e4 <memcmp+0x5c>
 80020b0:	4293      	cmp	r3, r2
 80020b2:	d1f7      	bne.n	80020a4 <memcmp+0x1c>
 80020b4:	2000      	movs	r0, #0
 80020b6:	bc70      	pop	{r4, r5, r6}
 80020b8:	4770      	bx	lr
 80020ba:	460c      	mov	r4, r1
 80020bc:	4603      	mov	r3, r0
 80020be:	681e      	ldr	r6, [r3, #0]
 80020c0:	6825      	ldr	r5, [r4, #0]
 80020c2:	42ae      	cmp	r6, r5
 80020c4:	4618      	mov	r0, r3
 80020c6:	4621      	mov	r1, r4
 80020c8:	f103 0304 	add.w	r3, r3, #4
 80020cc:	f104 0404 	add.w	r4, r4, #4
 80020d0:	d1e1      	bne.n	8002096 <memcmp+0xe>
 80020d2:	3a04      	subs	r2, #4
 80020d4:	2a03      	cmp	r2, #3
 80020d6:	4618      	mov	r0, r3
 80020d8:	4621      	mov	r1, r4
 80020da:	d8f0      	bhi.n	80020be <memcmp+0x36>
 80020dc:	2a00      	cmp	r2, #0
 80020de:	d1da      	bne.n	8002096 <memcmp+0xe>
 80020e0:	4610      	mov	r0, r2
 80020e2:	e7e8      	b.n	80020b6 <memcmp+0x2e>
 80020e4:	1b60      	subs	r0, r4, r5
 80020e6:	bc70      	pop	{r4, r5, r6}
 80020e8:	4770      	bx	lr
 80020ea:	bf00      	nop

080020ec <strchr>:
 80020ec:	b470      	push	{r4, r5, r6}
 80020ee:	f011 04ff 	ands.w	r4, r1, #255	; 0xff
 80020f2:	d034      	beq.n	800215e <strchr+0x72>
 80020f4:	0785      	lsls	r5, r0, #30
 80020f6:	d00f      	beq.n	8002118 <strchr+0x2c>
 80020f8:	7803      	ldrb	r3, [r0, #0]
 80020fa:	2b00      	cmp	r3, #0
 80020fc:	d05a      	beq.n	80021b4 <strchr+0xc8>
 80020fe:	429c      	cmp	r4, r3
 8002100:	d02b      	beq.n	800215a <strchr+0x6e>
 8002102:	1c43      	adds	r3, r0, #1
 8002104:	e005      	b.n	8002112 <strchr+0x26>
 8002106:	f813 2b01 	ldrb.w	r2, [r3], #1
 800210a:	2a00      	cmp	r2, #0
 800210c:	d04f      	beq.n	80021ae <strchr+0xc2>
 800210e:	4294      	cmp	r4, r2
 8002110:	d023      	beq.n	800215a <strchr+0x6e>
 8002112:	079a      	lsls	r2, r3, #30
 8002114:	4618      	mov	r0, r3
 8002116:	d1f6      	bne.n	8002106 <strchr+0x1a>
 8002118:	020e      	lsls	r6, r1, #8
 800211a:	f406 467f 	and.w	r6, r6, #65280	; 0xff00
 800211e:	4326      	orrs	r6, r4
 8002120:	6803      	ldr	r3, [r0, #0]
 8002122:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 8002126:	e001      	b.n	800212c <strchr+0x40>
 8002128:	f850 3f04 	ldr.w	r3, [r0, #4]!
 800212c:	ea86 0503 	eor.w	r5, r6, r3
 8002130:	f1a5 3201 	sub.w	r2, r5, #16843009	; 0x1010101
 8002134:	f1a3 3101 	sub.w	r1, r3, #16843009	; 0x1010101
 8002138:	ea22 0205 	bic.w	r2, r2, r5
 800213c:	ea21 0303 	bic.w	r3, r1, r3
 8002140:	4313      	orrs	r3, r2
 8002142:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 8002146:	d0ef      	beq.n	8002128 <strchr+0x3c>
 8002148:	7803      	ldrb	r3, [r0, #0]
 800214a:	b923      	cbnz	r3, 8002156 <strchr+0x6a>
 800214c:	e032      	b.n	80021b4 <strchr+0xc8>
 800214e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8002152:	2b00      	cmp	r3, #0
 8002154:	d02e      	beq.n	80021b4 <strchr+0xc8>
 8002156:	429c      	cmp	r4, r3
 8002158:	d1f9      	bne.n	800214e <strchr+0x62>
 800215a:	bc70      	pop	{r4, r5, r6}
 800215c:	4770      	bx	lr
 800215e:	0784      	lsls	r4, r0, #30
 8002160:	d00b      	beq.n	800217a <strchr+0x8e>
 8002162:	7803      	ldrb	r3, [r0, #0]
 8002164:	2b00      	cmp	r3, #0
 8002166:	d0f8      	beq.n	800215a <strchr+0x6e>
 8002168:	1c43      	adds	r3, r0, #1
 800216a:	e003      	b.n	8002174 <strchr+0x88>
 800216c:	7802      	ldrb	r2, [r0, #0]
 800216e:	3301      	adds	r3, #1
 8002170:	2a00      	cmp	r2, #0
 8002172:	d0f2      	beq.n	800215a <strchr+0x6e>
 8002174:	0799      	lsls	r1, r3, #30
 8002176:	4618      	mov	r0, r3
 8002178:	d1f8      	bne.n	800216c <strchr+0x80>
 800217a:	6802      	ldr	r2, [r0, #0]
 800217c:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 8002180:	ea23 0302 	bic.w	r3, r3, r2
 8002184:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 8002188:	d108      	bne.n	800219c <strchr+0xb0>
 800218a:	f850 2f04 	ldr.w	r2, [r0, #4]!
 800218e:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 8002192:	ea23 0302 	bic.w	r3, r3, r2
 8002196:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800219a:	d0f6      	beq.n	800218a <strchr+0x9e>
 800219c:	7803      	ldrb	r3, [r0, #0]
 800219e:	2b00      	cmp	r3, #0
 80021a0:	d0db      	beq.n	800215a <strchr+0x6e>
 80021a2:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 80021a6:	2b00      	cmp	r3, #0
 80021a8:	d1fb      	bne.n	80021a2 <strchr+0xb6>
 80021aa:	bc70      	pop	{r4, r5, r6}
 80021ac:	4770      	bx	lr
 80021ae:	4610      	mov	r0, r2
 80021b0:	bc70      	pop	{r4, r5, r6}
 80021b2:	4770      	bx	lr
 80021b4:	4618      	mov	r0, r3
 80021b6:	bc70      	pop	{r4, r5, r6}
 80021b8:	4770      	bx	lr
 80021ba:	bf00      	nop

080021bc <strncmp>:
 80021bc:	2a00      	cmp	r2, #0
 80021be:	d041      	beq.n	8002244 <strncmp+0x88>
 80021c0:	ea40 0301 	orr.w	r3, r0, r1
 80021c4:	f013 0303 	ands.w	r3, r3, #3
 80021c8:	b4f0      	push	{r4, r5, r6, r7}
 80021ca:	d125      	bne.n	8002218 <strncmp+0x5c>
 80021cc:	2a03      	cmp	r2, #3
 80021ce:	d923      	bls.n	8002218 <strncmp+0x5c>
 80021d0:	6804      	ldr	r4, [r0, #0]
 80021d2:	680d      	ldr	r5, [r1, #0]
 80021d4:	42ac      	cmp	r4, r5
 80021d6:	d11f      	bne.n	8002218 <strncmp+0x5c>
 80021d8:	3a04      	subs	r2, #4
 80021da:	d035      	beq.n	8002248 <strncmp+0x8c>
 80021dc:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
 80021e0:	ea25 0404 	bic.w	r4, r5, r4
 80021e4:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 80021e8:	d131      	bne.n	800224e <strncmp+0x92>
 80021ea:	1d07      	adds	r7, r0, #4
 80021ec:	1d0d      	adds	r5, r1, #4
 80021ee:	e00d      	b.n	800220c <strncmp+0x50>
 80021f0:	f857 3b04 	ldr.w	r3, [r7], #4
 80021f4:	680e      	ldr	r6, [r1, #0]
 80021f6:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
 80021fa:	42b3      	cmp	r3, r6
 80021fc:	ea24 0403 	bic.w	r4, r4, r3
 8002200:	d10a      	bne.n	8002218 <strncmp+0x5c>
 8002202:	3a04      	subs	r2, #4
 8002204:	d020      	beq.n	8002248 <strncmp+0x8c>
 8002206:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 800220a:	d123      	bne.n	8002254 <strncmp+0x98>
 800220c:	2a03      	cmp	r2, #3
 800220e:	4629      	mov	r1, r5
 8002210:	4638      	mov	r0, r7
 8002212:	f105 0504 	add.w	r5, r5, #4
 8002216:	d8eb      	bhi.n	80021f0 <strncmp+0x34>
 8002218:	7803      	ldrb	r3, [r0, #0]
 800221a:	780c      	ldrb	r4, [r1, #0]
 800221c:	429c      	cmp	r4, r3
 800221e:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
 8002222:	d10c      	bne.n	800223e <strncmp+0x82>
 8002224:	b182      	cbz	r2, 8002248 <strncmp+0x8c>
 8002226:	b914      	cbnz	r4, 800222e <strncmp+0x72>
 8002228:	e016      	b.n	8002258 <strncmp+0x9c>
 800222a:	b16a      	cbz	r2, 8002248 <strncmp+0x8c>
 800222c:	b17b      	cbz	r3, 800224e <strncmp+0x92>
 800222e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8002232:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8002236:	42a3      	cmp	r3, r4
 8002238:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
 800223c:	d0f5      	beq.n	800222a <strncmp+0x6e>
 800223e:	1b18      	subs	r0, r3, r4
 8002240:	bcf0      	pop	{r4, r5, r6, r7}
 8002242:	4770      	bx	lr
 8002244:	4610      	mov	r0, r2
 8002246:	4770      	bx	lr
 8002248:	4610      	mov	r0, r2
 800224a:	bcf0      	pop	{r4, r5, r6, r7}
 800224c:	4770      	bx	lr
 800224e:	4618      	mov	r0, r3
 8002250:	bcf0      	pop	{r4, r5, r6, r7}
 8002252:	4770      	bx	lr
 8002254:	2000      	movs	r0, #0
 8002256:	e7f3      	b.n	8002240 <strncmp+0x84>
 8002258:	4620      	mov	r0, r4
 800225a:	e7f1      	b.n	8002240 <strncmp+0x84>

0800225c <strncpy>:
 800225c:	ea40 0301 	orr.w	r3, r0, r1
 8002260:	079b      	lsls	r3, r3, #30
 8002262:	b470      	push	{r4, r5, r6}
 8002264:	d12b      	bne.n	80022be <strncpy+0x62>
 8002266:	2a03      	cmp	r2, #3
 8002268:	d929      	bls.n	80022be <strncpy+0x62>
 800226a:	460c      	mov	r4, r1
 800226c:	4603      	mov	r3, r0
 800226e:	4621      	mov	r1, r4
 8002270:	f854 6b04 	ldr.w	r6, [r4], #4
 8002274:	f1a6 3501 	sub.w	r5, r6, #16843009	; 0x1010101
 8002278:	ea25 0506 	bic.w	r5, r5, r6
 800227c:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
 8002280:	d106      	bne.n	8002290 <strncpy+0x34>
 8002282:	3a04      	subs	r2, #4
 8002284:	2a03      	cmp	r2, #3
 8002286:	f843 6b04 	str.w	r6, [r3], #4
 800228a:	4621      	mov	r1, r4
 800228c:	d8ef      	bhi.n	800226e <strncpy+0x12>
 800228e:	b1a2      	cbz	r2, 80022ba <strncpy+0x5e>
 8002290:	780c      	ldrb	r4, [r1, #0]
 8002292:	701c      	strb	r4, [r3, #0]
 8002294:	3a01      	subs	r2, #1
 8002296:	3301      	adds	r3, #1
 8002298:	3101      	adds	r1, #1
 800229a:	b13c      	cbz	r4, 80022ac <strncpy+0x50>
 800229c:	b16a      	cbz	r2, 80022ba <strncpy+0x5e>
 800229e:	f811 4b01 	ldrb.w	r4, [r1], #1
 80022a2:	f803 4b01 	strb.w	r4, [r3], #1
 80022a6:	3a01      	subs	r2, #1
 80022a8:	2c00      	cmp	r4, #0
 80022aa:	d1f7      	bne.n	800229c <strncpy+0x40>
 80022ac:	b12a      	cbz	r2, 80022ba <strncpy+0x5e>
 80022ae:	441a      	add	r2, r3
 80022b0:	2100      	movs	r1, #0
 80022b2:	f803 1b01 	strb.w	r1, [r3], #1
 80022b6:	429a      	cmp	r2, r3
 80022b8:	d1fb      	bne.n	80022b2 <strncpy+0x56>
 80022ba:	bc70      	pop	{r4, r5, r6}
 80022bc:	4770      	bx	lr
 80022be:	4603      	mov	r3, r0
 80022c0:	e7e5      	b.n	800228e <strncpy+0x32>
 80022c2:	bf00      	nop

080022c4 <strpbrk>:
 80022c4:	b430      	push	{r4, r5}
 80022c6:	7804      	ldrb	r4, [r0, #0]
 80022c8:	b1dc      	cbz	r4, 8002302 <strpbrk+0x3e>
 80022ca:	780d      	ldrb	r5, [r1, #0]
 80022cc:	b19d      	cbz	r5, 80022f6 <strpbrk+0x32>
 80022ce:	42a5      	cmp	r5, r4
 80022d0:	d00f      	beq.n	80022f2 <strpbrk+0x2e>
 80022d2:	460a      	mov	r2, r1
 80022d4:	e001      	b.n	80022da <strpbrk+0x16>
 80022d6:	42a3      	cmp	r3, r4
 80022d8:	d00b      	beq.n	80022f2 <strpbrk+0x2e>
 80022da:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 80022de:	2b00      	cmp	r3, #0
 80022e0:	d1f9      	bne.n	80022d6 <strpbrk+0x12>
 80022e2:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 80022e6:	2c00      	cmp	r4, #0
 80022e8:	d1f0      	bne.n	80022cc <strpbrk+0x8>
 80022ea:	7813      	ldrb	r3, [r2, #0]
 80022ec:	2b00      	cmp	r3, #0
 80022ee:	bf08      	it	eq
 80022f0:	2000      	moveq	r0, #0
 80022f2:	bc30      	pop	{r4, r5}
 80022f4:	4770      	bx	lr
 80022f6:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 80022fa:	460a      	mov	r2, r1
 80022fc:	2c00      	cmp	r4, #0
 80022fe:	d1e5      	bne.n	80022cc <strpbrk+0x8>
 8002300:	e7f3      	b.n	80022ea <strpbrk+0x26>
 8002302:	4620      	mov	r0, r4
 8002304:	bc30      	pop	{r4, r5}
 8002306:	4770      	bx	lr

08002308 <strspn>:
 8002308:	b470      	push	{r4, r5, r6}
 800230a:	7804      	ldrb	r4, [r0, #0]
 800230c:	b1a4      	cbz	r4, 8002338 <strspn+0x30>
 800230e:	780e      	ldrb	r6, [r1, #0]
 8002310:	4605      	mov	r5, r0
 8002312:	b14e      	cbz	r6, 8002328 <strspn+0x20>
 8002314:	42b4      	cmp	r4, r6
 8002316:	d00a      	beq.n	800232e <strspn+0x26>
 8002318:	460a      	mov	r2, r1
 800231a:	e001      	b.n	8002320 <strspn+0x18>
 800231c:	42a3      	cmp	r3, r4
 800231e:	d006      	beq.n	800232e <strspn+0x26>
 8002320:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8002324:	2b00      	cmp	r3, #0
 8002326:	d1f9      	bne.n	800231c <strspn+0x14>
 8002328:	1a28      	subs	r0, r5, r0
 800232a:	bc70      	pop	{r4, r5, r6}
 800232c:	4770      	bx	lr
 800232e:	f815 4f01 	ldrb.w	r4, [r5, #1]!
 8002332:	2c00      	cmp	r4, #0
 8002334:	d1ed      	bne.n	8002312 <strspn+0xa>
 8002336:	e7f7      	b.n	8002328 <strspn+0x20>
 8002338:	4620      	mov	r0, r4
 800233a:	e7f6      	b.n	800232a <strspn+0x22>
 800233c:	0000      	movs	r0, r0
	...

08002340 <sduInterruptTransmitted>:
 *          interrupt endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {
 8002340:	4770      	bx	lr
 8002342:	bf00      	nop
	...

08002350 <sduRequestsHook>:
  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8002350:	f890 3074 	ldrb.w	r3, [r0, #116]	; 0x74
 8002354:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8002358:	2b20      	cmp	r3, #32
 800235a:	d11e      	bne.n	800239a <sduRequestsHook+0x4a>
    switch (usbp->setup[1]) {
 800235c:	f890 3075 	ldrb.w	r3, [r0, #117]	; 0x75
 8002360:	2b21      	cmp	r3, #33	; 0x21
 8002362:	d004      	beq.n	800236e <sduRequestsHook+0x1e>
 8002364:	2b22      	cmp	r3, #34	; 0x22
 8002366:	d012      	beq.n	800238e <sduRequestsHook+0x3e>
 8002368:	2b20      	cmp	r3, #32
 800236a:	d118      	bne.n	800239e <sduRequestsHook+0x4e>
 800236c:	e007      	b.n	800237e <sduRequestsHook+0x2e>
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 800236e:	4b0d      	ldr	r3, [pc, #52]	; (80023a4 <sduRequestsHook+0x54>)
 8002370:	6683      	str	r3, [r0, #104]	; 0x68
 8002372:	2307      	movs	r3, #7
 8002374:	66c3      	str	r3, [r0, #108]	; 0x6c
 8002376:	2300      	movs	r3, #0
 8002378:	6703      	str	r3, [r0, #112]	; 0x70
      return true;
 800237a:	2001      	movs	r0, #1
 800237c:	4770      	bx	lr
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 800237e:	4b09      	ldr	r3, [pc, #36]	; (80023a4 <sduRequestsHook+0x54>)
 8002380:	6683      	str	r3, [r0, #104]	; 0x68
 8002382:	2307      	movs	r3, #7
 8002384:	66c3      	str	r3, [r0, #108]	; 0x6c
 8002386:	2300      	movs	r3, #0
 8002388:	6703      	str	r3, [r0, #112]	; 0x70
      return true;
 800238a:	2001      	movs	r0, #1
 800238c:	4770      	bx	lr
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800238e:	2300      	movs	r3, #0
 8002390:	6683      	str	r3, [r0, #104]	; 0x68
 8002392:	66c3      	str	r3, [r0, #108]	; 0x6c
 8002394:	6703      	str	r3, [r0, #112]	; 0x70
      return true;
 8002396:	2001      	movs	r0, #1
 8002398:	4770      	bx	lr
  return false;
 800239a:	2000      	movs	r0, #0
 800239c:	4770      	bx	lr
      return false;
 800239e:	2000      	movs	r0, #0
}
 80023a0:	4770      	bx	lr
 80023a2:	bf00      	nop
 80023a4:	20002440 	.word	0x20002440
	...

080023b0 <_ctl.lto_priv.151>:
}
 80023b0:	2000      	movs	r0, #0
 80023b2:	4770      	bx	lr
	...

080023c0 <_ctl.lto_priv.150>:
#else
    break;
#endif
  }
  return MSG_OK;
}
 80023c0:	2000      	movs	r0, #0
 80023c2:	4770      	bx	lr
	...

080023d0 <oqObjectInit>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80023d0:	6000      	str	r0, [r0, #0]
  tqp->prev = (thread_t *)tqp;
 80023d2:	6040      	str	r0, [r0, #4]
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 80023d4:	6082      	str	r2, [r0, #8]
  oqp->q_buffer  = bp;
 80023d6:	60c1      	str	r1, [r0, #12]
  oqp->q_rdptr   = bp;
 80023d8:	6181      	str	r1, [r0, #24]
  oqp->q_wrptr   = bp;
 80023da:	6141      	str	r1, [r0, #20]
  oqp->q_top     = bp + size;
 80023dc:	440a      	add	r2, r1
 80023de:	6102      	str	r2, [r0, #16]
  oqp->q_notify  = onfy;
 80023e0:	61c3      	str	r3, [r0, #28]
  oqp->q_link    = link;
 80023e2:	9b00      	ldr	r3, [sp, #0]
 80023e4:	6203      	str	r3, [r0, #32]
 80023e6:	4770      	bx	lr
	...

080023f0 <iqObjectInit>:
                  qnotify_t infy, void *link) {
 80023f0:	b410      	push	{r4}
  tqp->next = (thread_t *)tqp;
 80023f2:	6000      	str	r0, [r0, #0]
  tqp->prev = (thread_t *)tqp;
 80023f4:	6040      	str	r0, [r0, #4]
  iqp->q_counter = 0;
 80023f6:	2400      	movs	r4, #0
 80023f8:	6084      	str	r4, [r0, #8]
  iqp->q_buffer  = bp;
 80023fa:	60c1      	str	r1, [r0, #12]
  iqp->q_rdptr   = bp;
 80023fc:	6181      	str	r1, [r0, #24]
  iqp->q_wrptr   = bp;
 80023fe:	6141      	str	r1, [r0, #20]
  iqp->q_top     = bp + size;
 8002400:	440a      	add	r2, r1
 8002402:	6102      	str	r2, [r0, #16]
  iqp->q_notify  = infy;
 8002404:	61c3      	str	r3, [r0, #28]
  iqp->q_link    = link;
 8002406:	9b01      	ldr	r3, [sp, #4]
 8002408:	6203      	str	r3, [r0, #32]
}
 800240a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800240e:	4770      	bx	lr

08002410 <obqTryFlushI>:
 * @retval false        if no new filled buffer has been posted to the queue.
 * @retval true         if a new filled buffer has been posted to the queue.
 *
 * @iclass
 */
bool obqTryFlushI(output_buffers_queue_t *obqp) {
 8002410:	4603      	mov	r3, r0

  osalDbgCheckClassI();

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 8002412:	6901      	ldr	r1, [r0, #16]
 8002414:	6942      	ldr	r2, [r0, #20]
 8002416:	4291      	cmp	r1, r2
 8002418:	d102      	bne.n	8002420 <obqTryFlushI+0x10>
 800241a:	68c2      	ldr	r2, [r0, #12]
 800241c:	b912      	cbnz	r2, 8002424 <obqTryFlushI+0x14>
 800241e:	e002      	b.n	8002426 <obqTryFlushI+0x16>
 8002420:	2200      	movs	r2, #0
 8002422:	e000      	b.n	8002426 <obqTryFlushI+0x16>
 8002424:	2201      	movs	r2, #1
 8002426:	4610      	mov	r0, r2
 8002428:	b1ba      	cbz	r2, 800245a <obqTryFlushI+0x4a>
 800242a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800242c:	b192      	cbz	r2, 8002454 <obqTryFlushI+0x44>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
 800242e:	1a52      	subs	r2, r2, r1

    if (size > 0U) {
 8002430:	3a04      	subs	r2, #4
 8002432:	d011      	beq.n	8002458 <obqTryFlushI+0x48>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
 8002434:	600a      	str	r2, [r1, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
 8002436:	68da      	ldr	r2, [r3, #12]
 8002438:	3a01      	subs	r2, #1
 800243a:	60da      	str	r2, [r3, #12]
      obqp->bwrptr += obqp->bsize;
 800243c:	6919      	ldr	r1, [r3, #16]
 800243e:	69da      	ldr	r2, [r3, #28]
 8002440:	440a      	add	r2, r1
 8002442:	611a      	str	r2, [r3, #16]
      if (obqp->bwrptr >= obqp->btop) {
 8002444:	6999      	ldr	r1, [r3, #24]
 8002446:	428a      	cmp	r2, r1
 8002448:	d301      	bcc.n	800244e <obqTryFlushI+0x3e>
        obqp->bwrptr = obqp->buffers;
 800244a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800244c:	611a      	str	r2, [r3, #16]
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 800244e:	2200      	movs	r2, #0
 8002450:	629a      	str	r2, [r3, #40]	; 0x28
 8002452:	4770      	bx	lr

      return true;
    }
  }
  return false;
 8002454:	2000      	movs	r0, #0
 8002456:	4770      	bx	lr
 8002458:	2000      	movs	r0, #0
}
 800245a:	4770      	bx	lr
 800245c:	0000      	movs	r0, r0
	...

08002460 <obqPostFullBufferS>:
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
 8002460:	b508      	push	{r3, lr}
  *((size_t *)obqp->bwrptr) = size;
 8002462:	6903      	ldr	r3, [r0, #16]
 8002464:	6019      	str	r1, [r3, #0]
  obqp->bcounter--;
 8002466:	68c3      	ldr	r3, [r0, #12]
 8002468:	3b01      	subs	r3, #1
 800246a:	60c3      	str	r3, [r0, #12]
  obqp->bwrptr += obqp->bsize;
 800246c:	6902      	ldr	r2, [r0, #16]
 800246e:	69c3      	ldr	r3, [r0, #28]
 8002470:	4413      	add	r3, r2
 8002472:	6103      	str	r3, [r0, #16]
  if (obqp->bwrptr >= obqp->btop) {
 8002474:	6982      	ldr	r2, [r0, #24]
 8002476:	4293      	cmp	r3, r2
 8002478:	d301      	bcc.n	800247e <obqPostFullBufferS+0x1e>
    obqp->bwrptr = obqp->buffers;
 800247a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800247c:	6103      	str	r3, [r0, #16]
  obqp->ptr = NULL;
 800247e:	2300      	movs	r3, #0
 8002480:	6283      	str	r3, [r0, #40]	; 0x28
  if (obqp->notify != NULL) {
 8002482:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8002484:	b103      	cbz	r3, 8002488 <obqPostFullBufferS+0x28>
    obqp->notify(obqp);
 8002486:	4798      	blx	r3
 8002488:	bd08      	pop	{r3, pc}
 800248a:	bf00      	nop
 800248c:	0000      	movs	r0, r0
	...

08002490 <obqGetFullBufferI>:
  if (obqIsEmptyI(obqp)) {
 8002490:	6943      	ldr	r3, [r0, #20]
 8002492:	6902      	ldr	r2, [r0, #16]
 8002494:	429a      	cmp	r2, r3
 8002496:	d102      	bne.n	800249e <obqGetFullBufferI+0xe>
 8002498:	68c2      	ldr	r2, [r0, #12]
 800249a:	b912      	cbnz	r2, 80024a2 <obqGetFullBufferI+0x12>
 800249c:	e002      	b.n	80024a4 <obqGetFullBufferI+0x14>
 800249e:	2200      	movs	r2, #0
 80024a0:	e000      	b.n	80024a4 <obqGetFullBufferI+0x14>
 80024a2:	2201      	movs	r2, #1
 80024a4:	b922      	cbnz	r2, 80024b0 <obqGetFullBufferI+0x20>
  *sizep = *((size_t *)obqp->brdptr);
 80024a6:	681b      	ldr	r3, [r3, #0]
 80024a8:	600b      	str	r3, [r1, #0]
  return obqp->brdptr + sizeof (size_t);
 80024aa:	6940      	ldr	r0, [r0, #20]
 80024ac:	3004      	adds	r0, #4
 80024ae:	4770      	bx	lr
    return NULL;
 80024b0:	2000      	movs	r0, #0
}
 80024b2:	4770      	bx	lr
	...

080024c0 <obqObjectInit>:
                   size_t size, size_t n, bqnotify_t onfy, void *link) {
 80024c0:	b410      	push	{r4}
 80024c2:	9c01      	ldr	r4, [sp, #4]
  tqp->next = (thread_t *)tqp;
 80024c4:	6000      	str	r0, [r0, #0]
  tqp->prev = (thread_t *)tqp;
 80024c6:	6040      	str	r0, [r0, #4]
  obqp->suspended = suspended;
 80024c8:	7201      	strb	r1, [r0, #8]
  obqp->bcounter  = n;
 80024ca:	60c4      	str	r4, [r0, #12]
  obqp->brdptr    = bp;
 80024cc:	6142      	str	r2, [r0, #20]
  obqp->bwrptr    = bp;
 80024ce:	6102      	str	r2, [r0, #16]
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
 80024d0:	3304      	adds	r3, #4
 80024d2:	fb03 2104 	mla	r1, r3, r4, r2
 80024d6:	6181      	str	r1, [r0, #24]
  obqp->bsize     = size + sizeof (size_t);
 80024d8:	61c3      	str	r3, [r0, #28]
  obqp->bn        = n;
 80024da:	6204      	str	r4, [r0, #32]
  obqp->buffers   = bp;
 80024dc:	6242      	str	r2, [r0, #36]	; 0x24
  obqp->ptr       = NULL;
 80024de:	2300      	movs	r3, #0
 80024e0:	6283      	str	r3, [r0, #40]	; 0x28
  obqp->top       = NULL;
 80024e2:	62c3      	str	r3, [r0, #44]	; 0x2c
  obqp->notify    = onfy;
 80024e4:	9b02      	ldr	r3, [sp, #8]
 80024e6:	6303      	str	r3, [r0, #48]	; 0x30
  obqp->link      = link;
 80024e8:	9b03      	ldr	r3, [sp, #12]
 80024ea:	6343      	str	r3, [r0, #52]	; 0x34
}
 80024ec:	f85d 4b04 	ldr.w	r4, [sp], #4
 80024f0:	4770      	bx	lr
 80024f2:	bf00      	nop
	...

08002500 <ibqReleaseEmptyBufferS>:
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
 8002500:	b508      	push	{r3, lr}
  ibqp->bcounter--;
 8002502:	68c3      	ldr	r3, [r0, #12]
 8002504:	3b01      	subs	r3, #1
 8002506:	60c3      	str	r3, [r0, #12]
  ibqp->brdptr += ibqp->bsize;
 8002508:	6942      	ldr	r2, [r0, #20]
 800250a:	69c3      	ldr	r3, [r0, #28]
 800250c:	4413      	add	r3, r2
 800250e:	6143      	str	r3, [r0, #20]
  if (ibqp->brdptr >= ibqp->btop) {
 8002510:	6982      	ldr	r2, [r0, #24]
 8002512:	4293      	cmp	r3, r2
 8002514:	d301      	bcc.n	800251a <ibqReleaseEmptyBufferS+0x1a>
    ibqp->brdptr = ibqp->buffers;
 8002516:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8002518:	6143      	str	r3, [r0, #20]
  ibqp->ptr = NULL;
 800251a:	2300      	movs	r3, #0
 800251c:	6283      	str	r3, [r0, #40]	; 0x28
  if (ibqp->notify != NULL) {
 800251e:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8002520:	b103      	cbz	r3, 8002524 <ibqReleaseEmptyBufferS+0x24>
    ibqp->notify(ibqp);
 8002522:	4798      	blx	r3
 8002524:	bd08      	pop	{r3, pc}
 8002526:	bf00      	nop
	...

08002530 <ibqGetEmptyBufferI>:
  if (ibqIsFullI(ibqp)) {
 8002530:	6903      	ldr	r3, [r0, #16]
 8002532:	6942      	ldr	r2, [r0, #20]
 8002534:	4293      	cmp	r3, r2
 8002536:	d102      	bne.n	800253e <ibqGetEmptyBufferI+0xe>
 8002538:	68c2      	ldr	r2, [r0, #12]
 800253a:	b912      	cbnz	r2, 8002542 <ibqGetEmptyBufferI+0x12>
 800253c:	e002      	b.n	8002544 <ibqGetEmptyBufferI+0x14>
 800253e:	2200      	movs	r2, #0
 8002540:	e000      	b.n	8002544 <ibqGetEmptyBufferI+0x14>
 8002542:	2201      	movs	r2, #1
 8002544:	b90a      	cbnz	r2, 800254a <ibqGetEmptyBufferI+0x1a>
  return ibqp->bwrptr + sizeof (size_t);
 8002546:	1d18      	adds	r0, r3, #4
 8002548:	4770      	bx	lr
    return NULL;
 800254a:	2000      	movs	r0, #0
}
 800254c:	4770      	bx	lr
 800254e:	bf00      	nop

08002550 <ibqObjectInit>:
                   size_t size, size_t n, bqnotify_t infy, void *link) {
 8002550:	b430      	push	{r4, r5}
 8002552:	9c02      	ldr	r4, [sp, #8]
  tqp->next = (thread_t *)tqp;
 8002554:	6000      	str	r0, [r0, #0]
  tqp->prev = (thread_t *)tqp;
 8002556:	6040      	str	r0, [r0, #4]
  ibqp->suspended = suspended;
 8002558:	7201      	strb	r1, [r0, #8]
  ibqp->bcounter  = 0;
 800255a:	2100      	movs	r1, #0
 800255c:	60c1      	str	r1, [r0, #12]
  ibqp->brdptr    = bp;
 800255e:	6142      	str	r2, [r0, #20]
  ibqp->bwrptr    = bp;
 8002560:	6102      	str	r2, [r0, #16]
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8002562:	3304      	adds	r3, #4
 8002564:	fb04 2503 	mla	r5, r4, r3, r2
 8002568:	6185      	str	r5, [r0, #24]
  ibqp->bsize     = size + sizeof (size_t);
 800256a:	61c3      	str	r3, [r0, #28]
  ibqp->bn        = n;
 800256c:	6204      	str	r4, [r0, #32]
  ibqp->buffers   = bp;
 800256e:	6242      	str	r2, [r0, #36]	; 0x24
  ibqp->ptr       = NULL;
 8002570:	6281      	str	r1, [r0, #40]	; 0x28
  ibqp->top       = NULL;
 8002572:	62c1      	str	r1, [r0, #44]	; 0x2c
  ibqp->notify    = infy;
 8002574:	9b03      	ldr	r3, [sp, #12]
 8002576:	6303      	str	r3, [r0, #48]	; 0x30
  ibqp->link      = link;
 8002578:	9b04      	ldr	r3, [sp, #16]
 800257a:	6343      	str	r3, [r0, #52]	; 0x34
}
 800257c:	bc30      	pop	{r4, r5}
 800257e:	4770      	bx	lr

08002580 <usbInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void usbInit(void) {
 8002580:	b508      	push	{r3, lr}

  usb_lld_init();
 8002582:	f003 fa2d 	bl	80059e0 <usb_lld_init>
 8002586:	bd08      	pop	{r3, pc}
	...

08002590 <set_address>:
static void set_address(USBDriver *usbp) {
 8002590:	b510      	push	{r4, lr}
 8002592:	4604      	mov	r4, r0
  usbp->address = usbp->setup[2];
 8002594:	f890 3076 	ldrb.w	r3, [r0, #118]	; 0x76
 8002598:	f880 307e 	strb.w	r3, [r0, #126]	; 0x7e
  usb_lld_set_address(usbp);
 800259c:	f004 fef8 	bl	8007390 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 80025a0:	6863      	ldr	r3, [r4, #4]
 80025a2:	681b      	ldr	r3, [r3, #0]
 80025a4:	b113      	cbz	r3, 80025ac <set_address+0x1c>
 80025a6:	2101      	movs	r1, #1
 80025a8:	4620      	mov	r0, r4
 80025aa:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 80025ac:	2303      	movs	r3, #3
 80025ae:	7023      	strb	r3, [r4, #0]
 80025b0:	bd10      	pop	{r4, pc}
 80025b2:	bf00      	nop
	...

080025c0 <obnotify>:
static void obnotify(io_buffers_queue_t *bqp) {
 80025c0:	b510      	push	{r4, lr}
 80025c2:	b082      	sub	sp, #8
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 80025c4:	6b44      	ldr	r4, [r0, #52]	; 0x34
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80025c6:	f8d4 348c 	ldr.w	r3, [r4, #1164]	; 0x48c
 80025ca:	681a      	ldr	r2, [r3, #0]
 80025cc:	7811      	ldrb	r1, [r2, #0]
 80025ce:	2904      	cmp	r1, #4
 80025d0:	d115      	bne.n	80025fe <obnotify+0x3e>
      (sdup->state != SDU_READY)) {
 80025d2:	7a21      	ldrb	r1, [r4, #8]
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80025d4:	2902      	cmp	r1, #2
 80025d6:	d112      	bne.n	80025fe <obnotify+0x3e>
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 80025d8:	8912      	ldrh	r2, [r2, #8]
 80025da:	7919      	ldrb	r1, [r3, #4]
 80025dc:	2301      	movs	r3, #1
 80025de:	408b      	lsls	r3, r1
 80025e0:	4213      	tst	r3, r2
 80025e2:	d10c      	bne.n	80025fe <obnotify+0x3e>
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 80025e4:	a901      	add	r1, sp, #4
 80025e6:	f104 0044 	add.w	r0, r4, #68	; 0x44
 80025ea:	f7ff ff51 	bl	8002490 <obqGetFullBufferI>
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 80025ee:	f8d4 448c 	ldr.w	r4, [r4, #1164]	; 0x48c
 80025f2:	9b01      	ldr	r3, [sp, #4]
 80025f4:	4602      	mov	r2, r0
 80025f6:	7921      	ldrb	r1, [r4, #4]
 80025f8:	6820      	ldr	r0, [r4, #0]
 80025fa:	f003 fdb1 	bl	8006160 <usbStartTransmitI>
}
 80025fe:	b002      	add	sp, #8
 8002600:	bd10      	pop	{r4, pc}
 8002602:	bf00      	nop
	...

08002610 <obqResetI>:
void obqResetI(output_buffers_queue_t *obqp) {
 8002610:	b508      	push	{r3, lr}
  obqp->bcounter  = bqSizeX(obqp);
 8002612:	6a02      	ldr	r2, [r0, #32]
 8002614:	60c2      	str	r2, [r0, #12]
  obqp->brdptr    = obqp->buffers;
 8002616:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8002618:	6142      	str	r2, [r0, #20]
  obqp->bwrptr    = obqp->buffers;
 800261a:	6102      	str	r2, [r0, #16]
  obqp->ptr       = NULL;
 800261c:	2200      	movs	r2, #0
 800261e:	6282      	str	r2, [r0, #40]	; 0x28
  obqp->top       = NULL;
 8002620:	62c2      	str	r2, [r0, #44]	; 0x2c
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 8002622:	f06f 0101 	mvn.w	r1, #1
 8002626:	f008 fe6b 	bl	800b300 <chThdDequeueAllI>
 800262a:	bd08      	pop	{r3, pc}
 800262c:	0000      	movs	r0, r0
	...

08002630 <ibqResetI>:
void ibqResetI(input_buffers_queue_t *ibqp) {
 8002630:	b508      	push	{r3, lr}
  ibqp->bcounter  = 0;
 8002632:	2200      	movs	r2, #0
 8002634:	60c2      	str	r2, [r0, #12]
  ibqp->brdptr    = ibqp->buffers;
 8002636:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8002638:	6141      	str	r1, [r0, #20]
  ibqp->bwrptr    = ibqp->buffers;
 800263a:	6101      	str	r1, [r0, #16]
  ibqp->ptr       = NULL;
 800263c:	6282      	str	r2, [r0, #40]	; 0x28
  ibqp->top       = NULL;
 800263e:	62c2      	str	r2, [r0, #44]	; 0x2c
 8002640:	f06f 0101 	mvn.w	r1, #1
 8002644:	f008 fe5c 	bl	800b300 <chThdDequeueAllI>
 8002648:	bd08      	pop	{r3, pc}
 800264a:	bf00      	nop
 800264c:	0000      	movs	r0, r0
	...

08002650 <sdu_start_receive>:
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8002650:	f8d0 248c 	ldr.w	r2, [r0, #1164]	; 0x48c
 8002654:	6813      	ldr	r3, [r2, #0]
 8002656:	7819      	ldrb	r1, [r3, #0]
 8002658:	2904      	cmp	r1, #4
 800265a:	d11a      	bne.n	8002692 <sdu_start_receive+0x42>
      (sdup->state != SDU_READY)) {
 800265c:	7a01      	ldrb	r1, [r0, #8]
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800265e:	2902      	cmp	r1, #2
 8002660:	d119      	bne.n	8002696 <sdu_start_receive+0x46>
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8002662:	7911      	ldrb	r1, [r2, #4]
 8002664:	2201      	movs	r2, #1
 8002666:	408a      	lsls	r2, r1
 8002668:	895b      	ldrh	r3, [r3, #10]
 800266a:	4013      	ands	r3, r2
 800266c:	b29b      	uxth	r3, r3
 800266e:	b9a3      	cbnz	r3, 800269a <sdu_start_receive+0x4a>
static bool sdu_start_receive(SerialUSBDriver *sdup) {
 8002670:	b510      	push	{r4, lr}
 8002672:	4604      	mov	r4, r0
  buf = ibqGetEmptyBufferI(&sdup->ibqueue);
 8002674:	300c      	adds	r0, #12
 8002676:	f7ff ff5b 	bl	8002530 <ibqGetEmptyBufferI>
  if (buf == NULL) {
 800267a:	4602      	mov	r2, r0
 800267c:	b178      	cbz	r0, 800269e <sdu_start_receive+0x4e>
  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 800267e:	f8d4 048c 	ldr.w	r0, [r4, #1164]	; 0x48c
 8002682:	f44f 7380 	mov.w	r3, #256	; 0x100
 8002686:	7941      	ldrb	r1, [r0, #5]
 8002688:	6800      	ldr	r0, [r0, #0]
 800268a:	f003 fdc1 	bl	8006210 <usbStartReceiveI>
  return false;
 800268e:	2000      	movs	r0, #0
 8002690:	bd10      	pop	{r4, pc}
    return true;
 8002692:	2001      	movs	r0, #1
 8002694:	4770      	bx	lr
 8002696:	2001      	movs	r0, #1
}
 8002698:	4770      	bx	lr
    return true;
 800269a:	2001      	movs	r0, #1
 800269c:	4770      	bx	lr
    return true;
 800269e:	2001      	movs	r0, #1
}
 80026a0:	bd10      	pop	{r4, pc}
 80026a2:	bf00      	nop
	...

080026b0 <ibnotify>:
static void ibnotify(io_buffers_queue_t *bqp) {
 80026b0:	b508      	push	{r3, lr}
  (void) sdu_start_receive(sdup);
 80026b2:	6b40      	ldr	r0, [r0, #52]	; 0x34
 80026b4:	f7ff ffcc 	bl	8002650 <sdu_start_receive>
 80026b8:	bd08      	pop	{r3, pc}
 80026ba:	bf00      	nop
 80026bc:	0000      	movs	r0, r0
	...

080026c0 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 80026c0:	b508      	push	{r3, lr}

  sd_lld_init();
 80026c2:	f004 fa85 	bl	8006bd0 <sd_lld_init>
 80026c6:	bd08      	pop	{r3, pc}
	...

080026d0 <pwmInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void pwmInit(void) {
 80026d0:	b508      	push	{r3, lr}

  pwm_lld_init();
 80026d2:	f004 fbe5 	bl	8006ea0 <pwm_lld_init>
 80026d6:	bd08      	pop	{r3, pc}
	...

080026e0 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 80026e0:	b570      	push	{r4, r5, r6, lr}
 80026e2:	4604      	mov	r4, r0
 80026e4:	460e      	mov	r6, r1
 80026e6:	4615      	mov	r5, r2
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80026e8:	2320      	movs	r3, #32
 80026ea:	f383 8811 	msr	BASEPRI, r3
 80026ee:	e009      	b.n	8002704 <oqPutTimeout+0x24>
  return chThdEnqueueTimeoutS(tqp, timeout);
 80026f0:	4629      	mov	r1, r5
 80026f2:	4620      	mov	r0, r4
 80026f4:	f009 fa6c 	bl	800bbd0 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 80026f8:	2800      	cmp	r0, #0
 80026fa:	da03      	bge.n	8002704 <oqPutTimeout+0x24>
 80026fc:	2300      	movs	r3, #0
 80026fe:	f383 8811 	msr	BASEPRI, r3
 8002702:	bd70      	pop	{r4, r5, r6, pc}
  while (oqIsFullI(oqp)) {
 8002704:	68a3      	ldr	r3, [r4, #8]
 8002706:	2b00      	cmp	r3, #0
 8002708:	d0f2      	beq.n	80026f0 <oqPutTimeout+0x10>
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 800270a:	68a3      	ldr	r3, [r4, #8]
 800270c:	3b01      	subs	r3, #1
 800270e:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8002710:	6963      	ldr	r3, [r4, #20]
 8002712:	1c5a      	adds	r2, r3, #1
 8002714:	6162      	str	r2, [r4, #20]
 8002716:	701e      	strb	r6, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8002718:	6962      	ldr	r2, [r4, #20]
 800271a:	6923      	ldr	r3, [r4, #16]
 800271c:	429a      	cmp	r2, r3
 800271e:	d301      	bcc.n	8002724 <oqPutTimeout+0x44>
    oqp->q_wrptr = oqp->q_buffer;
 8002720:	68e3      	ldr	r3, [r4, #12]
 8002722:	6163      	str	r3, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 8002724:	69e3      	ldr	r3, [r4, #28]
 8002726:	b10b      	cbz	r3, 800272c <oqPutTimeout+0x4c>
    oqp->q_notify(oqp);
 8002728:	4620      	mov	r0, r4
 800272a:	4798      	blx	r3
 800272c:	2000      	movs	r0, #0
 800272e:	f380 8811 	msr	BASEPRI, r0
  }

  osalSysUnlock();

  return MSG_OK;
}
 8002732:	bd70      	pop	{r4, r5, r6, pc}
	...

08002740 <_putt.lto_priv.158>:
static msg_t _putt(void *ip, uint8_t b, sysinterval_t timeout) {
 8002740:	b508      	push	{r3, lr}
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8002742:	3030      	adds	r0, #48	; 0x30
 8002744:	f7ff ffcc 	bl	80026e0 <oqPutTimeout>
}
 8002748:	bd08      	pop	{r3, pc}
 800274a:	bf00      	nop
 800274c:	0000      	movs	r0, r0
	...

08002750 <_put.lto_priv.162>:
static msg_t _put(void *ip, uint8_t b) {
 8002750:	b508      	push	{r3, lr}
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8002752:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8002756:	3030      	adds	r0, #48	; 0x30
 8002758:	f7ff ffc2 	bl	80026e0 <oqPutTimeout>
}
 800275c:	bd08      	pop	{r3, pc}
 800275e:	bf00      	nop

08002760 <iqGetTimeout>:
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 8002760:	b538      	push	{r3, r4, r5, lr}
 8002762:	4604      	mov	r4, r0
 8002764:	460d      	mov	r5, r1
 8002766:	2320      	movs	r3, #32
 8002768:	f383 8811 	msr	BASEPRI, r3
 800276c:	e009      	b.n	8002782 <iqGetTimeout+0x22>
 800276e:	4629      	mov	r1, r5
 8002770:	4620      	mov	r0, r4
 8002772:	f009 fa2d 	bl	800bbd0 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 8002776:	2800      	cmp	r0, #0
 8002778:	da03      	bge.n	8002782 <iqGetTimeout+0x22>
 800277a:	2300      	movs	r3, #0
 800277c:	f383 8811 	msr	BASEPRI, r3
 8002780:	bd38      	pop	{r3, r4, r5, pc}
  while (iqIsEmptyI(iqp)) {
 8002782:	68a3      	ldr	r3, [r4, #8]
 8002784:	2b00      	cmp	r3, #0
 8002786:	d0f2      	beq.n	800276e <iqGetTimeout+0xe>
  iqp->q_counter--;
 8002788:	68a3      	ldr	r3, [r4, #8]
 800278a:	3b01      	subs	r3, #1
 800278c:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 800278e:	69a2      	ldr	r2, [r4, #24]
 8002790:	1c53      	adds	r3, r2, #1
 8002792:	61a3      	str	r3, [r4, #24]
 8002794:	7815      	ldrb	r5, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
 8002796:	6922      	ldr	r2, [r4, #16]
 8002798:	4293      	cmp	r3, r2
 800279a:	d301      	bcc.n	80027a0 <iqGetTimeout+0x40>
    iqp->q_rdptr = iqp->q_buffer;
 800279c:	68e3      	ldr	r3, [r4, #12]
 800279e:	61a3      	str	r3, [r4, #24]
  if (iqp->q_notify != NULL) {
 80027a0:	69e3      	ldr	r3, [r4, #28]
 80027a2:	b10b      	cbz	r3, 80027a8 <iqGetTimeout+0x48>
    iqp->q_notify(iqp);
 80027a4:	4620      	mov	r0, r4
 80027a6:	4798      	blx	r3
 80027a8:	2300      	movs	r3, #0
 80027aa:	f383 8811 	msr	BASEPRI, r3
  return (msg_t)b;
 80027ae:	4628      	mov	r0, r5
}
 80027b0:	bd38      	pop	{r3, r4, r5, pc}
 80027b2:	bf00      	nop
	...

080027c0 <_gett.lto_priv.156>:
static msg_t _gett(void *ip, sysinterval_t timeout) {
 80027c0:	b508      	push	{r3, lr}
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 80027c2:	300c      	adds	r0, #12
 80027c4:	f7ff ffcc 	bl	8002760 <iqGetTimeout>
}
 80027c8:	bd08      	pop	{r3, pc}
 80027ca:	bf00      	nop
 80027cc:	0000      	movs	r0, r0
	...

080027d0 <_get.lto_priv.160>:
static msg_t _get(void *ip) {
 80027d0:	b508      	push	{r3, lr}
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80027d2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80027d6:	300c      	adds	r0, #12
 80027d8:	f7ff ffc2 	bl	8002760 <iqGetTimeout>
}
 80027dc:	bd08      	pop	{r3, pc}
 80027de:	bf00      	nop

080027e0 <obqGetEmptyBufferTimeoutS>:
                                sysinterval_t timeout) {
 80027e0:	b538      	push	{r3, r4, r5, lr}
 80027e2:	4604      	mov	r4, r0
 80027e4:	460d      	mov	r5, r1
 80027e6:	e007      	b.n	80027f8 <obqGetEmptyBufferTimeoutS+0x18>
    if (obqp->suspended) {
 80027e8:	7a23      	ldrb	r3, [r4, #8]
 80027ea:	b983      	cbnz	r3, 800280e <obqGetEmptyBufferTimeoutS+0x2e>
 80027ec:	4629      	mov	r1, r5
 80027ee:	4620      	mov	r0, r4
 80027f0:	f009 f9ee 	bl	800bbd0 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 80027f4:	2800      	cmp	r0, #0
 80027f6:	db0c      	blt.n	8002812 <obqGetEmptyBufferTimeoutS+0x32>
  while (obqIsFullI(obqp)) {
 80027f8:	68e3      	ldr	r3, [r4, #12]
 80027fa:	2b00      	cmp	r3, #0
 80027fc:	d0f4      	beq.n	80027e8 <obqGetEmptyBufferTimeoutS+0x8>
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 80027fe:	6922      	ldr	r2, [r4, #16]
 8002800:	1d13      	adds	r3, r2, #4
 8002802:	62a3      	str	r3, [r4, #40]	; 0x28
  obqp->top = obqp->bwrptr + obqp->bsize;
 8002804:	69e3      	ldr	r3, [r4, #28]
 8002806:	4413      	add	r3, r2
 8002808:	62e3      	str	r3, [r4, #44]	; 0x2c
  return MSG_OK;
 800280a:	2000      	movs	r0, #0
 800280c:	bd38      	pop	{r3, r4, r5, pc}
      return MSG_RESET;
 800280e:	f06f 0001 	mvn.w	r0, #1
}
 8002812:	bd38      	pop	{r3, r4, r5, pc}
	...

08002820 <obqPutTimeout>:
                    sysinterval_t timeout) {
 8002820:	b538      	push	{r3, r4, r5, lr}
 8002822:	4604      	mov	r4, r0
 8002824:	460d      	mov	r5, r1
 8002826:	2320      	movs	r3, #32
 8002828:	f383 8811 	msr	BASEPRI, r3
  if (obqp->ptr == NULL) {
 800282c:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800282e:	b93b      	cbnz	r3, 8002840 <obqPutTimeout+0x20>
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 8002830:	4611      	mov	r1, r2
 8002832:	f7ff ffd5 	bl	80027e0 <obqGetEmptyBufferTimeoutS>
    if (msg != MSG_OK) {
 8002836:	b118      	cbz	r0, 8002840 <obqPutTimeout+0x20>
 8002838:	2200      	movs	r2, #0
 800283a:	f382 8811 	msr	BASEPRI, r2
 800283e:	bd38      	pop	{r3, r4, r5, pc}
  *obqp->ptr = b;
 8002840:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002842:	701d      	strb	r5, [r3, #0]
  obqp->ptr++;
 8002844:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002846:	3301      	adds	r3, #1
 8002848:	62a3      	str	r3, [r4, #40]	; 0x28
  if (obqp->ptr >= obqp->top) {
 800284a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800284c:	4293      	cmp	r3, r2
 800284e:	d304      	bcc.n	800285a <obqPutTimeout+0x3a>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8002850:	69e1      	ldr	r1, [r4, #28]
 8002852:	3904      	subs	r1, #4
 8002854:	4620      	mov	r0, r4
 8002856:	f7ff fe03 	bl	8002460 <obqPostFullBufferS>
 800285a:	2000      	movs	r0, #0
 800285c:	f380 8811 	msr	BASEPRI, r0
}
 8002860:	bd38      	pop	{r3, r4, r5, pc}
 8002862:	bf00      	nop
	...

08002870 <_putt.lto_priv.159>:
static msg_t _putt(void *ip, uint8_t b, sysinterval_t timeout) {
 8002870:	b508      	push	{r3, lr}
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
 8002872:	3044      	adds	r0, #68	; 0x44
 8002874:	f7ff ffd4 	bl	8002820 <obqPutTimeout>
}
 8002878:	bd08      	pop	{r3, pc}
 800287a:	bf00      	nop
 800287c:	0000      	movs	r0, r0
	...

08002880 <_put.lto_priv.163>:
static msg_t _put(void *ip, uint8_t b) {
 8002880:	b508      	push	{r3, lr}
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
 8002882:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8002886:	3044      	adds	r0, #68	; 0x44
 8002888:	f7ff ffca 	bl	8002820 <obqPutTimeout>
}
 800288c:	bd08      	pop	{r3, pc}
 800288e:	bf00      	nop

08002890 <ibqGetFullBufferTimeoutS>:
                                 sysinterval_t timeout) {
 8002890:	b538      	push	{r3, r4, r5, lr}
 8002892:	4604      	mov	r4, r0
 8002894:	460d      	mov	r5, r1
 8002896:	e007      	b.n	80028a8 <ibqGetFullBufferTimeoutS+0x18>
    if (ibqp->suspended) {
 8002898:	7a23      	ldrb	r3, [r4, #8]
 800289a:	b983      	cbnz	r3, 80028be <ibqGetFullBufferTimeoutS+0x2e>
 800289c:	4629      	mov	r1, r5
 800289e:	4620      	mov	r0, r4
 80028a0:	f009 f996 	bl	800bbd0 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 80028a4:	2800      	cmp	r0, #0
 80028a6:	db0c      	blt.n	80028c2 <ibqGetFullBufferTimeoutS+0x32>
  while (ibqIsEmptyI(ibqp)) {
 80028a8:	68e3      	ldr	r3, [r4, #12]
 80028aa:	2b00      	cmp	r3, #0
 80028ac:	d0f4      	beq.n	8002898 <ibqGetFullBufferTimeoutS+0x8>
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 80028ae:	6963      	ldr	r3, [r4, #20]
 80028b0:	1d1a      	adds	r2, r3, #4
 80028b2:	62a2      	str	r2, [r4, #40]	; 0x28
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 80028b4:	681b      	ldr	r3, [r3, #0]
 80028b6:	4413      	add	r3, r2
 80028b8:	62e3      	str	r3, [r4, #44]	; 0x2c
  return MSG_OK;
 80028ba:	2000      	movs	r0, #0
 80028bc:	bd38      	pop	{r3, r4, r5, pc}
      return MSG_RESET;
 80028be:	f06f 0001 	mvn.w	r0, #1
}
 80028c2:	bd38      	pop	{r3, r4, r5, pc}
	...

080028d0 <ibqGetTimeout>:
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, sysinterval_t timeout) {
 80028d0:	b538      	push	{r3, r4, r5, lr}
 80028d2:	4604      	mov	r4, r0
 80028d4:	2320      	movs	r3, #32
 80028d6:	f383 8811 	msr	BASEPRI, r3
  if (ibqp->ptr == NULL) {
 80028da:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80028dc:	b933      	cbnz	r3, 80028ec <ibqGetTimeout+0x1c>
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 80028de:	f7ff ffd7 	bl	8002890 <ibqGetFullBufferTimeoutS>
    if (msg != MSG_OK) {
 80028e2:	b118      	cbz	r0, 80028ec <ibqGetTimeout+0x1c>
 80028e4:	2200      	movs	r2, #0
 80028e6:	f382 8811 	msr	BASEPRI, r2
 80028ea:	bd38      	pop	{r3, r4, r5, pc}
  msg = (msg_t)*ibqp->ptr;
 80028ec:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80028ee:	f813 5b01 	ldrb.w	r5, [r3], #1
  ibqp->ptr++;
 80028f2:	62a3      	str	r3, [r4, #40]	; 0x28
  if (ibqp->ptr >= ibqp->top) {
 80028f4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80028f6:	4293      	cmp	r3, r2
 80028f8:	d302      	bcc.n	8002900 <ibqGetTimeout+0x30>
    ibqReleaseEmptyBufferS(ibqp);
 80028fa:	4620      	mov	r0, r4
 80028fc:	f7ff fe00 	bl	8002500 <ibqReleaseEmptyBufferS>
 8002900:	2300      	movs	r3, #0
 8002902:	f383 8811 	msr	BASEPRI, r3
  return msg;
 8002906:	4628      	mov	r0, r5
}
 8002908:	bd38      	pop	{r3, r4, r5, pc}
 800290a:	bf00      	nop
 800290c:	0000      	movs	r0, r0
	...

08002910 <_gett.lto_priv.157>:
static msg_t _gett(void *ip, sysinterval_t timeout) {
 8002910:	b508      	push	{r3, lr}
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
 8002912:	300c      	adds	r0, #12
 8002914:	f7ff ffdc 	bl	80028d0 <ibqGetTimeout>
}
 8002918:	bd08      	pop	{r3, pc}
 800291a:	bf00      	nop
 800291c:	0000      	movs	r0, r0
	...

08002920 <_get.lto_priv.161>:
static msg_t _get(void *ip) {
 8002920:	b508      	push	{r3, lr}
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
 8002922:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8002926:	300c      	adds	r0, #12
 8002928:	f7ff ffd2 	bl	80028d0 <ibqGetTimeout>
}
 800292c:	bd08      	pop	{r3, pc}
 800292e:	bf00      	nop

08002930 <iqPutI>:
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
 8002930:	b508      	push	{r3, lr}
  if (!iqIsFullI(iqp)) {
 8002932:	6943      	ldr	r3, [r0, #20]
 8002934:	6982      	ldr	r2, [r0, #24]
 8002936:	4293      	cmp	r3, r2
 8002938:	d102      	bne.n	8002940 <iqPutI+0x10>
 800293a:	6882      	ldr	r2, [r0, #8]
 800293c:	b912      	cbnz	r2, 8002944 <iqPutI+0x14>
 800293e:	e002      	b.n	8002946 <iqPutI+0x16>
 8002940:	2200      	movs	r2, #0
 8002942:	e000      	b.n	8002946 <iqPutI+0x16>
 8002944:	2201      	movs	r2, #1
 8002946:	b982      	cbnz	r2, 800296a <iqPutI+0x3a>
    iqp->q_counter++;
 8002948:	6882      	ldr	r2, [r0, #8]
 800294a:	3201      	adds	r2, #1
 800294c:	6082      	str	r2, [r0, #8]
    *iqp->q_wrptr++ = b;
 800294e:	1c5a      	adds	r2, r3, #1
 8002950:	6142      	str	r2, [r0, #20]
 8002952:	7019      	strb	r1, [r3, #0]
    if (iqp->q_wrptr >= iqp->q_top) {
 8002954:	6942      	ldr	r2, [r0, #20]
 8002956:	6903      	ldr	r3, [r0, #16]
 8002958:	429a      	cmp	r2, r3
 800295a:	d301      	bcc.n	8002960 <iqPutI+0x30>
      iqp->q_wrptr = iqp->q_buffer;
 800295c:	68c3      	ldr	r3, [r0, #12]
 800295e:	6143      	str	r3, [r0, #20]
  chThdDequeueNextI(tqp, msg);
 8002960:	2100      	movs	r1, #0
 8002962:	f008 fcdd 	bl	800b320 <chThdDequeueNextI>
    return MSG_OK;
 8002966:	2000      	movs	r0, #0
 8002968:	bd08      	pop	{r3, pc}
  return MSG_TIMEOUT;
 800296a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 800296e:	bd08      	pop	{r3, pc}

08002970 <obqReleaseEmptyBufferI>:
void obqReleaseEmptyBufferI(output_buffers_queue_t *obqp) {
 8002970:	b508      	push	{r3, lr}
  obqp->bcounter++;
 8002972:	68c3      	ldr	r3, [r0, #12]
 8002974:	3301      	adds	r3, #1
 8002976:	60c3      	str	r3, [r0, #12]
  obqp->brdptr += obqp->bsize;
 8002978:	6942      	ldr	r2, [r0, #20]
 800297a:	69c3      	ldr	r3, [r0, #28]
 800297c:	4413      	add	r3, r2
 800297e:	6143      	str	r3, [r0, #20]
  if (obqp->brdptr >= obqp->btop) {
 8002980:	6982      	ldr	r2, [r0, #24]
 8002982:	4293      	cmp	r3, r2
 8002984:	d301      	bcc.n	800298a <obqReleaseEmptyBufferI+0x1a>
    obqp->brdptr = obqp->buffers;
 8002986:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8002988:	6143      	str	r3, [r0, #20]
 800298a:	2100      	movs	r1, #0
 800298c:	f008 fcc8 	bl	800b320 <chThdDequeueNextI>
 8002990:	bd08      	pop	{r3, pc}
 8002992:	bf00      	nop
	...

080029a0 <sduDataTransmitted>:
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 80029a0:	b570      	push	{r4, r5, r6, lr}
 80029a2:	b082      	sub	sp, #8
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 80029a4:	f101 0309 	add.w	r3, r1, #9
 80029a8:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80029ac:	685e      	ldr	r6, [r3, #4]
  if (sdup == NULL) {
 80029ae:	b3ae      	cbz	r6, 8002a1c <sduDataTransmitted+0x7c>
 80029b0:	460d      	mov	r5, r1
 80029b2:	4604      	mov	r4, r0
 80029b4:	2320      	movs	r3, #32
 80029b6:	f383 8811 	msr	BASEPRI, r3
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 80029ba:	2108      	movs	r1, #8
 80029bc:	1d30      	adds	r0, r6, #4
 80029be:	f008 fb87 	bl	800b0d0 <chEvtBroadcastFlagsI>
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 80029c2:	1cab      	adds	r3, r5, #2
 80029c4:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 80029c8:	685b      	ldr	r3, [r3, #4]
 80029ca:	695b      	ldr	r3, [r3, #20]
 80029cc:	681b      	ldr	r3, [r3, #0]
 80029ce:	b11b      	cbz	r3, 80029d8 <sduDataTransmitted+0x38>
    obqReleaseEmptyBufferI(&sdup->obqueue);
 80029d0:	f106 0044 	add.w	r0, r6, #68	; 0x44
 80029d4:	f7ff ffcc 	bl	8002970 <obqReleaseEmptyBufferI>
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 80029d8:	a901      	add	r1, sp, #4
 80029da:	f106 0044 	add.w	r0, r6, #68	; 0x44
 80029de:	f7ff fd57 	bl	8002490 <obqGetFullBufferI>
  if (buf != NULL) {
 80029e2:	4602      	mov	r2, r0
 80029e4:	b128      	cbz	r0, 80029f2 <sduDataTransmitted+0x52>
    usbStartTransmitI(usbp, ep, buf, n);
 80029e6:	9b01      	ldr	r3, [sp, #4]
 80029e8:	4629      	mov	r1, r5
 80029ea:	4620      	mov	r0, r4
 80029ec:	f003 fbb8 	bl	8006160 <usbStartTransmitI>
 80029f0:	e011      	b.n	8002a16 <sduDataTransmitted+0x76>
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 80029f2:	1cab      	adds	r3, r5, #2
 80029f4:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 80029f8:	685a      	ldr	r2, [r3, #4]
 80029fa:	6953      	ldr	r3, [r2, #20]
 80029fc:	681b      	ldr	r3, [r3, #0]
 80029fe:	b153      	cbz	r3, 8002a16 <sduDataTransmitted+0x76>
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
 8002a00:	8a12      	ldrh	r2, [r2, #16]
 8002a02:	3a01      	subs	r2, #1
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 8002a04:	4213      	tst	r3, r2
 8002a06:	d106      	bne.n	8002a16 <sduDataTransmitted+0x76>
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
 8002a08:	2300      	movs	r3, #0
 8002a0a:	f104 0274 	add.w	r2, r4, #116	; 0x74
 8002a0e:	4629      	mov	r1, r5
 8002a10:	4620      	mov	r0, r4
 8002a12:	f003 fba5 	bl	8006160 <usbStartTransmitI>
 8002a16:	2300      	movs	r3, #0
 8002a18:	f383 8811 	msr	BASEPRI, r3
}
 8002a1c:	b002      	add	sp, #8
 8002a1e:	bd70      	pop	{r4, r5, r6, pc}

08002a20 <ibqPostFullBufferI>:
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {
 8002a20:	b508      	push	{r3, lr}
  *((size_t *)ibqp->bwrptr) = size;
 8002a22:	6903      	ldr	r3, [r0, #16]
 8002a24:	6019      	str	r1, [r3, #0]
  ibqp->bcounter++;
 8002a26:	68c3      	ldr	r3, [r0, #12]
 8002a28:	3301      	adds	r3, #1
 8002a2a:	60c3      	str	r3, [r0, #12]
  ibqp->bwrptr += ibqp->bsize;
 8002a2c:	6902      	ldr	r2, [r0, #16]
 8002a2e:	69c3      	ldr	r3, [r0, #28]
 8002a30:	4413      	add	r3, r2
 8002a32:	6103      	str	r3, [r0, #16]
  if (ibqp->bwrptr >= ibqp->btop) {
 8002a34:	6982      	ldr	r2, [r0, #24]
 8002a36:	4293      	cmp	r3, r2
 8002a38:	d301      	bcc.n	8002a3e <ibqPostFullBufferI+0x1e>
    ibqp->bwrptr = ibqp->buffers;
 8002a3a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8002a3c:	6103      	str	r3, [r0, #16]
  chThdDequeueNextI(tqp, msg);
 8002a3e:	2100      	movs	r1, #0
 8002a40:	f008 fc6e 	bl	800b320 <chThdDequeueNextI>
 8002a44:	bd08      	pop	{r3, pc}
 8002a46:	bf00      	nop
	...

08002a50 <sduDataReceived>:
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 8002a50:	b538      	push	{r3, r4, r5, lr}
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 8002a52:	3111      	adds	r1, #17
 8002a54:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
  if (sdup == NULL) {
 8002a58:	b1e4      	cbz	r4, 8002a94 <sduDataReceived+0x44>
 8002a5a:	2320      	movs	r3, #32
 8002a5c:	f383 8811 	msr	BASEPRI, r3
  size = usbGetReceiveTransactionSizeX(sdup->config->usbp,
 8002a60:	f8d4 348c 	ldr.w	r3, [r4, #1164]	; 0x48c
 8002a64:	681a      	ldr	r2, [r3, #0]
 8002a66:	795b      	ldrb	r3, [r3, #5]
 8002a68:	3302      	adds	r3, #2
 8002a6a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8002a6e:	685b      	ldr	r3, [r3, #4]
 8002a70:	699b      	ldr	r3, [r3, #24]
 8002a72:	685d      	ldr	r5, [r3, #4]
  if (size > (size_t)0) {
 8002a74:	b145      	cbz	r5, 8002a88 <sduDataReceived+0x38>
  chEvtBroadcastFlagsI(esp, flags);
 8002a76:	2104      	movs	r1, #4
 8002a78:	1860      	adds	r0, r4, r1
 8002a7a:	f008 fb29 	bl	800b0d0 <chEvtBroadcastFlagsI>
    ibqPostFullBufferI(&sdup->ibqueue, size);
 8002a7e:	4629      	mov	r1, r5
 8002a80:	f104 000c 	add.w	r0, r4, #12
 8002a84:	f7ff ffcc 	bl	8002a20 <ibqPostFullBufferI>
  (void) sdu_start_receive(sdup);
 8002a88:	4620      	mov	r0, r4
 8002a8a:	f7ff fde1 	bl	8002650 <sdu_start_receive>
 8002a8e:	2300      	movs	r3, #0
 8002a90:	f383 8811 	msr	BASEPRI, r3
 8002a94:	bd38      	pop	{r3, r4, r5, pc}
 8002a96:	bf00      	nop
	...

08002aa0 <oq_write>:
static size_t oq_write(output_queue_t *oqp, const uint8_t *bp, size_t n) {
 8002aa0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002aa4:	4604      	mov	r4, r0
 8002aa6:	460f      	mov	r7, r1
 8002aa8:	4615      	mov	r5, r2
  if (n > oqGetEmptyI(oqp)) {
 8002aaa:	6883      	ldr	r3, [r0, #8]
 8002aac:	4293      	cmp	r3, r2
 8002aae:	d200      	bcs.n	8002ab2 <oq_write+0x12>
    n = oqGetEmptyI(oqp);
 8002ab0:	6885      	ldr	r5, [r0, #8]
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8002ab2:	6926      	ldr	r6, [r4, #16]
 8002ab4:	6960      	ldr	r0, [r4, #20]
 8002ab6:	1a36      	subs	r6, r6, r0
  if (n < s1) {
 8002ab8:	42b5      	cmp	r5, r6
 8002aba:	d207      	bcs.n	8002acc <oq_write+0x2c>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8002abc:	462a      	mov	r2, r5
 8002abe:	4639      	mov	r1, r7
 8002ac0:	f7fe fe86 	bl	80017d0 <memcpy>
    oqp->q_wrptr += n;
 8002ac4:	6963      	ldr	r3, [r4, #20]
 8002ac6:	442b      	add	r3, r5
 8002ac8:	6163      	str	r3, [r4, #20]
 8002aca:	e016      	b.n	8002afa <oq_write+0x5a>
  else if (n > s1) {
 8002acc:	42b5      	cmp	r5, r6
 8002ace:	d90e      	bls.n	8002aee <oq_write+0x4e>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8002ad0:	4632      	mov	r2, r6
 8002ad2:	4639      	mov	r1, r7
 8002ad4:	f7fe fe7c 	bl	80017d0 <memcpy>
    s2 = n - s1;
 8002ad8:	ebc6 0805 	rsb	r8, r6, r5
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 8002adc:	4642      	mov	r2, r8
 8002ade:	19b9      	adds	r1, r7, r6
 8002ae0:	68e0      	ldr	r0, [r4, #12]
 8002ae2:	f7fe fe75 	bl	80017d0 <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
 8002ae6:	68e3      	ldr	r3, [r4, #12]
 8002ae8:	4443      	add	r3, r8
 8002aea:	6163      	str	r3, [r4, #20]
 8002aec:	e005      	b.n	8002afa <oq_write+0x5a>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8002aee:	462a      	mov	r2, r5
 8002af0:	4639      	mov	r1, r7
 8002af2:	f7fe fe6d 	bl	80017d0 <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 8002af6:	68e3      	ldr	r3, [r4, #12]
 8002af8:	6163      	str	r3, [r4, #20]
  oqp->q_counter -= n;
 8002afa:	68a3      	ldr	r3, [r4, #8]
 8002afc:	1b5b      	subs	r3, r3, r5
 8002afe:	60a3      	str	r3, [r4, #8]
}
 8002b00:	4628      	mov	r0, r5
 8002b02:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002b06:	bf00      	nop
	...

08002b10 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 8002b10:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002b14:	4607      	mov	r7, r0
 8002b16:	460d      	mov	r5, r1
 8002b18:	4692      	mov	sl, r2
 8002b1a:	4699      	mov	r9, r3
  qnotify_t nfy = oqp->q_notify;
 8002b1c:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8002b20:	2320      	movs	r3, #32
 8002b22:	f383 8811 	msr	BASEPRI, r3
 8002b26:	4614      	mov	r4, r2
 8002b28:	e019      	b.n	8002b5e <oqWriteTimeout+0x4e>
  osalSysLock();

  while (n > 0U) {
    size_t done;

    done = oq_write(oqp, bp, n);
 8002b2a:	4622      	mov	r2, r4
 8002b2c:	4629      	mov	r1, r5
 8002b2e:	4638      	mov	r0, r7
 8002b30:	f7ff ffb6 	bl	8002aa0 <oq_write>
    if (done == (size_t)0) {
 8002b34:	4606      	mov	r6, r0
 8002b36:	b928      	cbnz	r0, 8002b44 <oqWriteTimeout+0x34>
  return chThdEnqueueTimeoutS(tqp, timeout);
 8002b38:	4649      	mov	r1, r9
 8002b3a:	4638      	mov	r0, r7
 8002b3c:	f009 f848 	bl	800bbd0 <chThdEnqueueTimeoutS>
      msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8002b40:	b168      	cbz	r0, 8002b5e <oqWriteTimeout+0x4e>
 8002b42:	e00e      	b.n	8002b62 <oqWriteTimeout+0x52>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
 8002b44:	f1b8 0f00 	cmp.w	r8, #0
 8002b48:	d001      	beq.n	8002b4e <oqWriteTimeout+0x3e>
        nfy(oqp);
 8002b4a:	4638      	mov	r0, r7
 8002b4c:	47c0      	blx	r8
 8002b4e:	2300      	movs	r3, #0
 8002b50:	f383 8811 	msr	BASEPRI, r3
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
 8002b54:	1ba4      	subs	r4, r4, r6
      bp += done;
 8002b56:	4435      	add	r5, r6
 8002b58:	2320      	movs	r3, #32
 8002b5a:	f383 8811 	msr	BASEPRI, r3
  while (n > 0U) {
 8002b5e:	2c00      	cmp	r4, #0
 8002b60:	d1e3      	bne.n	8002b2a <oqWriteTimeout+0x1a>
 8002b62:	2300      	movs	r3, #0
 8002b64:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return max - n;
}
 8002b68:	ebc4 000a 	rsb	r0, r4, sl
 8002b6c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08002b70 <_writet.lto_priv.154>:
                      sysinterval_t timeout) {
 8002b70:	b508      	push	{r3, lr}
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8002b72:	3030      	adds	r0, #48	; 0x30
 8002b74:	f7ff ffcc 	bl	8002b10 <oqWriteTimeout>
}
 8002b78:	bd08      	pop	{r3, pc}
 8002b7a:	bf00      	nop
 8002b7c:	0000      	movs	r0, r0
	...

08002b80 <_write.lto_priv.166>:
static size_t _write(void *ip, const uint8_t *bp, size_t n) {
 8002b80:	b508      	push	{r3, lr}
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8002b82:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8002b86:	3030      	adds	r0, #48	; 0x30
 8002b88:	f7ff ffc2 	bl	8002b10 <oqWriteTimeout>
}
 8002b8c:	bd08      	pop	{r3, pc}
 8002b8e:	bf00      	nop

08002b90 <iq_read>:
static size_t iq_read(input_queue_t *iqp, uint8_t *bp, size_t n) {
 8002b90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002b94:	4604      	mov	r4, r0
 8002b96:	460f      	mov	r7, r1
 8002b98:	4615      	mov	r5, r2
  if (n > iqGetFullI(iqp)) {
 8002b9a:	6883      	ldr	r3, [r0, #8]
 8002b9c:	4293      	cmp	r3, r2
 8002b9e:	d200      	bcs.n	8002ba2 <iq_read+0x12>
    n = iqGetFullI(iqp);
 8002ba0:	6885      	ldr	r5, [r0, #8]
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8002ba2:	6926      	ldr	r6, [r4, #16]
 8002ba4:	69a1      	ldr	r1, [r4, #24]
 8002ba6:	1a76      	subs	r6, r6, r1
  if (n < s1) {
 8002ba8:	42b5      	cmp	r5, r6
 8002baa:	d207      	bcs.n	8002bbc <iq_read+0x2c>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8002bac:	462a      	mov	r2, r5
 8002bae:	4638      	mov	r0, r7
 8002bb0:	f7fe fe0e 	bl	80017d0 <memcpy>
    iqp->q_rdptr += n;
 8002bb4:	69a3      	ldr	r3, [r4, #24]
 8002bb6:	442b      	add	r3, r5
 8002bb8:	61a3      	str	r3, [r4, #24]
 8002bba:	e016      	b.n	8002bea <iq_read+0x5a>
  else if (n > s1) {
 8002bbc:	42b5      	cmp	r5, r6
 8002bbe:	d90e      	bls.n	8002bde <iq_read+0x4e>
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8002bc0:	4632      	mov	r2, r6
 8002bc2:	4638      	mov	r0, r7
 8002bc4:	f7fe fe04 	bl	80017d0 <memcpy>
    s2 = n - s1;
 8002bc8:	ebc6 0805 	rsb	r8, r6, r5
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 8002bcc:	4642      	mov	r2, r8
 8002bce:	68e1      	ldr	r1, [r4, #12]
 8002bd0:	19b8      	adds	r0, r7, r6
 8002bd2:	f7fe fdfd 	bl	80017d0 <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
 8002bd6:	68e3      	ldr	r3, [r4, #12]
 8002bd8:	4443      	add	r3, r8
 8002bda:	61a3      	str	r3, [r4, #24]
 8002bdc:	e005      	b.n	8002bea <iq_read+0x5a>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8002bde:	462a      	mov	r2, r5
 8002be0:	4638      	mov	r0, r7
 8002be2:	f7fe fdf5 	bl	80017d0 <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 8002be6:	68e3      	ldr	r3, [r4, #12]
 8002be8:	61a3      	str	r3, [r4, #24]
  iqp->q_counter -= n;
 8002bea:	68a3      	ldr	r3, [r4, #8]
 8002bec:	1b5b      	subs	r3, r3, r5
 8002bee:	60a3      	str	r3, [r4, #8]
}
 8002bf0:	4628      	mov	r0, r5
 8002bf2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002bf6:	bf00      	nop
	...

08002c00 <iqReadTimeout>:
                     size_t n, sysinterval_t timeout) {
 8002c00:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002c04:	4607      	mov	r7, r0
 8002c06:	460d      	mov	r5, r1
 8002c08:	4692      	mov	sl, r2
 8002c0a:	4699      	mov	r9, r3
  qnotify_t nfy = iqp->q_notify;
 8002c0c:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8002c10:	2320      	movs	r3, #32
 8002c12:	f383 8811 	msr	BASEPRI, r3
 8002c16:	4614      	mov	r4, r2
 8002c18:	e019      	b.n	8002c4e <iqReadTimeout+0x4e>
    done = iq_read(iqp, bp, n);
 8002c1a:	4622      	mov	r2, r4
 8002c1c:	4629      	mov	r1, r5
 8002c1e:	4638      	mov	r0, r7
 8002c20:	f7ff ffb6 	bl	8002b90 <iq_read>
    if (done == (size_t)0) {
 8002c24:	4606      	mov	r6, r0
 8002c26:	b928      	cbnz	r0, 8002c34 <iqReadTimeout+0x34>
 8002c28:	4649      	mov	r1, r9
 8002c2a:	4638      	mov	r0, r7
 8002c2c:	f008 ffd0 	bl	800bbd0 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 8002c30:	b168      	cbz	r0, 8002c4e <iqReadTimeout+0x4e>
 8002c32:	e00e      	b.n	8002c52 <iqReadTimeout+0x52>
      if (nfy != NULL) {
 8002c34:	f1b8 0f00 	cmp.w	r8, #0
 8002c38:	d001      	beq.n	8002c3e <iqReadTimeout+0x3e>
        nfy(iqp);
 8002c3a:	4638      	mov	r0, r7
 8002c3c:	47c0      	blx	r8
 8002c3e:	2300      	movs	r3, #0
 8002c40:	f383 8811 	msr	BASEPRI, r3
      n  -= done;
 8002c44:	1ba4      	subs	r4, r4, r6
      bp += done;
 8002c46:	4435      	add	r5, r6
 8002c48:	2320      	movs	r3, #32
 8002c4a:	f383 8811 	msr	BASEPRI, r3
  while (n > 0U) {
 8002c4e:	2c00      	cmp	r4, #0
 8002c50:	d1e3      	bne.n	8002c1a <iqReadTimeout+0x1a>
 8002c52:	2300      	movs	r3, #0
 8002c54:	f383 8811 	msr	BASEPRI, r3
}
 8002c58:	ebc4 000a 	rsb	r0, r4, sl
 8002c5c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08002c60 <_readt.lto_priv.152>:
                     sysinterval_t timeout) {
 8002c60:	b508      	push	{r3, lr}
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8002c62:	300c      	adds	r0, #12
 8002c64:	f7ff ffcc 	bl	8002c00 <iqReadTimeout>
}
 8002c68:	bd08      	pop	{r3, pc}
 8002c6a:	bf00      	nop
 8002c6c:	0000      	movs	r0, r0
	...

08002c70 <_read.lto_priv.164>:
static size_t _read(void *ip, uint8_t *bp, size_t n) {
 8002c70:	b508      	push	{r3, lr}
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8002c72:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8002c76:	300c      	adds	r0, #12
 8002c78:	f7ff ffc2 	bl	8002c00 <iqReadTimeout>
}
 8002c7c:	bd08      	pop	{r3, pc}
 8002c7e:	bf00      	nop

08002c80 <obqWriteTimeout>:
                       size_t n, sysinterval_t timeout) {
 8002c80:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002c84:	4604      	mov	r4, r0
 8002c86:	460f      	mov	r7, r1
 8002c88:	4690      	mov	r8, r2
 8002c8a:	4699      	mov	r9, r3
 8002c8c:	2320      	movs	r3, #32
 8002c8e:	f383 8811 	msr	BASEPRI, r3
  size_t w = 0;
 8002c92:	2600      	movs	r6, #0
    if (obqp->ptr == NULL) {
 8002c94:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002c96:	b943      	cbnz	r3, 8002caa <obqWriteTimeout+0x2a>
      msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 8002c98:	4649      	mov	r1, r9
 8002c9a:	4620      	mov	r0, r4
 8002c9c:	f7ff fda0 	bl	80027e0 <obqGetEmptyBufferTimeoutS>
      if (msg != MSG_OK) {
 8002ca0:	b118      	cbz	r0, 8002caa <obqWriteTimeout+0x2a>
 8002ca2:	2300      	movs	r3, #0
 8002ca4:	f383 8811 	msr	BASEPRI, r3
 8002ca8:	e03d      	b.n	8002d26 <obqWriteTimeout+0xa6>
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 8002caa:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002cac:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8002cae:	1a1b      	subs	r3, r3, r0
    if (size > (n - w)) {
 8002cb0:	ebc6 0508 	rsb	r5, r6, r8
 8002cb4:	42ab      	cmp	r3, r5
 8002cb6:	d800      	bhi.n	8002cba <obqWriteTimeout+0x3a>
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 8002cb8:	461d      	mov	r5, r3
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
 8002cba:	2d40      	cmp	r5, #64	; 0x40
 8002cbc:	d918      	bls.n	8002cf0 <obqWriteTimeout+0x70>
      memcpy(obqp->ptr, bp, (size_t)BUFFERS_CHUNKS_SIZE);
 8002cbe:	463b      	mov	r3, r7
 8002cc0:	f107 0240 	add.w	r2, r7, #64	; 0x40
 8002cc4:	f8d3 c000 	ldr.w	ip, [r3]
 8002cc8:	f8d3 e004 	ldr.w	lr, [r3, #4]
 8002ccc:	689d      	ldr	r5, [r3, #8]
 8002cce:	68d9      	ldr	r1, [r3, #12]
 8002cd0:	f8c0 c000 	str.w	ip, [r0]
 8002cd4:	f8c0 e004 	str.w	lr, [r0, #4]
 8002cd8:	6085      	str	r5, [r0, #8]
 8002cda:	60c1      	str	r1, [r0, #12]
 8002cdc:	3310      	adds	r3, #16
 8002cde:	3010      	adds	r0, #16
 8002ce0:	4293      	cmp	r3, r2
 8002ce2:	d1ef      	bne.n	8002cc4 <obqWriteTimeout+0x44>
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
 8002ce4:	3740      	adds	r7, #64	; 0x40
      obqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 8002ce6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002ce8:	3340      	adds	r3, #64	; 0x40
 8002cea:	62a3      	str	r3, [r4, #40]	; 0x28
      w         += (size_t)BUFFERS_CHUNKS_SIZE;
 8002cec:	3640      	adds	r6, #64	; 0x40
 8002cee:	e008      	b.n	8002d02 <obqWriteTimeout+0x82>
      memcpy(obqp->ptr, bp, size);
 8002cf0:	462a      	mov	r2, r5
 8002cf2:	4639      	mov	r1, r7
 8002cf4:	f7fe fd6c 	bl	80017d0 <memcpy>
      bp        += size;
 8002cf8:	442f      	add	r7, r5
      obqp->ptr += size;
 8002cfa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002cfc:	442b      	add	r3, r5
 8002cfe:	62a3      	str	r3, [r4, #40]	; 0x28
      w         += size;
 8002d00:	442e      	add	r6, r5
    if (obqp->ptr >= obqp->top) {
 8002d02:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8002d04:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002d06:	429a      	cmp	r2, r3
 8002d08:	d304      	bcc.n	8002d14 <obqWriteTimeout+0x94>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8002d0a:	69e1      	ldr	r1, [r4, #28]
 8002d0c:	3904      	subs	r1, #4
 8002d0e:	4620      	mov	r0, r4
 8002d10:	f7ff fba6 	bl	8002460 <obqPostFullBufferS>
 8002d14:	2300      	movs	r3, #0
 8002d16:	f383 8811 	msr	BASEPRI, r3
    if (w >= n) {
 8002d1a:	4546      	cmp	r6, r8
 8002d1c:	d203      	bcs.n	8002d26 <obqWriteTimeout+0xa6>
 8002d1e:	2320      	movs	r3, #32
 8002d20:	f383 8811 	msr	BASEPRI, r3
 8002d24:	e7b6      	b.n	8002c94 <obqWriteTimeout+0x14>
}
 8002d26:	4630      	mov	r0, r6
 8002d28:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8002d2c:	0000      	movs	r0, r0
	...

08002d30 <_writet.lto_priv.155>:
                      sysinterval_t timeout) {
 8002d30:	b508      	push	{r3, lr}
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
 8002d32:	3044      	adds	r0, #68	; 0x44
 8002d34:	f7ff ffa4 	bl	8002c80 <obqWriteTimeout>
}
 8002d38:	bd08      	pop	{r3, pc}
 8002d3a:	bf00      	nop
 8002d3c:	0000      	movs	r0, r0
	...

08002d40 <_write.lto_priv.167>:
static size_t _write(void *ip, const uint8_t *bp, size_t n) {
 8002d40:	b508      	push	{r3, lr}
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp,
 8002d42:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8002d46:	3044      	adds	r0, #68	; 0x44
 8002d48:	f7ff ff9a 	bl	8002c80 <obqWriteTimeout>
}
 8002d4c:	bd08      	pop	{r3, pc}
 8002d4e:	bf00      	nop

08002d50 <ibqReadTimeout>:
                      size_t n, sysinterval_t timeout) {
 8002d50:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002d54:	4604      	mov	r4, r0
 8002d56:	460f      	mov	r7, r1
 8002d58:	4690      	mov	r8, r2
 8002d5a:	4699      	mov	r9, r3
 8002d5c:	2320      	movs	r3, #32
 8002d5e:	f383 8811 	msr	BASEPRI, r3
  size_t r = 0;
 8002d62:	2600      	movs	r6, #0
    if (ibqp->ptr == NULL) {
 8002d64:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002d66:	b943      	cbnz	r3, 8002d7a <ibqReadTimeout+0x2a>
      msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8002d68:	4649      	mov	r1, r9
 8002d6a:	4620      	mov	r0, r4
 8002d6c:	f7ff fd90 	bl	8002890 <ibqGetFullBufferTimeoutS>
      if (msg != MSG_OK) {
 8002d70:	b118      	cbz	r0, 8002d7a <ibqReadTimeout+0x2a>
 8002d72:	2300      	movs	r3, #0
 8002d74:	f383 8811 	msr	BASEPRI, r3
 8002d78:	e03b      	b.n	8002df2 <ibqReadTimeout+0xa2>
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8002d7a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002d7c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8002d7e:	1a5b      	subs	r3, r3, r1
    if (size > (n - r)) {
 8002d80:	ebc6 0508 	rsb	r5, r6, r8
 8002d84:	42ab      	cmp	r3, r5
 8002d86:	d800      	bhi.n	8002d8a <ibqReadTimeout+0x3a>
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8002d88:	461d      	mov	r5, r3
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
 8002d8a:	2d40      	cmp	r5, #64	; 0x40
 8002d8c:	d918      	bls.n	8002dc0 <ibqReadTimeout+0x70>
      memcpy(bp, ibqp->ptr, BUFFERS_CHUNKS_SIZE);
 8002d8e:	460b      	mov	r3, r1
 8002d90:	463a      	mov	r2, r7
 8002d92:	3140      	adds	r1, #64	; 0x40
 8002d94:	f8d3 c000 	ldr.w	ip, [r3]
 8002d98:	f8d3 e004 	ldr.w	lr, [r3, #4]
 8002d9c:	689d      	ldr	r5, [r3, #8]
 8002d9e:	68d8      	ldr	r0, [r3, #12]
 8002da0:	f8c2 c000 	str.w	ip, [r2]
 8002da4:	f8c2 e004 	str.w	lr, [r2, #4]
 8002da8:	6095      	str	r5, [r2, #8]
 8002daa:	60d0      	str	r0, [r2, #12]
 8002dac:	3310      	adds	r3, #16
 8002dae:	3210      	adds	r2, #16
 8002db0:	428b      	cmp	r3, r1
 8002db2:	d1ef      	bne.n	8002d94 <ibqReadTimeout+0x44>
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
 8002db4:	3740      	adds	r7, #64	; 0x40
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 8002db6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002db8:	3340      	adds	r3, #64	; 0x40
 8002dba:	62a3      	str	r3, [r4, #40]	; 0x28
      r         += (size_t)BUFFERS_CHUNKS_SIZE;
 8002dbc:	3640      	adds	r6, #64	; 0x40
 8002dbe:	e008      	b.n	8002dd2 <ibqReadTimeout+0x82>
      memcpy(bp, ibqp->ptr, size);
 8002dc0:	462a      	mov	r2, r5
 8002dc2:	4638      	mov	r0, r7
 8002dc4:	f7fe fd04 	bl	80017d0 <memcpy>
      bp        += size;
 8002dc8:	442f      	add	r7, r5
      ibqp->ptr += size;
 8002dca:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002dcc:	442b      	add	r3, r5
 8002dce:	62a3      	str	r3, [r4, #40]	; 0x28
      r         += size;
 8002dd0:	442e      	add	r6, r5
    if (ibqp->ptr >= ibqp->top) {
 8002dd2:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8002dd4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002dd6:	429a      	cmp	r2, r3
 8002dd8:	d302      	bcc.n	8002de0 <ibqReadTimeout+0x90>
      ibqReleaseEmptyBufferS(ibqp);
 8002dda:	4620      	mov	r0, r4
 8002ddc:	f7ff fb90 	bl	8002500 <ibqReleaseEmptyBufferS>
 8002de0:	2300      	movs	r3, #0
 8002de2:	f383 8811 	msr	BASEPRI, r3
    if (r >= n) {
 8002de6:	4546      	cmp	r6, r8
 8002de8:	d203      	bcs.n	8002df2 <ibqReadTimeout+0xa2>
 8002dea:	2320      	movs	r3, #32
 8002dec:	f383 8811 	msr	BASEPRI, r3
 8002df0:	e7b8      	b.n	8002d64 <ibqReadTimeout+0x14>
}
 8002df2:	4630      	mov	r0, r6
 8002df4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	...

08002e00 <_readt.lto_priv.153>:
                     sysinterval_t timeout) {
 8002e00:	b508      	push	{r3, lr}
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, timeout);
 8002e02:	300c      	adds	r0, #12
 8002e04:	f7ff ffa4 	bl	8002d50 <ibqReadTimeout>
}
 8002e08:	bd08      	pop	{r3, pc}
 8002e0a:	bf00      	nop
 8002e0c:	0000      	movs	r0, r0
	...

08002e10 <_read.lto_priv.165>:
static size_t _read(void *ip, uint8_t *bp, size_t n) {
 8002e10:	b508      	push	{r3, lr}
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp,
 8002e12:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8002e16:	300c      	adds	r0, #12
 8002e18:	f7ff ff9a 	bl	8002d50 <ibqReadTimeout>
}
 8002e1c:	bd08      	pop	{r3, pc}
 8002e1e:	bf00      	nop

08002e20 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8002e20:	b508      	push	{r3, lr}

  st_lld_init();
 8002e22:	f004 f88d 	bl	8006f40 <st_lld_init>
 8002e26:	bd08      	pop	{r3, pc}
	...

08002e30 <usbStart>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] config    pointer to the @p USBConfig object
 *
 * @api
 */
void usbStart(USBDriver *usbp, const USBConfig *config) {
 8002e30:	b510      	push	{r4, lr}
 8002e32:	4604      	mov	r4, r0
 8002e34:	2320      	movs	r3, #32
 8002e36:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck((usbp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
 8002e3a:	6041      	str	r1, [r0, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8002e3c:	2300      	movs	r3, #0
 8002e3e:	e005      	b.n	8002e4c <usbStart+0x1c>
    usbp->epc[i] = NULL;
 8002e40:	1c9a      	adds	r2, r3, #2
 8002e42:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 8002e46:	2100      	movs	r1, #0
 8002e48:	6051      	str	r1, [r2, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8002e4a:	3301      	adds	r3, #1
 8002e4c:	2b07      	cmp	r3, #7
 8002e4e:	d9f7      	bls.n	8002e40 <usbStart+0x10>
  }
  usb_lld_start(usbp);
 8002e50:	4620      	mov	r0, r4
 8002e52:	f003 f895 	bl	8005f80 <usb_lld_start>
  usbp->state = USB_READY;
 8002e56:	2302      	movs	r3, #2
 8002e58:	7023      	strb	r3, [r4, #0]
 8002e5a:	2300      	movs	r3, #0
 8002e5c:	f383 8811 	msr	BASEPRI, r3
 8002e60:	bd10      	pop	{r4, pc}
 8002e62:	bf00      	nop
	...

08002e70 <usbObjectInit>:
  usbp->state        = USB_STOP;
 8002e70:	2301      	movs	r3, #1
 8002e72:	7003      	strb	r3, [r0, #0]
  usbp->config       = NULL;
 8002e74:	2300      	movs	r3, #0
 8002e76:	6043      	str	r3, [r0, #4]
 8002e78:	e00a      	b.n	8002e90 <usbObjectInit+0x20>
    usbp->in_params[i]  = NULL;
 8002e7a:	f103 020a 	add.w	r2, r3, #10
 8002e7e:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8002e82:	2100      	movs	r1, #0
 8002e84:	6051      	str	r1, [r2, #4]
    usbp->out_params[i] = NULL;
 8002e86:	f103 0212 	add.w	r2, r3, #18
 8002e8a:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8002e8e:	3301      	adds	r3, #1
 8002e90:	2b06      	cmp	r3, #6
 8002e92:	d9f2      	bls.n	8002e7a <usbObjectInit+0xa>
  usbp->transmitting = 0;
 8002e94:	2300      	movs	r3, #0
 8002e96:	8103      	strh	r3, [r0, #8]
  usbp->receiving    = 0;
 8002e98:	8143      	strh	r3, [r0, #10]
 8002e9a:	4770      	bx	lr
 8002e9c:	0000      	movs	r0, r0
	...

08002ea0 <get_hword.lto_priv.146>:
  hw  = (uint16_t)*p++;
 8002ea0:	7803      	ldrb	r3, [r0, #0]
  hw |= (uint16_t)*p << 8U;
 8002ea2:	7840      	ldrb	r0, [r0, #1]
}
 8002ea4:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8002ea8:	4770      	bx	lr
 8002eaa:	bf00      	nop
 8002eac:	0000      	movs	r0, r0
	...

08002eb0 <default_handler.lto_priv.147>:
static bool default_handler(USBDriver *usbp) {
 8002eb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002eb2:	4604      	mov	r4, r0
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8002eb4:	f890 3074 	ldrb.w	r3, [r0, #116]	; 0x74
 8002eb8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
           ((uint32_t)usbp->setup[1] << 8U))) {
 8002ebc:	f890 2075 	ldrb.w	r2, [r0, #117]	; 0x75
                                        USB_RTYPE_TYPE_MASK)) |
 8002ec0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8002ec4:	f240 3202 	movw	r2, #770	; 0x302
 8002ec8:	4293      	cmp	r3, r2
 8002eca:	f000 8104 	beq.w	80030d6 <default_handler.lto_priv.147+0x226>
 8002ece:	d814      	bhi.n	8002efa <default_handler.lto_priv.147+0x4a>
 8002ed0:	2b02      	cmp	r3, #2
 8002ed2:	f000 80b2 	beq.w	800303a <default_handler.lto_priv.147+0x18a>
 8002ed6:	d804      	bhi.n	8002ee2 <default_handler.lto_priv.147+0x32>
 8002ed8:	b333      	cbz	r3, 8002f28 <default_handler.lto_priv.147+0x78>
 8002eda:	2b01      	cmp	r3, #1
 8002edc:	f000 80a5 	beq.w	800302a <default_handler.lto_priv.147+0x17a>
 8002ee0:	e10f      	b.n	8003102 <default_handler.lto_priv.147+0x252>
 8002ee2:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
 8002ee6:	f000 80df 	beq.w	80030a8 <default_handler.lto_priv.147+0x1f8>
 8002eea:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8002eee:	d035      	beq.n	8002f5c <default_handler.lto_priv.147+0xac>
 8002ef0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8002ef4:	f040 8105 	bne.w	8003102 <default_handler.lto_priv.147+0x252>
 8002ef8:	e01f      	b.n	8002f3a <default_handler.lto_priv.147+0x8a>
 8002efa:	f240 6201 	movw	r2, #1537	; 0x601
 8002efe:	4293      	cmp	r3, r2
 8002f00:	d806      	bhi.n	8002f10 <default_handler.lto_priv.147+0x60>
 8002f02:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 8002f06:	d247      	bcs.n	8002f98 <default_handler.lto_priv.147+0xe8>
 8002f08:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8002f0c:	d037      	beq.n	8002f7e <default_handler.lto_priv.147+0xce>
 8002f0e:	e0f8      	b.n	8003102 <default_handler.lto_priv.147+0x252>
 8002f10:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
 8002f14:	d061      	beq.n	8002fda <default_handler.lto_priv.147+0x12a>
 8002f16:	f640 4202 	movw	r2, #3074	; 0xc02
 8002f1a:	4293      	cmp	r3, r2
 8002f1c:	f000 8085 	beq.w	800302a <default_handler.lto_priv.147+0x17a>
 8002f20:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8002f24:	d051      	beq.n	8002fca <default_handler.lto_priv.147+0x11a>
 8002f26:	e0ec      	b.n	8003102 <default_handler.lto_priv.147+0x252>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8002f28:	f100 037c 	add.w	r3, r0, #124	; 0x7c
 8002f2c:	6683      	str	r3, [r0, #104]	; 0x68
 8002f2e:	2302      	movs	r3, #2
 8002f30:	66c3      	str	r3, [r0, #108]	; 0x6c
 8002f32:	2300      	movs	r3, #0
 8002f34:	6703      	str	r3, [r0, #112]	; 0x70
    return true;
 8002f36:	2001      	movs	r0, #1
 8002f38:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8002f3a:	f890 3076 	ldrb.w	r3, [r0, #118]	; 0x76
 8002f3e:	2b01      	cmp	r3, #1
 8002f40:	f040 80e1 	bne.w	8003106 <default_handler.lto_priv.147+0x256>
      usbp->status &= ~2U;
 8002f44:	f8b0 307c 	ldrh.w	r3, [r0, #124]	; 0x7c
 8002f48:	f023 0302 	bic.w	r3, r3, #2
 8002f4c:	f8a0 307c 	strh.w	r3, [r0, #124]	; 0x7c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8002f50:	2300      	movs	r3, #0
 8002f52:	6683      	str	r3, [r0, #104]	; 0x68
 8002f54:	66c3      	str	r3, [r0, #108]	; 0x6c
 8002f56:	6703      	str	r3, [r0, #112]	; 0x70
      return true;
 8002f58:	2001      	movs	r0, #1
 8002f5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8002f5c:	f890 3076 	ldrb.w	r3, [r0, #118]	; 0x76
 8002f60:	2b01      	cmp	r3, #1
 8002f62:	f040 80d2 	bne.w	800310a <default_handler.lto_priv.147+0x25a>
      usbp->status |= 2U;
 8002f66:	f8b0 307c 	ldrh.w	r3, [r0, #124]	; 0x7c
 8002f6a:	f043 0302 	orr.w	r3, r3, #2
 8002f6e:	f8a0 307c 	strh.w	r3, [r0, #124]	; 0x7c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8002f72:	2300      	movs	r3, #0
 8002f74:	6683      	str	r3, [r0, #104]	; 0x68
 8002f76:	66c3      	str	r3, [r0, #108]	; 0x6c
 8002f78:	6703      	str	r3, [r0, #112]	; 0x70
      return true;
 8002f7a:	2001      	movs	r0, #1
 8002f7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 8002f7e:	f8b0 3074 	ldrh.w	r3, [r0, #116]	; 0x74
 8002f82:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8002f86:	d101      	bne.n	8002f8c <default_handler.lto_priv.147+0xdc>
      set_address(usbp);
 8002f88:	f7ff fb02 	bl	8002590 <set_address>
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8002f8c:	2300      	movs	r3, #0
 8002f8e:	66a3      	str	r3, [r4, #104]	; 0x68
 8002f90:	66e3      	str	r3, [r4, #108]	; 0x6c
 8002f92:	6723      	str	r3, [r4, #112]	; 0x70
    return true;
 8002f94:	2001      	movs	r0, #1
 8002f96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 8002f98:	6843      	ldr	r3, [r0, #4]
 8002f9a:	685d      	ldr	r5, [r3, #4]
 8002f9c:	f890 6077 	ldrb.w	r6, [r0, #119]	; 0x77
 8002fa0:	f890 7076 	ldrb.w	r7, [r0, #118]	; 0x76
 8002fa4:	3078      	adds	r0, #120	; 0x78
 8002fa6:	f7ff ff7b 	bl	8002ea0 <get_hword.lto_priv.146>
 8002faa:	4603      	mov	r3, r0
 8002fac:	463a      	mov	r2, r7
 8002fae:	4631      	mov	r1, r6
 8002fb0:	4620      	mov	r0, r4
 8002fb2:	47a8      	blx	r5
    if (dp == NULL) {
 8002fb4:	2800      	cmp	r0, #0
 8002fb6:	f000 80aa 	beq.w	800310e <default_handler.lto_priv.147+0x25e>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 8002fba:	6842      	ldr	r2, [r0, #4]
 8002fbc:	66a2      	str	r2, [r4, #104]	; 0x68
 8002fbe:	6803      	ldr	r3, [r0, #0]
 8002fc0:	66e3      	str	r3, [r4, #108]	; 0x6c
 8002fc2:	2300      	movs	r3, #0
 8002fc4:	6723      	str	r3, [r4, #112]	; 0x70
    return true;
 8002fc6:	2001      	movs	r0, #1
 8002fc8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8002fca:	f100 037f 	add.w	r3, r0, #127	; 0x7f
 8002fce:	6683      	str	r3, [r0, #104]	; 0x68
 8002fd0:	2001      	movs	r0, #1
 8002fd2:	66e0      	str	r0, [r4, #108]	; 0x6c
 8002fd4:	2300      	movs	r3, #0
 8002fd6:	6723      	str	r3, [r4, #112]	; 0x70
 8002fd8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (usbp->state == USB_ACTIVE) {
 8002fda:	7803      	ldrb	r3, [r0, #0]
 8002fdc:	2b04      	cmp	r3, #4
 8002fde:	d111      	bne.n	8003004 <default_handler.lto_priv.147+0x154>
 8002fe0:	2320      	movs	r3, #32
 8002fe2:	f383 8811 	msr	BASEPRI, r3
        usbDisableEndpointsI(usbp);
 8002fe6:	f003 fa03 	bl	80063f0 <usbDisableEndpointsI>
 8002fea:	2300      	movs	r3, #0
 8002fec:	f383 8811 	msr	BASEPRI, r3
        usbp->configuration = 0U;
 8002ff0:	f884 307f 	strb.w	r3, [r4, #127]	; 0x7f
        usbp->state = USB_SELECTED;
 8002ff4:	2303      	movs	r3, #3
 8002ff6:	7023      	strb	r3, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8002ff8:	6863      	ldr	r3, [r4, #4]
 8002ffa:	681b      	ldr	r3, [r3, #0]
 8002ffc:	b113      	cbz	r3, 8003004 <default_handler.lto_priv.147+0x154>
 8002ffe:	2103      	movs	r1, #3
 8003000:	4620      	mov	r0, r4
 8003002:	4798      	blx	r3
      if (usbp->setup[2] != 0U) {
 8003004:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 8003008:	b14b      	cbz	r3, 800301e <default_handler.lto_priv.147+0x16e>
        usbp->configuration = usbp->setup[2];
 800300a:	f884 307f 	strb.w	r3, [r4, #127]	; 0x7f
        usbp->state = USB_ACTIVE;
 800300e:	2304      	movs	r3, #4
 8003010:	7023      	strb	r3, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8003012:	6863      	ldr	r3, [r4, #4]
 8003014:	681b      	ldr	r3, [r3, #0]
 8003016:	b113      	cbz	r3, 800301e <default_handler.lto_priv.147+0x16e>
 8003018:	2102      	movs	r1, #2
 800301a:	4620      	mov	r0, r4
 800301c:	4798      	blx	r3
    usbSetupTransfer(usbp, NULL, 0, NULL);
 800301e:	2300      	movs	r3, #0
 8003020:	66a3      	str	r3, [r4, #104]	; 0x68
 8003022:	66e3      	str	r3, [r4, #108]	; 0x6c
 8003024:	6723      	str	r3, [r4, #112]	; 0x70
    return true;
 8003026:	2001      	movs	r0, #1
 8003028:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 800302a:	4b3e      	ldr	r3, [pc, #248]	; (8003124 <default_handler.lto_priv.147+0x274>)
 800302c:	66a3      	str	r3, [r4, #104]	; 0x68
 800302e:	2302      	movs	r3, #2
 8003030:	66e3      	str	r3, [r4, #108]	; 0x6c
 8003032:	2300      	movs	r3, #0
 8003034:	6723      	str	r3, [r4, #112]	; 0x70
    return true;
 8003036:	2001      	movs	r0, #1
 8003038:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((usbp->setup[4] & 0x80U) != 0U) {
 800303a:	f890 1078 	ldrb.w	r1, [r0, #120]	; 0x78
 800303e:	f011 0f80 	tst.w	r1, #128	; 0x80
 8003042:	d018      	beq.n	8003076 <default_handler.lto_priv.147+0x1c6>
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 8003044:	f001 010f 	and.w	r1, r1, #15
 8003048:	f004 f8c2 	bl	80071d0 <usb_lld_get_status_in>
 800304c:	2801      	cmp	r0, #1
 800304e:	d002      	beq.n	8003056 <default_handler.lto_priv.147+0x1a6>
 8003050:	2802      	cmp	r0, #2
 8003052:	d008      	beq.n	8003066 <default_handler.lto_priv.147+0x1b6>
 8003054:	e05d      	b.n	8003112 <default_handler.lto_priv.147+0x262>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8003056:	4b34      	ldr	r3, [pc, #208]	; (8003128 <default_handler.lto_priv.147+0x278>)
 8003058:	66a3      	str	r3, [r4, #104]	; 0x68
 800305a:	2302      	movs	r3, #2
 800305c:	66e3      	str	r3, [r4, #108]	; 0x6c
 800305e:	2300      	movs	r3, #0
 8003060:	6723      	str	r3, [r4, #112]	; 0x70
        return true;
 8003062:	2001      	movs	r0, #1
 8003064:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8003066:	4b31      	ldr	r3, [pc, #196]	; (800312c <default_handler.lto_priv.147+0x27c>)
 8003068:	66a3      	str	r3, [r4, #104]	; 0x68
 800306a:	2302      	movs	r3, #2
 800306c:	66e3      	str	r3, [r4, #108]	; 0x6c
 800306e:	2300      	movs	r3, #0
 8003070:	6723      	str	r3, [r4, #112]	; 0x70
        return true;
 8003072:	2001      	movs	r0, #1
 8003074:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
 8003076:	f001 010f 	and.w	r1, r1, #15
 800307a:	f004 f8c1 	bl	8007200 <usb_lld_get_status_out>
 800307e:	2801      	cmp	r0, #1
 8003080:	d002      	beq.n	8003088 <default_handler.lto_priv.147+0x1d8>
 8003082:	2802      	cmp	r0, #2
 8003084:	d008      	beq.n	8003098 <default_handler.lto_priv.147+0x1e8>
 8003086:	e046      	b.n	8003116 <default_handler.lto_priv.147+0x266>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8003088:	4b27      	ldr	r3, [pc, #156]	; (8003128 <default_handler.lto_priv.147+0x278>)
 800308a:	66a3      	str	r3, [r4, #104]	; 0x68
 800308c:	2302      	movs	r3, #2
 800308e:	66e3      	str	r3, [r4, #108]	; 0x6c
 8003090:	2300      	movs	r3, #0
 8003092:	6723      	str	r3, [r4, #112]	; 0x70
        return true;
 8003094:	2001      	movs	r0, #1
 8003096:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8003098:	4b24      	ldr	r3, [pc, #144]	; (800312c <default_handler.lto_priv.147+0x27c>)
 800309a:	66a3      	str	r3, [r4, #104]	; 0x68
 800309c:	2302      	movs	r3, #2
 800309e:	66e3      	str	r3, [r4, #108]	; 0x6c
 80030a0:	2300      	movs	r3, #0
 80030a2:	6723      	str	r3, [r4, #112]	; 0x70
        return true;
 80030a4:	2001      	movs	r0, #1
 80030a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 80030a8:	f890 3076 	ldrb.w	r3, [r0, #118]	; 0x76
 80030ac:	2b00      	cmp	r3, #0
 80030ae:	d134      	bne.n	800311a <default_handler.lto_priv.147+0x26a>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 80030b0:	f890 3078 	ldrb.w	r3, [r0, #120]	; 0x78
 80030b4:	f013 010f 	ands.w	r1, r3, #15
 80030b8:	d007      	beq.n	80030ca <default_handler.lto_priv.147+0x21a>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80030ba:	f013 0f80 	tst.w	r3, #128	; 0x80
 80030be:	d002      	beq.n	80030c6 <default_handler.lto_priv.147+0x216>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 80030c0:	f003 ff86 	bl	8006fd0 <usb_lld_clear_in>
 80030c4:	e001      	b.n	80030ca <default_handler.lto_priv.147+0x21a>
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0FU);
 80030c6:	f003 ff93 	bl	8006ff0 <usb_lld_clear_out>
    usbSetupTransfer(usbp, NULL, 0, NULL);
 80030ca:	2300      	movs	r3, #0
 80030cc:	66a3      	str	r3, [r4, #104]	; 0x68
 80030ce:	66e3      	str	r3, [r4, #108]	; 0x6c
 80030d0:	6723      	str	r3, [r4, #112]	; 0x70
    return true;
 80030d2:	2001      	movs	r0, #1
 80030d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 80030d6:	f890 3076 	ldrb.w	r3, [r0, #118]	; 0x76
 80030da:	bb03      	cbnz	r3, 800311e <default_handler.lto_priv.147+0x26e>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 80030dc:	f890 3078 	ldrb.w	r3, [r0, #120]	; 0x78
 80030e0:	f013 010f 	ands.w	r1, r3, #15
 80030e4:	d007      	beq.n	80030f6 <default_handler.lto_priv.147+0x246>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80030e6:	f013 0f80 	tst.w	r3, #128	; 0x80
 80030ea:	d002      	beq.n	80030f2 <default_handler.lto_priv.147+0x242>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 80030ec:	f003 ff90 	bl	8007010 <usb_lld_stall_in>
 80030f0:	e001      	b.n	80030f6 <default_handler.lto_priv.147+0x246>
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
 80030f2:	f003 ff9d 	bl	8007030 <usb_lld_stall_out>
    usbSetupTransfer(usbp, NULL, 0, NULL);
 80030f6:	2300      	movs	r3, #0
 80030f8:	66a3      	str	r3, [r4, #104]	; 0x68
 80030fa:	66e3      	str	r3, [r4, #108]	; 0x6c
 80030fc:	6723      	str	r3, [r4, #112]	; 0x70
    return true;
 80030fe:	2001      	movs	r0, #1
 8003100:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return false;
 8003102:	2000      	movs	r0, #0
 8003104:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return false;
 8003106:	2000      	movs	r0, #0
 8003108:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return false;
 800310a:	2000      	movs	r0, #0
 800310c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      return false;
 800310e:	2000      	movs	r0, #0
 8003110:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return false;
 8003112:	2000      	movs	r0, #0
 8003114:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return false;
 8003116:	2000      	movs	r0, #0
 8003118:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      return false;
 800311a:	2000      	movs	r0, #0
 800311c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      return false;
 800311e:	2000      	movs	r0, #0
}
 8003120:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003122:	bf00      	nop
 8003124:	0800e3f4 	.word	0x0800e3f4
 8003128:	0800e47c 	.word	0x0800e47c
 800312c:	0800e3f8 	.word	0x0800e3f8

08003130 <sduSOFHookI>:
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8003130:	f8d0 248c 	ldr.w	r2, [r0, #1164]	; 0x48c
 8003134:	6813      	ldr	r3, [r2, #0]
 8003136:	7819      	ldrb	r1, [r3, #0]
 8003138:	2904      	cmp	r1, #4
 800313a:	d120      	bne.n	800317e <sduSOFHookI+0x4e>
      (sdup->state != SDU_READY)) {
 800313c:	7a01      	ldrb	r1, [r0, #8]
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800313e:	2902      	cmp	r1, #2
 8003140:	d11d      	bne.n	800317e <sduSOFHookI+0x4e>
  if (usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8003142:	7911      	ldrb	r1, [r2, #4]
 8003144:	2201      	movs	r2, #1
 8003146:	408a      	lsls	r2, r1
 8003148:	891b      	ldrh	r3, [r3, #8]
 800314a:	4013      	ands	r3, r2
 800314c:	b29b      	uxth	r3, r3
 800314e:	b9b3      	cbnz	r3, 800317e <sduSOFHookI+0x4e>
void sduSOFHookI(SerialUSBDriver *sdup) {
 8003150:	b530      	push	{r4, r5, lr}
 8003152:	b083      	sub	sp, #12
 8003154:	4604      	mov	r4, r0
  if (obqTryFlushI(&sdup->obqueue)) {
 8003156:	f100 0544 	add.w	r5, r0, #68	; 0x44
 800315a:	4628      	mov	r0, r5
 800315c:	f7ff f958 	bl	8002410 <obqTryFlushI>
 8003160:	b158      	cbz	r0, 800317a <sduSOFHookI+0x4a>
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8003162:	a901      	add	r1, sp, #4
 8003164:	4628      	mov	r0, r5
 8003166:	f7ff f993 	bl	8002490 <obqGetFullBufferI>
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 800316a:	f8d4 448c 	ldr.w	r4, [r4, #1164]	; 0x48c
 800316e:	9b01      	ldr	r3, [sp, #4]
 8003170:	4602      	mov	r2, r0
 8003172:	7921      	ldrb	r1, [r4, #4]
 8003174:	6820      	ldr	r0, [r4, #0]
 8003176:	f002 fff3 	bl	8006160 <usbStartTransmitI>
}
 800317a:	b003      	add	sp, #12
 800317c:	bd30      	pop	{r4, r5, pc}
 800317e:	4770      	bx	lr

08003180 <sduConfigureHookI>:
void sduConfigureHookI(SerialUSBDriver *sdup) {
 8003180:	b538      	push	{r3, r4, r5, lr}
 8003182:	4604      	mov	r4, r0
  ibqResetI(&sdup->ibqueue);
 8003184:	300c      	adds	r0, #12
 8003186:	f7ff fa53 	bl	8002630 <ibqResetI>
  bqResumeX(&sdup->ibqueue);
 800318a:	2500      	movs	r5, #0
 800318c:	7525      	strb	r5, [r4, #20]
  obqResetI(&sdup->obqueue);
 800318e:	f104 0044 	add.w	r0, r4, #68	; 0x44
 8003192:	f7ff fa3d 	bl	8002610 <obqResetI>
  bqResumeX(&sdup->obqueue);
 8003196:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
  chEvtBroadcastFlagsI(esp, flags);
 800319a:	2101      	movs	r1, #1
 800319c:	1d20      	adds	r0, r4, #4
 800319e:	f007 ff97 	bl	800b0d0 <chEvtBroadcastFlagsI>
  (void) sdu_start_receive(sdup);
 80031a2:	4620      	mov	r0, r4
 80031a4:	f7ff fa54 	bl	8002650 <sdu_start_receive>
 80031a8:	bd38      	pop	{r3, r4, r5, pc}
 80031aa:	bf00      	nop
 80031ac:	0000      	movs	r0, r0
	...

080031b0 <sduWakeupHookI>:
void sduWakeupHookI(SerialUSBDriver *sdup) {
 80031b0:	b510      	push	{r4, lr}
 80031b2:	4604      	mov	r4, r0
 80031b4:	2101      	movs	r1, #1
 80031b6:	3004      	adds	r0, #4
 80031b8:	f007 ff8a 	bl	800b0d0 <chEvtBroadcastFlagsI>
  bqResumeX(&sdup->ibqueue);
 80031bc:	2300      	movs	r3, #0
 80031be:	7523      	strb	r3, [r4, #20]
  bqResumeX(&sdup->obqueue);
 80031c0:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 80031c4:	bd10      	pop	{r4, pc}
 80031c6:	bf00      	nop
	...

080031d0 <sduSuspendHookI>:
void sduSuspendHookI(SerialUSBDriver *sdup) {
 80031d0:	b538      	push	{r3, r4, r5, lr}
  if(bqIsSuspendedX(&sdup->ibqueue) && bqIsSuspendedX(&sdup->obqueue)) {
 80031d2:	7d03      	ldrb	r3, [r0, #20]
 80031d4:	b113      	cbz	r3, 80031dc <sduSuspendHookI+0xc>
 80031d6:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
 80031da:	b9a3      	cbnz	r3, 8003206 <sduSuspendHookI+0x36>
 80031dc:	4604      	mov	r4, r0
 80031de:	2102      	movs	r1, #2
 80031e0:	3004      	adds	r0, #4
 80031e2:	f007 ff75 	bl	800b0d0 <chEvtBroadcastFlagsI>
  bqSuspendI(&sdup->ibqueue);
 80031e6:	2501      	movs	r5, #1
 80031e8:	7525      	strb	r5, [r4, #20]
  chThdDequeueAllI(tqp, msg);
 80031ea:	f06f 0101 	mvn.w	r1, #1
 80031ee:	f104 000c 	add.w	r0, r4, #12
 80031f2:	f008 f885 	bl	800b300 <chThdDequeueAllI>
  bqSuspendI(&sdup->obqueue);
 80031f6:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
 80031fa:	f06f 0101 	mvn.w	r1, #1
 80031fe:	f104 0044 	add.w	r0, r4, #68	; 0x44
 8003202:	f008 f87d 	bl	800b300 <chThdDequeueAllI>
 8003206:	bd38      	pop	{r3, r4, r5, pc}
	...

08003210 <sduStart>:
  USBDriver *usbp = config->usbp;
 8003210:	680a      	ldr	r2, [r1, #0]
 8003212:	2320      	movs	r3, #32
 8003214:	f383 8811 	msr	BASEPRI, r3
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 8003218:	790b      	ldrb	r3, [r1, #4]
 800321a:	3309      	adds	r3, #9
 800321c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8003220:	6058      	str	r0, [r3, #4]
  usbp->out_params[config->bulk_out - 1U] = sdup;
 8003222:	794b      	ldrb	r3, [r1, #5]
 8003224:	3311      	adds	r3, #17
 8003226:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  if (config->int_in > 0U) {
 800322a:	798b      	ldrb	r3, [r1, #6]
 800322c:	b11b      	cbz	r3, 8003236 <sduStart+0x26>
    usbp->in_params[config->int_in - 1U]  = sdup;
 800322e:	3309      	adds	r3, #9
 8003230:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8003234:	6050      	str	r0, [r2, #4]
  sdup->config = config;
 8003236:	f8c0 148c 	str.w	r1, [r0, #1164]	; 0x48c
  sdup->state = SDU_READY;
 800323a:	2302      	movs	r3, #2
 800323c:	7203      	strb	r3, [r0, #8]
 800323e:	2300      	movs	r3, #0
 8003240:	f383 8811 	msr	BASEPRI, r3
 8003244:	4770      	bx	lr
 8003246:	bf00      	nop
	...

08003250 <sduObjectInit>:
void sduObjectInit(SerialUSBDriver *sdup) {
 8003250:	b570      	push	{r4, r5, r6, lr}
 8003252:	b084      	sub	sp, #16
 8003254:	4604      	mov	r4, r0
  sdup->vmt = &vmt;
 8003256:	4603      	mov	r3, r0
 8003258:	4a10      	ldr	r2, [pc, #64]	; (800329c <sduObjectInit+0x4c>)
 800325a:	f843 2b04 	str.w	r2, [r3], #4
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 800325e:	6043      	str	r3, [r0, #4]
  sdup->state = SDU_STOP;
 8003260:	2501      	movs	r5, #1
 8003262:	7205      	strb	r5, [r0, #8]
  ibqObjectInit(&sdup->ibqueue, true, sdup->ib,
 8003264:	9002      	str	r0, [sp, #8]
 8003266:	4b0e      	ldr	r3, [pc, #56]	; (80032a0 <sduObjectInit+0x50>)
 8003268:	9301      	str	r3, [sp, #4]
 800326a:	2602      	movs	r6, #2
 800326c:	9600      	str	r6, [sp, #0]
 800326e:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003272:	f100 027c 	add.w	r2, r0, #124	; 0x7c
 8003276:	4629      	mov	r1, r5
 8003278:	300c      	adds	r0, #12
 800327a:	f7ff f969 	bl	8002550 <ibqObjectInit>
  obqObjectInit(&sdup->obqueue, true, sdup->ob,
 800327e:	9402      	str	r4, [sp, #8]
 8003280:	4b08      	ldr	r3, [pc, #32]	; (80032a4 <sduObjectInit+0x54>)
 8003282:	9301      	str	r3, [sp, #4]
 8003284:	9600      	str	r6, [sp, #0]
 8003286:	f44f 7380 	mov.w	r3, #256	; 0x100
 800328a:	f504 7221 	add.w	r2, r4, #644	; 0x284
 800328e:	4629      	mov	r1, r5
 8003290:	f104 0044 	add.w	r0, r4, #68	; 0x44
 8003294:	f7ff f914 	bl	80024c0 <obqObjectInit>
}
 8003298:	b004      	add	sp, #16
 800329a:	bd70      	pop	{r4, r5, r6, pc}
 800329c:	0800e3cc 	.word	0x0800e3cc
 80032a0:	080026b1 	.word	0x080026b1
 80032a4:	080025c1 	.word	0x080025c1
	...

080032b0 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 80032b0:	b538      	push	{r3, r4, r5, lr}
 80032b2:	4604      	mov	r4, r0
 80032b4:	460d      	mov	r5, r1

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 80032b6:	6943      	ldr	r3, [r0, #20]
 80032b8:	b91b      	cbnz	r3, 80032c2 <sdIncomingDataI+0x12>
  chEvtBroadcastFlagsI(esp, flags);
 80032ba:	2104      	movs	r1, #4
 80032bc:	4408      	add	r0, r1
 80032be:	f007 ff07 	bl	800b0d0 <chEvtBroadcastFlagsI>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 80032c2:	4629      	mov	r1, r5
 80032c4:	f104 000c 	add.w	r0, r4, #12
 80032c8:	f7ff fb32 	bl	8002930 <iqPutI>
 80032cc:	2800      	cmp	r0, #0
 80032ce:	da04      	bge.n	80032da <sdIncomingDataI+0x2a>
 80032d0:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80032d4:	1d20      	adds	r0, r4, #4
 80032d6:	f007 fefb 	bl	800b0d0 <chEvtBroadcastFlagsI>
 80032da:	bd38      	pop	{r3, r4, r5, pc}
 80032dc:	0000      	movs	r0, r0
	...

080032e0 <sdStart>:
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 80032e0:	b510      	push	{r4, lr}
 80032e2:	4604      	mov	r4, r0
 80032e4:	2320      	movs	r3, #32
 80032e6:	f383 8811 	msr	BASEPRI, r3
  sd_lld_start(sdp, config);
 80032ea:	f003 fc49 	bl	8006b80 <sd_lld_start>
  sdp->state = SD_READY;
 80032ee:	2302      	movs	r3, #2
 80032f0:	7223      	strb	r3, [r4, #8]
 80032f2:	2300      	movs	r3, #0
 80032f4:	f383 8811 	msr	BASEPRI, r3
 80032f8:	bd10      	pop	{r4, pc}
 80032fa:	bf00      	nop
 80032fc:	0000      	movs	r0, r0
	...

08003300 <sdObjectInit>:
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8003300:	b530      	push	{r4, r5, lr}
 8003302:	b083      	sub	sp, #12
 8003304:	4604      	mov	r4, r0
 8003306:	4615      	mov	r5, r2
  sdp->vmt = &vmt;
 8003308:	4603      	mov	r3, r0
 800330a:	4a0c      	ldr	r2, [pc, #48]	; (800333c <sdObjectInit+0x3c>)
 800330c:	f843 2b04 	str.w	r2, [r3], #4
 8003310:	6043      	str	r3, [r0, #4]
  sdp->state = SD_STOP;
 8003312:	2301      	movs	r3, #1
 8003314:	7203      	strb	r3, [r0, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8003316:	9000      	str	r0, [sp, #0]
 8003318:	460b      	mov	r3, r1
 800331a:	2210      	movs	r2, #16
 800331c:	f100 0154 	add.w	r1, r0, #84	; 0x54
 8003320:	300c      	adds	r0, #12
 8003322:	f7ff f865 	bl	80023f0 <iqObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 8003326:	9400      	str	r4, [sp, #0]
 8003328:	462b      	mov	r3, r5
 800332a:	2210      	movs	r2, #16
 800332c:	f104 0164 	add.w	r1, r4, #100	; 0x64
 8003330:	f104 0030 	add.w	r0, r4, #48	; 0x30
 8003334:	f7ff f84c 	bl	80023d0 <oqObjectInit>
}
 8003338:	b003      	add	sp, #12
 800333a:	bd30      	pop	{r4, r5, pc}
 800333c:	0800e3a4 	.word	0x0800e3a4

08003340 <pwmEnableChannel>:
 *
 * @api
 */
void pwmEnableChannel(PWMDriver *pwmp,
                      pwmchannel_t channel,
                      pwmcnt_t width) {
 8003340:	b538      	push	{r3, r4, r5, lr}
 8003342:	2320      	movs	r3, #32
 8003344:	f383 8811 	msr	BASEPRI, r3

  osalSysLock();

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");

  pwmEnableChannelI(pwmp, channel, width);
 8003348:	2301      	movs	r3, #1
 800334a:	408b      	lsls	r3, r1
 800334c:	68c5      	ldr	r5, [r0, #12]
 800334e:	432b      	orrs	r3, r5
 8003350:	60c3      	str	r3, [r0, #12]
 8003352:	f003 fce5 	bl	8006d20 <pwm_lld_enable_channel>
 8003356:	2300      	movs	r3, #0
 8003358:	f383 8811 	msr	BASEPRI, r3
 800335c:	bd38      	pop	{r3, r4, r5, pc}
 800335e:	bf00      	nop

08003360 <pwmStart>:
void pwmStart(PWMDriver *pwmp, const PWMConfig *config) {
 8003360:	b510      	push	{r4, lr}
 8003362:	4604      	mov	r4, r0
 8003364:	2320      	movs	r3, #32
 8003366:	f383 8811 	msr	BASEPRI, r3
  pwmp->config = config;
 800336a:	6041      	str	r1, [r0, #4]
  pwmp->period = config->period;
 800336c:	684b      	ldr	r3, [r1, #4]
 800336e:	6083      	str	r3, [r0, #8]
  pwm_lld_start(pwmp);
 8003370:	f003 fcde 	bl	8006d30 <pwm_lld_start>
  pwmp->enabled = 0;
 8003374:	2300      	movs	r3, #0
 8003376:	60e3      	str	r3, [r4, #12]
  pwmp->state = PWM_READY;
 8003378:	2202      	movs	r2, #2
 800337a:	7022      	strb	r2, [r4, #0]
 800337c:	f383 8811 	msr	BASEPRI, r3
 8003380:	bd10      	pop	{r4, pc}
 8003382:	bf00      	nop
	...

08003390 <pwmObjectInit>:
  pwmp->state    = PWM_STOP;
 8003390:	2301      	movs	r3, #1
 8003392:	7003      	strb	r3, [r0, #0]
  pwmp->config   = NULL;
 8003394:	2300      	movs	r3, #0
 8003396:	6043      	str	r3, [r0, #4]
  pwmp->enabled  = 0;
 8003398:	60c3      	str	r3, [r0, #12]
  pwmp->channels = 0;
 800339a:	7403      	strb	r3, [r0, #16]
 800339c:	4770      	bx	lr
 800339e:	bf00      	nop

080033a0 <oqGetI>:
  if (!oqIsEmptyI(oqp)) {
 80033a0:	6983      	ldr	r3, [r0, #24]
 80033a2:	6942      	ldr	r2, [r0, #20]
 80033a4:	429a      	cmp	r2, r3
 80033a6:	d102      	bne.n	80033ae <oqGetI+0xe>
 80033a8:	6882      	ldr	r2, [r0, #8]
 80033aa:	b912      	cbnz	r2, 80033b2 <oqGetI+0x12>
 80033ac:	e002      	b.n	80033b4 <oqGetI+0x14>
 80033ae:	2200      	movs	r2, #0
 80033b0:	e000      	b.n	80033b4 <oqGetI+0x14>
 80033b2:	2201      	movs	r2, #1
 80033b4:	b982      	cbnz	r2, 80033d8 <oqGetI+0x38>
msg_t oqGetI(output_queue_t *oqp) {
 80033b6:	b510      	push	{r4, lr}
    oqp->q_counter++;
 80033b8:	6882      	ldr	r2, [r0, #8]
 80033ba:	3201      	adds	r2, #1
 80033bc:	6082      	str	r2, [r0, #8]
    b = *oqp->q_rdptr++;
 80033be:	1c5a      	adds	r2, r3, #1
 80033c0:	6182      	str	r2, [r0, #24]
 80033c2:	781c      	ldrb	r4, [r3, #0]
    if (oqp->q_rdptr >= oqp->q_top) {
 80033c4:	6903      	ldr	r3, [r0, #16]
 80033c6:	429a      	cmp	r2, r3
 80033c8:	d301      	bcc.n	80033ce <oqGetI+0x2e>
      oqp->q_rdptr = oqp->q_buffer;
 80033ca:	68c3      	ldr	r3, [r0, #12]
 80033cc:	6183      	str	r3, [r0, #24]
  chThdDequeueNextI(tqp, msg);
 80033ce:	2100      	movs	r1, #0
 80033d0:	f007 ffa6 	bl	800b320 <chThdDequeueNextI>
    return (msg_t)b;
 80033d4:	4620      	mov	r0, r4
 80033d6:	bd10      	pop	{r4, pc}
  return MSG_TIMEOUT;
 80033d8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80033dc:	4770      	bx	lr
 80033de:	bf00      	nop

080033e0 <obqPostFullBuffer>:
void obqPostFullBuffer(output_buffers_queue_t *obqp, size_t size) {
 80033e0:	b508      	push	{r3, lr}
 80033e2:	2320      	movs	r3, #32
 80033e4:	f383 8811 	msr	BASEPRI, r3
  obqPostFullBufferS(obqp, size);
 80033e8:	f7ff f83a 	bl	8002460 <obqPostFullBufferS>
 80033ec:	2300      	movs	r3, #0
 80033ee:	f383 8811 	msr	BASEPRI, r3
 80033f2:	bd08      	pop	{r3, pc}
	...

08003400 <obqGetEmptyBufferTimeout>:
                               sysinterval_t timeout) {
 8003400:	b508      	push	{r3, lr}
 8003402:	2320      	movs	r3, #32
 8003404:	f383 8811 	msr	BASEPRI, r3
  msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 8003408:	f7ff f9ea 	bl	80027e0 <obqGetEmptyBufferTimeoutS>
 800340c:	2300      	movs	r3, #0
 800340e:	f383 8811 	msr	BASEPRI, r3
}
 8003412:	bd08      	pop	{r3, pc}
	...

08003420 <stSetAlarm>:
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003420:	4b01      	ldr	r3, [pc, #4]	; (8003428 <stSetAlarm+0x8>)
 8003422:	6358      	str	r0, [r3, #52]	; 0x34
 8003424:	4770      	bx	lr
 8003426:	bf00      	nop
 8003428:	40000c00 	.word	0x40000c00
 800342c:	00000000 	.word	0x00000000

08003430 <stStopAlarm>:
  STM32_ST_TIM->DIER = 0;
 8003430:	2200      	movs	r2, #0
 8003432:	4b01      	ldr	r3, [pc, #4]	; (8003438 <stStopAlarm+0x8>)
 8003434:	60da      	str	r2, [r3, #12]
 8003436:	4770      	bx	lr
 8003438:	40000c00 	.word	0x40000c00
 800343c:	00000000 	.word	0x00000000

08003440 <stStartAlarm>:
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003440:	4b03      	ldr	r3, [pc, #12]	; (8003450 <stStartAlarm+0x10>)
 8003442:	6358      	str	r0, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8003444:	2200      	movs	r2, #0
 8003446:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8003448:	2202      	movs	r2, #2
 800344a:	60da      	str	r2, [r3, #12]
 800344c:	4770      	bx	lr
 800344e:	bf00      	nop
 8003450:	40000c00 	.word	0x40000c00
	...

08003460 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8003460:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
 8003462:	f002 fe0d 	bl	8006080 <hal_lld_init>
#endif
#if (HAL_USE_MAC == TRUE) || defined(__DOXYGEN__)
  macInit();
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
 8003466:	f7ff f933 	bl	80026d0 <pwmInit>
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 800346a:	f7ff f929 	bl	80026c0 <sdInit>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
 800346e:	f7ff f887 	bl	8002580 <usbInit>
#if (HAL_USE_WSPI == TRUE) || defined(__DOXYGEN__)
  wspiInit();
#endif

  #if HAL_USE_QEI || defined(__DOXYGEN__)
  qeiInit();
 8003472:	f002 fe6d 	bl	8006150 <qeiInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8003476:	f7ff fcd3 	bl	8002e20 <stInit>
 800347a:	bd08      	pop	{r3, pc}
 800347c:	0000      	movs	r0, r0
	...

08003480 <__init_ram_areas>:
/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8003480:	4a0b      	ldr	r2, [pc, #44]	; (80034b0 <__init_ram_areas+0x30>)

  do {
    uint32_t *tp = rap->init_text_area;
 8003482:	6810      	ldr	r0, [r2, #0]
    uint32_t *p = rap->init_area;
 8003484:	6853      	ldr	r3, [r2, #4]
 8003486:	e003      	b.n	8003490 <__init_ram_areas+0x10>

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
      *p = *tp;
 8003488:	f850 1b04 	ldr.w	r1, [r0], #4
 800348c:	f843 1b04 	str.w	r1, [r3], #4
    while (p < rap->clear_area) {
 8003490:	6891      	ldr	r1, [r2, #8]
 8003492:	428b      	cmp	r3, r1
 8003494:	d3f8      	bcc.n	8003488 <__init_ram_areas+0x8>
 8003496:	e002      	b.n	800349e <__init_ram_areas+0x1e>
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8003498:	2100      	movs	r1, #0
 800349a:	f843 1b04 	str.w	r1, [r3], #4
    while (p < rap->no_init_area) {
 800349e:	68d1      	ldr	r1, [r2, #12]
 80034a0:	428b      	cmp	r3, r1
 80034a2:	d3f9      	bcc.n	8003498 <__init_ram_areas+0x18>
      p++;
    }
    rap++;
 80034a4:	3210      	adds	r2, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 80034a6:	4b03      	ldr	r3, [pc, #12]	; (80034b4 <__init_ram_areas+0x34>)
 80034a8:	429a      	cmp	r2, r3
 80034aa:	d3ea      	bcc.n	8003482 <__init_ram_areas+0x2>
#endif
}
 80034ac:	4770      	bx	lr
 80034ae:	bf00      	nop
 80034b0:	0800e3fc 	.word	0x0800e3fc
 80034b4:	0800e47c 	.word	0x0800e47c
	...

080034c0 <__default_exit>:
void __default_exit(void) {
 80034c0:	e7fe      	b.n	80034c0 <__default_exit>
 80034c2:	bf00      	nop
	...

080034d0 <__late_init>:
void __late_init(void) {}
 80034d0:	4770      	bx	lr
 80034d2:	bf00      	nop
	...

080034e0 <__core_init>:
void __core_init(void) {
 80034e0:	4770      	bx	lr
 80034e2:	bf00      	nop
	...

080034f0 <oslib_test_001_002_execute.lto_priv.34>:

static void oslib_test_001_002_teardown(void) {
  chMBReset(&mb1);
}

static void oslib_test_001_002_execute(void) {
 80034f0:	b570      	push	{r4, r5, r6, lr}
 80034f2:	b082      	sub	sp, #8
  msg_t msg1, msg2;
  unsigned i;

  /* [1.2.1] Testing the mailbox size.*/
  test_set_step(1);
 80034f4:	2201      	movs	r2, #1
 80034f6:	4baf      	ldr	r3, [pc, #700]	; (80037b4 <oslib_test_001_002_execute.lto_priv.34+0x2c4>)
 80034f8:	601a      	str	r2, [r3, #0]
 80034fa:	2320      	movs	r3, #32
 80034fc:	f383 8811 	msr	BASEPRI, r3
 */
static inline size_t chMBGetSizeI(const mailbox_t *mbp) {

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (size_t)(mbp->top - mbp->buffer);
 8003500:	4aad      	ldr	r2, [pc, #692]	; (80037b8 <oslib_test_001_002_execute.lto_priv.34+0x2c8>)
 8003502:	6853      	ldr	r3, [r2, #4]
 8003504:	6810      	ldr	r0, [r2, #0]
 8003506:	1a18      	subs	r0, r3, r0
 */
static inline size_t chMBGetUsedCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return mbp->cnt;
 8003508:	6913      	ldr	r3, [r2, #16]
 */
static inline size_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 800350a:	ebc3 00a0 	rsb	r0, r3, r0, asr #2
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 800350e:	49ab      	ldr	r1, [pc, #684]	; (80037bc <oslib_test_001_002_execute.lto_priv.34+0x2cc>)
 8003510:	2804      	cmp	r0, #4
 8003512:	bf14      	ite	ne
 8003514:	2000      	movne	r0, #0
 8003516:	2001      	moveq	r0, #1
 8003518:	f009 fe4a 	bl	800d1b0 <_test_assert>
 800351c:	b118      	cbz	r0, 8003526 <oslib_test_001_002_execute.lto_priv.34+0x36>
 800351e:	2300      	movs	r3, #0
 8003520:	f383 8811 	msr	BASEPRI, r3
 8003524:	e178      	b.n	8003818 <oslib_test_001_002_execute.lto_priv.34+0x328>
 8003526:	2600      	movs	r6, #0
 8003528:	f386 8811 	msr	BASEPRI, r6
  }

  /* [1.2.2] Resetting the mailbox, conditions are checked, no errors
     expected. The mailbox is then returned in active state.*/
  test_set_step(2);
 800352c:	2202      	movs	r2, #2
 800352e:	4ba1      	ldr	r3, [pc, #644]	; (80037b4 <oslib_test_001_002_execute.lto_priv.34+0x2c4>)
 8003530:	601a      	str	r2, [r3, #0]
 8003532:	2520      	movs	r5, #32
 8003534:	f385 8811 	msr	BASEPRI, r5
  {
    chSysLock();
    chMBResetI(&mb1);
 8003538:	4c9f      	ldr	r4, [pc, #636]	; (80037b8 <oslib_test_001_002_execute.lto_priv.34+0x2c8>)
 800353a:	4620      	mov	r0, r4
 800353c:	f006 fc18 	bl	8009d70 <chMBResetI>
 8003540:	f386 8811 	msr	BASEPRI, r6
 8003544:	f385 8811 	msr	BASEPRI, r5
  return (size_t)(mbp->top - mbp->buffer);
 8003548:	6863      	ldr	r3, [r4, #4]
 800354a:	6820      	ldr	r0, [r4, #0]
 800354c:	1a18      	subs	r0, r3, r0
  return mbp->cnt;
 800354e:	6923      	ldr	r3, [r4, #16]
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8003550:	ebc3 00a0 	rsb	r0, r3, r0, asr #2
    chSysUnlock();
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8003554:	499a      	ldr	r1, [pc, #616]	; (80037c0 <oslib_test_001_002_execute.lto_priv.34+0x2d0>)
 8003556:	2804      	cmp	r0, #4
 8003558:	bf14      	ite	ne
 800355a:	2000      	movne	r0, #0
 800355c:	2001      	moveq	r0, #1
 800355e:	f009 fe27 	bl	800d1b0 <_test_assert>
 8003562:	b110      	cbz	r0, 800356a <oslib_test_001_002_execute.lto_priv.34+0x7a>
 8003564:	f386 8811 	msr	BASEPRI, r6
 8003568:	e156      	b.n	8003818 <oslib_test_001_002_execute.lto_priv.34+0x328>
 800356a:	2300      	movs	r3, #0
 800356c:	f383 8811 	msr	BASEPRI, r3
 8003570:	2320      	movs	r3, #32
 8003572:	f383 8811 	msr	BASEPRI, r3
  return mbp->cnt;
 8003576:	4b90      	ldr	r3, [pc, #576]	; (80037b8 <oslib_test_001_002_execute.lto_priv.34+0x2c8>)
 8003578:	6918      	ldr	r0, [r3, #16]
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 800357a:	4992      	ldr	r1, [pc, #584]	; (80037c4 <oslib_test_001_002_execute.lto_priv.34+0x2d4>)
 800357c:	fab0 f080 	clz	r0, r0
 8003580:	0940      	lsrs	r0, r0, #5
 8003582:	f009 fe15 	bl	800d1b0 <_test_assert>
 8003586:	b118      	cbz	r0, 8003590 <oslib_test_001_002_execute.lto_priv.34+0xa0>
 8003588:	2300      	movs	r3, #0
 800358a:	f383 8811 	msr	BASEPRI, r3
 800358e:	e143      	b.n	8003818 <oslib_test_001_002_execute.lto_priv.34+0x328>
 8003590:	2300      	movs	r3, #0
 8003592:	f383 8811 	msr	BASEPRI, r3
 8003596:	2320      	movs	r3, #32
 8003598:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 800359c:	4b86      	ldr	r3, [pc, #536]	; (80037b8 <oslib_test_001_002_execute.lto_priv.34+0x2c8>)
 800359e:	6818      	ldr	r0, [r3, #0]
 80035a0:	689b      	ldr	r3, [r3, #8]
 80035a2:	4989      	ldr	r1, [pc, #548]	; (80037c8 <oslib_test_001_002_execute.lto_priv.34+0x2d8>)
 80035a4:	4298      	cmp	r0, r3
 80035a6:	bf14      	ite	ne
 80035a8:	2000      	movne	r0, #0
 80035aa:	2001      	moveq	r0, #1
 80035ac:	f009 fe00 	bl	800d1b0 <_test_assert>
 80035b0:	b118      	cbz	r0, 80035ba <oslib_test_001_002_execute.lto_priv.34+0xca>
 80035b2:	2300      	movs	r3, #0
 80035b4:	f383 8811 	msr	BASEPRI, r3
 80035b8:	e12e      	b.n	8003818 <oslib_test_001_002_execute.lto_priv.34+0x328>
 80035ba:	2300      	movs	r3, #0
 80035bc:	f383 8811 	msr	BASEPRI, r3
 80035c0:	2320      	movs	r3, #32
 80035c2:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 80035c6:	4b7c      	ldr	r3, [pc, #496]	; (80037b8 <oslib_test_001_002_execute.lto_priv.34+0x2c8>)
 80035c8:	6818      	ldr	r0, [r3, #0]
 80035ca:	68db      	ldr	r3, [r3, #12]
 80035cc:	497f      	ldr	r1, [pc, #508]	; (80037cc <oslib_test_001_002_execute.lto_priv.34+0x2dc>)
 80035ce:	4298      	cmp	r0, r3
 80035d0:	bf14      	ite	ne
 80035d2:	2000      	movne	r0, #0
 80035d4:	2001      	moveq	r0, #1
 80035d6:	f009 fdeb 	bl	800d1b0 <_test_assert>
 80035da:	b118      	cbz	r0, 80035e4 <oslib_test_001_002_execute.lto_priv.34+0xf4>
 80035dc:	2300      	movs	r3, #0
 80035de:	f383 8811 	msr	BASEPRI, r3
 80035e2:	e119      	b.n	8003818 <oslib_test_001_002_execute.lto_priv.34+0x328>
 80035e4:	2400      	movs	r4, #0
 80035e6:	f384 8811 	msr	BASEPRI, r4
 *
 * @xclass
 */
static inline void chMBResumeX(mailbox_t *mbp) {

  mbp->reset = false;
 80035ea:	4b73      	ldr	r3, [pc, #460]	; (80037b8 <oslib_test_001_002_execute.lto_priv.34+0x2c8>)
 80035ec:	751c      	strb	r4, [r3, #20]
    chMBResumeX(&mb1);
  }

  /* [1.2.3] Filling the mailbox using chMBPostI() and chMBPostAheadI()
     once, no errors expected.*/
  test_set_step(3);
 80035ee:	2203      	movs	r2, #3
 80035f0:	4b70      	ldr	r3, [pc, #448]	; (80037b4 <oslib_test_001_002_execute.lto_priv.34+0x2c4>)
 80035f2:	601a      	str	r2, [r3, #0]
 80035f4:	e014      	b.n	8003620 <oslib_test_001_002_execute.lto_priv.34+0x130>
 80035f6:	2320      	movs	r3, #32
 80035f8:	f383 8811 	msr	BASEPRI, r3
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
      chSysLock();
      msg1 = chMBPostI(&mb1, 'B' + i);
 80035fc:	f104 0142 	add.w	r1, r4, #66	; 0x42
 8003600:	486d      	ldr	r0, [pc, #436]	; (80037b8 <oslib_test_001_002_execute.lto_priv.34+0x2c8>)
 8003602:	f006 fb7d 	bl	8009d00 <chMBPostI>
 8003606:	2300      	movs	r3, #0
 8003608:	f383 8811 	msr	BASEPRI, r3
      chSysUnlock();
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800360c:	4970      	ldr	r1, [pc, #448]	; (80037d0 <oslib_test_001_002_execute.lto_priv.34+0x2e0>)
 800360e:	fab0 f080 	clz	r0, r0
 8003612:	0940      	lsrs	r0, r0, #5
 8003614:	f009 fdcc 	bl	800d1b0 <_test_assert>
 8003618:	2800      	cmp	r0, #0
 800361a:	f040 80fd 	bne.w	8003818 <oslib_test_001_002_execute.lto_priv.34+0x328>
    for (i = 0; i < MB_SIZE - 1; i++) {
 800361e:	3401      	adds	r4, #1
 8003620:	2c02      	cmp	r4, #2
 8003622:	d9e8      	bls.n	80035f6 <oslib_test_001_002_execute.lto_priv.34+0x106>
 8003624:	2320      	movs	r3, #32
 8003626:	f383 8811 	msr	BASEPRI, r3
    }
    chSysLock();
    msg1 = chMBPostAheadI(&mb1, 'A');
 800362a:	2141      	movs	r1, #65	; 0x41
 800362c:	4862      	ldr	r0, [pc, #392]	; (80037b8 <oslib_test_001_002_execute.lto_priv.34+0x2c8>)
 800362e:	f006 fb2f 	bl	8009c90 <chMBPostAheadI>
 8003632:	2300      	movs	r3, #0
 8003634:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8003638:	4965      	ldr	r1, [pc, #404]	; (80037d0 <oslib_test_001_002_execute.lto_priv.34+0x2e0>)
 800363a:	fab0 f080 	clz	r0, r0
 800363e:	0940      	lsrs	r0, r0, #5
 8003640:	f009 fdb6 	bl	800d1b0 <_test_assert>
 8003644:	2800      	cmp	r0, #0
 8003646:	f040 80e7 	bne.w	8003818 <oslib_test_001_002_execute.lto_priv.34+0x328>
  }

  /* [1.2.4] Testing intermediate conditions. Data pointers must be
     aligned, semaphore counters are checked.*/
  test_set_step(4);
 800364a:	2204      	movs	r2, #4
 800364c:	4b59      	ldr	r3, [pc, #356]	; (80037b4 <oslib_test_001_002_execute.lto_priv.34+0x2c4>)
 800364e:	601a      	str	r2, [r3, #0]
 8003650:	2320      	movs	r3, #32
 8003652:	f383 8811 	msr	BASEPRI, r3
  return (size_t)(mbp->top - mbp->buffer);
 8003656:	4a58      	ldr	r2, [pc, #352]	; (80037b8 <oslib_test_001_002_execute.lto_priv.34+0x2c8>)
 8003658:	6853      	ldr	r3, [r2, #4]
 800365a:	6811      	ldr	r1, [r2, #0]
 800365c:	1a5b      	subs	r3, r3, r1
  return mbp->cnt;
 800365e:	6912      	ldr	r2, [r2, #16]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
 8003660:	ebb2 0fa3 	cmp.w	r2, r3, asr #2
 8003664:	495b      	ldr	r1, [pc, #364]	; (80037d4 <oslib_test_001_002_execute.lto_priv.34+0x2e4>)
 8003666:	bf0c      	ite	eq
 8003668:	2001      	moveq	r0, #1
 800366a:	2000      	movne	r0, #0
 800366c:	f009 fda0 	bl	800d1b0 <_test_assert>
 8003670:	b118      	cbz	r0, 800367a <oslib_test_001_002_execute.lto_priv.34+0x18a>
 8003672:	2300      	movs	r3, #0
 8003674:	f383 8811 	msr	BASEPRI, r3
 8003678:	e0ce      	b.n	8003818 <oslib_test_001_002_execute.lto_priv.34+0x328>
 800367a:	2300      	movs	r3, #0
 800367c:	f383 8811 	msr	BASEPRI, r3
 8003680:	2320      	movs	r3, #32
 8003682:	f383 8811 	msr	BASEPRI, r3
 8003686:	4b4c      	ldr	r3, [pc, #304]	; (80037b8 <oslib_test_001_002_execute.lto_priv.34+0x2c8>)
 8003688:	6918      	ldr	r0, [r3, #16]
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 800368a:	4953      	ldr	r1, [pc, #332]	; (80037d8 <oslib_test_001_002_execute.lto_priv.34+0x2e8>)
 800368c:	2804      	cmp	r0, #4
 800368e:	bf14      	ite	ne
 8003690:	2000      	movne	r0, #0
 8003692:	2001      	moveq	r0, #1
 8003694:	f009 fd8c 	bl	800d1b0 <_test_assert>
 8003698:	b118      	cbz	r0, 80036a2 <oslib_test_001_002_execute.lto_priv.34+0x1b2>
 800369a:	2300      	movs	r3, #0
 800369c:	f383 8811 	msr	BASEPRI, r3
 80036a0:	e0ba      	b.n	8003818 <oslib_test_001_002_execute.lto_priv.34+0x328>
 80036a2:	2300      	movs	r3, #0
 80036a4:	f383 8811 	msr	BASEPRI, r3
 80036a8:	2320      	movs	r3, #32
 80036aa:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
 80036ae:	4b42      	ldr	r3, [pc, #264]	; (80037b8 <oslib_test_001_002_execute.lto_priv.34+0x2c8>)
 80036b0:	68d8      	ldr	r0, [r3, #12]
 80036b2:	689b      	ldr	r3, [r3, #8]
 80036b4:	4949      	ldr	r1, [pc, #292]	; (80037dc <oslib_test_001_002_execute.lto_priv.34+0x2ec>)
 80036b6:	4298      	cmp	r0, r3
 80036b8:	bf14      	ite	ne
 80036ba:	2000      	movne	r0, #0
 80036bc:	2001      	moveq	r0, #1
 80036be:	f009 fd77 	bl	800d1b0 <_test_assert>
 80036c2:	b118      	cbz	r0, 80036cc <oslib_test_001_002_execute.lto_priv.34+0x1dc>
 80036c4:	2300      	movs	r3, #0
 80036c6:	f383 8811 	msr	BASEPRI, r3
 80036ca:	e0a5      	b.n	8003818 <oslib_test_001_002_execute.lto_priv.34+0x328>
 80036cc:	2400      	movs	r4, #0
 80036ce:	f384 8811 	msr	BASEPRI, r4
  }

  /* [1.2.5] Emptying the mailbox using chMBFetchI(), no errors
     expected.*/
  test_set_step(5);
 80036d2:	2205      	movs	r2, #5
 80036d4:	4b37      	ldr	r3, [pc, #220]	; (80037b4 <oslib_test_001_002_execute.lto_priv.34+0x2c4>)
 80036d6:	601a      	str	r2, [r3, #0]
 80036d8:	e017      	b.n	800370a <oslib_test_001_002_execute.lto_priv.34+0x21a>
 80036da:	2320      	movs	r3, #32
 80036dc:	f383 8811 	msr	BASEPRI, r3
  {
    for (i = 0; i < MB_SIZE; i++) {
      chSysLock();
      msg1 = chMBFetchI(&mb1, &msg2);
 80036e0:	a901      	add	r1, sp, #4
 80036e2:	4835      	ldr	r0, [pc, #212]	; (80037b8 <oslib_test_001_002_execute.lto_priv.34+0x2c8>)
 80036e4:	f006 faa4 	bl	8009c30 <chMBFetchI>
 80036e8:	2300      	movs	r3, #0
 80036ea:	f383 8811 	msr	BASEPRI, r3
      chSysUnlock();
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80036ee:	4938      	ldr	r1, [pc, #224]	; (80037d0 <oslib_test_001_002_execute.lto_priv.34+0x2e0>)
 80036f0:	fab0 f080 	clz	r0, r0
 80036f4:	0940      	lsrs	r0, r0, #5
 80036f6:	f009 fd5b 	bl	800d1b0 <_test_assert>
 80036fa:	2800      	cmp	r0, #0
 80036fc:	f040 808c 	bne.w	8003818 <oslib_test_001_002_execute.lto_priv.34+0x328>
      test_emit_token(msg2);
 8003700:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8003704:	f009 f944 	bl	800c990 <test_emit_token>
    for (i = 0; i < MB_SIZE; i++) {
 8003708:	3401      	adds	r4, #1
 800370a:	2c03      	cmp	r4, #3
 800370c:	d9e5      	bls.n	80036da <oslib_test_001_002_execute.lto_priv.34+0x1ea>
    }
    test_assert_sequence("ABCD", "wrong get sequence");
 800370e:	4934      	ldr	r1, [pc, #208]	; (80037e0 <oslib_test_001_002_execute.lto_priv.34+0x2f0>)
 8003710:	4834      	ldr	r0, [pc, #208]	; (80037e4 <oslib_test_001_002_execute.lto_priv.34+0x2f4>)
 8003712:	f009 fd25 	bl	800d160 <_test_assert_sequence>
 8003716:	2800      	cmp	r0, #0
 8003718:	d17e      	bne.n	8003818 <oslib_test_001_002_execute.lto_priv.34+0x328>
  }

  /* [1.2.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 800371a:	2206      	movs	r2, #6
 800371c:	4b25      	ldr	r3, [pc, #148]	; (80037b4 <oslib_test_001_002_execute.lto_priv.34+0x2c4>)
 800371e:	601a      	str	r2, [r3, #0]
  {
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 8003720:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8003724:	f104 0142 	add.w	r1, r4, #66	; 0x42
 8003728:	4823      	ldr	r0, [pc, #140]	; (80037b8 <oslib_test_001_002_execute.lto_priv.34+0x2c8>)
 800372a:	f006 fb11 	bl	8009d50 <chMBPostTimeout>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800372e:	4928      	ldr	r1, [pc, #160]	; (80037d0 <oslib_test_001_002_execute.lto_priv.34+0x2e0>)
 8003730:	fab0 f080 	clz	r0, r0
 8003734:	0940      	lsrs	r0, r0, #5
 8003736:	f009 fd3b 	bl	800d1b0 <_test_assert>
 800373a:	2800      	cmp	r0, #0
 800373c:	d16c      	bne.n	8003818 <oslib_test_001_002_execute.lto_priv.34+0x328>
    msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
 800373e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8003742:	a901      	add	r1, sp, #4
 8003744:	481c      	ldr	r0, [pc, #112]	; (80037b8 <oslib_test_001_002_execute.lto_priv.34+0x2c8>)
 8003746:	f006 fa93 	bl	8009c70 <chMBFetchTimeout>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800374a:	4921      	ldr	r1, [pc, #132]	; (80037d0 <oslib_test_001_002_execute.lto_priv.34+0x2e0>)
 800374c:	fab0 f080 	clz	r0, r0
 8003750:	0940      	lsrs	r0, r0, #5
 8003752:	f009 fd2d 	bl	800d1b0 <_test_assert>
 8003756:	2800      	cmp	r0, #0
 8003758:	d15e      	bne.n	8003818 <oslib_test_001_002_execute.lto_priv.34+0x328>
  }

  /* [1.2.7] Testing final conditions. Data pointers must be aligned to
     buffer start, semaphore counters are checked.*/
  test_set_step(7);
 800375a:	2207      	movs	r2, #7
 800375c:	4b15      	ldr	r3, [pc, #84]	; (80037b4 <oslib_test_001_002_execute.lto_priv.34+0x2c4>)
 800375e:	601a      	str	r2, [r3, #0]
 8003760:	2320      	movs	r3, #32
 8003762:	f383 8811 	msr	BASEPRI, r3
  return (size_t)(mbp->top - mbp->buffer);
 8003766:	4a14      	ldr	r2, [pc, #80]	; (80037b8 <oslib_test_001_002_execute.lto_priv.34+0x2c8>)
 8003768:	6853      	ldr	r3, [r2, #4]
 800376a:	6810      	ldr	r0, [r2, #0]
 800376c:	1a18      	subs	r0, r3, r0
  return mbp->cnt;
 800376e:	6913      	ldr	r3, [r2, #16]
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8003770:	ebc3 00a0 	rsb	r0, r3, r0, asr #2
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8003774:	4912      	ldr	r1, [pc, #72]	; (80037c0 <oslib_test_001_002_execute.lto_priv.34+0x2d0>)
 8003776:	2804      	cmp	r0, #4
 8003778:	bf14      	ite	ne
 800377a:	2000      	movne	r0, #0
 800377c:	2001      	moveq	r0, #1
 800377e:	f009 fd17 	bl	800d1b0 <_test_assert>
 8003782:	b118      	cbz	r0, 800378c <oslib_test_001_002_execute.lto_priv.34+0x29c>
 8003784:	2300      	movs	r3, #0
 8003786:	f383 8811 	msr	BASEPRI, r3
 800378a:	e045      	b.n	8003818 <oslib_test_001_002_execute.lto_priv.34+0x328>
 800378c:	2300      	movs	r3, #0
 800378e:	f383 8811 	msr	BASEPRI, r3
 8003792:	2320      	movs	r3, #32
 8003794:	f383 8811 	msr	BASEPRI, r3
  return mbp->cnt;
 8003798:	4b07      	ldr	r3, [pc, #28]	; (80037b8 <oslib_test_001_002_execute.lto_priv.34+0x2c8>)
 800379a:	6918      	ldr	r0, [r3, #16]
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 800379c:	4909      	ldr	r1, [pc, #36]	; (80037c4 <oslib_test_001_002_execute.lto_priv.34+0x2d4>)
 800379e:	fab0 f080 	clz	r0, r0
 80037a2:	0940      	lsrs	r0, r0, #5
 80037a4:	f009 fd04 	bl	800d1b0 <_test_assert>
 80037a8:	b1f0      	cbz	r0, 80037e8 <oslib_test_001_002_execute.lto_priv.34+0x2f8>
 80037aa:	2300      	movs	r3, #0
 80037ac:	f383 8811 	msr	BASEPRI, r3
 80037b0:	e032      	b.n	8003818 <oslib_test_001_002_execute.lto_priv.34+0x328>
 80037b2:	bf00      	nop
 80037b4:	20003e04 	.word	0x20003e04
 80037b8:	20002494 	.word	0x20002494
 80037bc:	0800e494 	.word	0x0800e494
 80037c0:	0800e4a0 	.word	0x0800e4a0
 80037c4:	0800e4ac 	.word	0x0800e4ac
 80037c8:	0800e4b8 	.word	0x0800e4b8
 80037cc:	0800e4dc 	.word	0x0800e4dc
 80037d0:	0800e500 	.word	0x0800e500
 80037d4:	0800e518 	.word	0x0800e518
 80037d8:	0800e524 	.word	0x0800e524
 80037dc:	0800e530 	.word	0x0800e530
 80037e0:	0800e548 	.word	0x0800e548
 80037e4:	0800e55c 	.word	0x0800e55c
 80037e8:	2300      	movs	r3, #0
 80037ea:	f383 8811 	msr	BASEPRI, r3
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 80037ee:	4b0b      	ldr	r3, [pc, #44]	; (800381c <oslib_test_001_002_execute.lto_priv.34+0x32c>)
 80037f0:	6818      	ldr	r0, [r3, #0]
 80037f2:	689b      	ldr	r3, [r3, #8]
 80037f4:	490a      	ldr	r1, [pc, #40]	; (8003820 <oslib_test_001_002_execute.lto_priv.34+0x330>)
 80037f6:	4298      	cmp	r0, r3
 80037f8:	bf14      	ite	ne
 80037fa:	2000      	movne	r0, #0
 80037fc:	2001      	moveq	r0, #1
 80037fe:	f009 fcd7 	bl	800d1b0 <_test_assert>
 8003802:	b948      	cbnz	r0, 8003818 <oslib_test_001_002_execute.lto_priv.34+0x328>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8003804:	4b05      	ldr	r3, [pc, #20]	; (800381c <oslib_test_001_002_execute.lto_priv.34+0x32c>)
 8003806:	6818      	ldr	r0, [r3, #0]
 8003808:	68db      	ldr	r3, [r3, #12]
 800380a:	4906      	ldr	r1, [pc, #24]	; (8003824 <oslib_test_001_002_execute.lto_priv.34+0x334>)
 800380c:	4298      	cmp	r0, r3
 800380e:	bf14      	ite	ne
 8003810:	2000      	movne	r0, #0
 8003812:	2001      	moveq	r0, #1
 8003814:	f009 fccc 	bl	800d1b0 <_test_assert>
  }
}
 8003818:	b002      	add	sp, #8
 800381a:	bd70      	pop	{r4, r5, r6, pc}
 800381c:	20002494 	.word	0x20002494
 8003820:	0800e4b8 	.word	0x0800e4b8
 8003824:	0800e4dc 	.word	0x0800e4dc
	...

08003830 <oslib_test_001_002_teardown.lto_priv.33>:
static void oslib_test_001_002_teardown(void) {
 8003830:	b508      	push	{r3, lr}
  chMBReset(&mb1);
 8003832:	4802      	ldr	r0, [pc, #8]	; (800383c <oslib_test_001_002_teardown.lto_priv.33+0xc>)
 8003834:	f006 fab4 	bl	8009da0 <chMBReset>
 8003838:	bd08      	pop	{r3, pc}
 800383a:	bf00      	nop
 800383c:	20002494 	.word	0x20002494

08003840 <oslib_test_001_001_teardown.lto_priv.30>:
static void oslib_test_001_001_teardown(void) {
 8003840:	b508      	push	{r3, lr}
  chMBReset(&mb1);
 8003842:	4802      	ldr	r0, [pc, #8]	; (800384c <oslib_test_001_001_teardown.lto_priv.30+0xc>)
 8003844:	f006 faac 	bl	8009da0 <chMBReset>
 8003848:	bd08      	pop	{r3, pc}
 800384a:	bf00      	nop
 800384c:	20002494 	.word	0x20002494

08003850 <oslib_test_001_002_setup.lto_priv.32>:
static void oslib_test_001_002_setup(void) {
 8003850:	b508      	push	{r3, lr}
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
 8003852:	2204      	movs	r2, #4
 8003854:	4902      	ldr	r1, [pc, #8]	; (8003860 <oslib_test_001_002_setup.lto_priv.32+0x10>)
 8003856:	4803      	ldr	r0, [pc, #12]	; (8003864 <oslib_test_001_002_setup.lto_priv.32+0x14>)
 8003858:	f006 fab2 	bl	8009dc0 <chMBObjectInit>
 800385c:	bd08      	pop	{r3, pc}
 800385e:	bf00      	nop
 8003860:	200031c0 	.word	0x200031c0
 8003864:	20002494 	.word	0x20002494
	...

08003870 <oslib_test_001_001_setup.lto_priv.29>:
static void oslib_test_001_001_setup(void) {
 8003870:	b508      	push	{r3, lr}
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
 8003872:	2204      	movs	r2, #4
 8003874:	4902      	ldr	r1, [pc, #8]	; (8003880 <oslib_test_001_001_setup.lto_priv.29+0x10>)
 8003876:	4803      	ldr	r0, [pc, #12]	; (8003884 <oslib_test_001_001_setup.lto_priv.29+0x14>)
 8003878:	f006 faa2 	bl	8009dc0 <chMBObjectInit>
 800387c:	bd08      	pop	{r3, pc}
 800387e:	bf00      	nop
 8003880:	200031c0 	.word	0x200031c0
 8003884:	20002494 	.word	0x20002494
	...

08003890 <oslib_test_001_001_execute.lto_priv.31>:
static void oslib_test_001_001_execute(void) {
 8003890:	b510      	push	{r4, lr}
 8003892:	b082      	sub	sp, #8
  test_set_step(1);
 8003894:	2201      	movs	r2, #1
 8003896:	4b8e      	ldr	r3, [pc, #568]	; (8003ad0 <oslib_test_001_001_execute.lto_priv.31+0x240>)
 8003898:	601a      	str	r2, [r3, #0]
 800389a:	2320      	movs	r3, #32
 800389c:	f383 8811 	msr	BASEPRI, r3
  return (size_t)(mbp->top - mbp->buffer);
 80038a0:	4a8c      	ldr	r2, [pc, #560]	; (8003ad4 <oslib_test_001_001_execute.lto_priv.31+0x244>)
 80038a2:	6853      	ldr	r3, [r2, #4]
 80038a4:	6810      	ldr	r0, [r2, #0]
 80038a6:	1a18      	subs	r0, r3, r0
  return mbp->cnt;
 80038a8:	6913      	ldr	r3, [r2, #16]
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 80038aa:	ebc3 00a0 	rsb	r0, r3, r0, asr #2
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 80038ae:	498a      	ldr	r1, [pc, #552]	; (8003ad8 <oslib_test_001_001_execute.lto_priv.31+0x248>)
 80038b0:	2804      	cmp	r0, #4
 80038b2:	bf14      	ite	ne
 80038b4:	2000      	movne	r0, #0
 80038b6:	2001      	moveq	r0, #1
 80038b8:	f009 fc7a 	bl	800d1b0 <_test_assert>
 80038bc:	b118      	cbz	r0, 80038c6 <oslib_test_001_001_execute.lto_priv.31+0x36>
 80038be:	2300      	movs	r3, #0
 80038c0:	f383 8811 	msr	BASEPRI, r3
 80038c4:	e19b      	b.n	8003bfe <oslib_test_001_001_execute.lto_priv.31+0x36e>
 80038c6:	2300      	movs	r3, #0
 80038c8:	f383 8811 	msr	BASEPRI, r3
  test_set_step(2);
 80038cc:	2202      	movs	r2, #2
 80038ce:	4b80      	ldr	r3, [pc, #512]	; (8003ad0 <oslib_test_001_001_execute.lto_priv.31+0x240>)
 80038d0:	601a      	str	r2, [r3, #0]
    chMBReset(&mb1);
 80038d2:	4c80      	ldr	r4, [pc, #512]	; (8003ad4 <oslib_test_001_001_execute.lto_priv.31+0x244>)
 80038d4:	4620      	mov	r0, r4
 80038d6:	f006 fa63 	bl	8009da0 <chMBReset>
 80038da:	2320      	movs	r3, #32
 80038dc:	f383 8811 	msr	BASEPRI, r3
  return (size_t)(mbp->top - mbp->buffer);
 80038e0:	6863      	ldr	r3, [r4, #4]
 80038e2:	6820      	ldr	r0, [r4, #0]
 80038e4:	1a18      	subs	r0, r3, r0
  return mbp->cnt;
 80038e6:	6923      	ldr	r3, [r4, #16]
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 80038e8:	ebc3 00a0 	rsb	r0, r3, r0, asr #2
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 80038ec:	497b      	ldr	r1, [pc, #492]	; (8003adc <oslib_test_001_001_execute.lto_priv.31+0x24c>)
 80038ee:	2804      	cmp	r0, #4
 80038f0:	bf14      	ite	ne
 80038f2:	2000      	movne	r0, #0
 80038f4:	2001      	moveq	r0, #1
 80038f6:	f009 fc5b 	bl	800d1b0 <_test_assert>
 80038fa:	b118      	cbz	r0, 8003904 <oslib_test_001_001_execute.lto_priv.31+0x74>
 80038fc:	2300      	movs	r3, #0
 80038fe:	f383 8811 	msr	BASEPRI, r3
 8003902:	e17c      	b.n	8003bfe <oslib_test_001_001_execute.lto_priv.31+0x36e>
 8003904:	2300      	movs	r3, #0
 8003906:	f383 8811 	msr	BASEPRI, r3
 800390a:	2320      	movs	r3, #32
 800390c:	f383 8811 	msr	BASEPRI, r3
  return mbp->cnt;
 8003910:	4b70      	ldr	r3, [pc, #448]	; (8003ad4 <oslib_test_001_001_execute.lto_priv.31+0x244>)
 8003912:	6918      	ldr	r0, [r3, #16]
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 8003914:	4972      	ldr	r1, [pc, #456]	; (8003ae0 <oslib_test_001_001_execute.lto_priv.31+0x250>)
 8003916:	fab0 f080 	clz	r0, r0
 800391a:	0940      	lsrs	r0, r0, #5
 800391c:	f009 fc48 	bl	800d1b0 <_test_assert>
 8003920:	b118      	cbz	r0, 800392a <oslib_test_001_001_execute.lto_priv.31+0x9a>
 8003922:	2300      	movs	r3, #0
 8003924:	f383 8811 	msr	BASEPRI, r3
 8003928:	e169      	b.n	8003bfe <oslib_test_001_001_execute.lto_priv.31+0x36e>
 800392a:	2300      	movs	r3, #0
 800392c:	f383 8811 	msr	BASEPRI, r3
 8003930:	2320      	movs	r3, #32
 8003932:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8003936:	4b67      	ldr	r3, [pc, #412]	; (8003ad4 <oslib_test_001_001_execute.lto_priv.31+0x244>)
 8003938:	6818      	ldr	r0, [r3, #0]
 800393a:	689b      	ldr	r3, [r3, #8]
 800393c:	4969      	ldr	r1, [pc, #420]	; (8003ae4 <oslib_test_001_001_execute.lto_priv.31+0x254>)
 800393e:	4298      	cmp	r0, r3
 8003940:	bf14      	ite	ne
 8003942:	2000      	movne	r0, #0
 8003944:	2001      	moveq	r0, #1
 8003946:	f009 fc33 	bl	800d1b0 <_test_assert>
 800394a:	b118      	cbz	r0, 8003954 <oslib_test_001_001_execute.lto_priv.31+0xc4>
 800394c:	2300      	movs	r3, #0
 800394e:	f383 8811 	msr	BASEPRI, r3
 8003952:	e154      	b.n	8003bfe <oslib_test_001_001_execute.lto_priv.31+0x36e>
 8003954:	2300      	movs	r3, #0
 8003956:	f383 8811 	msr	BASEPRI, r3
 800395a:	2320      	movs	r3, #32
 800395c:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8003960:	4b5c      	ldr	r3, [pc, #368]	; (8003ad4 <oslib_test_001_001_execute.lto_priv.31+0x244>)
 8003962:	6818      	ldr	r0, [r3, #0]
 8003964:	68db      	ldr	r3, [r3, #12]
 8003966:	4960      	ldr	r1, [pc, #384]	; (8003ae8 <oslib_test_001_001_execute.lto_priv.31+0x258>)
 8003968:	4298      	cmp	r0, r3
 800396a:	bf14      	ite	ne
 800396c:	2000      	movne	r0, #0
 800396e:	2001      	moveq	r0, #1
 8003970:	f009 fc1e 	bl	800d1b0 <_test_assert>
 8003974:	b118      	cbz	r0, 800397e <oslib_test_001_001_execute.lto_priv.31+0xee>
 8003976:	2300      	movs	r3, #0
 8003978:	f383 8811 	msr	BASEPRI, r3
 800397c:	e13f      	b.n	8003bfe <oslib_test_001_001_execute.lto_priv.31+0x36e>
 800397e:	2100      	movs	r1, #0
 8003980:	f381 8811 	msr	BASEPRI, r1
  test_set_step(3);
 8003984:	2203      	movs	r2, #3
 8003986:	4b52      	ldr	r3, [pc, #328]	; (8003ad0 <oslib_test_001_001_execute.lto_priv.31+0x240>)
 8003988:	601a      	str	r2, [r3, #0]
    msg1 = chMBPostTimeout(&mb1, (msg_t)0, TIME_INFINITE);
 800398a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800398e:	4851      	ldr	r0, [pc, #324]	; (8003ad4 <oslib_test_001_001_execute.lto_priv.31+0x244>)
 8003990:	f006 f9de 	bl	8009d50 <chMBPostTimeout>
    test_assert(msg1 == MSG_RESET, "not in reset state");
 8003994:	4955      	ldr	r1, [pc, #340]	; (8003aec <oslib_test_001_001_execute.lto_priv.31+0x25c>)
 8003996:	f110 0f02 	cmn.w	r0, #2
 800399a:	bf14      	ite	ne
 800399c:	2000      	movne	r0, #0
 800399e:	2001      	moveq	r0, #1
 80039a0:	f009 fc06 	bl	800d1b0 <_test_assert>
 80039a4:	2800      	cmp	r0, #0
 80039a6:	f040 812a 	bne.w	8003bfe <oslib_test_001_001_execute.lto_priv.31+0x36e>
    msg1 = chMBPostAheadTimeout(&mb1, (msg_t)0, TIME_INFINITE);
 80039aa:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80039ae:	2100      	movs	r1, #0
 80039b0:	4848      	ldr	r0, [pc, #288]	; (8003ad4 <oslib_test_001_001_execute.lto_priv.31+0x244>)
 80039b2:	f006 f995 	bl	8009ce0 <chMBPostAheadTimeout>
    test_assert(msg1 == MSG_RESET, "not in reset state");
 80039b6:	494d      	ldr	r1, [pc, #308]	; (8003aec <oslib_test_001_001_execute.lto_priv.31+0x25c>)
 80039b8:	f110 0f02 	cmn.w	r0, #2
 80039bc:	bf14      	ite	ne
 80039be:	2000      	movne	r0, #0
 80039c0:	2001      	moveq	r0, #1
 80039c2:	f009 fbf5 	bl	800d1b0 <_test_assert>
 80039c6:	2800      	cmp	r0, #0
 80039c8:	f040 8119 	bne.w	8003bfe <oslib_test_001_001_execute.lto_priv.31+0x36e>
    msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
 80039cc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80039d0:	a901      	add	r1, sp, #4
 80039d2:	4840      	ldr	r0, [pc, #256]	; (8003ad4 <oslib_test_001_001_execute.lto_priv.31+0x244>)
 80039d4:	f006 f94c 	bl	8009c70 <chMBFetchTimeout>
    test_assert(msg1 == MSG_RESET, "not in reset state");
 80039d8:	4944      	ldr	r1, [pc, #272]	; (8003aec <oslib_test_001_001_execute.lto_priv.31+0x25c>)
 80039da:	f110 0f02 	cmn.w	r0, #2
 80039de:	bf14      	ite	ne
 80039e0:	2000      	movne	r0, #0
 80039e2:	2001      	moveq	r0, #1
 80039e4:	f009 fbe4 	bl	800d1b0 <_test_assert>
 80039e8:	2800      	cmp	r0, #0
 80039ea:	f040 8108 	bne.w	8003bfe <oslib_test_001_001_execute.lto_priv.31+0x36e>
  mbp->reset = false;
 80039ee:	2400      	movs	r4, #0
 80039f0:	4b38      	ldr	r3, [pc, #224]	; (8003ad4 <oslib_test_001_001_execute.lto_priv.31+0x244>)
 80039f2:	751c      	strb	r4, [r3, #20]
  test_set_step(4);
 80039f4:	2204      	movs	r2, #4
 80039f6:	4b36      	ldr	r3, [pc, #216]	; (8003ad0 <oslib_test_001_001_execute.lto_priv.31+0x240>)
 80039f8:	601a      	str	r2, [r3, #0]
 80039fa:	e010      	b.n	8003a1e <oslib_test_001_001_execute.lto_priv.31+0x18e>
      msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 80039fc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8003a00:	f104 0142 	add.w	r1, r4, #66	; 0x42
 8003a04:	4833      	ldr	r0, [pc, #204]	; (8003ad4 <oslib_test_001_001_execute.lto_priv.31+0x244>)
 8003a06:	f006 f9a3 	bl	8009d50 <chMBPostTimeout>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8003a0a:	4939      	ldr	r1, [pc, #228]	; (8003af0 <oslib_test_001_001_execute.lto_priv.31+0x260>)
 8003a0c:	fab0 f080 	clz	r0, r0
 8003a10:	0940      	lsrs	r0, r0, #5
 8003a12:	f009 fbcd 	bl	800d1b0 <_test_assert>
 8003a16:	2800      	cmp	r0, #0
 8003a18:	f040 80f1 	bne.w	8003bfe <oslib_test_001_001_execute.lto_priv.31+0x36e>
    for (i = 0; i < MB_SIZE - 1; i++) {
 8003a1c:	3401      	adds	r4, #1
 8003a1e:	2c02      	cmp	r4, #2
 8003a20:	d9ec      	bls.n	80039fc <oslib_test_001_001_execute.lto_priv.31+0x16c>
    msg1 = chMBPostAheadTimeout(&mb1, 'A', TIME_INFINITE);
 8003a22:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8003a26:	2141      	movs	r1, #65	; 0x41
 8003a28:	482a      	ldr	r0, [pc, #168]	; (8003ad4 <oslib_test_001_001_execute.lto_priv.31+0x244>)
 8003a2a:	f006 f959 	bl	8009ce0 <chMBPostAheadTimeout>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8003a2e:	4930      	ldr	r1, [pc, #192]	; (8003af0 <oslib_test_001_001_execute.lto_priv.31+0x260>)
 8003a30:	fab0 f080 	clz	r0, r0
 8003a34:	0940      	lsrs	r0, r0, #5
 8003a36:	f009 fbbb 	bl	800d1b0 <_test_assert>
 8003a3a:	2800      	cmp	r0, #0
 8003a3c:	f040 80df 	bne.w	8003bfe <oslib_test_001_001_execute.lto_priv.31+0x36e>
  test_set_step(5);
 8003a40:	2205      	movs	r2, #5
 8003a42:	4b23      	ldr	r3, [pc, #140]	; (8003ad0 <oslib_test_001_001_execute.lto_priv.31+0x240>)
 8003a44:	601a      	str	r2, [r3, #0]
 8003a46:	2320      	movs	r3, #32
 8003a48:	f383 8811 	msr	BASEPRI, r3
  return (size_t)(mbp->top - mbp->buffer);
 8003a4c:	4a21      	ldr	r2, [pc, #132]	; (8003ad4 <oslib_test_001_001_execute.lto_priv.31+0x244>)
 8003a4e:	6853      	ldr	r3, [r2, #4]
 8003a50:	6811      	ldr	r1, [r2, #0]
 8003a52:	1a5b      	subs	r3, r3, r1
  return mbp->cnt;
 8003a54:	6912      	ldr	r2, [r2, #16]
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
 8003a56:	ebb2 0fa3 	cmp.w	r2, r3, asr #2
 8003a5a:	4926      	ldr	r1, [pc, #152]	; (8003af4 <oslib_test_001_001_execute.lto_priv.31+0x264>)
 8003a5c:	bf0c      	ite	eq
 8003a5e:	2001      	moveq	r0, #1
 8003a60:	2000      	movne	r0, #0
 8003a62:	f009 fba5 	bl	800d1b0 <_test_assert>
 8003a66:	b118      	cbz	r0, 8003a70 <oslib_test_001_001_execute.lto_priv.31+0x1e0>
 8003a68:	2300      	movs	r3, #0
 8003a6a:	f383 8811 	msr	BASEPRI, r3
 8003a6e:	e0c6      	b.n	8003bfe <oslib_test_001_001_execute.lto_priv.31+0x36e>
 8003a70:	2300      	movs	r3, #0
 8003a72:	f383 8811 	msr	BASEPRI, r3
 8003a76:	2320      	movs	r3, #32
 8003a78:	f383 8811 	msr	BASEPRI, r3
 8003a7c:	4b15      	ldr	r3, [pc, #84]	; (8003ad4 <oslib_test_001_001_execute.lto_priv.31+0x244>)
 8003a7e:	6918      	ldr	r0, [r3, #16]
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 8003a80:	491d      	ldr	r1, [pc, #116]	; (8003af8 <oslib_test_001_001_execute.lto_priv.31+0x268>)
 8003a82:	2804      	cmp	r0, #4
 8003a84:	bf14      	ite	ne
 8003a86:	2000      	movne	r0, #0
 8003a88:	2001      	moveq	r0, #1
 8003a8a:	f009 fb91 	bl	800d1b0 <_test_assert>
 8003a8e:	b118      	cbz	r0, 8003a98 <oslib_test_001_001_execute.lto_priv.31+0x208>
 8003a90:	2300      	movs	r3, #0
 8003a92:	f383 8811 	msr	BASEPRI, r3
 8003a96:	e0b2      	b.n	8003bfe <oslib_test_001_001_execute.lto_priv.31+0x36e>
 8003a98:	2300      	movs	r3, #0
 8003a9a:	f383 8811 	msr	BASEPRI, r3
 8003a9e:	2320      	movs	r3, #32
 8003aa0:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
 8003aa4:	4b0b      	ldr	r3, [pc, #44]	; (8003ad4 <oslib_test_001_001_execute.lto_priv.31+0x244>)
 8003aa6:	68d8      	ldr	r0, [r3, #12]
 8003aa8:	689b      	ldr	r3, [r3, #8]
 8003aaa:	4914      	ldr	r1, [pc, #80]	; (8003afc <oslib_test_001_001_execute.lto_priv.31+0x26c>)
 8003aac:	4298      	cmp	r0, r3
 8003aae:	bf14      	ite	ne
 8003ab0:	2000      	movne	r0, #0
 8003ab2:	2001      	moveq	r0, #1
 8003ab4:	f009 fb7c 	bl	800d1b0 <_test_assert>
 8003ab8:	b118      	cbz	r0, 8003ac2 <oslib_test_001_001_execute.lto_priv.31+0x232>
 8003aba:	2300      	movs	r3, #0
 8003abc:	f383 8811 	msr	BASEPRI, r3
 8003ac0:	e09d      	b.n	8003bfe <oslib_test_001_001_execute.lto_priv.31+0x36e>
 8003ac2:	2400      	movs	r4, #0
 8003ac4:	f384 8811 	msr	BASEPRI, r4
  test_set_step(6);
 8003ac8:	2206      	movs	r2, #6
 8003aca:	4b01      	ldr	r3, [pc, #4]	; (8003ad0 <oslib_test_001_001_execute.lto_priv.31+0x240>)
 8003acc:	601a      	str	r2, [r3, #0]
 8003ace:	e02a      	b.n	8003b26 <oslib_test_001_001_execute.lto_priv.31+0x296>
 8003ad0:	20003e04 	.word	0x20003e04
 8003ad4:	20002494 	.word	0x20002494
 8003ad8:	0800e494 	.word	0x0800e494
 8003adc:	0800e4a0 	.word	0x0800e4a0
 8003ae0:	0800e4ac 	.word	0x0800e4ac
 8003ae4:	0800e4b8 	.word	0x0800e4b8
 8003ae8:	0800e4dc 	.word	0x0800e4dc
 8003aec:	0800e564 	.word	0x0800e564
 8003af0:	0800e500 	.word	0x0800e500
 8003af4:	0800e518 	.word	0x0800e518
 8003af8:	0800e524 	.word	0x0800e524
 8003afc:	0800e530 	.word	0x0800e530
      msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
 8003b00:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8003b04:	a901      	add	r1, sp, #4
 8003b06:	483f      	ldr	r0, [pc, #252]	; (8003c04 <oslib_test_001_001_execute.lto_priv.31+0x374>)
 8003b08:	f006 f8b2 	bl	8009c70 <chMBFetchTimeout>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8003b0c:	493e      	ldr	r1, [pc, #248]	; (8003c08 <oslib_test_001_001_execute.lto_priv.31+0x378>)
 8003b0e:	fab0 f080 	clz	r0, r0
 8003b12:	0940      	lsrs	r0, r0, #5
 8003b14:	f009 fb4c 	bl	800d1b0 <_test_assert>
 8003b18:	2800      	cmp	r0, #0
 8003b1a:	d170      	bne.n	8003bfe <oslib_test_001_001_execute.lto_priv.31+0x36e>
      test_emit_token(msg2);
 8003b1c:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8003b20:	f008 ff36 	bl	800c990 <test_emit_token>
    for (i = 0; i < MB_SIZE; i++) {
 8003b24:	3401      	adds	r4, #1
 8003b26:	2c03      	cmp	r4, #3
 8003b28:	d9ea      	bls.n	8003b00 <oslib_test_001_001_execute.lto_priv.31+0x270>
    test_assert_sequence("ABCD", "wrong get sequence");
 8003b2a:	4938      	ldr	r1, [pc, #224]	; (8003c0c <oslib_test_001_001_execute.lto_priv.31+0x37c>)
 8003b2c:	4838      	ldr	r0, [pc, #224]	; (8003c10 <oslib_test_001_001_execute.lto_priv.31+0x380>)
 8003b2e:	f009 fb17 	bl	800d160 <_test_assert_sequence>
 8003b32:	2800      	cmp	r0, #0
 8003b34:	d163      	bne.n	8003bfe <oslib_test_001_001_execute.lto_priv.31+0x36e>
  test_set_step(7);
 8003b36:	2207      	movs	r2, #7
 8003b38:	4b36      	ldr	r3, [pc, #216]	; (8003c14 <oslib_test_001_001_execute.lto_priv.31+0x384>)
 8003b3a:	601a      	str	r2, [r3, #0]
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 8003b3c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8003b40:	f104 0142 	add.w	r1, r4, #66	; 0x42
 8003b44:	482f      	ldr	r0, [pc, #188]	; (8003c04 <oslib_test_001_001_execute.lto_priv.31+0x374>)
 8003b46:	f006 f903 	bl	8009d50 <chMBPostTimeout>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8003b4a:	492f      	ldr	r1, [pc, #188]	; (8003c08 <oslib_test_001_001_execute.lto_priv.31+0x378>)
 8003b4c:	fab0 f080 	clz	r0, r0
 8003b50:	0940      	lsrs	r0, r0, #5
 8003b52:	f009 fb2d 	bl	800d1b0 <_test_assert>
 8003b56:	2800      	cmp	r0, #0
 8003b58:	d151      	bne.n	8003bfe <oslib_test_001_001_execute.lto_priv.31+0x36e>
    msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
 8003b5a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8003b5e:	a901      	add	r1, sp, #4
 8003b60:	4828      	ldr	r0, [pc, #160]	; (8003c04 <oslib_test_001_001_execute.lto_priv.31+0x374>)
 8003b62:	f006 f885 	bl	8009c70 <chMBFetchTimeout>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8003b66:	4928      	ldr	r1, [pc, #160]	; (8003c08 <oslib_test_001_001_execute.lto_priv.31+0x378>)
 8003b68:	fab0 f080 	clz	r0, r0
 8003b6c:	0940      	lsrs	r0, r0, #5
 8003b6e:	f009 fb1f 	bl	800d1b0 <_test_assert>
 8003b72:	2800      	cmp	r0, #0
 8003b74:	d143      	bne.n	8003bfe <oslib_test_001_001_execute.lto_priv.31+0x36e>
  test_set_step(8);
 8003b76:	2208      	movs	r2, #8
 8003b78:	4b26      	ldr	r3, [pc, #152]	; (8003c14 <oslib_test_001_001_execute.lto_priv.31+0x384>)
 8003b7a:	601a      	str	r2, [r3, #0]
 8003b7c:	2320      	movs	r3, #32
 8003b7e:	f383 8811 	msr	BASEPRI, r3
  return (size_t)(mbp->top - mbp->buffer);
 8003b82:	4a20      	ldr	r2, [pc, #128]	; (8003c04 <oslib_test_001_001_execute.lto_priv.31+0x374>)
 8003b84:	6853      	ldr	r3, [r2, #4]
 8003b86:	6810      	ldr	r0, [r2, #0]
 8003b88:	1a18      	subs	r0, r3, r0
  return mbp->cnt;
 8003b8a:	6913      	ldr	r3, [r2, #16]
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8003b8c:	ebc3 00a0 	rsb	r0, r3, r0, asr #2
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8003b90:	4921      	ldr	r1, [pc, #132]	; (8003c18 <oslib_test_001_001_execute.lto_priv.31+0x388>)
 8003b92:	2804      	cmp	r0, #4
 8003b94:	bf14      	ite	ne
 8003b96:	2000      	movne	r0, #0
 8003b98:	2001      	moveq	r0, #1
 8003b9a:	f009 fb09 	bl	800d1b0 <_test_assert>
 8003b9e:	b118      	cbz	r0, 8003ba8 <oslib_test_001_001_execute.lto_priv.31+0x318>
 8003ba0:	2300      	movs	r3, #0
 8003ba2:	f383 8811 	msr	BASEPRI, r3
 8003ba6:	e02a      	b.n	8003bfe <oslib_test_001_001_execute.lto_priv.31+0x36e>
 8003ba8:	2300      	movs	r3, #0
 8003baa:	f383 8811 	msr	BASEPRI, r3
 8003bae:	2320      	movs	r3, #32
 8003bb0:	f383 8811 	msr	BASEPRI, r3
  return mbp->cnt;
 8003bb4:	4b13      	ldr	r3, [pc, #76]	; (8003c04 <oslib_test_001_001_execute.lto_priv.31+0x374>)
 8003bb6:	6918      	ldr	r0, [r3, #16]
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 8003bb8:	4918      	ldr	r1, [pc, #96]	; (8003c1c <oslib_test_001_001_execute.lto_priv.31+0x38c>)
 8003bba:	fab0 f080 	clz	r0, r0
 8003bbe:	0940      	lsrs	r0, r0, #5
 8003bc0:	f009 faf6 	bl	800d1b0 <_test_assert>
 8003bc4:	b118      	cbz	r0, 8003bce <oslib_test_001_001_execute.lto_priv.31+0x33e>
 8003bc6:	2300      	movs	r3, #0
 8003bc8:	f383 8811 	msr	BASEPRI, r3
 8003bcc:	e017      	b.n	8003bfe <oslib_test_001_001_execute.lto_priv.31+0x36e>
 8003bce:	2300      	movs	r3, #0
 8003bd0:	f383 8811 	msr	BASEPRI, r3
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8003bd4:	4b0b      	ldr	r3, [pc, #44]	; (8003c04 <oslib_test_001_001_execute.lto_priv.31+0x374>)
 8003bd6:	6818      	ldr	r0, [r3, #0]
 8003bd8:	689b      	ldr	r3, [r3, #8]
 8003bda:	4911      	ldr	r1, [pc, #68]	; (8003c20 <oslib_test_001_001_execute.lto_priv.31+0x390>)
 8003bdc:	4298      	cmp	r0, r3
 8003bde:	bf14      	ite	ne
 8003be0:	2000      	movne	r0, #0
 8003be2:	2001      	moveq	r0, #1
 8003be4:	f009 fae4 	bl	800d1b0 <_test_assert>
 8003be8:	b948      	cbnz	r0, 8003bfe <oslib_test_001_001_execute.lto_priv.31+0x36e>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8003bea:	4b06      	ldr	r3, [pc, #24]	; (8003c04 <oslib_test_001_001_execute.lto_priv.31+0x374>)
 8003bec:	6818      	ldr	r0, [r3, #0]
 8003bee:	68db      	ldr	r3, [r3, #12]
 8003bf0:	490c      	ldr	r1, [pc, #48]	; (8003c24 <oslib_test_001_001_execute.lto_priv.31+0x394>)
 8003bf2:	4298      	cmp	r0, r3
 8003bf4:	bf14      	ite	ne
 8003bf6:	2000      	movne	r0, #0
 8003bf8:	2001      	moveq	r0, #1
 8003bfa:	f009 fad9 	bl	800d1b0 <_test_assert>
}
 8003bfe:	b002      	add	sp, #8
 8003c00:	bd10      	pop	{r4, pc}
 8003c02:	bf00      	nop
 8003c04:	20002494 	.word	0x20002494
 8003c08:	0800e500 	.word	0x0800e500
 8003c0c:	0800e548 	.word	0x0800e548
 8003c10:	0800e55c 	.word	0x0800e55c
 8003c14:	20003e04 	.word	0x20003e04
 8003c18:	0800e4a0 	.word	0x0800e4a0
 8003c1c:	0800e4ac 	.word	0x0800e4ac
 8003c20:	0800e4b8 	.word	0x0800e4b8
 8003c24:	0800e4dc 	.word	0x0800e4dc
	...

08003c30 <rt_test_010_012_execute.lto_priv.135>:
 * - [10.12.8] The size of an event listener is printed.
 * - [10.12.9] The size of a mailbox is printed.
 * .
 */

static void rt_test_010_012_execute(void) {
 8003c30:	b570      	push	{r4, r5, r6, lr}

  /* [10.12.1] The size of the system area is printed.*/
  test_set_step(1);
 8003c32:	4d33      	ldr	r5, [pc, #204]	; (8003d00 <rt_test_010_012_execute.lto_priv.135+0xd0>)
 8003c34:	2301      	movs	r3, #1
 8003c36:	602b      	str	r3, [r5, #0]
  {
    test_print("--- System: ");
 8003c38:	4832      	ldr	r0, [pc, #200]	; (8003d04 <rt_test_010_012_execute.lto_priv.135+0xd4>)
 8003c3a:	f008 fec1 	bl	800c9c0 <test_print>
    test_printn(sizeof(ch_system_t));
 8003c3e:	2078      	movs	r0, #120	; 0x78
 8003c40:	f008 fede 	bl	800ca00 <test_printn>
    test_println(" bytes");
 8003c44:	4c30      	ldr	r4, [pc, #192]	; (8003d08 <rt_test_010_012_execute.lto_priv.135+0xd8>)
 8003c46:	4620      	mov	r0, r4
 8003c48:	f008 feca 	bl	800c9e0 <test_println>
  }

  /* [10.12.2] The size of a thread structure is printed.*/
  test_set_step(2);
 8003c4c:	2302      	movs	r3, #2
 8003c4e:	602b      	str	r3, [r5, #0]
  {
    test_print("--- Thread: ");
 8003c50:	482e      	ldr	r0, [pc, #184]	; (8003d0c <rt_test_010_012_execute.lto_priv.135+0xdc>)
 8003c52:	f008 feb5 	bl	800c9c0 <test_print>
    test_printn(sizeof(thread_t));
 8003c56:	2044      	movs	r0, #68	; 0x44
 8003c58:	f008 fed2 	bl	800ca00 <test_printn>
    test_println(" bytes");
 8003c5c:	4620      	mov	r0, r4
 8003c5e:	f008 febf 	bl	800c9e0 <test_println>
  }

  /* [10.12.3] The size of a virtual timer structure is printed.*/
  test_set_step(3);
 8003c62:	2303      	movs	r3, #3
 8003c64:	602b      	str	r3, [r5, #0]
  {
    test_print("--- Timer : ");
 8003c66:	482a      	ldr	r0, [pc, #168]	; (8003d10 <rt_test_010_012_execute.lto_priv.135+0xe0>)
 8003c68:	f008 feaa 	bl	800c9c0 <test_print>
    test_printn(sizeof(virtual_timer_t));
 8003c6c:	2014      	movs	r0, #20
 8003c6e:	f008 fec7 	bl	800ca00 <test_printn>
    test_println(" bytes");
 8003c72:	4620      	mov	r0, r4
 8003c74:	f008 feb4 	bl	800c9e0 <test_println>
  }

  /* [10.12.4] The size of a semaphore structure is printed.*/
  test_set_step(4);
 8003c78:	2604      	movs	r6, #4
 8003c7a:	602e      	str	r6, [r5, #0]
  {
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
    test_print("--- Semaph: ");
 8003c7c:	4825      	ldr	r0, [pc, #148]	; (8003d14 <rt_test_010_012_execute.lto_priv.135+0xe4>)
 8003c7e:	f008 fe9f 	bl	800c9c0 <test_print>
    test_printn(sizeof(semaphore_t));
 8003c82:	200c      	movs	r0, #12
 8003c84:	f008 febc 	bl	800ca00 <test_printn>
    test_println(" bytes");
 8003c88:	4620      	mov	r0, r4
 8003c8a:	f008 fea9 	bl	800c9e0 <test_println>
#endif
  }

  /* [10.12.5] The size of a mutex is printed.*/
  test_set_step(5);
 8003c8e:	2305      	movs	r3, #5
 8003c90:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
    test_print("--- Mutex : ");
 8003c92:	4821      	ldr	r0, [pc, #132]	; (8003d18 <rt_test_010_012_execute.lto_priv.135+0xe8>)
 8003c94:	f008 fe94 	bl	800c9c0 <test_print>
    test_printn(sizeof(mutex_t));
 8003c98:	2010      	movs	r0, #16
 8003c9a:	f008 feb1 	bl	800ca00 <test_printn>
    test_println(" bytes");
 8003c9e:	4620      	mov	r0, r4
 8003ca0:	f008 fe9e 	bl	800c9e0 <test_println>
#endif
  }

  /* [10.12.6] The size of a condition variable is printed.*/
  test_set_step(6);
 8003ca4:	2306      	movs	r3, #6
 8003ca6:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
    test_print("--- CondV.: ");
 8003ca8:	481c      	ldr	r0, [pc, #112]	; (8003d1c <rt_test_010_012_execute.lto_priv.135+0xec>)
 8003caa:	f008 fe89 	bl	800c9c0 <test_print>
    test_printn(sizeof(condition_variable_t));
 8003cae:	2008      	movs	r0, #8
 8003cb0:	f008 fea6 	bl	800ca00 <test_printn>
    test_println(" bytes");
 8003cb4:	4620      	mov	r0, r4
 8003cb6:	f008 fe93 	bl	800c9e0 <test_println>
#endif
  }

  /* [10.12.7] The size of an event source is printed.*/
  test_set_step(7);
 8003cba:	2307      	movs	r3, #7
 8003cbc:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventS: ");
 8003cbe:	4818      	ldr	r0, [pc, #96]	; (8003d20 <rt_test_010_012_execute.lto_priv.135+0xf0>)
 8003cc0:	f008 fe7e 	bl	800c9c0 <test_print>
    test_printn(sizeof(event_source_t));
 8003cc4:	4630      	mov	r0, r6
 8003cc6:	f008 fe9b 	bl	800ca00 <test_printn>
    test_println(" bytes");
 8003cca:	4620      	mov	r0, r4
 8003ccc:	f008 fe88 	bl	800c9e0 <test_println>
#endif
  }

  /* [10.12.8] The size of an event listener is printed.*/
  test_set_step(8);
 8003cd0:	2308      	movs	r3, #8
 8003cd2:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventL: ");
 8003cd4:	4813      	ldr	r0, [pc, #76]	; (8003d24 <rt_test_010_012_execute.lto_priv.135+0xf4>)
 8003cd6:	f008 fe73 	bl	800c9c0 <test_print>
    test_printn(sizeof(event_listener_t));
 8003cda:	2014      	movs	r0, #20
 8003cdc:	f008 fe90 	bl	800ca00 <test_printn>
    test_println(" bytes");
 8003ce0:	4620      	mov	r0, r4
 8003ce2:	f008 fe7d 	bl	800c9e0 <test_println>
#endif
  }

  /* [10.12.9] The size of a mailbox is printed.*/
  test_set_step(9);
 8003ce6:	2309      	movs	r3, #9
 8003ce8:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
    test_print("--- MailB.: ");
 8003cea:	480f      	ldr	r0, [pc, #60]	; (8003d28 <rt_test_010_012_execute.lto_priv.135+0xf8>)
 8003cec:	f008 fe68 	bl	800c9c0 <test_print>
    test_printn(sizeof(mailbox_t));
 8003cf0:	2028      	movs	r0, #40	; 0x28
 8003cf2:	f008 fe85 	bl	800ca00 <test_printn>
    test_println(" bytes");
 8003cf6:	4620      	mov	r0, r4
 8003cf8:	f008 fe72 	bl	800c9e0 <test_println>
 8003cfc:	bd70      	pop	{r4, r5, r6, pc}
 8003cfe:	bf00      	nop
 8003d00:	20003e04 	.word	0x20003e04
 8003d04:	0800e578 	.word	0x0800e578
 8003d08:	0800e588 	.word	0x0800e588
 8003d0c:	0800e590 	.word	0x0800e590
 8003d10:	0800e5a0 	.word	0x0800e5a0
 8003d14:	0800e5b0 	.word	0x0800e5b0
 8003d18:	0800e5c0 	.word	0x0800e5c0
 8003d1c:	0800e5d0 	.word	0x0800e5d0
 8003d20:	0800e5e0 	.word	0x0800e5e0
 8003d24:	0800e5f0 	.word	0x0800e5f0
 8003d28:	0800e600 	.word	0x0800e600
 8003d2c:	00000000 	.word	0x00000000

08003d30 <rt_test_010_011_execute.lto_priv.134>:
static void rt_test_010_011_execute(void) {
 8003d30:	b570      	push	{r4, r5, r6, lr}
  test_set_step(1);
 8003d32:	2201      	movs	r2, #1
 8003d34:	4b19      	ldr	r3, [pc, #100]	; (8003d9c <rt_test_010_011_execute.lto_priv.134+0x6c>)
 8003d36:	601a      	str	r2, [r3, #0]
    start = test_wait_tick();
 8003d38:	f008 fdf2 	bl	800c920 <test_wait_tick>
 8003d3c:	4606      	mov	r6, r0
    n = 0;
 8003d3e:	2500      	movs	r5, #0
      chMtxLock(&mtx1);
 8003d40:	4c17      	ldr	r4, [pc, #92]	; (8003da0 <rt_test_010_011_execute.lto_priv.134+0x70>)
 8003d42:	4620      	mov	r0, r4
 8003d44:	f007 fe04 	bl	800b950 <chMtxLock>
      chMtxUnlock(&mtx1);
 8003d48:	4620      	mov	r0, r4
 8003d4a:	f007 fc41 	bl	800b5d0 <chMtxUnlock>
      chMtxLock(&mtx1);
 8003d4e:	4620      	mov	r0, r4
 8003d50:	f007 fdfe 	bl	800b950 <chMtxLock>
      chMtxUnlock(&mtx1);
 8003d54:	4620      	mov	r0, r4
 8003d56:	f007 fc3b 	bl	800b5d0 <chMtxUnlock>
      chMtxLock(&mtx1);
 8003d5a:	4620      	mov	r0, r4
 8003d5c:	f007 fdf8 	bl	800b950 <chMtxLock>
      chMtxUnlock(&mtx1);
 8003d60:	4620      	mov	r0, r4
 8003d62:	f007 fc35 	bl	800b5d0 <chMtxUnlock>
      chMtxLock(&mtx1);
 8003d66:	4620      	mov	r0, r4
 8003d68:	f007 fdf2 	bl	800b950 <chMtxLock>
      chMtxUnlock(&mtx1);
 8003d6c:	4620      	mov	r0, r4
 8003d6e:	f007 fc2f 	bl	800b5d0 <chMtxUnlock>
      n++;
 8003d72:	3501      	adds	r5, #1
  return (systime_t)STM32_ST_TIM->CNT;
 8003d74:	4b0b      	ldr	r3, [pc, #44]	; (8003da4 <rt_test_010_011_execute.lto_priv.134+0x74>)
 8003d76:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 */
static inline bool chTimeIsInRangeX(systime_t time,
                                    systime_t start,
                                    systime_t end) {

  return (bool)((time - start) < (end - start));
 8003d78:	1b9b      	subs	r3, r3, r6
    } while (chVTIsSystemTimeWithinX(start, end));
 8003d7a:	f242 720f 	movw	r2, #9999	; 0x270f
 8003d7e:	4293      	cmp	r3, r2
 8003d80:	d9de      	bls.n	8003d40 <rt_test_010_011_execute.lto_priv.134+0x10>
  test_set_step(2);
 8003d82:	2202      	movs	r2, #2
 8003d84:	4b05      	ldr	r3, [pc, #20]	; (8003d9c <rt_test_010_011_execute.lto_priv.134+0x6c>)
 8003d86:	601a      	str	r2, [r3, #0]
    test_print("--- Score : ");
 8003d88:	4807      	ldr	r0, [pc, #28]	; (8003da8 <rt_test_010_011_execute.lto_priv.134+0x78>)
 8003d8a:	f008 fe19 	bl	800c9c0 <test_print>
    test_printn(n * 4);
 8003d8e:	00a8      	lsls	r0, r5, #2
 8003d90:	f008 fe36 	bl	800ca00 <test_printn>
    test_println(" lock+unlock/S");
 8003d94:	4805      	ldr	r0, [pc, #20]	; (8003dac <rt_test_010_011_execute.lto_priv.134+0x7c>)
 8003d96:	f008 fe23 	bl	800c9e0 <test_println>
 8003d9a:	bd70      	pop	{r4, r5, r6, pc}
 8003d9c:	20003e04 	.word	0x20003e04
 8003da0:	20002f00 	.word	0x20002f00
 8003da4:	40000c00 	.word	0x40000c00
 8003da8:	0800e610 	.word	0x0800e610
 8003dac:	0800e620 	.word	0x0800e620

08003db0 <rt_test_010_011_setup.lto_priv.133>:
static void rt_test_010_011_setup(void) {
 8003db0:	b508      	push	{r3, lr}
  chMtxObjectInit(&mtx1);
 8003db2:	4802      	ldr	r0, [pc, #8]	; (8003dbc <rt_test_010_011_setup.lto_priv.133+0xc>)
 8003db4:	f007 fa44 	bl	800b240 <chMtxObjectInit>
 8003db8:	bd08      	pop	{r3, pc}
 8003dba:	bf00      	nop
 8003dbc:	20002f00 	.word	0x20002f00

08003dc0 <rt_test_010_010_execute.lto_priv.132>:
static void rt_test_010_010_execute(void) {
 8003dc0:	b570      	push	{r4, r5, r6, lr}
  test_set_step(1);
 8003dc2:	2201      	movs	r2, #1
 8003dc4:	4b19      	ldr	r3, [pc, #100]	; (8003e2c <rt_test_010_010_execute.lto_priv.132+0x6c>)
 8003dc6:	601a      	str	r2, [r3, #0]
    start = test_wait_tick();
 8003dc8:	f008 fdaa 	bl	800c920 <test_wait_tick>
 8003dcc:	4606      	mov	r6, r0
    n = 0;
 8003dce:	2500      	movs	r5, #0
      chSemWait(&sem1);
 8003dd0:	4c17      	ldr	r4, [pc, #92]	; (8003e30 <rt_test_010_010_execute.lto_priv.132+0x70>)
 8003dd2:	4620      	mov	r0, r4
 8003dd4:	f007 fe14 	bl	800ba00 <chSemWait>
      chSemSignal(&sem1);
 8003dd8:	4620      	mov	r0, r4
 8003dda:	f007 fc91 	bl	800b700 <chSemSignal>
      chSemWait(&sem1);
 8003dde:	4620      	mov	r0, r4
 8003de0:	f007 fe0e 	bl	800ba00 <chSemWait>
      chSemSignal(&sem1);
 8003de4:	4620      	mov	r0, r4
 8003de6:	f007 fc8b 	bl	800b700 <chSemSignal>
      chSemWait(&sem1);
 8003dea:	4620      	mov	r0, r4
 8003dec:	f007 fe08 	bl	800ba00 <chSemWait>
      chSemSignal(&sem1);
 8003df0:	4620      	mov	r0, r4
 8003df2:	f007 fc85 	bl	800b700 <chSemSignal>
      chSemWait(&sem1);
 8003df6:	4620      	mov	r0, r4
 8003df8:	f007 fe02 	bl	800ba00 <chSemWait>
      chSemSignal(&sem1);
 8003dfc:	4620      	mov	r0, r4
 8003dfe:	f007 fc7f 	bl	800b700 <chSemSignal>
      n++;
 8003e02:	3501      	adds	r5, #1
 8003e04:	4b0b      	ldr	r3, [pc, #44]	; (8003e34 <rt_test_010_010_execute.lto_priv.132+0x74>)
 8003e06:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003e08:	1b9b      	subs	r3, r3, r6
    } while (chVTIsSystemTimeWithinX(start, end));
 8003e0a:	f242 720f 	movw	r2, #9999	; 0x270f
 8003e0e:	4293      	cmp	r3, r2
 8003e10:	d9de      	bls.n	8003dd0 <rt_test_010_010_execute.lto_priv.132+0x10>
  test_set_step(2);
 8003e12:	2202      	movs	r2, #2
 8003e14:	4b05      	ldr	r3, [pc, #20]	; (8003e2c <rt_test_010_010_execute.lto_priv.132+0x6c>)
 8003e16:	601a      	str	r2, [r3, #0]
    test_print("--- Score : ");
 8003e18:	4807      	ldr	r0, [pc, #28]	; (8003e38 <rt_test_010_010_execute.lto_priv.132+0x78>)
 8003e1a:	f008 fdd1 	bl	800c9c0 <test_print>
    test_printn(n * 4);
 8003e1e:	00a8      	lsls	r0, r5, #2
 8003e20:	f008 fdee 	bl	800ca00 <test_printn>
    test_println(" wait+signal/S");
 8003e24:	4805      	ldr	r0, [pc, #20]	; (8003e3c <rt_test_010_010_execute.lto_priv.132+0x7c>)
 8003e26:	f008 fddb 	bl	800c9e0 <test_println>
 8003e2a:	bd70      	pop	{r4, r5, r6, pc}
 8003e2c:	20003e04 	.word	0x20003e04
 8003e30:	20002f10 	.word	0x20002f10
 8003e34:	40000c00 	.word	0x40000c00
 8003e38:	0800e610 	.word	0x0800e610
 8003e3c:	0800e630 	.word	0x0800e630

08003e40 <bmk_thread7>:
static THD_FUNCTION(bmk_thread7, p) {
 8003e40:	b508      	push	{r3, lr}
 8003e42:	e002      	b.n	8003e4a <bmk_thread7+0xa>
    chSemWait(&sem1);
 8003e44:	4805      	ldr	r0, [pc, #20]	; (8003e5c <bmk_thread7+0x1c>)
 8003e46:	f007 fddb 	bl	800ba00 <chSemWait>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8003e4a:	4b05      	ldr	r3, [pc, #20]	; (8003e60 <bmk_thread7+0x20>)
 8003e4c:	699b      	ldr	r3, [r3, #24]
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8003e4e:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
  while (!chThdShouldTerminateX())
 8003e52:	f013 0f04 	tst.w	r3, #4
 8003e56:	d0f5      	beq.n	8003e44 <bmk_thread7+0x4>
}
 8003e58:	bd08      	pop	{r3, pc}
 8003e5a:	bf00      	nop
 8003e5c:	20002f10 	.word	0x20002f10
 8003e60:	20003aec 	.word	0x20003aec
	...

08003e70 <rt_test_010_010_setup.lto_priv.131>:
static void rt_test_010_010_setup(void) {
 8003e70:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 1);
 8003e72:	2101      	movs	r1, #1
 8003e74:	4801      	ldr	r0, [pc, #4]	; (8003e7c <rt_test_010_010_setup.lto_priv.131+0xc>)
 8003e76:	f007 fa13 	bl	800b2a0 <chSemObjectInit>
 8003e7a:	bd08      	pop	{r3, pc}
 8003e7c:	20002f10 	.word	0x20002f10

08003e80 <rt_test_010_007_setup.lto_priv.127>:
static void rt_test_010_007_setup(void) {
 8003e80:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 0);
 8003e82:	2100      	movs	r1, #0
 8003e84:	4801      	ldr	r0, [pc, #4]	; (8003e8c <rt_test_010_007_setup.lto_priv.127+0xc>)
 8003e86:	f007 fa0b 	bl	800b2a0 <chSemObjectInit>
 8003e8a:	bd08      	pop	{r3, pc}
 8003e8c:	20002f10 	.word	0x20002f10

08003e90 <rt_test_010_009_execute.lto_priv.130>:
static void rt_test_010_009_execute(void) {
 8003e90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  test_set_step(1);
 8003e94:	2201      	movs	r2, #1
 8003e96:	4b1c      	ldr	r3, [pc, #112]	; (8003f08 <rt_test_010_009_execute.lto_priv.130+0x78>)
 8003e98:	601a      	str	r2, [r3, #0]
    start = test_wait_tick();
 8003e9a:	f008 fd41 	bl	800c920 <test_wait_tick>
 8003e9e:	4680      	mov	r8, r0
    n = 0;
 8003ea0:	2700      	movs	r7, #0
 8003ea2:	2320      	movs	r3, #32
 8003ea4:	f383 8811 	msr	BASEPRI, r3
      chVTDoSetI(&vt1, 1, tmo, NULL);
 8003ea8:	4e18      	ldr	r6, [pc, #96]	; (8003f0c <rt_test_010_009_execute.lto_priv.130+0x7c>)
 8003eaa:	4d19      	ldr	r5, [pc, #100]	; (8003f10 <rt_test_010_009_execute.lto_priv.130+0x80>)
 8003eac:	2300      	movs	r3, #0
 8003eae:	4632      	mov	r2, r6
 8003eb0:	2101      	movs	r1, #1
 8003eb2:	4628      	mov	r0, r5
 8003eb4:	f002 fd3c 	bl	8006930 <chVTDoSetI>
      chVTDoSetI(&vt2, 10000, tmo, NULL);
 8003eb8:	4c16      	ldr	r4, [pc, #88]	; (8003f14 <rt_test_010_009_execute.lto_priv.130+0x84>)
 8003eba:	2300      	movs	r3, #0
 8003ebc:	4632      	mov	r2, r6
 8003ebe:	f242 7110 	movw	r1, #10000	; 0x2710
 8003ec2:	4620      	mov	r0, r4
 8003ec4:	f002 fd34 	bl	8006930 <chVTDoSetI>
      chVTDoResetI(&vt1);
 8003ec8:	4628      	mov	r0, r5
 8003eca:	f002 fcf1 	bl	80068b0 <chVTDoResetI>
      chVTDoResetI(&vt2);
 8003ece:	4620      	mov	r0, r4
 8003ed0:	f002 fcee 	bl	80068b0 <chVTDoResetI>
 8003ed4:	2300      	movs	r3, #0
 8003ed6:	f383 8811 	msr	BASEPRI, r3
      n++;
 8003eda:	3701      	adds	r7, #1
 8003edc:	4b0e      	ldr	r3, [pc, #56]	; (8003f18 <rt_test_010_009_execute.lto_priv.130+0x88>)
 8003ede:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003ee0:	ebc8 0303 	rsb	r3, r8, r3
    } while (chVTIsSystemTimeWithinX(start, end));
 8003ee4:	f242 720f 	movw	r2, #9999	; 0x270f
 8003ee8:	4293      	cmp	r3, r2
 8003eea:	d9da      	bls.n	8003ea2 <rt_test_010_009_execute.lto_priv.130+0x12>
  test_set_step(2);
 8003eec:	2202      	movs	r2, #2
 8003eee:	4b06      	ldr	r3, [pc, #24]	; (8003f08 <rt_test_010_009_execute.lto_priv.130+0x78>)
 8003ef0:	601a      	str	r2, [r3, #0]
    test_print("--- Score : ");
 8003ef2:	480a      	ldr	r0, [pc, #40]	; (8003f1c <rt_test_010_009_execute.lto_priv.130+0x8c>)
 8003ef4:	f008 fd64 	bl	800c9c0 <test_print>
    test_printn(n * 2);
 8003ef8:	0078      	lsls	r0, r7, #1
 8003efa:	f008 fd81 	bl	800ca00 <test_printn>
    test_println(" timers/S");
 8003efe:	4808      	ldr	r0, [pc, #32]	; (8003f20 <rt_test_010_009_execute.lto_priv.130+0x90>)
 8003f00:	f008 fd6e 	bl	800c9e0 <test_println>
 8003f04:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003f08:	20003e04 	.word	0x20003e04
 8003f0c:	08004601 	.word	0x08004601
 8003f10:	20002f44 	.word	0x20002f44
 8003f14:	20002f30 	.word	0x20002f30
 8003f18:	40000c00 	.word	0x40000c00
 8003f1c:	0800e610 	.word	0x0800e610
 8003f20:	0800e640 	.word	0x0800e640
	...

08003f30 <rt_test_010_008_execute.lto_priv.129>:
static void rt_test_010_008_execute(void) {
 8003f30:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8003f34:	b085      	sub	sp, #20
  test_set_step(1);
 8003f36:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 800401c <rt_test_010_008_execute.lto_priv.129+0xec>
 8003f3a:	2301      	movs	r3, #1
 8003f3c:	f8c9 3000 	str.w	r3, [r9]
    n = 0;
 8003f40:	ac04      	add	r4, sp, #16
 8003f42:	2300      	movs	r3, #0
 8003f44:	f844 3d04 	str.w	r3, [r4, #-4]!
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8003f48:	f008 fcea 	bl	800c920 <test_wait_tick>
  return ch.rlist.current;
 8003f4c:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 8004020 <rt_test_010_008_execute.lto_priv.129+0xf0>
 8003f50:	f8d8 3018 	ldr.w	r3, [r8, #24]
  return chThdGetSelfX()->prio;
 8003f54:	689a      	ldr	r2, [r3, #8]
 8003f56:	4f2c      	ldr	r7, [pc, #176]	; (8004008 <rt_test_010_008_execute.lto_priv.129+0xd8>)
 8003f58:	4e2c      	ldr	r6, [pc, #176]	; (800400c <rt_test_010_008_execute.lto_priv.129+0xdc>)
 8003f5a:	9400      	str	r4, [sp, #0]
 8003f5c:	463b      	mov	r3, r7
 8003f5e:	3a01      	subs	r2, #1
 8003f60:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003f64:	4630      	mov	r0, r6
 8003f66:	f007 fc03 	bl	800b770 <chThdCreateStatic>
 8003f6a:	4d29      	ldr	r5, [pc, #164]	; (8004010 <rt_test_010_008_execute.lto_priv.129+0xe0>)
 8003f6c:	6028      	str	r0, [r5, #0]
  return ch.rlist.current;
 8003f6e:	f8d8 3018 	ldr.w	r3, [r8, #24]
  return chThdGetSelfX()->prio;
 8003f72:	689a      	ldr	r2, [r3, #8]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8003f74:	9400      	str	r4, [sp, #0]
 8003f76:	463b      	mov	r3, r7
 8003f78:	3a01      	subs	r2, #1
 8003f7a:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003f7e:	1870      	adds	r0, r6, r1
 8003f80:	f007 fbf6 	bl	800b770 <chThdCreateStatic>
 8003f84:	6068      	str	r0, [r5, #4]
  return ch.rlist.current;
 8003f86:	f8d8 3018 	ldr.w	r3, [r8, #24]
  return chThdGetSelfX()->prio;
 8003f8a:	689a      	ldr	r2, [r3, #8]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8003f8c:	9400      	str	r4, [sp, #0]
 8003f8e:	463b      	mov	r3, r7
 8003f90:	3a01      	subs	r2, #1
 8003f92:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003f96:	f506 7068 	add.w	r0, r6, #928	; 0x3a0
 8003f9a:	f007 fbe9 	bl	800b770 <chThdCreateStatic>
 8003f9e:	60a8      	str	r0, [r5, #8]
  return ch.rlist.current;
 8003fa0:	f8d8 3018 	ldr.w	r3, [r8, #24]
  return chThdGetSelfX()->prio;
 8003fa4:	689a      	ldr	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8003fa6:	9400      	str	r4, [sp, #0]
 8003fa8:	463b      	mov	r3, r7
 8003faa:	3a01      	subs	r2, #1
 8003fac:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003fb0:	f506 60ae 	add.w	r0, r6, #1392	; 0x570
 8003fb4:	f007 fbdc 	bl	800b770 <chThdCreateStatic>
 8003fb8:	60e8      	str	r0, [r5, #12]
  return ch.rlist.current;
 8003fba:	f8d8 3018 	ldr.w	r3, [r8, #24]
  return chThdGetSelfX()->prio;
 8003fbe:	689a      	ldr	r2, [r3, #8]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8003fc0:	9400      	str	r4, [sp, #0]
 8003fc2:	463b      	mov	r3, r7
 8003fc4:	3a01      	subs	r2, #1
 8003fc6:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8003fca:	f506 60e8 	add.w	r0, r6, #1856	; 0x740
 8003fce:	f007 fbcf 	bl	800b770 <chThdCreateStatic>
 8003fd2:	6128      	str	r0, [r5, #16]
  test_set_step(2);
 8003fd4:	2302      	movs	r3, #2
 8003fd6:	f8c9 3000 	str.w	r3, [r9]
    chThdSleepSeconds(1);
 8003fda:	f242 7010 	movw	r0, #10000	; 0x2710
 8003fde:	f007 fe37 	bl	800bc50 <chThdSleep>
    test_terminate_threads();
 8003fe2:	f008 fcc5 	bl	800c970 <test_terminate_threads>
    test_wait_threads();
 8003fe6:	f008 fcab 	bl	800c940 <test_wait_threads>
  test_set_step(3);
 8003fea:	2303      	movs	r3, #3
 8003fec:	f8c9 3000 	str.w	r3, [r9]
    test_print("--- Score : ");
 8003ff0:	4808      	ldr	r0, [pc, #32]	; (8004014 <rt_test_010_008_execute.lto_priv.129+0xe4>)
 8003ff2:	f008 fce5 	bl	800c9c0 <test_print>
    test_printn(n);
 8003ff6:	9803      	ldr	r0, [sp, #12]
 8003ff8:	f008 fd02 	bl	800ca00 <test_printn>
    test_println(" ctxswc/S");
 8003ffc:	4806      	ldr	r0, [pc, #24]	; (8004018 <rt_test_010_008_execute.lto_priv.129+0xe8>)
 8003ffe:	f008 fcef 	bl	800c9e0 <test_println>
}
 8004002:	b005      	add	sp, #20
 8004004:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8004008:	08004031 	.word	0x08004031
 800400c:	200025f0 	.word	0x200025f0
 8004010:	20002f1c 	.word	0x20002f1c
 8004014:	0800e610 	.word	0x0800e610
 8004018:	0800e64c 	.word	0x0800e64c
 800401c:	20003e04 	.word	0x20003e04
 8004020:	20003aec 	.word	0x20003aec
	...

08004030 <bmk_thread8>:
static THD_FUNCTION(bmk_thread8, p) {
 8004030:	b510      	push	{r4, lr}
 8004032:	4604      	mov	r4, r0
    chThdYield();
 8004034:	f007 f994 	bl	800b360 <chThdYield>
    chThdYield();
 8004038:	f007 f992 	bl	800b360 <chThdYield>
    chThdYield();
 800403c:	f007 f990 	bl	800b360 <chThdYield>
    chThdYield();
 8004040:	f007 f98e 	bl	800b360 <chThdYield>
    (*(uint32_t *)p) += 4;
 8004044:	6823      	ldr	r3, [r4, #0]
 8004046:	3304      	adds	r3, #4
 8004048:	6023      	str	r3, [r4, #0]
  return ch.rlist.current;
 800404a:	4b04      	ldr	r3, [pc, #16]	; (800405c <bmk_thread8+0x2c>)
 800404c:	699b      	ldr	r3, [r3, #24]
  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 800404e:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
  } while(!chThdShouldTerminateX());
 8004052:	f013 0f04 	tst.w	r3, #4
 8004056:	d0ed      	beq.n	8004034 <bmk_thread8+0x4>
}
 8004058:	bd10      	pop	{r4, pc}
 800405a:	bf00      	nop
 800405c:	20003aec 	.word	0x20003aec

08004060 <rt_test_010_007_execute.lto_priv.128>:
static void rt_test_010_007_execute(void) {
 8004060:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8004064:	b083      	sub	sp, #12
  test_set_step(1);
 8004066:	f8df 910c 	ldr.w	r9, [pc, #268]	; 8004174 <rt_test_010_007_execute.lto_priv.128+0x114>
 800406a:	2301      	movs	r3, #1
 800406c:	f8c9 3000 	str.w	r3, [r9]
  return ch.rlist.current;
 8004070:	f8df 8110 	ldr.w	r8, [pc, #272]	; 8004184 <rt_test_010_007_execute.lto_priv.128+0x124>
 8004074:	f8d8 3018 	ldr.w	r3, [r8, #24]
  return chThdGetSelfX()->prio;
 8004078:	689a      	ldr	r2, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 800407a:	4f39      	ldr	r7, [pc, #228]	; (8004160 <rt_test_010_007_execute.lto_priv.128+0x100>)
 800407c:	4e39      	ldr	r6, [pc, #228]	; (8004164 <rt_test_010_007_execute.lto_priv.128+0x104>)
 800407e:	2400      	movs	r4, #0
 8004080:	9400      	str	r4, [sp, #0]
 8004082:	463b      	mov	r3, r7
 8004084:	3205      	adds	r2, #5
 8004086:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800408a:	4630      	mov	r0, r6
 800408c:	f007 fb70 	bl	800b770 <chThdCreateStatic>
 8004090:	4d35      	ldr	r5, [pc, #212]	; (8004168 <rt_test_010_007_execute.lto_priv.128+0x108>)
 8004092:	6028      	str	r0, [r5, #0]
  return ch.rlist.current;
 8004094:	f8d8 3018 	ldr.w	r3, [r8, #24]
  return chThdGetSelfX()->prio;
 8004098:	689a      	ldr	r2, [r3, #8]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
 800409a:	9400      	str	r4, [sp, #0]
 800409c:	463b      	mov	r3, r7
 800409e:	3204      	adds	r2, #4
 80040a0:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80040a4:	1870      	adds	r0, r6, r1
 80040a6:	f007 fb63 	bl	800b770 <chThdCreateStatic>
 80040aa:	6068      	str	r0, [r5, #4]
  return ch.rlist.current;
 80040ac:	f8d8 3018 	ldr.w	r3, [r8, #24]
  return chThdGetSelfX()->prio;
 80040b0:	689a      	ldr	r2, [r3, #8]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
 80040b2:	9400      	str	r4, [sp, #0]
 80040b4:	463b      	mov	r3, r7
 80040b6:	3203      	adds	r2, #3
 80040b8:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80040bc:	f506 7068 	add.w	r0, r6, #928	; 0x3a0
 80040c0:	f007 fb56 	bl	800b770 <chThdCreateStatic>
 80040c4:	60a8      	str	r0, [r5, #8]
  return ch.rlist.current;
 80040c6:	f8d8 3018 	ldr.w	r3, [r8, #24]
  return chThdGetSelfX()->prio;
 80040ca:	689a      	ldr	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
 80040cc:	9400      	str	r4, [sp, #0]
 80040ce:	463b      	mov	r3, r7
 80040d0:	3202      	adds	r2, #2
 80040d2:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80040d6:	f506 60ae 	add.w	r0, r6, #1392	; 0x570
 80040da:	f007 fb49 	bl	800b770 <chThdCreateStatic>
 80040de:	60e8      	str	r0, [r5, #12]
  return ch.rlist.current;
 80040e0:	f8d8 3018 	ldr.w	r3, [r8, #24]
  return chThdGetSelfX()->prio;
 80040e4:	689a      	ldr	r2, [r3, #8]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 80040e6:	9400      	str	r4, [sp, #0]
 80040e8:	463b      	mov	r3, r7
 80040ea:	3201      	adds	r2, #1
 80040ec:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80040f0:	f506 60e8 	add.w	r0, r6, #1856	; 0x740
 80040f4:	f007 fb3c 	bl	800b770 <chThdCreateStatic>
 80040f8:	6128      	str	r0, [r5, #16]
  test_set_step(2);
 80040fa:	2302      	movs	r3, #2
 80040fc:	f8c9 3000 	str.w	r3, [r9]
    start = test_wait_tick();
 8004100:	f008 fc0e 	bl	800c920 <test_wait_tick>
 8004104:	4605      	mov	r5, r0
      chSemReset(&sem1, 0);
 8004106:	2100      	movs	r1, #0
 8004108:	4818      	ldr	r0, [pc, #96]	; (800416c <rt_test_010_007_execute.lto_priv.128+0x10c>)
 800410a:	f007 fa91 	bl	800b630 <chSemReset>
      n++;
 800410e:	3401      	adds	r4, #1
 8004110:	4b17      	ldr	r3, [pc, #92]	; (8004170 <rt_test_010_007_execute.lto_priv.128+0x110>)
 8004112:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004114:	1b5b      	subs	r3, r3, r5
    } while (chVTIsSystemTimeWithinX(start, end));
 8004116:	f242 720f 	movw	r2, #9999	; 0x270f
 800411a:	4293      	cmp	r3, r2
 800411c:	d9f3      	bls.n	8004106 <rt_test_010_007_execute.lto_priv.128+0xa6>
  test_set_step(3);
 800411e:	4d15      	ldr	r5, [pc, #84]	; (8004174 <rt_test_010_007_execute.lto_priv.128+0x114>)
 8004120:	2303      	movs	r3, #3
 8004122:	602b      	str	r3, [r5, #0]
    test_terminate_threads();
 8004124:	f008 fc24 	bl	800c970 <test_terminate_threads>
    chSemReset(&sem1, 0);
 8004128:	2100      	movs	r1, #0
 800412a:	4810      	ldr	r0, [pc, #64]	; (800416c <rt_test_010_007_execute.lto_priv.128+0x10c>)
 800412c:	f007 fa80 	bl	800b630 <chSemReset>
    test_wait_threads();
 8004130:	f008 fc06 	bl	800c940 <test_wait_threads>
  test_set_step(4);
 8004134:	2304      	movs	r3, #4
 8004136:	602b      	str	r3, [r5, #0]
    test_print("--- Score : ");
 8004138:	480f      	ldr	r0, [pc, #60]	; (8004178 <rt_test_010_007_execute.lto_priv.128+0x118>)
 800413a:	f008 fc41 	bl	800c9c0 <test_print>
    test_printn(n);
 800413e:	4620      	mov	r0, r4
 8004140:	f008 fc5e 	bl	800ca00 <test_printn>
    test_print(" reschedules/S, ");
 8004144:	480d      	ldr	r0, [pc, #52]	; (800417c <rt_test_010_007_execute.lto_priv.128+0x11c>)
 8004146:	f008 fc3b 	bl	800c9c0 <test_print>
    test_printn(n * 6);
 800414a:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 800414e:	0060      	lsls	r0, r4, #1
 8004150:	f008 fc56 	bl	800ca00 <test_printn>
    test_println(" ctxswc/S");
 8004154:	480a      	ldr	r0, [pc, #40]	; (8004180 <rt_test_010_007_execute.lto_priv.128+0x120>)
 8004156:	f008 fc43 	bl	800c9e0 <test_println>
}
 800415a:	b003      	add	sp, #12
 800415c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8004160:	08003e41 	.word	0x08003e41
 8004164:	200025f0 	.word	0x200025f0
 8004168:	20002f1c 	.word	0x20002f1c
 800416c:	20002f10 	.word	0x20002f10
 8004170:	40000c00 	.word	0x40000c00
 8004174:	20003e04 	.word	0x20003e04
 8004178:	0800e610 	.word	0x0800e610
 800417c:	0800e658 	.word	0x0800e658
 8004180:	0800e64c 	.word	0x0800e64c
 8004184:	20003aec 	.word	0x20003aec
	...

08004190 <rt_test_010_006_execute.lto_priv.126>:
static void rt_test_010_006_execute(void) {
 8004190:	b570      	push	{r4, r5, r6, lr}
 8004192:	b082      	sub	sp, #8
  return ch.rlist.current;
 8004194:	4b15      	ldr	r3, [pc, #84]	; (80041ec <rt_test_010_006_execute.lto_priv.126+0x5c>)
 8004196:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 8004198:	689d      	ldr	r5, [r3, #8]
  tprio_t prio = chThdGetPriorityX() + 1;
 800419a:	3501      	adds	r5, #1
  test_set_step(1);
 800419c:	2201      	movs	r2, #1
 800419e:	4b14      	ldr	r3, [pc, #80]	; (80041f0 <rt_test_010_006_execute.lto_priv.126+0x60>)
 80041a0:	601a      	str	r2, [r3, #0]
    start = test_wait_tick();
 80041a2:	f008 fbbd 	bl	800c920 <test_wait_tick>
 80041a6:	4606      	mov	r6, r0
    n = 0;
 80041a8:	2400      	movs	r4, #0
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 80041aa:	2300      	movs	r3, #0
 80041ac:	9300      	str	r3, [sp, #0]
 80041ae:	4b11      	ldr	r3, [pc, #68]	; (80041f4 <rt_test_010_006_execute.lto_priv.126+0x64>)
 80041b0:	462a      	mov	r2, r5
 80041b2:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80041b6:	4810      	ldr	r0, [pc, #64]	; (80041f8 <rt_test_010_006_execute.lto_priv.126+0x68>)
 80041b8:	f007 fada 	bl	800b770 <chThdCreateStatic>
 80041bc:	f007 f8f8 	bl	800b3b0 <chThdRelease>
      n++;
 80041c0:	3401      	adds	r4, #1
 80041c2:	4b0e      	ldr	r3, [pc, #56]	; (80041fc <rt_test_010_006_execute.lto_priv.126+0x6c>)
 80041c4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80041c6:	1b9b      	subs	r3, r3, r6
    } while (chVTIsSystemTimeWithinX(start, end));
 80041c8:	f242 720f 	movw	r2, #9999	; 0x270f
 80041cc:	4293      	cmp	r3, r2
 80041ce:	d9ec      	bls.n	80041aa <rt_test_010_006_execute.lto_priv.126+0x1a>
  test_set_step(2);
 80041d0:	2202      	movs	r2, #2
 80041d2:	4b07      	ldr	r3, [pc, #28]	; (80041f0 <rt_test_010_006_execute.lto_priv.126+0x60>)
 80041d4:	601a      	str	r2, [r3, #0]
    test_print("--- Score : ");
 80041d6:	480a      	ldr	r0, [pc, #40]	; (8004200 <rt_test_010_006_execute.lto_priv.126+0x70>)
 80041d8:	f008 fbf2 	bl	800c9c0 <test_print>
    test_printn(n);
 80041dc:	4620      	mov	r0, r4
 80041de:	f008 fc0f 	bl	800ca00 <test_printn>
    test_println(" threads/S");
 80041e2:	4808      	ldr	r0, [pc, #32]	; (8004204 <rt_test_010_006_execute.lto_priv.126+0x74>)
 80041e4:	f008 fbfc 	bl	800c9e0 <test_println>
}
 80041e8:	b002      	add	sp, #8
 80041ea:	bd70      	pop	{r4, r5, r6, pc}
 80041ec:	20003aec 	.word	0x20003aec
 80041f0:	20003e04 	.word	0x20003e04
 80041f4:	080045f1 	.word	0x080045f1
 80041f8:	200025f0 	.word	0x200025f0
 80041fc:	40000c00 	.word	0x40000c00
 8004200:	0800e610 	.word	0x0800e610
 8004204:	0800e66c 	.word	0x0800e66c
	...

08004210 <rt_test_010_005_execute.lto_priv.125>:
static void rt_test_010_005_execute(void) {
 8004210:	b570      	push	{r4, r5, r6, lr}
 8004212:	b082      	sub	sp, #8
  return ch.rlist.current;
 8004214:	4b15      	ldr	r3, [pc, #84]	; (800426c <rt_test_010_005_execute.lto_priv.125+0x5c>)
 8004216:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 8004218:	689d      	ldr	r5, [r3, #8]
  tprio_t prio = chThdGetPriorityX() - 1;
 800421a:	3d01      	subs	r5, #1
  test_set_step(1);
 800421c:	2201      	movs	r2, #1
 800421e:	4b14      	ldr	r3, [pc, #80]	; (8004270 <rt_test_010_005_execute.lto_priv.125+0x60>)
 8004220:	601a      	str	r2, [r3, #0]
    start = test_wait_tick();
 8004222:	f008 fb7d 	bl	800c920 <test_wait_tick>
 8004226:	4606      	mov	r6, r0
    n = 0;
 8004228:	2400      	movs	r4, #0
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 800422a:	2300      	movs	r3, #0
 800422c:	9300      	str	r3, [sp, #0]
 800422e:	4b11      	ldr	r3, [pc, #68]	; (8004274 <rt_test_010_005_execute.lto_priv.125+0x64>)
 8004230:	462a      	mov	r2, r5
 8004232:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8004236:	4810      	ldr	r0, [pc, #64]	; (8004278 <rt_test_010_005_execute.lto_priv.125+0x68>)
 8004238:	f007 fa9a 	bl	800b770 <chThdCreateStatic>
 800423c:	f007 fbf0 	bl	800ba20 <chThdWait>
      n++;
 8004240:	3401      	adds	r4, #1
 8004242:	4b0e      	ldr	r3, [pc, #56]	; (800427c <rt_test_010_005_execute.lto_priv.125+0x6c>)
 8004244:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004246:	1b9b      	subs	r3, r3, r6
    } while (chVTIsSystemTimeWithinX(start, end));
 8004248:	f242 720f 	movw	r2, #9999	; 0x270f
 800424c:	4293      	cmp	r3, r2
 800424e:	d9ec      	bls.n	800422a <rt_test_010_005_execute.lto_priv.125+0x1a>
  test_set_step(2);
 8004250:	2202      	movs	r2, #2
 8004252:	4b07      	ldr	r3, [pc, #28]	; (8004270 <rt_test_010_005_execute.lto_priv.125+0x60>)
 8004254:	601a      	str	r2, [r3, #0]
    test_print("--- Score : ");
 8004256:	480a      	ldr	r0, [pc, #40]	; (8004280 <rt_test_010_005_execute.lto_priv.125+0x70>)
 8004258:	f008 fbb2 	bl	800c9c0 <test_print>
    test_printn(n);
 800425c:	4620      	mov	r0, r4
 800425e:	f008 fbcf 	bl	800ca00 <test_printn>
    test_println(" threads/S");
 8004262:	4808      	ldr	r0, [pc, #32]	; (8004284 <rt_test_010_005_execute.lto_priv.125+0x74>)
 8004264:	f008 fbbc 	bl	800c9e0 <test_println>
}
 8004268:	b002      	add	sp, #8
 800426a:	bd70      	pop	{r4, r5, r6, pc}
 800426c:	20003aec 	.word	0x20003aec
 8004270:	20003e04 	.word	0x20003e04
 8004274:	080045f1 	.word	0x080045f1
 8004278:	200025f0 	.word	0x200025f0
 800427c:	40000c00 	.word	0x40000c00
 8004280:	0800e610 	.word	0x0800e610
 8004284:	0800e66c 	.word	0x0800e66c
	...

08004290 <rt_test_010_004_execute.lto_priv.124>:
static void rt_test_010_004_execute(void) {
 8004290:	b570      	push	{r4, r5, r6, lr}
 8004292:	b082      	sub	sp, #8
  test_set_step(1);
 8004294:	4e28      	ldr	r6, [pc, #160]	; (8004338 <rt_test_010_004_execute.lto_priv.124+0xa8>)
 8004296:	2301      	movs	r3, #1
 8004298:	6033      	str	r3, [r6, #0]
  return ch.rlist.current;
 800429a:	4b28      	ldr	r3, [pc, #160]	; (800433c <rt_test_010_004_execute.lto_priv.124+0xac>)
 800429c:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 800429e:	689a      	ldr	r2, [r3, #8]
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 80042a0:	2500      	movs	r5, #0
 80042a2:	9500      	str	r5, [sp, #0]
 80042a4:	4b26      	ldr	r3, [pc, #152]	; (8004340 <rt_test_010_004_execute.lto_priv.124+0xb0>)
 80042a6:	3201      	adds	r2, #1
 80042a8:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80042ac:	4825      	ldr	r0, [pc, #148]	; (8004344 <rt_test_010_004_execute.lto_priv.124+0xb4>)
 80042ae:	f007 fa5f 	bl	800b770 <chThdCreateStatic>
 80042b2:	4604      	mov	r4, r0
 80042b4:	4b24      	ldr	r3, [pc, #144]	; (8004348 <rt_test_010_004_execute.lto_priv.124+0xb8>)
 80042b6:	6018      	str	r0, [r3, #0]
  test_set_step(2);
 80042b8:	2302      	movs	r3, #2
 80042ba:	6033      	str	r3, [r6, #0]
    start = test_wait_tick();
 80042bc:	f008 fb30 	bl	800c920 <test_wait_tick>
 80042c0:	4606      	mov	r6, r0
 80042c2:	2320      	movs	r3, #32
 80042c4:	f383 8811 	msr	BASEPRI, r3
      chSchWakeupS(tp, MSG_OK);
 80042c8:	2100      	movs	r1, #0
 80042ca:	4620      	mov	r0, r4
 80042cc:	f007 f9e0 	bl	800b690 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 80042d0:	2100      	movs	r1, #0
 80042d2:	4620      	mov	r0, r4
 80042d4:	f007 f9dc 	bl	800b690 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 80042d8:	2100      	movs	r1, #0
 80042da:	4620      	mov	r0, r4
 80042dc:	f007 f9d8 	bl	800b690 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 80042e0:	2100      	movs	r1, #0
 80042e2:	4620      	mov	r0, r4
 80042e4:	f007 f9d4 	bl	800b690 <chSchWakeupS>
 80042e8:	2300      	movs	r3, #0
 80042ea:	f383 8811 	msr	BASEPRI, r3
      n += 4;
 80042ee:	3504      	adds	r5, #4
 80042f0:	4b16      	ldr	r3, [pc, #88]	; (800434c <rt_test_010_004_execute.lto_priv.124+0xbc>)
 80042f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80042f4:	1b9b      	subs	r3, r3, r6
    } while (chVTIsSystemTimeWithinX(start, end));
 80042f6:	f242 720f 	movw	r2, #9999	; 0x270f
 80042fa:	4293      	cmp	r3, r2
 80042fc:	d9e1      	bls.n	80042c2 <rt_test_010_004_execute.lto_priv.124+0x32>
  test_set_step(3);
 80042fe:	4e0e      	ldr	r6, [pc, #56]	; (8004338 <rt_test_010_004_execute.lto_priv.124+0xa8>)
 8004300:	2303      	movs	r3, #3
 8004302:	6033      	str	r3, [r6, #0]
 8004304:	2320      	movs	r3, #32
 8004306:	f383 8811 	msr	BASEPRI, r3
    chSchWakeupS(tp, MSG_TIMEOUT);
 800430a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800430e:	4620      	mov	r0, r4
 8004310:	f007 f9be 	bl	800b690 <chSchWakeupS>
 8004314:	2300      	movs	r3, #0
 8004316:	f383 8811 	msr	BASEPRI, r3
    test_wait_threads();
 800431a:	f008 fb11 	bl	800c940 <test_wait_threads>
  test_set_step(4);
 800431e:	2304      	movs	r3, #4
 8004320:	6033      	str	r3, [r6, #0]
    test_print("--- Score : ");
 8004322:	480b      	ldr	r0, [pc, #44]	; (8004350 <rt_test_010_004_execute.lto_priv.124+0xc0>)
 8004324:	f008 fb4c 	bl	800c9c0 <test_print>
    test_printn(n * 2);
 8004328:	0068      	lsls	r0, r5, #1
 800432a:	f008 fb69 	bl	800ca00 <test_printn>
    test_println(" ctxswc/S");
 800432e:	4809      	ldr	r0, [pc, #36]	; (8004354 <rt_test_010_004_execute.lto_priv.124+0xc4>)
 8004330:	f008 fb56 	bl	800c9e0 <test_println>
}
 8004334:	b002      	add	sp, #8
 8004336:	bd70      	pop	{r4, r5, r6, pc}
 8004338:	20003e04 	.word	0x20003e04
 800433c:	20003aec 	.word	0x20003aec
 8004340:	08004361 	.word	0x08004361
 8004344:	200025f0 	.word	0x200025f0
 8004348:	20002f1c 	.word	0x20002f1c
 800434c:	40000c00 	.word	0x40000c00
 8004350:	0800e610 	.word	0x0800e610
 8004354:	0800e64c 	.word	0x0800e64c
	...

08004360 <bmk_thread4>:
static THD_FUNCTION(bmk_thread4, p) {
 8004360:	b510      	push	{r4, lr}
  return ch.rlist.current;
 8004362:	4b07      	ldr	r3, [pc, #28]	; (8004380 <bmk_thread4+0x20>)
 8004364:	699c      	ldr	r4, [r3, #24]
 8004366:	2320      	movs	r3, #32
 8004368:	f383 8811 	msr	BASEPRI, r3
    chSchGoSleepS(CH_STATE_SUSPENDED);
 800436c:	2003      	movs	r0, #3
 800436e:	f007 fa37 	bl	800b7e0 <chSchGoSleepS>
    msg = self->u.rdymsg;
 8004372:	6a63      	ldr	r3, [r4, #36]	; 0x24
  } while (msg == MSG_OK);
 8004374:	2b00      	cmp	r3, #0
 8004376:	d0f9      	beq.n	800436c <bmk_thread4+0xc>
 8004378:	2300      	movs	r3, #0
 800437a:	f383 8811 	msr	BASEPRI, r3
 800437e:	bd10      	pop	{r4, pc}
 8004380:	20003aec 	.word	0x20003aec
	...

08004390 <bmk_thread1>:
static THD_FUNCTION(bmk_thread1, p) {
 8004390:	b510      	push	{r4, lr}
    tp = chMsgWait();
 8004392:	f005 fd95 	bl	8009ec0 <chMsgWait>
 */
static inline msg_t chMsgGet(thread_t *tp) {

  chDbgAssert(tp->state == CH_STATE_SNDMSG, "invalid state");

  return tp->u.sentmsg;
 8004396:	6a44      	ldr	r4, [r0, #36]	; 0x24
    chMsgRelease(tp, msg);
 8004398:	4621      	mov	r1, r4
 800439a:	f005 fd81 	bl	8009ea0 <chMsgRelease>
  } while (msg);
 800439e:	2c00      	cmp	r4, #0
 80043a0:	d1f7      	bne.n	8004392 <bmk_thread1+0x2>
}
 80043a2:	bd10      	pop	{r4, pc}
	...

080043b0 <msg_loop_test>:
NOINLINE static unsigned int msg_loop_test(thread_t *tp) {
 80043b0:	b570      	push	{r4, r5, r6, lr}
 80043b2:	4605      	mov	r5, r0
  start = test_wait_tick();
 80043b4:	f008 fab4 	bl	800c920 <test_wait_tick>
 80043b8:	4606      	mov	r6, r0
  uint32_t n = 0;
 80043ba:	2400      	movs	r4, #0
    (void)chMsgSend(tp, 1);
 80043bc:	2101      	movs	r1, #1
 80043be:	4628      	mov	r0, r5
 80043c0:	f005 fd9e 	bl	8009f00 <chMsgSend>
    n++;
 80043c4:	3401      	adds	r4, #1
 80043c6:	4b06      	ldr	r3, [pc, #24]	; (80043e0 <msg_loop_test+0x30>)
 80043c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80043ca:	1b9b      	subs	r3, r3, r6
  } while (chVTIsSystemTimeWithinX(start, end));
 80043cc:	f242 720f 	movw	r2, #9999	; 0x270f
 80043d0:	4293      	cmp	r3, r2
 80043d2:	d9f3      	bls.n	80043bc <msg_loop_test+0xc>
  (void)chMsgSend(tp, 0);
 80043d4:	2100      	movs	r1, #0
 80043d6:	4628      	mov	r0, r5
 80043d8:	f005 fd92 	bl	8009f00 <chMsgSend>
}
 80043dc:	4620      	mov	r0, r4
 80043de:	bd70      	pop	{r4, r5, r6, pc}
 80043e0:	40000c00 	.word	0x40000c00
	...

080043f0 <rt_test_010_003_execute.lto_priv.123>:
static void rt_test_010_003_execute(void) {
 80043f0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80043f4:	b083      	sub	sp, #12
  test_set_step(1);
 80043f6:	f8df 80e8 	ldr.w	r8, [pc, #232]	; 80044e0 <rt_test_010_003_execute.lto_priv.123+0xf0>
 80043fa:	2301      	movs	r3, #1
 80043fc:	f8c8 3000 	str.w	r3, [r8]
 8004400:	4f30      	ldr	r7, [pc, #192]	; (80044c4 <rt_test_010_003_execute.lto_priv.123+0xd4>)
 8004402:	69bb      	ldr	r3, [r7, #24]
  return chThdGetSelfX()->prio;
 8004404:	689a      	ldr	r2, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8004406:	4d30      	ldr	r5, [pc, #192]	; (80044c8 <rt_test_010_003_execute.lto_priv.123+0xd8>)
 8004408:	2600      	movs	r6, #0
 800440a:	9600      	str	r6, [sp, #0]
 800440c:	4b2f      	ldr	r3, [pc, #188]	; (80044cc <rt_test_010_003_execute.lto_priv.123+0xdc>)
 800440e:	3201      	adds	r2, #1
 8004410:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8004414:	4628      	mov	r0, r5
 8004416:	f007 f9ab 	bl	800b770 <chThdCreateStatic>
 800441a:	4c2d      	ldr	r4, [pc, #180]	; (80044d0 <rt_test_010_003_execute.lto_priv.123+0xe0>)
 800441c:	6020      	str	r0, [r4, #0]
  test_set_step(2);
 800441e:	2302      	movs	r3, #2
 8004420:	f8c8 3000 	str.w	r3, [r8]
  return ch.rlist.current;
 8004424:	69bb      	ldr	r3, [r7, #24]
  return chThdGetSelfX()->prio;
 8004426:	689a      	ldr	r2, [r3, #8]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 8004428:	f8df 90b8 	ldr.w	r9, [pc, #184]	; 80044e4 <rt_test_010_003_execute.lto_priv.123+0xf4>
 800442c:	9600      	str	r6, [sp, #0]
 800442e:	464b      	mov	r3, r9
 8004430:	3a02      	subs	r2, #2
 8004432:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8004436:	1868      	adds	r0, r5, r1
 8004438:	f007 f99a 	bl	800b770 <chThdCreateStatic>
 800443c:	6060      	str	r0, [r4, #4]
  return ch.rlist.current;
 800443e:	69bb      	ldr	r3, [r7, #24]
  return chThdGetSelfX()->prio;
 8004440:	689a      	ldr	r2, [r3, #8]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
 8004442:	9600      	str	r6, [sp, #0]
 8004444:	464b      	mov	r3, r9
 8004446:	3a03      	subs	r2, #3
 8004448:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800444c:	f505 7068 	add.w	r0, r5, #928	; 0x3a0
 8004450:	f007 f98e 	bl	800b770 <chThdCreateStatic>
 8004454:	60a0      	str	r0, [r4, #8]
  return ch.rlist.current;
 8004456:	69bb      	ldr	r3, [r7, #24]
  return chThdGetSelfX()->prio;
 8004458:	689a      	ldr	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
 800445a:	9600      	str	r6, [sp, #0]
 800445c:	464b      	mov	r3, r9
 800445e:	3a04      	subs	r2, #4
 8004460:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8004464:	f505 60ae 	add.w	r0, r5, #1392	; 0x570
 8004468:	f007 f982 	bl	800b770 <chThdCreateStatic>
 800446c:	60e0      	str	r0, [r4, #12]
  return ch.rlist.current;
 800446e:	69bb      	ldr	r3, [r7, #24]
  return chThdGetSelfX()->prio;
 8004470:	689a      	ldr	r2, [r3, #8]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 8004472:	9600      	str	r6, [sp, #0]
 8004474:	464b      	mov	r3, r9
 8004476:	3a05      	subs	r2, #5
 8004478:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800447c:	f505 60e8 	add.w	r0, r5, #1856	; 0x740
 8004480:	f007 f976 	bl	800b770 <chThdCreateStatic>
 8004484:	6120      	str	r0, [r4, #16]
  test_set_step(3);
 8004486:	2303      	movs	r3, #3
 8004488:	f8c8 3000 	str.w	r3, [r8]
    n = msg_loop_test(threads[0]);
 800448c:	6820      	ldr	r0, [r4, #0]
 800448e:	f7ff ff8f 	bl	80043b0 <msg_loop_test>
 8004492:	4604      	mov	r4, r0
    test_wait_threads();
 8004494:	f008 fa54 	bl	800c940 <test_wait_threads>
  test_set_step(4);
 8004498:	2304      	movs	r3, #4
 800449a:	f8c8 3000 	str.w	r3, [r8]
    test_print("--- Score : ");
 800449e:	480d      	ldr	r0, [pc, #52]	; (80044d4 <rt_test_010_003_execute.lto_priv.123+0xe4>)
 80044a0:	f008 fa8e 	bl	800c9c0 <test_print>
    test_printn(n);
 80044a4:	4620      	mov	r0, r4
 80044a6:	f008 faab 	bl	800ca00 <test_printn>
    test_print(" msgs/S, ");
 80044aa:	480b      	ldr	r0, [pc, #44]	; (80044d8 <rt_test_010_003_execute.lto_priv.123+0xe8>)
 80044ac:	f008 fa88 	bl	800c9c0 <test_print>
    test_printn(n << 1);
 80044b0:	0060      	lsls	r0, r4, #1
 80044b2:	f008 faa5 	bl	800ca00 <test_printn>
    test_println(" ctxswc/S");
 80044b6:	4809      	ldr	r0, [pc, #36]	; (80044dc <rt_test_010_003_execute.lto_priv.123+0xec>)
 80044b8:	f008 fa92 	bl	800c9e0 <test_println>
}
 80044bc:	b003      	add	sp, #12
 80044be:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80044c2:	bf00      	nop
 80044c4:	20003aec 	.word	0x20003aec
 80044c8:	200025f0 	.word	0x200025f0
 80044cc:	08004391 	.word	0x08004391
 80044d0:	20002f1c 	.word	0x20002f1c
 80044d4:	0800e610 	.word	0x0800e610
 80044d8:	0800e678 	.word	0x0800e678
 80044dc:	0800e64c 	.word	0x0800e64c
 80044e0:	20003e04 	.word	0x20003e04
 80044e4:	080045f1 	.word	0x080045f1
	...

080044f0 <rt_test_010_002_execute.lto_priv.122>:
static void rt_test_010_002_execute(void) {
 80044f0:	b530      	push	{r4, r5, lr}
 80044f2:	b083      	sub	sp, #12
  test_set_step(1);
 80044f4:	4c15      	ldr	r4, [pc, #84]	; (800454c <rt_test_010_002_execute.lto_priv.122+0x5c>)
 80044f6:	2301      	movs	r3, #1
 80044f8:	6023      	str	r3, [r4, #0]
  return ch.rlist.current;
 80044fa:	4b15      	ldr	r3, [pc, #84]	; (8004550 <rt_test_010_002_execute.lto_priv.122+0x60>)
 80044fc:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 80044fe:	689a      	ldr	r2, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8004500:	2300      	movs	r3, #0
 8004502:	9300      	str	r3, [sp, #0]
 8004504:	4b13      	ldr	r3, [pc, #76]	; (8004554 <rt_test_010_002_execute.lto_priv.122+0x64>)
 8004506:	3201      	adds	r2, #1
 8004508:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800450c:	4812      	ldr	r0, [pc, #72]	; (8004558 <rt_test_010_002_execute.lto_priv.122+0x68>)
 800450e:	f007 f92f 	bl	800b770 <chThdCreateStatic>
 8004512:	4b12      	ldr	r3, [pc, #72]	; (800455c <rt_test_010_002_execute.lto_priv.122+0x6c>)
 8004514:	6018      	str	r0, [r3, #0]
  test_set_step(2);
 8004516:	2302      	movs	r3, #2
 8004518:	6023      	str	r3, [r4, #0]
    n = msg_loop_test(threads[0]);
 800451a:	f7ff ff49 	bl	80043b0 <msg_loop_test>
 800451e:	4605      	mov	r5, r0
    test_wait_threads();
 8004520:	f008 fa0e 	bl	800c940 <test_wait_threads>
  test_set_step(3);
 8004524:	2303      	movs	r3, #3
 8004526:	6023      	str	r3, [r4, #0]
    test_print("--- Score : ");
 8004528:	480d      	ldr	r0, [pc, #52]	; (8004560 <rt_test_010_002_execute.lto_priv.122+0x70>)
 800452a:	f008 fa49 	bl	800c9c0 <test_print>
    test_printn(n);
 800452e:	4628      	mov	r0, r5
 8004530:	f008 fa66 	bl	800ca00 <test_printn>
    test_print(" msgs/S, ");
 8004534:	480b      	ldr	r0, [pc, #44]	; (8004564 <rt_test_010_002_execute.lto_priv.122+0x74>)
 8004536:	f008 fa43 	bl	800c9c0 <test_print>
    test_printn(n << 1);
 800453a:	0068      	lsls	r0, r5, #1
 800453c:	f008 fa60 	bl	800ca00 <test_printn>
    test_println(" ctxswc/S");
 8004540:	4809      	ldr	r0, [pc, #36]	; (8004568 <rt_test_010_002_execute.lto_priv.122+0x78>)
 8004542:	f008 fa4d 	bl	800c9e0 <test_println>
}
 8004546:	b003      	add	sp, #12
 8004548:	bd30      	pop	{r4, r5, pc}
 800454a:	bf00      	nop
 800454c:	20003e04 	.word	0x20003e04
 8004550:	20003aec 	.word	0x20003aec
 8004554:	08004391 	.word	0x08004391
 8004558:	200025f0 	.word	0x200025f0
 800455c:	20002f1c 	.word	0x20002f1c
 8004560:	0800e610 	.word	0x0800e610
 8004564:	0800e678 	.word	0x0800e678
 8004568:	0800e64c 	.word	0x0800e64c
 800456c:	00000000 	.word	0x00000000

08004570 <rt_test_010_001_execute.lto_priv.121>:
static void rt_test_010_001_execute(void) {
 8004570:	b530      	push	{r4, r5, lr}
 8004572:	b083      	sub	sp, #12
  test_set_step(1);
 8004574:	4c15      	ldr	r4, [pc, #84]	; (80045cc <rt_test_010_001_execute.lto_priv.121+0x5c>)
 8004576:	2301      	movs	r3, #1
 8004578:	6023      	str	r3, [r4, #0]
  return ch.rlist.current;
 800457a:	4b15      	ldr	r3, [pc, #84]	; (80045d0 <rt_test_010_001_execute.lto_priv.121+0x60>)
 800457c:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 800457e:	689a      	ldr	r2, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 8004580:	2300      	movs	r3, #0
 8004582:	9300      	str	r3, [sp, #0]
 8004584:	4b13      	ldr	r3, [pc, #76]	; (80045d4 <rt_test_010_001_execute.lto_priv.121+0x64>)
 8004586:	3a01      	subs	r2, #1
 8004588:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800458c:	4812      	ldr	r0, [pc, #72]	; (80045d8 <rt_test_010_001_execute.lto_priv.121+0x68>)
 800458e:	f007 f8ef 	bl	800b770 <chThdCreateStatic>
 8004592:	4b12      	ldr	r3, [pc, #72]	; (80045dc <rt_test_010_001_execute.lto_priv.121+0x6c>)
 8004594:	6018      	str	r0, [r3, #0]
  test_set_step(2);
 8004596:	2302      	movs	r3, #2
 8004598:	6023      	str	r3, [r4, #0]
    n = msg_loop_test(threads[0]);
 800459a:	f7ff ff09 	bl	80043b0 <msg_loop_test>
 800459e:	4605      	mov	r5, r0
    test_wait_threads();
 80045a0:	f008 f9ce 	bl	800c940 <test_wait_threads>
  test_set_step(3);
 80045a4:	2303      	movs	r3, #3
 80045a6:	6023      	str	r3, [r4, #0]
    test_print("--- Score : ");
 80045a8:	480d      	ldr	r0, [pc, #52]	; (80045e0 <rt_test_010_001_execute.lto_priv.121+0x70>)
 80045aa:	f008 fa09 	bl	800c9c0 <test_print>
    test_printn(n);
 80045ae:	4628      	mov	r0, r5
 80045b0:	f008 fa26 	bl	800ca00 <test_printn>
    test_print(" msgs/S, ");
 80045b4:	480b      	ldr	r0, [pc, #44]	; (80045e4 <rt_test_010_001_execute.lto_priv.121+0x74>)
 80045b6:	f008 fa03 	bl	800c9c0 <test_print>
    test_printn(n << 1);
 80045ba:	0068      	lsls	r0, r5, #1
 80045bc:	f008 fa20 	bl	800ca00 <test_printn>
    test_println(" ctxswc/S");
 80045c0:	4809      	ldr	r0, [pc, #36]	; (80045e8 <rt_test_010_001_execute.lto_priv.121+0x78>)
 80045c2:	f008 fa0d 	bl	800c9e0 <test_println>
}
 80045c6:	b003      	add	sp, #12
 80045c8:	bd30      	pop	{r4, r5, pc}
 80045ca:	bf00      	nop
 80045cc:	20003e04 	.word	0x20003e04
 80045d0:	20003aec 	.word	0x20003aec
 80045d4:	08004391 	.word	0x08004391
 80045d8:	200025f0 	.word	0x200025f0
 80045dc:	20002f1c 	.word	0x20002f1c
 80045e0:	0800e610 	.word	0x0800e610
 80045e4:	0800e678 	.word	0x0800e678
 80045e8:	0800e64c 	.word	0x0800e64c
 80045ec:	00000000 	.word	0x00000000

080045f0 <bmk_thread3>:
static THD_FUNCTION(bmk_thread3, p) {
 80045f0:	b508      	push	{r3, lr}
  chThdExit((msg_t)p);
 80045f2:	f007 fa5d 	bl	800bab0 <chThdExit>
 80045f6:	bd08      	pop	{r3, pc}
	...

08004600 <tmo.lto_priv.6>:
static void tmo(void *param) {(void)param;}
 8004600:	4770      	bx	lr
 8004602:	bf00      	nop
	...

08004610 <rt_test_006_004_teardown.lto_priv.93>:
static void rt_test_006_004_setup(void) {
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static void rt_test_006_004_teardown(void) {
 8004610:	b508      	push	{r3, lr}
  test_wait_threads();
 8004612:	f008 f995 	bl	800c940 <test_wait_threads>
 8004616:	bd08      	pop	{r3, pc}
	...

08004620 <rt_test_009_002_execute.lto_priv.120>:

static void rt_test_009_002_setup(void) {
  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}

static void rt_test_009_002_execute(void) {
 8004620:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004624:	b082      	sub	sp, #8
  unsigned i;
  tprio_t prio;

  /* [9.2.1] Adding four working areas to the pool.*/
  test_set_step(1);
 8004626:	2201      	movs	r2, #1
 8004628:	4b46      	ldr	r3, [pc, #280]	; (8004744 <rt_test_009_002_execute.lto_priv.120+0x124>)
 800462a:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < 4; i++)
 800462c:	2400      	movs	r4, #0
 800462e:	e006      	b.n	800463e <rt_test_009_002_execute.lto_priv.120+0x1e>
      chPoolFree(&mp1, wa[i]);
 8004630:	4b45      	ldr	r3, [pc, #276]	; (8004748 <rt_test_009_002_execute.lto_priv.120+0x128>)
 8004632:	f853 1024 	ldr.w	r1, [r3, r4, lsl #2]
 8004636:	4845      	ldr	r0, [pc, #276]	; (800474c <rt_test_009_002_execute.lto_priv.120+0x12c>)
 8004638:	f005 f91a 	bl	8009870 <chPoolFree>
    for (i = 0; i < 4; i++)
 800463c:	3401      	adds	r4, #1
 800463e:	2c03      	cmp	r4, #3
 8004640:	d9f6      	bls.n	8004630 <rt_test_009_002_execute.lto_priv.120+0x10>
  }

  /* [9.2.2] Getting base priority for threads.*/
  test_set_step(2);
 8004642:	f8df 8100 	ldr.w	r8, [pc, #256]	; 8004744 <rt_test_009_002_execute.lto_priv.120+0x124>
  return ch.rlist.current;
 8004646:	4b42      	ldr	r3, [pc, #264]	; (8004750 <rt_test_009_002_execute.lto_priv.120+0x130>)
 8004648:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 800464a:	689e      	ldr	r6, [r3, #8]
  {
    prio = chThdGetPriorityX();
  }

  /* [9.2.3] Creating the five threads.*/
  test_set_step(3);
 800464c:	2303      	movs	r3, #3
 800464e:	f8c8 3000 	str.w	r3, [r8]
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 8004652:	4f40      	ldr	r7, [pc, #256]	; (8004754 <rt_test_009_002_execute.lto_priv.120+0x134>)
 8004654:	4d3d      	ldr	r5, [pc, #244]	; (800474c <rt_test_009_002_execute.lto_priv.120+0x12c>)
 8004656:	4b40      	ldr	r3, [pc, #256]	; (8004758 <rt_test_009_002_execute.lto_priv.120+0x138>)
 8004658:	9300      	str	r3, [sp, #0]
 800465a:	463b      	mov	r3, r7
 800465c:	1e72      	subs	r2, r6, #1
 800465e:	493f      	ldr	r1, [pc, #252]	; (800475c <rt_test_009_002_execute.lto_priv.120+0x13c>)
 8004660:	4628      	mov	r0, r5
 8004662:	f005 fbc5 	bl	8009df0 <chThdCreateFromMemoryPool>
 8004666:	4c3e      	ldr	r4, [pc, #248]	; (8004760 <rt_test_009_002_execute.lto_priv.120+0x140>)
 8004668:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 800466a:	4b3e      	ldr	r3, [pc, #248]	; (8004764 <rt_test_009_002_execute.lto_priv.120+0x144>)
 800466c:	9300      	str	r3, [sp, #0]
 800466e:	463b      	mov	r3, r7
 8004670:	1eb2      	subs	r2, r6, #2
 8004672:	493d      	ldr	r1, [pc, #244]	; (8004768 <rt_test_009_002_execute.lto_priv.120+0x148>)
 8004674:	4628      	mov	r0, r5
 8004676:	f005 fbbb 	bl	8009df0 <chThdCreateFromMemoryPool>
 800467a:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 800467c:	4b3b      	ldr	r3, [pc, #236]	; (800476c <rt_test_009_002_execute.lto_priv.120+0x14c>)
 800467e:	9300      	str	r3, [sp, #0]
 8004680:	463b      	mov	r3, r7
 8004682:	1ef2      	subs	r2, r6, #3
 8004684:	493a      	ldr	r1, [pc, #232]	; (8004770 <rt_test_009_002_execute.lto_priv.120+0x150>)
 8004686:	4628      	mov	r0, r5
 8004688:	f005 fbb2 	bl	8009df0 <chThdCreateFromMemoryPool>
 800468c:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 800468e:	4b39      	ldr	r3, [pc, #228]	; (8004774 <rt_test_009_002_execute.lto_priv.120+0x154>)
 8004690:	9300      	str	r3, [sp, #0]
 8004692:	463b      	mov	r3, r7
 8004694:	1f32      	subs	r2, r6, #4
 8004696:	4938      	ldr	r1, [pc, #224]	; (8004778 <rt_test_009_002_execute.lto_priv.120+0x158>)
 8004698:	4628      	mov	r0, r5
 800469a:	f005 fba9 	bl	8009df0 <chThdCreateFromMemoryPool>
 800469e:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 80046a0:	4b36      	ldr	r3, [pc, #216]	; (800477c <rt_test_009_002_execute.lto_priv.120+0x15c>)
 80046a2:	9300      	str	r3, [sp, #0]
 80046a4:	463b      	mov	r3, r7
 80046a6:	1f72      	subs	r2, r6, #5
 80046a8:	4935      	ldr	r1, [pc, #212]	; (8004780 <rt_test_009_002_execute.lto_priv.120+0x160>)
 80046aa:	4628      	mov	r0, r5
 80046ac:	f005 fba0 	bl	8009df0 <chThdCreateFromMemoryPool>
 80046b0:	6120      	str	r0, [r4, #16]
  }

  /* [9.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
 80046b2:	2304      	movs	r3, #4
 80046b4:	f8c8 3000 	str.w	r3, [r8]
  {
    test_assert((threads[0] != NULL) &&
 80046b8:	6823      	ldr	r3, [r4, #0]
 80046ba:	b13b      	cbz	r3, 80046cc <rt_test_009_002_execute.lto_priv.120+0xac>
 80046bc:	6863      	ldr	r3, [r4, #4]
 80046be:	b13b      	cbz	r3, 80046d0 <rt_test_009_002_execute.lto_priv.120+0xb0>
 80046c0:	68a3      	ldr	r3, [r4, #8]
 80046c2:	b13b      	cbz	r3, 80046d4 <rt_test_009_002_execute.lto_priv.120+0xb4>
 80046c4:	68e3      	ldr	r3, [r4, #12]
 80046c6:	b93b      	cbnz	r3, 80046d8 <rt_test_009_002_execute.lto_priv.120+0xb8>
 80046c8:	2000      	movs	r0, #0
 80046ca:	e006      	b.n	80046da <rt_test_009_002_execute.lto_priv.120+0xba>
 80046cc:	2000      	movs	r0, #0
 80046ce:	e004      	b.n	80046da <rt_test_009_002_execute.lto_priv.120+0xba>
 80046d0:	2000      	movs	r0, #0
 80046d2:	e002      	b.n	80046da <rt_test_009_002_execute.lto_priv.120+0xba>
 80046d4:	2000      	movs	r0, #0
 80046d6:	e000      	b.n	80046da <rt_test_009_002_execute.lto_priv.120+0xba>
 80046d8:	2001      	movs	r0, #1
 80046da:	492a      	ldr	r1, [pc, #168]	; (8004784 <rt_test_009_002_execute.lto_priv.120+0x164>)
 80046dc:	f008 fd68 	bl	800d1b0 <_test_assert>
 80046e0:	bb68      	cbnz	r0, 800473e <rt_test_009_002_execute.lto_priv.120+0x11e>
                (threads[1] != NULL) &&
                (threads[2] != NULL) &&
                (threads[3] != NULL),
                "thread creation failed");
    test_assert(threads[4] == NULL,
 80046e2:	4b1f      	ldr	r3, [pc, #124]	; (8004760 <rt_test_009_002_execute.lto_priv.120+0x140>)
 80046e4:	6918      	ldr	r0, [r3, #16]
 80046e6:	4928      	ldr	r1, [pc, #160]	; (8004788 <rt_test_009_002_execute.lto_priv.120+0x168>)
 80046e8:	fab0 f080 	clz	r0, r0
 80046ec:	0940      	lsrs	r0, r0, #5
 80046ee:	f008 fd5f 	bl	800d1b0 <_test_assert>
 80046f2:	bb20      	cbnz	r0, 800473e <rt_test_009_002_execute.lto_priv.120+0x11e>
                "thread creation not failed");
  }

  /* [9.2.5] Letting them run, free the memory then checking the
     execution sequence.*/
  test_set_step(5);
 80046f4:	2205      	movs	r2, #5
 80046f6:	4b13      	ldr	r3, [pc, #76]	; (8004744 <rt_test_009_002_execute.lto_priv.120+0x124>)
 80046f8:	601a      	str	r2, [r3, #0]
  {
    test_wait_threads();
 80046fa:	f008 f921 	bl	800c940 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
 80046fe:	4923      	ldr	r1, [pc, #140]	; (800478c <rt_test_009_002_execute.lto_priv.120+0x16c>)
 8004700:	4823      	ldr	r0, [pc, #140]	; (8004790 <rt_test_009_002_execute.lto_priv.120+0x170>)
 8004702:	f008 fd2d 	bl	800d160 <_test_assert_sequence>
 8004706:	b9d0      	cbnz	r0, 800473e <rt_test_009_002_execute.lto_priv.120+0x11e>
  }

  /* [9.2.6] Testing that the pool contains four elements again.*/
  test_set_step(6);
 8004708:	2206      	movs	r2, #6
 800470a:	4b0e      	ldr	r3, [pc, #56]	; (8004744 <rt_test_009_002_execute.lto_priv.120+0x124>)
 800470c:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < 4; i++)
 800470e:	2400      	movs	r4, #0
 8004710:	e00a      	b.n	8004728 <rt_test_009_002_execute.lto_priv.120+0x108>
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
 8004712:	480e      	ldr	r0, [pc, #56]	; (800474c <rt_test_009_002_execute.lto_priv.120+0x12c>)
 8004714:	f005 f8cc 	bl	80098b0 <chPoolAlloc>
 8004718:	491e      	ldr	r1, [pc, #120]	; (8004794 <rt_test_009_002_execute.lto_priv.120+0x174>)
 800471a:	3000      	adds	r0, #0
 800471c:	bf18      	it	ne
 800471e:	2001      	movne	r0, #1
 8004720:	f008 fd46 	bl	800d1b0 <_test_assert>
 8004724:	b958      	cbnz	r0, 800473e <rt_test_009_002_execute.lto_priv.120+0x11e>
    for (i = 0; i < 4; i++)
 8004726:	3401      	adds	r4, #1
 8004728:	2c03      	cmp	r4, #3
 800472a:	d9f2      	bls.n	8004712 <rt_test_009_002_execute.lto_priv.120+0xf2>
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
 800472c:	4807      	ldr	r0, [pc, #28]	; (800474c <rt_test_009_002_execute.lto_priv.120+0x12c>)
 800472e:	f005 f8bf 	bl	80098b0 <chPoolAlloc>
 8004732:	4919      	ldr	r1, [pc, #100]	; (8004798 <rt_test_009_002_execute.lto_priv.120+0x178>)
 8004734:	fab0 f080 	clz	r0, r0
 8004738:	0940      	lsrs	r0, r0, #5
 800473a:	f008 fd39 	bl	800d1b0 <_test_assert>
  }
}
 800473e:	b002      	add	sp, #8
 8004740:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004744:	20003e04 	.word	0x20003e04
 8004748:	0800e480 	.word	0x0800e480
 800474c:	20002f58 	.word	0x20002f58
 8004750:	20003aec 	.word	0x20003aec
 8004754:	080047a1 	.word	0x080047a1
 8004758:	0800e68c 	.word	0x0800e68c
 800475c:	0800e684 	.word	0x0800e684
 8004760:	20002f1c 	.word	0x20002f1c
 8004764:	0800e698 	.word	0x0800e698
 8004768:	0800e690 	.word	0x0800e690
 800476c:	08010ec4 	.word	0x08010ec4
 8004770:	0800e69c 	.word	0x0800e69c
 8004774:	0800fa8c 	.word	0x0800fa8c
 8004778:	0800e6a4 	.word	0x0800e6a4
 800477c:	0800e830 	.word	0x0800e830
 8004780:	0800e6ac 	.word	0x0800e6ac
 8004784:	0800e6b4 	.word	0x0800e6b4
 8004788:	0800e6cc 	.word	0x0800e6cc
 800478c:	0800e6e8 	.word	0x0800e6e8
 8004790:	0800e55c 	.word	0x0800e55c
 8004794:	0800e6fc 	.word	0x0800e6fc
 8004798:	0800e70c 	.word	0x0800e70c
 800479c:	00000000 	.word	0x00000000

080047a0 <dyn_thread1>:
static THD_FUNCTION(dyn_thread1, p) {
 80047a0:	b508      	push	{r3, lr}
  test_emit_token(*(char *)p);
 80047a2:	7800      	ldrb	r0, [r0, #0]
 80047a4:	f008 f8f4 	bl	800c990 <test_emit_token>
 80047a8:	bd08      	pop	{r3, pc}
 80047aa:	bf00      	nop
 80047ac:	0000      	movs	r0, r0
	...

080047b0 <h3>:
static EVENTSOURCE_DECL(es1);
static EVENTSOURCE_DECL(es2);

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 80047b0:	b508      	push	{r3, lr}
 80047b2:	2043      	movs	r0, #67	; 0x43
 80047b4:	f008 f8ec 	bl	800c990 <test_emit_token>
 80047b8:	bd08      	pop	{r3, pc}
 80047ba:	bf00      	nop
 80047bc:	0000      	movs	r0, r0
	...

080047c0 <h2>:
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 80047c0:	b508      	push	{r3, lr}
 80047c2:	2042      	movs	r0, #66	; 0x42
 80047c4:	f008 f8e4 	bl	800c990 <test_emit_token>
 80047c8:	bd08      	pop	{r3, pc}
 80047ca:	bf00      	nop
 80047cc:	0000      	movs	r0, r0
	...

080047d0 <h1>:
static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 80047d0:	b508      	push	{r3, lr}
 80047d2:	2041      	movs	r0, #65	; 0x41
 80047d4:	f008 f8dc 	bl	800c990 <test_emit_token>
 80047d8:	bd08      	pop	{r3, pc}
 80047da:	bf00      	nop
 80047dc:	0000      	movs	r0, r0
	...

080047e0 <rt_test_009_002_setup.lto_priv.119>:
static void rt_test_009_002_setup(void) {
 80047e0:	b508      	push	{r3, lr}
 */
static inline void chPoolObjectInit(memory_pool_t *mp,
                                    size_t size,
                                    memgetfunc_t provider) {

  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 80047e2:	2300      	movs	r3, #0
 80047e4:	2204      	movs	r2, #4
 80047e6:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80047ea:	4802      	ldr	r0, [pc, #8]	; (80047f4 <rt_test_009_002_setup.lto_priv.119+0x14>)
 80047ec:	f005 f8a0 	bl	8009930 <chPoolObjectInitAligned>
 80047f0:	bd08      	pop	{r3, pc}
 80047f2:	bf00      	nop
 80047f4:	20002f58 	.word	0x20002f58
	...

08004800 <rt_test_009_001_execute.lto_priv.118>:
static void rt_test_009_001_execute(void) {
 8004800:	b530      	push	{r4, r5, lr}
 8004802:	b087      	sub	sp, #28
  return ch.rlist.current;
 8004804:	4b45      	ldr	r3, [pc, #276]	; (800491c <rt_test_009_001_execute.lto_priv.118+0x11c>)
 8004806:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 8004808:	689d      	ldr	r5, [r3, #8]
  test_set_step(2);
 800480a:	2202      	movs	r2, #2
 800480c:	4b44      	ldr	r3, [pc, #272]	; (8004920 <rt_test_009_001_execute.lto_priv.118+0x120>)
 800480e:	601a      	str	r2, [r3, #0]
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8004810:	aa04      	add	r2, sp, #16
 8004812:	a905      	add	r1, sp, #20
 8004814:	4843      	ldr	r0, [pc, #268]	; (8004924 <rt_test_009_001_execute.lto_priv.118+0x124>)
 8004816:	f005 f8ab 	bl	8009970 <chHeapStatus>
 800481a:	4604      	mov	r4, r0
    test_assert(n1 == 1, "heap fragmented");
 800481c:	4942      	ldr	r1, [pc, #264]	; (8004928 <rt_test_009_001_execute.lto_priv.118+0x128>)
 800481e:	2801      	cmp	r0, #1
 8004820:	bf14      	ite	ne
 8004822:	2000      	movne	r0, #0
 8004824:	2001      	moveq	r0, #1
 8004826:	f008 fcc3 	bl	800d1b0 <_test_assert>
 800482a:	2800      	cmp	r0, #0
 800482c:	d174      	bne.n	8004918 <rt_test_009_001_execute.lto_priv.118+0x118>
  test_set_step(3);
 800482e:	2203      	movs	r2, #3
 8004830:	4b3b      	ldr	r3, [pc, #236]	; (8004920 <rt_test_009_001_execute.lto_priv.118+0x120>)
 8004832:	601a      	str	r2, [r3, #0]
    threads[0] = chThdCreateFromHeap(&heap1,
 8004834:	4b3d      	ldr	r3, [pc, #244]	; (800492c <rt_test_009_001_execute.lto_priv.118+0x12c>)
 8004836:	9301      	str	r3, [sp, #4]
 8004838:	4b3d      	ldr	r3, [pc, #244]	; (8004930 <rt_test_009_001_execute.lto_priv.118+0x130>)
 800483a:	9300      	str	r3, [sp, #0]
 800483c:	1e6b      	subs	r3, r5, #1
 800483e:	4a3d      	ldr	r2, [pc, #244]	; (8004934 <rt_test_009_001_execute.lto_priv.118+0x134>)
 8004840:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8004844:	4837      	ldr	r0, [pc, #220]	; (8004924 <rt_test_009_001_execute.lto_priv.118+0x124>)
 8004846:	f005 fb03 	bl	8009e50 <chThdCreateFromHeap>
 800484a:	4b3b      	ldr	r3, [pc, #236]	; (8004938 <rt_test_009_001_execute.lto_priv.118+0x138>)
 800484c:	6018      	str	r0, [r3, #0]
    test_assert(threads[0] != NULL, "thread creation failed");
 800484e:	493b      	ldr	r1, [pc, #236]	; (800493c <rt_test_009_001_execute.lto_priv.118+0x13c>)
 8004850:	3000      	adds	r0, #0
 8004852:	bf18      	it	ne
 8004854:	2001      	movne	r0, #1
 8004856:	f008 fcab 	bl	800d1b0 <_test_assert>
 800485a:	2800      	cmp	r0, #0
 800485c:	d15c      	bne.n	8004918 <rt_test_009_001_execute.lto_priv.118+0x118>
  test_set_step(4);
 800485e:	2204      	movs	r2, #4
 8004860:	4b2f      	ldr	r3, [pc, #188]	; (8004920 <rt_test_009_001_execute.lto_priv.118+0x120>)
 8004862:	601a      	str	r2, [r3, #0]
    threads[1] = chThdCreateFromHeap(&heap1,
 8004864:	4b36      	ldr	r3, [pc, #216]	; (8004940 <rt_test_009_001_execute.lto_priv.118+0x140>)
 8004866:	9301      	str	r3, [sp, #4]
 8004868:	4b31      	ldr	r3, [pc, #196]	; (8004930 <rt_test_009_001_execute.lto_priv.118+0x130>)
 800486a:	9300      	str	r3, [sp, #0]
 800486c:	1eab      	subs	r3, r5, #2
 800486e:	4a35      	ldr	r2, [pc, #212]	; (8004944 <rt_test_009_001_execute.lto_priv.118+0x144>)
 8004870:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8004874:	482b      	ldr	r0, [pc, #172]	; (8004924 <rt_test_009_001_execute.lto_priv.118+0x124>)
 8004876:	f005 faeb 	bl	8009e50 <chThdCreateFromHeap>
 800487a:	4b2f      	ldr	r3, [pc, #188]	; (8004938 <rt_test_009_001_execute.lto_priv.118+0x138>)
 800487c:	6058      	str	r0, [r3, #4]
    test_assert(threads[1] != NULL, "thread creation failed");
 800487e:	492f      	ldr	r1, [pc, #188]	; (800493c <rt_test_009_001_execute.lto_priv.118+0x13c>)
 8004880:	3000      	adds	r0, #0
 8004882:	bf18      	it	ne
 8004884:	2001      	movne	r0, #1
 8004886:	f008 fc93 	bl	800d1b0 <_test_assert>
 800488a:	2800      	cmp	r0, #0
 800488c:	d144      	bne.n	8004918 <rt_test_009_001_execute.lto_priv.118+0x118>
  test_set_step(5);
 800488e:	2205      	movs	r2, #5
 8004890:	4b23      	ldr	r3, [pc, #140]	; (8004920 <rt_test_009_001_execute.lto_priv.118+0x120>)
 8004892:	601a      	str	r2, [r3, #0]
    threads[2] = chThdCreateFromHeap(&heap1,
 8004894:	4b2c      	ldr	r3, [pc, #176]	; (8004948 <rt_test_009_001_execute.lto_priv.118+0x148>)
 8004896:	9301      	str	r3, [sp, #4]
 8004898:	4b25      	ldr	r3, [pc, #148]	; (8004930 <rt_test_009_001_execute.lto_priv.118+0x130>)
 800489a:	9300      	str	r3, [sp, #0]
 800489c:	1eeb      	subs	r3, r5, #3
 800489e:	4a2b      	ldr	r2, [pc, #172]	; (800494c <rt_test_009_001_execute.lto_priv.118+0x14c>)
 80048a0:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
 80048a4:	481f      	ldr	r0, [pc, #124]	; (8004924 <rt_test_009_001_execute.lto_priv.118+0x124>)
 80048a6:	f005 fad3 	bl	8009e50 <chThdCreateFromHeap>
 80048aa:	4b23      	ldr	r3, [pc, #140]	; (8004938 <rt_test_009_001_execute.lto_priv.118+0x138>)
 80048ac:	6098      	str	r0, [r3, #8]
    test_assert(threads[2] == NULL, "thread creation not failed");
 80048ae:	4928      	ldr	r1, [pc, #160]	; (8004950 <rt_test_009_001_execute.lto_priv.118+0x150>)
 80048b0:	fab0 f080 	clz	r0, r0
 80048b4:	0940      	lsrs	r0, r0, #5
 80048b6:	f008 fc7b 	bl	800d1b0 <_test_assert>
 80048ba:	2800      	cmp	r0, #0
 80048bc:	d12c      	bne.n	8004918 <rt_test_009_001_execute.lto_priv.118+0x118>
  test_set_step(6);
 80048be:	2206      	movs	r2, #6
 80048c0:	4b17      	ldr	r3, [pc, #92]	; (8004920 <rt_test_009_001_execute.lto_priv.118+0x120>)
 80048c2:	601a      	str	r2, [r3, #0]
    test_wait_threads();
 80048c4:	f008 f83c 	bl	800c940 <test_wait_threads>
    test_assert_sequence("AB", "invalid sequence");
 80048c8:	4922      	ldr	r1, [pc, #136]	; (8004954 <rt_test_009_001_execute.lto_priv.118+0x154>)
 80048ca:	4823      	ldr	r0, [pc, #140]	; (8004958 <rt_test_009_001_execute.lto_priv.118+0x158>)
 80048cc:	f008 fc48 	bl	800d160 <_test_assert_sequence>
 80048d0:	bb10      	cbnz	r0, 8004918 <rt_test_009_001_execute.lto_priv.118+0x118>
  test_set_step(7);
 80048d2:	2207      	movs	r2, #7
 80048d4:	4b12      	ldr	r3, [pc, #72]	; (8004920 <rt_test_009_001_execute.lto_priv.118+0x120>)
 80048d6:	601a      	str	r2, [r3, #0]
    n2 = chHeapStatus(&heap1, &total2, &largest2);
 80048d8:	aa02      	add	r2, sp, #8
 80048da:	a903      	add	r1, sp, #12
 80048dc:	4811      	ldr	r0, [pc, #68]	; (8004924 <rt_test_009_001_execute.lto_priv.118+0x124>)
 80048de:	f005 f847 	bl	8009970 <chHeapStatus>
    test_assert(n1 == n2, "fragmentation changed");
 80048e2:	491e      	ldr	r1, [pc, #120]	; (800495c <rt_test_009_001_execute.lto_priv.118+0x15c>)
 80048e4:	4284      	cmp	r4, r0
 80048e6:	bf14      	ite	ne
 80048e8:	2000      	movne	r0, #0
 80048ea:	2001      	moveq	r0, #1
 80048ec:	f008 fc60 	bl	800d1b0 <_test_assert>
 80048f0:	b990      	cbnz	r0, 8004918 <rt_test_009_001_execute.lto_priv.118+0x118>
    test_assert(total1 == total2, "total free space changed");
 80048f2:	491b      	ldr	r1, [pc, #108]	; (8004960 <rt_test_009_001_execute.lto_priv.118+0x160>)
 80048f4:	9b03      	ldr	r3, [sp, #12]
 80048f6:	9805      	ldr	r0, [sp, #20]
 80048f8:	4298      	cmp	r0, r3
 80048fa:	bf14      	ite	ne
 80048fc:	2000      	movne	r0, #0
 80048fe:	2001      	moveq	r0, #1
 8004900:	f008 fc56 	bl	800d1b0 <_test_assert>
 8004904:	b940      	cbnz	r0, 8004918 <rt_test_009_001_execute.lto_priv.118+0x118>
    test_assert(largest1 == largest2, "largest fragment size changed");
 8004906:	4917      	ldr	r1, [pc, #92]	; (8004964 <rt_test_009_001_execute.lto_priv.118+0x164>)
 8004908:	9b02      	ldr	r3, [sp, #8]
 800490a:	9804      	ldr	r0, [sp, #16]
 800490c:	4298      	cmp	r0, r3
 800490e:	bf14      	ite	ne
 8004910:	2000      	movne	r0, #0
 8004912:	2001      	moveq	r0, #1
 8004914:	f008 fc4c 	bl	800d1b0 <_test_assert>
}
 8004918:	b007      	add	sp, #28
 800491a:	bd30      	pop	{r4, r5, pc}
 800491c:	20003aec 	.word	0x20003aec
 8004920:	20003e04 	.word	0x20003e04
 8004924:	20002f68 	.word	0x20002f68
 8004928:	0800e720 	.word	0x0800e720
 800492c:	0800e68c 	.word	0x0800e68c
 8004930:	080047a1 	.word	0x080047a1
 8004934:	0800e684 	.word	0x0800e684
 8004938:	20002f1c 	.word	0x20002f1c
 800493c:	0800e6b4 	.word	0x0800e6b4
 8004940:	0800e698 	.word	0x0800e698
 8004944:	0800e690 	.word	0x0800e690
 8004948:	08010ec4 	.word	0x08010ec4
 800494c:	0800e69c 	.word	0x0800e69c
 8004950:	0800e6cc 	.word	0x0800e6cc
 8004954:	0800e6e8 	.word	0x0800e6e8
 8004958:	0800e730 	.word	0x0800e730
 800495c:	0800e734 	.word	0x0800e734
 8004960:	0800e74c 	.word	0x0800e74c
 8004964:	0800e768 	.word	0x0800e768
	...

08004970 <rt_test_009_001_setup.lto_priv.117>:
static void rt_test_009_001_setup(void) {
 8004970:	b508      	push	{r3, lr}
  chHeapObjectInit(&heap1, test_buffer, sizeof test_buffer);
 8004972:	f44f 6211 	mov.w	r2, #2320	; 0x910
 8004976:	4902      	ldr	r1, [pc, #8]	; (8004980 <rt_test_009_001_setup.lto_priv.117+0x10>)
 8004978:	4802      	ldr	r0, [pc, #8]	; (8004984 <rt_test_009_001_setup.lto_priv.117+0x14>)
 800497a:	f005 f919 	bl	8009bb0 <chHeapObjectInit>
 800497e:	bd08      	pop	{r3, pc}
 8004980:	200025f0 	.word	0x200025f0
 8004984:	20002f68 	.word	0x20002f68
	...

08004990 <rt_test_008_007_setup.lto_priv.115>:
 *   has been emptied.
 * - [8.7.4] Unregistering from the Event Sources.
 * .
 */

static void rt_test_008_007_setup(void) {
 8004990:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 8004992:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004996:	f006 fbc3 	bl	800b120 <chEvtGetAndClearEvents>
 800499a:	4b02      	ldr	r3, [pc, #8]	; (80049a4 <rt_test_008_007_setup.lto_priv.115+0x14>)
 800499c:	601b      	str	r3, [r3, #0]
 800499e:	4b02      	ldr	r3, [pc, #8]	; (80049a8 <rt_test_008_007_setup.lto_priv.115+0x18>)
 80049a0:	601b      	str	r3, [r3, #0]
 80049a2:	bd08      	pop	{r3, pc}
 80049a4:	20002468 	.word	0x20002468
 80049a8:	20002474 	.word	0x20002474
 80049ac:	00000000 	.word	0x00000000

080049b0 <rt_test_008_006_setup.lto_priv.113>:
static void rt_test_008_006_setup(void) {
 80049b0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 80049b2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80049b6:	f006 fbb3 	bl	800b120 <chEvtGetAndClearEvents>
 80049ba:	bd08      	pop	{r3, pc}
 80049bc:	0000      	movs	r0, r0
	...

080049c0 <rt_test_008_005_setup.lto_priv.111>:
static void rt_test_008_005_setup(void) {
 80049c0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 80049c2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80049c6:	f006 fbab 	bl	800b120 <chEvtGetAndClearEvents>
 80049ca:	bd08      	pop	{r3, pc}
 80049cc:	0000      	movs	r0, r0
	...

080049d0 <rt_test_008_004_setup.lto_priv.109>:
static void rt_test_008_004_setup(void) {
 80049d0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 80049d2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80049d6:	f006 fba3 	bl	800b120 <chEvtGetAndClearEvents>
 80049da:	bd08      	pop	{r3, pc}
 80049dc:	0000      	movs	r0, r0
	...

080049e0 <rt_test_008_003_setup.lto_priv.107>:
static void rt_test_008_003_setup(void) {
 80049e0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 80049e2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80049e6:	f006 fb9b 	bl	800b120 <chEvtGetAndClearEvents>
 80049ea:	bd08      	pop	{r3, pc}
 80049ec:	0000      	movs	r0, r0
	...

080049f0 <rt_test_008_002_setup.lto_priv.105>:
static void rt_test_008_002_setup(void) {
 80049f0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 80049f2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80049f6:	f006 fb93 	bl	800b120 <chEvtGetAndClearEvents>
 80049fa:	bd08      	pop	{r3, pc}
 80049fc:	0000      	movs	r0, r0
	...

08004a00 <rt_test_008_007_execute.lto_priv.116>:
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
}

static void rt_test_008_007_execute(void) {
 8004a00:	b570      	push	{r4, r5, r6, lr}
 8004a02:	b08c      	sub	sp, #48	; 0x30
  event_listener_t el1, el2;
  systime_t target_time;

  /* [8.7.1] Registering on two event sources associating them with
     flags 1 and 4.*/
  test_set_step(1);
 8004a04:	4c2e      	ldr	r4, [pc, #184]	; (8004ac0 <rt_test_008_007_execute.lto_priv.116+0xc0>)
 8004a06:	2201      	movs	r2, #1
 8004a08:	6022      	str	r2, [r4, #0]
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 8004a0a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004a0e:	a907      	add	r1, sp, #28
 8004a10:	482c      	ldr	r0, [pc, #176]	; (8004ac4 <rt_test_008_007_execute.lto_priv.116+0xc4>)
 8004a12:	f006 fbad 	bl	800b170 <chEvtRegisterMaskWithFlags>
 8004a16:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004a1a:	2204      	movs	r2, #4
 8004a1c:	a902      	add	r1, sp, #8
 8004a1e:	482a      	ldr	r0, [pc, #168]	; (8004ac8 <rt_test_008_007_execute.lto_priv.116+0xc8>)
 8004a20:	f006 fba6 	bl	800b170 <chEvtRegisterMaskWithFlags>
  }

  /* [8.7.2] Getting current time and starting a broadcaster thread,
     the thread broadcast the first Event Source immediately and the
     other after 50mS.*/
  test_set_step(2);
 8004a24:	2302      	movs	r3, #2
 8004a26:	6023      	str	r3, [r4, #0]
  {
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8004a28:	f007 ff7a 	bl	800c920 <test_wait_tick>
 8004a2c:	4605      	mov	r5, r0
  return systime + (systime_t)interval;
 8004a2e:	f500 76fa 	add.w	r6, r0, #500	; 0x1f4
  return ch.rlist.current;
 8004a32:	4b26      	ldr	r3, [pc, #152]	; (8004acc <rt_test_008_007_execute.lto_priv.116+0xcc>)
 8004a34:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 8004a36:	689a      	ldr	r2, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8004a38:	4b25      	ldr	r3, [pc, #148]	; (8004ad0 <rt_test_008_007_execute.lto_priv.116+0xd0>)
 8004a3a:	9300      	str	r3, [sp, #0]
 8004a3c:	4b25      	ldr	r3, [pc, #148]	; (8004ad4 <rt_test_008_007_execute.lto_priv.116+0xd4>)
 8004a3e:	3a01      	subs	r2, #1
 8004a40:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8004a44:	4824      	ldr	r0, [pc, #144]	; (8004ad8 <rt_test_008_007_execute.lto_priv.116+0xd8>)
 8004a46:	f006 fe93 	bl	800b770 <chThdCreateStatic>
 8004a4a:	4b24      	ldr	r3, [pc, #144]	; (8004adc <rt_test_008_007_execute.lto_priv.116+0xdc>)
 8004a4c:	6018      	str	r0, [r3, #0]
  }

  /* [8.7.3] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(3);
 8004a4e:	2303      	movs	r3, #3
 8004a50:	6023      	str	r3, [r4, #0]
  {
    m = chEvtWaitAll(5);
 8004a52:	2005      	movs	r0, #5
 8004a54:	f005 faf4 	bl	800a040 <chEvtWaitAll>
    test_assert_time_window(target_time,
 8004a58:	4a21      	ldr	r2, [pc, #132]	; (8004ae0 <rt_test_008_007_execute.lto_priv.116+0xe0>)
 8004a5a:	f505 7102 	add.w	r1, r5, #520	; 0x208
 8004a5e:	4630      	mov	r0, r6
 8004a60:	f008 fc6e 	bl	800d340 <_test_assert_time_window>
 8004a64:	bb48      	cbnz	r0, 8004aba <rt_test_008_007_execute.lto_priv.116+0xba>
                            chTimeAddX(target_time, ALLOWED_DELAY),
                            "out of time window");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8004a66:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004a6a:	f006 fb59 	bl	800b120 <chEvtGetAndClearEvents>
    test_assert(m == 0, "stuck event");
 8004a6e:	491d      	ldr	r1, [pc, #116]	; (8004ae4 <rt_test_008_007_execute.lto_priv.116+0xe4>)
 8004a70:	fab0 f080 	clz	r0, r0
 8004a74:	0940      	lsrs	r0, r0, #5
 8004a76:	f008 fb9b 	bl	800d1b0 <_test_assert>
 8004a7a:	b9f0      	cbnz	r0, 8004aba <rt_test_008_007_execute.lto_priv.116+0xba>
    test_wait_threads();
 8004a7c:	f007 ff60 	bl	800c940 <test_wait_threads>
  }

  /* [8.7.4] Unregistering from the Event Sources.*/
  test_set_step(4);
 8004a80:	2204      	movs	r2, #4
 8004a82:	6022      	str	r2, [r4, #0]
  {
    chEvtUnregister(&es1, &el1);
 8004a84:	4c0f      	ldr	r4, [pc, #60]	; (8004ac4 <rt_test_008_007_execute.lto_priv.116+0xc4>)
 8004a86:	a907      	add	r1, sp, #28
 8004a88:	4620      	mov	r0, r4
 8004a8a:	f006 fb59 	bl	800b140 <chEvtUnregister>
    chEvtUnregister(&es2, &el2);
 8004a8e:	a902      	add	r1, sp, #8
 8004a90:	480d      	ldr	r0, [pc, #52]	; (8004ac8 <rt_test_008_007_execute.lto_priv.116+0xc8>)
 8004a92:	f006 fb55 	bl	800b140 <chEvtUnregister>
 *
 * @iclass
 */
static inline bool chEvtIsListeningI(event_source_t *esp) {

  return (bool)(esp != (event_source_t *)esp->next);
 8004a96:	6820      	ldr	r0, [r4, #0]
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
 8004a98:	4913      	ldr	r1, [pc, #76]	; (8004ae8 <rt_test_008_007_execute.lto_priv.116+0xe8>)
 8004a9a:	42a0      	cmp	r0, r4
 8004a9c:	bf14      	ite	ne
 8004a9e:	2000      	movne	r0, #0
 8004aa0:	2001      	moveq	r0, #1
 8004aa2:	f008 fb85 	bl	800d1b0 <_test_assert>
 8004aa6:	b940      	cbnz	r0, 8004aba <rt_test_008_007_execute.lto_priv.116+0xba>
 8004aa8:	4b07      	ldr	r3, [pc, #28]	; (8004ac8 <rt_test_008_007_execute.lto_priv.116+0xc8>)
 8004aaa:	6818      	ldr	r0, [r3, #0]
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
 8004aac:	490e      	ldr	r1, [pc, #56]	; (8004ae8 <rt_test_008_007_execute.lto_priv.116+0xe8>)
 8004aae:	4298      	cmp	r0, r3
 8004ab0:	bf14      	ite	ne
 8004ab2:	2000      	movne	r0, #0
 8004ab4:	2001      	moveq	r0, #1
 8004ab6:	f008 fb7b 	bl	800d1b0 <_test_assert>
  }
}
 8004aba:	b00c      	add	sp, #48	; 0x30
 8004abc:	bd70      	pop	{r4, r5, r6, pc}
 8004abe:	bf00      	nop
 8004ac0:	20003e04 	.word	0x20003e04
 8004ac4:	20002468 	.word	0x20002468
 8004ac8:	20002474 	.word	0x20002474
 8004acc:	20003aec 	.word	0x20003aec
 8004ad0:	0800e68c 	.word	0x0800e68c
 8004ad4:	08004bc1 	.word	0x08004bc1
 8004ad8:	200025f0 	.word	0x200025f0
 8004adc:	20002f1c 	.word	0x20002f1c
 8004ae0:	0800e788 	.word	0x0800e788
 8004ae4:	0800e79c 	.word	0x0800e79c
 8004ae8:	0800e7a8 	.word	0x0800e7a8
 8004aec:	00000000 	.word	0x00000000

08004af0 <rt_test_008_001_execute.lto_priv.104>:
static void rt_test_008_001_execute(void) {
 8004af0:	b530      	push	{r4, r5, lr}
 8004af2:	b08b      	sub	sp, #44	; 0x2c
  esp->next = (event_listener_t *)esp;
 8004af4:	4c2d      	ldr	r4, [pc, #180]	; (8004bac <rt_test_008_001_execute.lto_priv.104+0xbc>)
 8004af6:	6024      	str	r4, [r4, #0]
  test_set_step(2);
 8004af8:	2502      	movs	r5, #2
 8004afa:	4b2d      	ldr	r3, [pc, #180]	; (8004bb0 <rt_test_008_001_execute.lto_priv.104+0xc0>)
 8004afc:	601d      	str	r5, [r3, #0]
  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 8004afe:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004b02:	2201      	movs	r2, #1
 8004b04:	a905      	add	r1, sp, #20
 8004b06:	4620      	mov	r0, r4
 8004b08:	f006 fb32 	bl	800b170 <chEvtRegisterMaskWithFlags>
 8004b0c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004b10:	462a      	mov	r2, r5
 8004b12:	4669      	mov	r1, sp
 8004b14:	4620      	mov	r0, r4
 8004b16:	f006 fb2b 	bl	800b170 <chEvtRegisterMaskWithFlags>
 8004b1a:	2320      	movs	r3, #32
 8004b1c:	f383 8811 	msr	BASEPRI, r3
  return (bool)(esp != (event_source_t *)esp->next);
 8004b20:	6820      	ldr	r0, [r4, #0]
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 8004b22:	4924      	ldr	r1, [pc, #144]	; (8004bb4 <rt_test_008_001_execute.lto_priv.104+0xc4>)
 8004b24:	1b00      	subs	r0, r0, r4
 8004b26:	bf18      	it	ne
 8004b28:	2001      	movne	r0, #1
 8004b2a:	f008 fb41 	bl	800d1b0 <_test_assert>
 8004b2e:	b118      	cbz	r0, 8004b38 <rt_test_008_001_execute.lto_priv.104+0x48>
 8004b30:	2300      	movs	r3, #0
 8004b32:	f383 8811 	msr	BASEPRI, r3
 8004b36:	e037      	b.n	8004ba8 <rt_test_008_001_execute.lto_priv.104+0xb8>
 8004b38:	2300      	movs	r3, #0
 8004b3a:	f383 8811 	msr	BASEPRI, r3
  test_set_step(3);
 8004b3e:	2203      	movs	r2, #3
 8004b40:	4b1b      	ldr	r3, [pc, #108]	; (8004bb0 <rt_test_008_001_execute.lto_priv.104+0xc0>)
 8004b42:	601a      	str	r2, [r3, #0]
    chEvtUnregister(&es1, &el1);
 8004b44:	4c19      	ldr	r4, [pc, #100]	; (8004bac <rt_test_008_001_execute.lto_priv.104+0xbc>)
 8004b46:	a905      	add	r1, sp, #20
 8004b48:	4620      	mov	r0, r4
 8004b4a:	f006 faf9 	bl	800b140 <chEvtUnregister>
 8004b4e:	2320      	movs	r3, #32
 8004b50:	f383 8811 	msr	BASEPRI, r3
 8004b54:	6820      	ldr	r0, [r4, #0]
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 8004b56:	4917      	ldr	r1, [pc, #92]	; (8004bb4 <rt_test_008_001_execute.lto_priv.104+0xc4>)
 8004b58:	1b00      	subs	r0, r0, r4
 8004b5a:	bf18      	it	ne
 8004b5c:	2001      	movne	r0, #1
 8004b5e:	f008 fb27 	bl	800d1b0 <_test_assert>
 8004b62:	b118      	cbz	r0, 8004b6c <rt_test_008_001_execute.lto_priv.104+0x7c>
 8004b64:	2300      	movs	r3, #0
 8004b66:	f383 8811 	msr	BASEPRI, r3
 8004b6a:	e01d      	b.n	8004ba8 <rt_test_008_001_execute.lto_priv.104+0xb8>
 8004b6c:	2300      	movs	r3, #0
 8004b6e:	f383 8811 	msr	BASEPRI, r3
  test_set_step(4);
 8004b72:	2204      	movs	r2, #4
 8004b74:	4b0e      	ldr	r3, [pc, #56]	; (8004bb0 <rt_test_008_001_execute.lto_priv.104+0xc0>)
 8004b76:	601a      	str	r2, [r3, #0]
    chEvtUnregister(&es1, &el2);
 8004b78:	4c0c      	ldr	r4, [pc, #48]	; (8004bac <rt_test_008_001_execute.lto_priv.104+0xbc>)
 8004b7a:	4669      	mov	r1, sp
 8004b7c:	4620      	mov	r0, r4
 8004b7e:	f006 fadf 	bl	800b140 <chEvtUnregister>
 8004b82:	2320      	movs	r3, #32
 8004b84:	f383 8811 	msr	BASEPRI, r3
 8004b88:	6820      	ldr	r0, [r4, #0]
    test_assert_lock(!chEvtIsListeningI(&es1), "stuck listener");
 8004b8a:	490b      	ldr	r1, [pc, #44]	; (8004bb8 <rt_test_008_001_execute.lto_priv.104+0xc8>)
 8004b8c:	42a0      	cmp	r0, r4
 8004b8e:	bf14      	ite	ne
 8004b90:	2000      	movne	r0, #0
 8004b92:	2001      	moveq	r0, #1
 8004b94:	f008 fb0c 	bl	800d1b0 <_test_assert>
 8004b98:	b118      	cbz	r0, 8004ba2 <rt_test_008_001_execute.lto_priv.104+0xb2>
 8004b9a:	2300      	movs	r3, #0
 8004b9c:	f383 8811 	msr	BASEPRI, r3
 8004ba0:	e002      	b.n	8004ba8 <rt_test_008_001_execute.lto_priv.104+0xb8>
 8004ba2:	2300      	movs	r3, #0
 8004ba4:	f383 8811 	msr	BASEPRI, r3
}
 8004ba8:	b00b      	add	sp, #44	; 0x2c
 8004baa:	bd30      	pop	{r4, r5, pc}
 8004bac:	20002468 	.word	0x20002468
 8004bb0:	20003e04 	.word	0x20003e04
 8004bb4:	0800e7b8 	.word	0x0800e7b8
 8004bb8:	0800e7a8 	.word	0x0800e7a8
 8004bbc:	00000000 	.word	0x00000000

08004bc0 <evt_thread7>:
static THD_FUNCTION(evt_thread7, p) {
 8004bc0:	b508      	push	{r3, lr}
 *
 * @api
 */
static inline void chEvtBroadcast(event_source_t *esp) {

  chEvtBroadcastFlags(esp, (eventflags_t)0);
 8004bc2:	2100      	movs	r1, #0
 8004bc4:	4805      	ldr	r0, [pc, #20]	; (8004bdc <evt_thread7+0x1c>)
 8004bc6:	f005 fab3 	bl	800a130 <chEvtBroadcastFlags>
  chThdSleepMilliseconds(50);
 8004bca:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8004bce:	f007 f83f 	bl	800bc50 <chThdSleep>
 8004bd2:	2100      	movs	r1, #0
 8004bd4:	4802      	ldr	r0, [pc, #8]	; (8004be0 <evt_thread7+0x20>)
 8004bd6:	f005 faab 	bl	800a130 <chEvtBroadcastFlags>
 8004bda:	bd08      	pop	{r3, pc}
 8004bdc:	20002468 	.word	0x20002468
 8004be0:	20002474 	.word	0x20002474
	...

08004bf0 <rt_test_008_006_execute.lto_priv.114>:
static void rt_test_008_006_execute(void) {
 8004bf0:	b508      	push	{r3, lr}
  test_set_step(1);
 8004bf2:	2201      	movs	r2, #1
 8004bf4:	4b28      	ldr	r3, [pc, #160]	; (8004c98 <rt_test_008_006_execute.lto_priv.114+0xa8>)
 8004bf6:	601a      	str	r2, [r3, #0]
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8004bf8:	2100      	movs	r1, #0
 8004bfa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004bfe:	f005 f9ef 	bl	8009fe0 <chEvtWaitOneTimeout>
    test_assert(m == 0, "spurious event");
 8004c02:	4926      	ldr	r1, [pc, #152]	; (8004c9c <rt_test_008_006_execute.lto_priv.114+0xac>)
 8004c04:	fab0 f080 	clz	r0, r0
 8004c08:	0940      	lsrs	r0, r0, #5
 8004c0a:	f008 fad1 	bl	800d1b0 <_test_assert>
 8004c0e:	2800      	cmp	r0, #0
 8004c10:	d140      	bne.n	8004c94 <rt_test_008_006_execute.lto_priv.114+0xa4>
    m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8004c12:	2100      	movs	r1, #0
 8004c14:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004c18:	f005 f9ba 	bl	8009f90 <chEvtWaitAnyTimeout>
    test_assert(m == 0, "spurious event");
 8004c1c:	491f      	ldr	r1, [pc, #124]	; (8004c9c <rt_test_008_006_execute.lto_priv.114+0xac>)
 8004c1e:	fab0 f080 	clz	r0, r0
 8004c22:	0940      	lsrs	r0, r0, #5
 8004c24:	f008 fac4 	bl	800d1b0 <_test_assert>
 8004c28:	bba0      	cbnz	r0, 8004c94 <rt_test_008_006_execute.lto_priv.114+0xa4>
    m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8004c2a:	2100      	movs	r1, #0
 8004c2c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004c30:	f005 f986 	bl	8009f40 <chEvtWaitAllTimeout>
    test_assert(m == 0, "spurious event");
 8004c34:	4919      	ldr	r1, [pc, #100]	; (8004c9c <rt_test_008_006_execute.lto_priv.114+0xac>)
 8004c36:	fab0 f080 	clz	r0, r0
 8004c3a:	0940      	lsrs	r0, r0, #5
 8004c3c:	f008 fab8 	bl	800d1b0 <_test_assert>
 8004c40:	bb40      	cbnz	r0, 8004c94 <rt_test_008_006_execute.lto_priv.114+0xa4>
  test_set_step(2);
 8004c42:	2202      	movs	r2, #2
 8004c44:	4b14      	ldr	r3, [pc, #80]	; (8004c98 <rt_test_008_006_execute.lto_priv.114+0xa8>)
 8004c46:	601a      	str	r2, [r3, #0]
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_MS2I(50));
 8004c48:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8004c4c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004c50:	f005 f9c6 	bl	8009fe0 <chEvtWaitOneTimeout>
    test_assert(m == 0, "spurious event");
 8004c54:	4911      	ldr	r1, [pc, #68]	; (8004c9c <rt_test_008_006_execute.lto_priv.114+0xac>)
 8004c56:	fab0 f080 	clz	r0, r0
 8004c5a:	0940      	lsrs	r0, r0, #5
 8004c5c:	f008 faa8 	bl	800d1b0 <_test_assert>
 8004c60:	b9c0      	cbnz	r0, 8004c94 <rt_test_008_006_execute.lto_priv.114+0xa4>
    m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_MS2I(50));
 8004c62:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8004c66:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004c6a:	f005 f991 	bl	8009f90 <chEvtWaitAnyTimeout>
    test_assert(m == 0, "spurious event");
 8004c6e:	490b      	ldr	r1, [pc, #44]	; (8004c9c <rt_test_008_006_execute.lto_priv.114+0xac>)
 8004c70:	fab0 f080 	clz	r0, r0
 8004c74:	0940      	lsrs	r0, r0, #5
 8004c76:	f008 fa9b 	bl	800d1b0 <_test_assert>
 8004c7a:	b958      	cbnz	r0, 8004c94 <rt_test_008_006_execute.lto_priv.114+0xa4>
    m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_MS2I(50));
 8004c7c:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8004c80:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004c84:	f005 f95c 	bl	8009f40 <chEvtWaitAllTimeout>
    test_assert(m == 0, "spurious event");
 8004c88:	4904      	ldr	r1, [pc, #16]	; (8004c9c <rt_test_008_006_execute.lto_priv.114+0xac>)
 8004c8a:	fab0 f080 	clz	r0, r0
 8004c8e:	0940      	lsrs	r0, r0, #5
 8004c90:	f008 fa8e 	bl	800d1b0 <_test_assert>
 8004c94:	bd08      	pop	{r3, pc}
 8004c96:	bf00      	nop
 8004c98:	20003e04 	.word	0x20003e04
 8004c9c:	0800e7c4 	.word	0x0800e7c4

08004ca0 <rt_test_008_005_execute.lto_priv.112>:
static void rt_test_008_005_execute(void) {
 8004ca0:	b570      	push	{r4, r5, r6, lr}
 8004ca2:	b082      	sub	sp, #8
  test_set_step(1);
 8004ca4:	4c2d      	ldr	r4, [pc, #180]	; (8004d5c <rt_test_008_005_execute.lto_priv.112+0xbc>)
 8004ca6:	2301      	movs	r3, #1
 8004ca8:	6023      	str	r3, [r4, #0]
    chEvtAddEvents(5);
 8004caa:	2005      	movs	r0, #5
 8004cac:	f006 fa28 	bl	800b100 <chEvtAddEvents>
  test_set_step(2);
 8004cb0:	2302      	movs	r3, #2
 8004cb2:	6023      	str	r3, [r4, #0]
    m = chEvtWaitAll(5);
 8004cb4:	2005      	movs	r0, #5
 8004cb6:	f005 f9c3 	bl	800a040 <chEvtWaitAll>
    test_assert(m == 5, "unexpected pending bit");
 8004cba:	4929      	ldr	r1, [pc, #164]	; (8004d60 <rt_test_008_005_execute.lto_priv.112+0xc0>)
 8004cbc:	2805      	cmp	r0, #5
 8004cbe:	bf14      	ite	ne
 8004cc0:	2000      	movne	r0, #0
 8004cc2:	2001      	moveq	r0, #1
 8004cc4:	f008 fa74 	bl	800d1b0 <_test_assert>
 8004cc8:	2800      	cmp	r0, #0
 8004cca:	d145      	bne.n	8004d58 <rt_test_008_005_execute.lto_priv.112+0xb8>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8004ccc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004cd0:	f006 fa26 	bl	800b120 <chEvtGetAndClearEvents>
    test_assert(m == 0, "stuck event");
 8004cd4:	4923      	ldr	r1, [pc, #140]	; (8004d64 <rt_test_008_005_execute.lto_priv.112+0xc4>)
 8004cd6:	fab0 f080 	clz	r0, r0
 8004cda:	0940      	lsrs	r0, r0, #5
 8004cdc:	f008 fa68 	bl	800d1b0 <_test_assert>
 8004ce0:	2800      	cmp	r0, #0
 8004ce2:	d139      	bne.n	8004d58 <rt_test_008_005_execute.lto_priv.112+0xb8>
  test_set_step(3);
 8004ce4:	2303      	movs	r3, #3
 8004ce6:	6023      	str	r3, [r4, #0]
    chEvtAddEvents(4);
 8004ce8:	2004      	movs	r0, #4
 8004cea:	f006 fa09 	bl	800b100 <chEvtAddEvents>
  test_set_step(4);
 8004cee:	2304      	movs	r3, #4
 8004cf0:	6023      	str	r3, [r4, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8004cf2:	f007 fe15 	bl	800c920 <test_wait_tick>
 8004cf6:	4605      	mov	r5, r0
 8004cf8:	f500 76fa 	add.w	r6, r0, #500	; 0x1f4
  return ch.rlist.current;
 8004cfc:	4b1a      	ldr	r3, [pc, #104]	; (8004d68 <rt_test_008_005_execute.lto_priv.112+0xc8>)
 8004cfe:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 8004d00:	689a      	ldr	r2, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8004d02:	9300      	str	r3, [sp, #0]
 8004d04:	4b19      	ldr	r3, [pc, #100]	; (8004d6c <rt_test_008_005_execute.lto_priv.112+0xcc>)
 8004d06:	3a01      	subs	r2, #1
 8004d08:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8004d0c:	4818      	ldr	r0, [pc, #96]	; (8004d70 <rt_test_008_005_execute.lto_priv.112+0xd0>)
 8004d0e:	f006 fd2f 	bl	800b770 <chThdCreateStatic>
 8004d12:	4b18      	ldr	r3, [pc, #96]	; (8004d74 <rt_test_008_005_execute.lto_priv.112+0xd4>)
 8004d14:	6018      	str	r0, [r3, #0]
  test_set_step(5);
 8004d16:	2005      	movs	r0, #5
 8004d18:	6020      	str	r0, [r4, #0]
    m = chEvtWaitAll(5);
 8004d1a:	f005 f991 	bl	800a040 <chEvtWaitAll>
 8004d1e:	4604      	mov	r4, r0
    test_assert_time_window(target_time,
 8004d20:	4a15      	ldr	r2, [pc, #84]	; (8004d78 <rt_test_008_005_execute.lto_priv.112+0xd8>)
 8004d22:	f505 7102 	add.w	r1, r5, #520	; 0x208
 8004d26:	4630      	mov	r0, r6
 8004d28:	f008 fb0a 	bl	800d340 <_test_assert_time_window>
 8004d2c:	b9a0      	cbnz	r0, 8004d58 <rt_test_008_005_execute.lto_priv.112+0xb8>
    test_assert(m == 5, "event flags error");
 8004d2e:	4913      	ldr	r1, [pc, #76]	; (8004d7c <rt_test_008_005_execute.lto_priv.112+0xdc>)
 8004d30:	2c05      	cmp	r4, #5
 8004d32:	bf14      	ite	ne
 8004d34:	2000      	movne	r0, #0
 8004d36:	2001      	moveq	r0, #1
 8004d38:	f008 fa3a 	bl	800d1b0 <_test_assert>
 8004d3c:	b960      	cbnz	r0, 8004d58 <rt_test_008_005_execute.lto_priv.112+0xb8>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8004d3e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004d42:	f006 f9ed 	bl	800b120 <chEvtGetAndClearEvents>
    test_assert(m == 0, "stuck event");
 8004d46:	4907      	ldr	r1, [pc, #28]	; (8004d64 <rt_test_008_005_execute.lto_priv.112+0xc4>)
 8004d48:	fab0 f080 	clz	r0, r0
 8004d4c:	0940      	lsrs	r0, r0, #5
 8004d4e:	f008 fa2f 	bl	800d1b0 <_test_assert>
 8004d52:	b908      	cbnz	r0, 8004d58 <rt_test_008_005_execute.lto_priv.112+0xb8>
    test_wait_threads();
 8004d54:	f007 fdf4 	bl	800c940 <test_wait_threads>
}
 8004d58:	b002      	add	sp, #8
 8004d5a:	bd70      	pop	{r4, r5, r6, pc}
 8004d5c:	20003e04 	.word	0x20003e04
 8004d60:	0800e7d4 	.word	0x0800e7d4
 8004d64:	0800e79c 	.word	0x0800e79c
 8004d68:	20003aec 	.word	0x20003aec
 8004d6c:	08004d81 	.word	0x08004d81
 8004d70:	200025f0 	.word	0x200025f0
 8004d74:	20002f1c 	.word	0x20002f1c
 8004d78:	0800e788 	.word	0x0800e788
 8004d7c:	0800e7ec 	.word	0x0800e7ec

08004d80 <evt_thread3>:
static THD_FUNCTION(evt_thread3, p) {
 8004d80:	b510      	push	{r4, lr}
 8004d82:	4604      	mov	r4, r0
  chThdSleepMilliseconds(50);
 8004d84:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8004d88:	f006 ff62 	bl	800bc50 <chThdSleep>
  chEvtSignal((thread_t *)p, 1);
 8004d8c:	2101      	movs	r1, #1
 8004d8e:	4620      	mov	r0, r4
 8004d90:	f006 fbd6 	bl	800b540 <chEvtSignal>
 8004d94:	bd10      	pop	{r4, pc}
 8004d96:	bf00      	nop
	...

08004da0 <rt_test_008_004_execute.lto_priv.110>:
static void rt_test_008_004_execute(void) {
 8004da0:	b570      	push	{r4, r5, r6, lr}
 8004da2:	b082      	sub	sp, #8
  test_set_step(1);
 8004da4:	4c2d      	ldr	r4, [pc, #180]	; (8004e5c <rt_test_008_004_execute.lto_priv.110+0xbc>)
 8004da6:	2301      	movs	r3, #1
 8004da8:	6023      	str	r3, [r4, #0]
    chEvtAddEvents(5);
 8004daa:	2005      	movs	r0, #5
 8004dac:	f006 f9a8 	bl	800b100 <chEvtAddEvents>
  test_set_step(2);
 8004db0:	2302      	movs	r3, #2
 8004db2:	6023      	str	r3, [r4, #0]
    m = chEvtWaitAny(ALL_EVENTS);
 8004db4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004db8:	f005 f962 	bl	800a080 <chEvtWaitAny>
    test_assert(m == 5, "unexpected pending bit");
 8004dbc:	4928      	ldr	r1, [pc, #160]	; (8004e60 <rt_test_008_004_execute.lto_priv.110+0xc0>)
 8004dbe:	2805      	cmp	r0, #5
 8004dc0:	bf14      	ite	ne
 8004dc2:	2000      	movne	r0, #0
 8004dc4:	2001      	moveq	r0, #1
 8004dc6:	f008 f9f3 	bl	800d1b0 <_test_assert>
 8004dca:	2800      	cmp	r0, #0
 8004dcc:	d143      	bne.n	8004e56 <rt_test_008_004_execute.lto_priv.110+0xb6>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8004dce:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004dd2:	f006 f9a5 	bl	800b120 <chEvtGetAndClearEvents>
    test_assert(m == 0, "stuck event");
 8004dd6:	4923      	ldr	r1, [pc, #140]	; (8004e64 <rt_test_008_004_execute.lto_priv.110+0xc4>)
 8004dd8:	fab0 f080 	clz	r0, r0
 8004ddc:	0940      	lsrs	r0, r0, #5
 8004dde:	f008 f9e7 	bl	800d1b0 <_test_assert>
 8004de2:	2800      	cmp	r0, #0
 8004de4:	d137      	bne.n	8004e56 <rt_test_008_004_execute.lto_priv.110+0xb6>
  test_set_step(3);
 8004de6:	4625      	mov	r5, r4
 8004de8:	2303      	movs	r3, #3
 8004dea:	6023      	str	r3, [r4, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8004dec:	f007 fd98 	bl	800c920 <test_wait_tick>
 8004df0:	4604      	mov	r4, r0
 8004df2:	f500 76fa 	add.w	r6, r0, #500	; 0x1f4
  return ch.rlist.current;
 8004df6:	4b1c      	ldr	r3, [pc, #112]	; (8004e68 <rt_test_008_004_execute.lto_priv.110+0xc8>)
 8004df8:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 8004dfa:	689a      	ldr	r2, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8004dfc:	9300      	str	r3, [sp, #0]
 8004dfe:	4b1b      	ldr	r3, [pc, #108]	; (8004e6c <rt_test_008_004_execute.lto_priv.110+0xcc>)
 8004e00:	3a01      	subs	r2, #1
 8004e02:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8004e06:	481a      	ldr	r0, [pc, #104]	; (8004e70 <rt_test_008_004_execute.lto_priv.110+0xd0>)
 8004e08:	f006 fcb2 	bl	800b770 <chThdCreateStatic>
 8004e0c:	4b19      	ldr	r3, [pc, #100]	; (8004e74 <rt_test_008_004_execute.lto_priv.110+0xd4>)
 8004e0e:	6018      	str	r0, [r3, #0]
  test_set_step(4);
 8004e10:	2304      	movs	r3, #4
 8004e12:	602b      	str	r3, [r5, #0]
    m = chEvtWaitAny(ALL_EVENTS);
 8004e14:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004e18:	f005 f932 	bl	800a080 <chEvtWaitAny>
 8004e1c:	4605      	mov	r5, r0
    test_assert_time_window(target_time,
 8004e1e:	4a16      	ldr	r2, [pc, #88]	; (8004e78 <rt_test_008_004_execute.lto_priv.110+0xd8>)
 8004e20:	f504 7102 	add.w	r1, r4, #520	; 0x208
 8004e24:	4630      	mov	r0, r6
 8004e26:	f008 fa8b 	bl	800d340 <_test_assert_time_window>
 8004e2a:	b9a0      	cbnz	r0, 8004e56 <rt_test_008_004_execute.lto_priv.110+0xb6>
    test_assert(m == 1, "event flag error");
 8004e2c:	4913      	ldr	r1, [pc, #76]	; (8004e7c <rt_test_008_004_execute.lto_priv.110+0xdc>)
 8004e2e:	2d01      	cmp	r5, #1
 8004e30:	bf14      	ite	ne
 8004e32:	2000      	movne	r0, #0
 8004e34:	2001      	moveq	r0, #1
 8004e36:	f008 f9bb 	bl	800d1b0 <_test_assert>
 8004e3a:	b960      	cbnz	r0, 8004e56 <rt_test_008_004_execute.lto_priv.110+0xb6>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8004e3c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004e40:	f006 f96e 	bl	800b120 <chEvtGetAndClearEvents>
    test_assert(m == 0, "stuck event");
 8004e44:	4907      	ldr	r1, [pc, #28]	; (8004e64 <rt_test_008_004_execute.lto_priv.110+0xc4>)
 8004e46:	fab0 f080 	clz	r0, r0
 8004e4a:	0940      	lsrs	r0, r0, #5
 8004e4c:	f008 f9b0 	bl	800d1b0 <_test_assert>
 8004e50:	b908      	cbnz	r0, 8004e56 <rt_test_008_004_execute.lto_priv.110+0xb6>
    test_wait_threads();
 8004e52:	f007 fd75 	bl	800c940 <test_wait_threads>
}
 8004e56:	b002      	add	sp, #8
 8004e58:	bd70      	pop	{r4, r5, r6, pc}
 8004e5a:	bf00      	nop
 8004e5c:	20003e04 	.word	0x20003e04
 8004e60:	0800e7d4 	.word	0x0800e7d4
 8004e64:	0800e79c 	.word	0x0800e79c
 8004e68:	20003aec 	.word	0x20003aec
 8004e6c:	08004d81 	.word	0x08004d81
 8004e70:	200025f0 	.word	0x200025f0
 8004e74:	20002f1c 	.word	0x20002f1c
 8004e78:	0800e788 	.word	0x0800e788
 8004e7c:	0800e800 	.word	0x0800e800

08004e80 <rt_test_008_003_execute.lto_priv.108>:
static void rt_test_008_003_execute(void) {
 8004e80:	b570      	push	{r4, r5, r6, lr}
 8004e82:	b082      	sub	sp, #8
  test_set_step(1);
 8004e84:	4c3a      	ldr	r4, [pc, #232]	; (8004f70 <rt_test_008_003_execute.lto_priv.108+0xf0>)
 8004e86:	2301      	movs	r3, #1
 8004e88:	6023      	str	r3, [r4, #0]
    chEvtAddEvents(7);
 8004e8a:	2007      	movs	r0, #7
 8004e8c:	f006 f938 	bl	800b100 <chEvtAddEvents>
  test_set_step(2);
 8004e90:	2302      	movs	r3, #2
 8004e92:	6023      	str	r3, [r4, #0]
    m = chEvtWaitOne(ALL_EVENTS);
 8004e94:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004e98:	f005 f912 	bl	800a0c0 <chEvtWaitOne>
    test_assert(m == 1, "single event error");
 8004e9c:	4935      	ldr	r1, [pc, #212]	; (8004f74 <rt_test_008_003_execute.lto_priv.108+0xf4>)
 8004e9e:	2801      	cmp	r0, #1
 8004ea0:	bf14      	ite	ne
 8004ea2:	2000      	movne	r0, #0
 8004ea4:	2001      	moveq	r0, #1
 8004ea6:	f008 f983 	bl	800d1b0 <_test_assert>
 8004eaa:	2800      	cmp	r0, #0
 8004eac:	d15d      	bne.n	8004f6a <rt_test_008_003_execute.lto_priv.108+0xea>
    m = chEvtWaitOne(ALL_EVENTS);
 8004eae:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004eb2:	f005 f905 	bl	800a0c0 <chEvtWaitOne>
    test_assert(m == 2, "single event error");
 8004eb6:	492f      	ldr	r1, [pc, #188]	; (8004f74 <rt_test_008_003_execute.lto_priv.108+0xf4>)
 8004eb8:	2802      	cmp	r0, #2
 8004eba:	bf14      	ite	ne
 8004ebc:	2000      	movne	r0, #0
 8004ebe:	2001      	moveq	r0, #1
 8004ec0:	f008 f976 	bl	800d1b0 <_test_assert>
 8004ec4:	2800      	cmp	r0, #0
 8004ec6:	d150      	bne.n	8004f6a <rt_test_008_003_execute.lto_priv.108+0xea>
    m = chEvtWaitOne(ALL_EVENTS);
 8004ec8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004ecc:	f005 f8f8 	bl	800a0c0 <chEvtWaitOne>
    test_assert(m == 4, "single event error");
 8004ed0:	4928      	ldr	r1, [pc, #160]	; (8004f74 <rt_test_008_003_execute.lto_priv.108+0xf4>)
 8004ed2:	2804      	cmp	r0, #4
 8004ed4:	bf14      	ite	ne
 8004ed6:	2000      	movne	r0, #0
 8004ed8:	2001      	moveq	r0, #1
 8004eda:	f008 f969 	bl	800d1b0 <_test_assert>
 8004ede:	2800      	cmp	r0, #0
 8004ee0:	d143      	bne.n	8004f6a <rt_test_008_003_execute.lto_priv.108+0xea>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8004ee2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004ee6:	f006 f91b 	bl	800b120 <chEvtGetAndClearEvents>
    test_assert(m == 0, "stuck event");
 8004eea:	4923      	ldr	r1, [pc, #140]	; (8004f78 <rt_test_008_003_execute.lto_priv.108+0xf8>)
 8004eec:	fab0 f080 	clz	r0, r0
 8004ef0:	0940      	lsrs	r0, r0, #5
 8004ef2:	f008 f95d 	bl	800d1b0 <_test_assert>
 8004ef6:	2800      	cmp	r0, #0
 8004ef8:	d137      	bne.n	8004f6a <rt_test_008_003_execute.lto_priv.108+0xea>
  test_set_step(3);
 8004efa:	4625      	mov	r5, r4
 8004efc:	2303      	movs	r3, #3
 8004efe:	6023      	str	r3, [r4, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8004f00:	f007 fd0e 	bl	800c920 <test_wait_tick>
 8004f04:	4604      	mov	r4, r0
 8004f06:	f500 76fa 	add.w	r6, r0, #500	; 0x1f4
  return ch.rlist.current;
 8004f0a:	4b1c      	ldr	r3, [pc, #112]	; (8004f7c <rt_test_008_003_execute.lto_priv.108+0xfc>)
 8004f0c:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 8004f0e:	689a      	ldr	r2, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8004f10:	9300      	str	r3, [sp, #0]
 8004f12:	4b1b      	ldr	r3, [pc, #108]	; (8004f80 <rt_test_008_003_execute.lto_priv.108+0x100>)
 8004f14:	3a01      	subs	r2, #1
 8004f16:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8004f1a:	481a      	ldr	r0, [pc, #104]	; (8004f84 <rt_test_008_003_execute.lto_priv.108+0x104>)
 8004f1c:	f006 fc28 	bl	800b770 <chThdCreateStatic>
 8004f20:	4b19      	ldr	r3, [pc, #100]	; (8004f88 <rt_test_008_003_execute.lto_priv.108+0x108>)
 8004f22:	6018      	str	r0, [r3, #0]
  test_set_step(4);
 8004f24:	2304      	movs	r3, #4
 8004f26:	602b      	str	r3, [r5, #0]
    m = chEvtWaitOne(ALL_EVENTS);
 8004f28:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004f2c:	f005 f8c8 	bl	800a0c0 <chEvtWaitOne>
 8004f30:	4605      	mov	r5, r0
    test_assert_time_window(target_time,
 8004f32:	4a16      	ldr	r2, [pc, #88]	; (8004f8c <rt_test_008_003_execute.lto_priv.108+0x10c>)
 8004f34:	f504 7102 	add.w	r1, r4, #520	; 0x208
 8004f38:	4630      	mov	r0, r6
 8004f3a:	f008 fa01 	bl	800d340 <_test_assert_time_window>
 8004f3e:	b9a0      	cbnz	r0, 8004f6a <rt_test_008_003_execute.lto_priv.108+0xea>
    test_assert(m == 1, "event flag error");
 8004f40:	4913      	ldr	r1, [pc, #76]	; (8004f90 <rt_test_008_003_execute.lto_priv.108+0x110>)
 8004f42:	2d01      	cmp	r5, #1
 8004f44:	bf14      	ite	ne
 8004f46:	2000      	movne	r0, #0
 8004f48:	2001      	moveq	r0, #1
 8004f4a:	f008 f931 	bl	800d1b0 <_test_assert>
 8004f4e:	b960      	cbnz	r0, 8004f6a <rt_test_008_003_execute.lto_priv.108+0xea>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8004f50:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004f54:	f006 f8e4 	bl	800b120 <chEvtGetAndClearEvents>
    test_assert(m == 0, "stuck event");
 8004f58:	4907      	ldr	r1, [pc, #28]	; (8004f78 <rt_test_008_003_execute.lto_priv.108+0xf8>)
 8004f5a:	fab0 f080 	clz	r0, r0
 8004f5e:	0940      	lsrs	r0, r0, #5
 8004f60:	f008 f926 	bl	800d1b0 <_test_assert>
 8004f64:	b908      	cbnz	r0, 8004f6a <rt_test_008_003_execute.lto_priv.108+0xea>
    test_wait_threads();
 8004f66:	f007 fceb 	bl	800c940 <test_wait_threads>
}
 8004f6a:	b002      	add	sp, #8
 8004f6c:	bd70      	pop	{r4, r5, r6, pc}
 8004f6e:	bf00      	nop
 8004f70:	20003e04 	.word	0x20003e04
 8004f74:	0800e814 	.word	0x0800e814
 8004f78:	0800e79c 	.word	0x0800e79c
 8004f7c:	20003aec 	.word	0x20003aec
 8004f80:	08004d81 	.word	0x08004d81
 8004f84:	200025f0 	.word	0x200025f0
 8004f88:	20002f1c 	.word	0x20002f1c
 8004f8c:	0800e788 	.word	0x0800e788
 8004f90:	0800e800 	.word	0x0800e800
	...

08004fa0 <rt_test_008_002_execute.lto_priv.106>:
static void rt_test_008_002_execute(void) {
 8004fa0:	b508      	push	{r3, lr}
  test_set_step(1);
 8004fa2:	2201      	movs	r2, #1
 8004fa4:	4b05      	ldr	r3, [pc, #20]	; (8004fbc <rt_test_008_002_execute.lto_priv.106+0x1c>)
 8004fa6:	601a      	str	r2, [r3, #0]
    chEvtDispatch(evhndl, 7);
 8004fa8:	2107      	movs	r1, #7
 8004faa:	4805      	ldr	r0, [pc, #20]	; (8004fc0 <rt_test_008_002_execute.lto_priv.106+0x20>)
 8004fac:	f005 f8a8 	bl	800a100 <chEvtDispatch>
    test_assert_sequence("ABC", "invalid sequence");
 8004fb0:	4904      	ldr	r1, [pc, #16]	; (8004fc4 <rt_test_008_002_execute.lto_priv.106+0x24>)
 8004fb2:	4805      	ldr	r0, [pc, #20]	; (8004fc8 <rt_test_008_002_execute.lto_priv.106+0x28>)
 8004fb4:	f008 f8d4 	bl	800d160 <_test_assert_sequence>
 8004fb8:	bd08      	pop	{r3, pc}
 8004fba:	bf00      	nop
 8004fbc:	20003e04 	.word	0x20003e04
 8004fc0:	0800e884 	.word	0x0800e884
 8004fc4:	0800e6e8 	.word	0x0800e6e8
 8004fc8:	0800e828 	.word	0x0800e828
 8004fcc:	00000000 	.word	0x00000000

08004fd0 <rt_test_007_001_execute.lto_priv.103>:
 * - [7.1.1] Starting the messenger thread.
 * - [7.1.2] Waiting for four messages then testing the receive order.
 * .
 */

static void rt_test_007_001_execute(void) {
 8004fd0:	b530      	push	{r4, r5, lr}
 8004fd2:	b083      	sub	sp, #12
  thread_t *tp;
  msg_t msg;

  /* [7.1.1] Starting the messenger thread.*/
  test_set_step(1);
 8004fd4:	4c13      	ldr	r4, [pc, #76]	; (8005024 <rt_test_007_001_execute.lto_priv.103+0x54>)
 8004fd6:	2301      	movs	r3, #1
 8004fd8:	6023      	str	r3, [r4, #0]
  return ch.rlist.current;
 8004fda:	4b13      	ldr	r3, [pc, #76]	; (8005028 <rt_test_007_001_execute.lto_priv.103+0x58>)
 8004fdc:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 8004fde:	689a      	ldr	r2, [r3, #8]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8004fe0:	9300      	str	r3, [sp, #0]
 8004fe2:	4b12      	ldr	r3, [pc, #72]	; (800502c <rt_test_007_001_execute.lto_priv.103+0x5c>)
 8004fe4:	3201      	adds	r2, #1
 8004fe6:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8004fea:	4811      	ldr	r0, [pc, #68]	; (8005030 <rt_test_007_001_execute.lto_priv.103+0x60>)
 8004fec:	f006 fbc0 	bl	800b770 <chThdCreateStatic>
 8004ff0:	4b10      	ldr	r3, [pc, #64]	; (8005034 <rt_test_007_001_execute.lto_priv.103+0x64>)
 8004ff2:	6018      	str	r0, [r3, #0]
                                   msg_thread1, chThdGetSelfX());
  }

  /* [7.1.2] Waiting for four messages then testing the receive
     order.*/
  test_set_step(2);
 8004ff4:	2302      	movs	r3, #2
 8004ff6:	6023      	str	r3, [r4, #0]
  {
    unsigned i;

    for (i = 0; i < 4; i++) {
 8004ff8:	2400      	movs	r4, #0
 8004ffa:	e009      	b.n	8005010 <rt_test_007_001_execute.lto_priv.103+0x40>
      tp = chMsgWait();
 8004ffc:	f004 ff60 	bl	8009ec0 <chMsgWait>
 8005000:	6a45      	ldr	r5, [r0, #36]	; 0x24
      msg = chMsgGet(tp);
      chMsgRelease(tp, msg);
 8005002:	4629      	mov	r1, r5
 8005004:	f004 ff4c 	bl	8009ea0 <chMsgRelease>
      test_emit_token(msg);
 8005008:	b2e8      	uxtb	r0, r5
 800500a:	f007 fcc1 	bl	800c990 <test_emit_token>
    for (i = 0; i < 4; i++) {
 800500e:	3401      	adds	r4, #1
 8005010:	2c03      	cmp	r4, #3
 8005012:	d9f3      	bls.n	8004ffc <rt_test_007_001_execute.lto_priv.103+0x2c>
    }
    test_wait_threads();
 8005014:	f007 fc94 	bl	800c940 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
 8005018:	4907      	ldr	r1, [pc, #28]	; (8005038 <rt_test_007_001_execute.lto_priv.103+0x68>)
 800501a:	4808      	ldr	r0, [pc, #32]	; (800503c <rt_test_007_001_execute.lto_priv.103+0x6c>)
 800501c:	f008 f8a0 	bl	800d160 <_test_assert_sequence>
  }
}
 8005020:	b003      	add	sp, #12
 8005022:	bd30      	pop	{r4, r5, pc}
 8005024:	20003e04 	.word	0x20003e04
 8005028:	20003aec 	.word	0x20003aec
 800502c:	08005041 	.word	0x08005041
 8005030:	200025f0 	.word	0x200025f0
 8005034:	20002f1c 	.word	0x20002f1c
 8005038:	0800e6e8 	.word	0x0800e6e8
 800503c:	0800e55c 	.word	0x0800e55c

08005040 <msg_thread1>:
static THD_FUNCTION(msg_thread1, p) {
 8005040:	b510      	push	{r4, lr}
 8005042:	4604      	mov	r4, r0
  chMsgSend(p, 'A');
 8005044:	2141      	movs	r1, #65	; 0x41
 8005046:	f004 ff5b 	bl	8009f00 <chMsgSend>
  chMsgSend(p, 'B');
 800504a:	2142      	movs	r1, #66	; 0x42
 800504c:	4620      	mov	r0, r4
 800504e:	f004 ff57 	bl	8009f00 <chMsgSend>
  chMsgSend(p, 'C');
 8005052:	2143      	movs	r1, #67	; 0x43
 8005054:	4620      	mov	r0, r4
 8005056:	f004 ff53 	bl	8009f00 <chMsgSend>
  chMsgSend(p, 'D');
 800505a:	2144      	movs	r1, #68	; 0x44
 800505c:	4620      	mov	r0, r4
 800505e:	f004 ff4f 	bl	8009f00 <chMsgSend>
 8005062:	bd10      	pop	{r4, pc}
	...

08005070 <rt_test_006_009_execute.lto_priv.102>:
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static void rt_test_006_009_execute(void) {
 8005070:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005072:	b083      	sub	sp, #12
  tprio_t prio;

  /* [6.9.1] Reading current base priority.*/
  test_set_step(1);
 8005074:	4c1f      	ldr	r4, [pc, #124]	; (80050f4 <rt_test_006_009_execute.lto_priv.102+0x84>)
  return ch.rlist.current;
 8005076:	4b20      	ldr	r3, [pc, #128]	; (80050f8 <rt_test_006_009_execute.lto_priv.102+0x88>)
 8005078:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 800507a:	689f      	ldr	r7, [r3, #8]
    prio = chThdGetPriorityX();
  }

  /* [6.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
 800507c:	2302      	movs	r3, #2
 800507e:	6023      	str	r3, [r4, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8005080:	4e1e      	ldr	r6, [pc, #120]	; (80050fc <rt_test_006_009_execute.lto_priv.102+0x8c>)
 8005082:	4b1f      	ldr	r3, [pc, #124]	; (8005100 <rt_test_006_009_execute.lto_priv.102+0x90>)
 8005084:	9300      	str	r3, [sp, #0]
 8005086:	4b1f      	ldr	r3, [pc, #124]	; (8005104 <rt_test_006_009_execute.lto_priv.102+0x94>)
 8005088:	1c7a      	adds	r2, r7, #1
 800508a:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800508e:	4630      	mov	r0, r6
 8005090:	f006 fb6e 	bl	800b770 <chThdCreateStatic>
 8005094:	4d1c      	ldr	r5, [pc, #112]	; (8005108 <rt_test_006_009_execute.lto_priv.102+0x98>)
 8005096:	6028      	str	r0, [r5, #0]
  }

  /* [6.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
 8005098:	2303      	movs	r3, #3
 800509a:	6023      	str	r3, [r4, #0]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 800509c:	4b1b      	ldr	r3, [pc, #108]	; (800510c <rt_test_006_009_execute.lto_priv.102+0x9c>)
 800509e:	9300      	str	r3, [sp, #0]
 80050a0:	4b1b      	ldr	r3, [pc, #108]	; (8005110 <rt_test_006_009_execute.lto_priv.102+0xa0>)
 80050a2:	1cba      	adds	r2, r7, #2
 80050a4:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80050a8:	1870      	adds	r0, r6, r1
 80050aa:	f006 fb61 	bl	800b770 <chThdCreateStatic>
 80050ae:	6068      	str	r0, [r5, #4]
  }

  /* [6.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
 80050b0:	2304      	movs	r3, #4
 80050b2:	6023      	str	r3, [r4, #0]
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 80050b4:	4b17      	ldr	r3, [pc, #92]	; (8005114 <rt_test_006_009_execute.lto_priv.102+0xa4>)
 80050b6:	9300      	str	r3, [sp, #0]
 80050b8:	4b17      	ldr	r3, [pc, #92]	; (8005118 <rt_test_006_009_execute.lto_priv.102+0xa8>)
 80050ba:	1cfa      	adds	r2, r7, #3
 80050bc:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80050c0:	f506 7068 	add.w	r0, r6, #928	; 0x3a0
 80050c4:	f006 fb54 	bl	800b770 <chThdCreateStatic>
 80050c8:	60a8      	str	r0, [r5, #8]
  }

  /* [6.9.5] Signaling C1: TA wakes up, unlocks M1 and priority goes to
     P(+2). TB locks M1, unlocks M1 and completes. TA unlocks M2 and
     priority goes to P(+1). TC waits on C1. TA completes.*/
  test_set_step(5);
 80050ca:	2305      	movs	r3, #5
 80050cc:	6023      	str	r3, [r4, #0]
  {
    chCondSignal(&c1);
 80050ce:	4d13      	ldr	r5, [pc, #76]	; (800511c <rt_test_006_009_execute.lto_priv.102+0xac>)
 80050d0:	4628      	mov	r0, r5
 80050d2:	f006 fafd 	bl	800b6d0 <chCondSignal>
  }

  /* [6.9.6] Signaling C1: TC wakes up, unlocks M1 and completes.*/
  test_set_step(6);
 80050d6:	2306      	movs	r3, #6
 80050d8:	6023      	str	r3, [r4, #0]
  {
    chCondSignal(&c1);
 80050da:	4628      	mov	r0, r5
 80050dc:	f006 faf8 	bl	800b6d0 <chCondSignal>
  }

  /* [6.9.7] Checking the order of operations.*/
  test_set_step(7);
 80050e0:	2307      	movs	r3, #7
 80050e2:	6023      	str	r3, [r4, #0]
  {
    test_wait_threads();
 80050e4:	f007 fc2c 	bl	800c940 <test_wait_threads>
    test_assert_sequence("ABC", "invalid sequence");
 80050e8:	490d      	ldr	r1, [pc, #52]	; (8005120 <rt_test_006_009_execute.lto_priv.102+0xb0>)
 80050ea:	480e      	ldr	r0, [pc, #56]	; (8005124 <rt_test_006_009_execute.lto_priv.102+0xb4>)
 80050ec:	f008 f838 	bl	800d160 <_test_assert_sequence>
  }
}
 80050f0:	b003      	add	sp, #12
 80050f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80050f4:	20003e04 	.word	0x20003e04
 80050f8:	20003aec 	.word	0x20003aec
 80050fc:	200025f0 	.word	0x200025f0
 8005100:	0800e68c 	.word	0x0800e68c
 8005104:	08007871 	.word	0x08007871
 8005108:	20002f1c 	.word	0x20002f1c
 800510c:	08010ec4 	.word	0x08010ec4
 8005110:	080078b1 	.word	0x080078b1
 8005114:	0800e698 	.word	0x0800e698
 8005118:	08007831 	.word	0x08007831
 800511c:	2000246c 	.word	0x2000246c
 8005120:	0800e6e8 	.word	0x0800e6e8
 8005124:	0800e828 	.word	0x0800e828
	...

08005130 <rt_test_006_005_setup.lto_priv.95>:
static void rt_test_006_005_setup(void) {
 8005130:	b508      	push	{r3, lr}
  chMtxObjectInit(&m1);
 8005132:	4802      	ldr	r0, [pc, #8]	; (800513c <rt_test_006_005_setup.lto_priv.95+0xc>)
 8005134:	f006 f884 	bl	800b240 <chMtxObjectInit>
 8005138:	bd08      	pop	{r3, pc}
 800513a:	bf00      	nop
 800513c:	20002458 	.word	0x20002458

08005140 <rt_test_006_004_setup.lto_priv.92>:
static void rt_test_006_004_setup(void) {
 8005140:	b508      	push	{r3, lr}
  chMtxObjectInit(&m1);
 8005142:	4803      	ldr	r0, [pc, #12]	; (8005150 <rt_test_006_004_setup.lto_priv.92+0x10>)
 8005144:	f006 f87c 	bl	800b240 <chMtxObjectInit>
  chMtxObjectInit(&m2);
 8005148:	4802      	ldr	r0, [pc, #8]	; (8005154 <rt_test_006_004_setup.lto_priv.92+0x14>)
 800514a:	f006 f879 	bl	800b240 <chMtxObjectInit>
 800514e:	bd08      	pop	{r3, pc}
 8005150:	20002458 	.word	0x20002458
 8005154:	20002448 	.word	0x20002448
	...

08005160 <rt_test_006_009_setup.lto_priv.101>:
static void rt_test_006_009_setup(void) {
 8005160:	b508      	push	{r3, lr}
  chCondObjectInit(&c1);
 8005162:	4805      	ldr	r0, [pc, #20]	; (8005178 <rt_test_006_009_setup.lto_priv.101+0x18>)
 8005164:	f006 f82c 	bl	800b1c0 <chCondObjectInit>
  chMtxObjectInit(&m1);
 8005168:	4804      	ldr	r0, [pc, #16]	; (800517c <rt_test_006_009_setup.lto_priv.101+0x1c>)
 800516a:	f006 f869 	bl	800b240 <chMtxObjectInit>
  chMtxObjectInit(&m2);
 800516e:	4804      	ldr	r0, [pc, #16]	; (8005180 <rt_test_006_009_setup.lto_priv.101+0x20>)
 8005170:	f006 f866 	bl	800b240 <chMtxObjectInit>
 8005174:	bd08      	pop	{r3, pc}
 8005176:	bf00      	nop
 8005178:	2000246c 	.word	0x2000246c
 800517c:	20002458 	.word	0x20002458
 8005180:	20002448 	.word	0x20002448
	...

08005190 <rt_test_006_008_setup.lto_priv.99>:
static void rt_test_006_008_setup(void) {
 8005190:	b508      	push	{r3, lr}
  chCondObjectInit(&c1);
 8005192:	4803      	ldr	r0, [pc, #12]	; (80051a0 <rt_test_006_008_setup.lto_priv.99+0x10>)
 8005194:	f006 f814 	bl	800b1c0 <chCondObjectInit>
  chMtxObjectInit(&m1);
 8005198:	4802      	ldr	r0, [pc, #8]	; (80051a4 <rt_test_006_008_setup.lto_priv.99+0x14>)
 800519a:	f006 f851 	bl	800b240 <chMtxObjectInit>
 800519e:	bd08      	pop	{r3, pc}
 80051a0:	2000246c 	.word	0x2000246c
 80051a4:	20002458 	.word	0x20002458
	...

080051b0 <rt_test_006_007_setup.lto_priv.97>:
static void rt_test_006_007_setup(void) {
 80051b0:	b508      	push	{r3, lr}
  chCondObjectInit(&c1);
 80051b2:	4803      	ldr	r0, [pc, #12]	; (80051c0 <rt_test_006_007_setup.lto_priv.97+0x10>)
 80051b4:	f006 f804 	bl	800b1c0 <chCondObjectInit>
  chMtxObjectInit(&m1);
 80051b8:	4802      	ldr	r0, [pc, #8]	; (80051c4 <rt_test_006_007_setup.lto_priv.97+0x14>)
 80051ba:	f006 f841 	bl	800b240 <chMtxObjectInit>
 80051be:	bd08      	pop	{r3, pc}
 80051c0:	2000246c 	.word	0x2000246c
 80051c4:	20002458 	.word	0x20002458
	...

080051d0 <rt_test_006_008_execute.lto_priv.100>:
static void rt_test_006_008_execute(void) {
 80051d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80051d4:	b082      	sub	sp, #8
  test_set_step(1);
 80051d6:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 80052a4 <rt_test_006_008_execute.lto_priv.100+0xd4>
 80051da:	2301      	movs	r3, #1
 80051dc:	f8c8 3000 	str.w	r3, [r8]
  return ch.rlist.current;
 80051e0:	4b24      	ldr	r3, [pc, #144]	; (8005274 <rt_test_006_008_execute.lto_priv.100+0xa4>)
 80051e2:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 80051e4:	689e      	ldr	r6, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80051e6:	4f24      	ldr	r7, [pc, #144]	; (8005278 <rt_test_006_008_execute.lto_priv.100+0xa8>)
 80051e8:	4d24      	ldr	r5, [pc, #144]	; (800527c <rt_test_006_008_execute.lto_priv.100+0xac>)
 80051ea:	4b25      	ldr	r3, [pc, #148]	; (8005280 <rt_test_006_008_execute.lto_priv.100+0xb0>)
 80051ec:	9300      	str	r3, [sp, #0]
 80051ee:	463b      	mov	r3, r7
 80051f0:	1c72      	adds	r2, r6, #1
 80051f2:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80051f6:	4628      	mov	r0, r5
 80051f8:	f006 faba 	bl	800b770 <chThdCreateStatic>
 80051fc:	4c21      	ldr	r4, [pc, #132]	; (8005284 <rt_test_006_008_execute.lto_priv.100+0xb4>)
 80051fe:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8005200:	4b21      	ldr	r3, [pc, #132]	; (8005288 <rt_test_006_008_execute.lto_priv.100+0xb8>)
 8005202:	9300      	str	r3, [sp, #0]
 8005204:	463b      	mov	r3, r7
 8005206:	1cb2      	adds	r2, r6, #2
 8005208:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800520c:	1868      	adds	r0, r5, r1
 800520e:	f006 faaf 	bl	800b770 <chThdCreateStatic>
 8005212:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8005214:	4b1d      	ldr	r3, [pc, #116]	; (800528c <rt_test_006_008_execute.lto_priv.100+0xbc>)
 8005216:	9300      	str	r3, [sp, #0]
 8005218:	463b      	mov	r3, r7
 800521a:	1cf2      	adds	r2, r6, #3
 800521c:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005220:	f505 7068 	add.w	r0, r5, #928	; 0x3a0
 8005224:	f006 faa4 	bl	800b770 <chThdCreateStatic>
 8005228:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 800522a:	4b19      	ldr	r3, [pc, #100]	; (8005290 <rt_test_006_008_execute.lto_priv.100+0xc0>)
 800522c:	9300      	str	r3, [sp, #0]
 800522e:	463b      	mov	r3, r7
 8005230:	1d32      	adds	r2, r6, #4
 8005232:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005236:	f505 60ae 	add.w	r0, r5, #1392	; 0x570
 800523a:	f006 fa99 	bl	800b770 <chThdCreateStatic>
 800523e:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8005240:	4b14      	ldr	r3, [pc, #80]	; (8005294 <rt_test_006_008_execute.lto_priv.100+0xc4>)
 8005242:	9300      	str	r3, [sp, #0]
 8005244:	463b      	mov	r3, r7
 8005246:	1d72      	adds	r2, r6, #5
 8005248:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800524c:	f505 60e8 	add.w	r0, r5, #1856	; 0x740
 8005250:	f006 fa8e 	bl	800b770 <chThdCreateStatic>
 8005254:	6120      	str	r0, [r4, #16]
  test_set_step(2);
 8005256:	2302      	movs	r3, #2
 8005258:	f8c8 3000 	str.w	r3, [r8]
    chCondBroadcast(&c1);
 800525c:	480e      	ldr	r0, [pc, #56]	; (8005298 <rt_test_006_008_execute.lto_priv.100+0xc8>)
 800525e:	f006 f97f 	bl	800b560 <chCondBroadcast>
    test_wait_threads();
 8005262:	f007 fb6d 	bl	800c940 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8005266:	490d      	ldr	r1, [pc, #52]	; (800529c <rt_test_006_008_execute.lto_priv.100+0xcc>)
 8005268:	480d      	ldr	r0, [pc, #52]	; (80052a0 <rt_test_006_008_execute.lto_priv.100+0xd0>)
 800526a:	f007 ff79 	bl	800d160 <_test_assert_sequence>
}
 800526e:	b002      	add	sp, #8
 8005270:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005274:	20003aec 	.word	0x20003aec
 8005278:	080078b1 	.word	0x080078b1
 800527c:	200025f0 	.word	0x200025f0
 8005280:	0800e830 	.word	0x0800e830
 8005284:	20002f1c 	.word	0x20002f1c
 8005288:	0800fa8c 	.word	0x0800fa8c
 800528c:	08010ec4 	.word	0x08010ec4
 8005290:	0800e698 	.word	0x0800e698
 8005294:	0800e68c 	.word	0x0800e68c
 8005298:	2000246c 	.word	0x2000246c
 800529c:	0800e6e8 	.word	0x0800e6e8
 80052a0:	0800e82c 	.word	0x0800e82c
 80052a4:	20003e04 	.word	0x20003e04
	...

080052b0 <rt_test_006_007_execute.lto_priv.98>:
static void rt_test_006_007_execute(void) {
 80052b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80052b4:	b082      	sub	sp, #8
  test_set_step(1);
 80052b6:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 80053b0 <rt_test_006_007_execute.lto_priv.98+0x100>
 80052ba:	2301      	movs	r3, #1
 80052bc:	f8c8 3000 	str.w	r3, [r8]
  return ch.rlist.current;
 80052c0:	4b2f      	ldr	r3, [pc, #188]	; (8005380 <rt_test_006_007_execute.lto_priv.98+0xd0>)
 80052c2:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 80052c4:	689e      	ldr	r6, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80052c6:	4f2f      	ldr	r7, [pc, #188]	; (8005384 <rt_test_006_007_execute.lto_priv.98+0xd4>)
 80052c8:	4d2f      	ldr	r5, [pc, #188]	; (8005388 <rt_test_006_007_execute.lto_priv.98+0xd8>)
 80052ca:	4b30      	ldr	r3, [pc, #192]	; (800538c <rt_test_006_007_execute.lto_priv.98+0xdc>)
 80052cc:	9300      	str	r3, [sp, #0]
 80052ce:	463b      	mov	r3, r7
 80052d0:	1c72      	adds	r2, r6, #1
 80052d2:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80052d6:	4628      	mov	r0, r5
 80052d8:	f006 fa4a 	bl	800b770 <chThdCreateStatic>
 80052dc:	4c2c      	ldr	r4, [pc, #176]	; (8005390 <rt_test_006_007_execute.lto_priv.98+0xe0>)
 80052de:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 80052e0:	4b2c      	ldr	r3, [pc, #176]	; (8005394 <rt_test_006_007_execute.lto_priv.98+0xe4>)
 80052e2:	9300      	str	r3, [sp, #0]
 80052e4:	463b      	mov	r3, r7
 80052e6:	1cb2      	adds	r2, r6, #2
 80052e8:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80052ec:	1868      	adds	r0, r5, r1
 80052ee:	f006 fa3f 	bl	800b770 <chThdCreateStatic>
 80052f2:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 80052f4:	4b28      	ldr	r3, [pc, #160]	; (8005398 <rt_test_006_007_execute.lto_priv.98+0xe8>)
 80052f6:	9300      	str	r3, [sp, #0]
 80052f8:	463b      	mov	r3, r7
 80052fa:	1cf2      	adds	r2, r6, #3
 80052fc:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005300:	f505 7068 	add.w	r0, r5, #928	; 0x3a0
 8005304:	f006 fa34 	bl	800b770 <chThdCreateStatic>
 8005308:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 800530a:	4b24      	ldr	r3, [pc, #144]	; (800539c <rt_test_006_007_execute.lto_priv.98+0xec>)
 800530c:	9300      	str	r3, [sp, #0]
 800530e:	463b      	mov	r3, r7
 8005310:	1d32      	adds	r2, r6, #4
 8005312:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005316:	f505 60ae 	add.w	r0, r5, #1392	; 0x570
 800531a:	f006 fa29 	bl	800b770 <chThdCreateStatic>
 800531e:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8005320:	4b1f      	ldr	r3, [pc, #124]	; (80053a0 <rt_test_006_007_execute.lto_priv.98+0xf0>)
 8005322:	9300      	str	r3, [sp, #0]
 8005324:	463b      	mov	r3, r7
 8005326:	1d72      	adds	r2, r6, #5
 8005328:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800532c:	f505 60e8 	add.w	r0, r5, #1856	; 0x740
 8005330:	f006 fa1e 	bl	800b770 <chThdCreateStatic>
 8005334:	6120      	str	r0, [r4, #16]
  test_set_step(2);
 8005336:	2302      	movs	r3, #2
 8005338:	f8c8 3000 	str.w	r3, [r8]
 800533c:	2320      	movs	r3, #32
 800533e:	f383 8811 	msr	BASEPRI, r3
    chCondSignalI(&c1);
 8005342:	4c18      	ldr	r4, [pc, #96]	; (80053a4 <rt_test_006_007_execute.lto_priv.98+0xf4>)
 8005344:	4620      	mov	r0, r4
 8005346:	f005 ff2b 	bl	800b1a0 <chCondSignalI>
    chCondSignalI(&c1);
 800534a:	4620      	mov	r0, r4
 800534c:	f005 ff28 	bl	800b1a0 <chCondSignalI>
    chCondSignalI(&c1);
 8005350:	4620      	mov	r0, r4
 8005352:	f005 ff25 	bl	800b1a0 <chCondSignalI>
    chCondSignalI(&c1);
 8005356:	4620      	mov	r0, r4
 8005358:	f005 ff22 	bl	800b1a0 <chCondSignalI>
    chCondSignalI(&c1);
 800535c:	4620      	mov	r0, r4
 800535e:	f005 ff1f 	bl	800b1a0 <chCondSignalI>
    chSchRescheduleS();
 8005362:	f006 f8dd 	bl	800b520 <chSchRescheduleS>
 8005366:	2300      	movs	r3, #0
 8005368:	f383 8811 	msr	BASEPRI, r3
    test_wait_threads();
 800536c:	f007 fae8 	bl	800c940 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8005370:	490d      	ldr	r1, [pc, #52]	; (80053a8 <rt_test_006_007_execute.lto_priv.98+0xf8>)
 8005372:	480e      	ldr	r0, [pc, #56]	; (80053ac <rt_test_006_007_execute.lto_priv.98+0xfc>)
 8005374:	f007 fef4 	bl	800d160 <_test_assert_sequence>
}
 8005378:	b002      	add	sp, #8
 800537a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800537e:	bf00      	nop
 8005380:	20003aec 	.word	0x20003aec
 8005384:	080078b1 	.word	0x080078b1
 8005388:	200025f0 	.word	0x200025f0
 800538c:	0800e830 	.word	0x0800e830
 8005390:	20002f1c 	.word	0x20002f1c
 8005394:	0800fa8c 	.word	0x0800fa8c
 8005398:	08010ec4 	.word	0x08010ec4
 800539c:	0800e698 	.word	0x0800e698
 80053a0:	0800e68c 	.word	0x0800e68c
 80053a4:	2000246c 	.word	0x2000246c
 80053a8:	0800e6e8 	.word	0x0800e6e8
 80053ac:	0800e82c 	.word	0x0800e82c
 80053b0:	20003e04 	.word	0x20003e04
	...

080053c0 <rt_test_006_005_execute.lto_priv.96>:
static void rt_test_006_005_execute(void) {
 80053c0:	b538      	push	{r3, r4, r5, lr}
  return ch.rlist.current;
 80053c2:	4b3d      	ldr	r3, [pc, #244]	; (80054b8 <rt_test_006_005_execute.lto_priv.96+0xf8>)
 80053c4:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 80053c6:	689c      	ldr	r4, [r3, #8]
  test_set_step(2);
 80053c8:	2202      	movs	r2, #2
 80053ca:	4b3c      	ldr	r3, [pc, #240]	; (80054bc <rt_test_006_005_execute.lto_priv.96+0xfc>)
 80053cc:	601a      	str	r2, [r3, #0]
    b = chMtxTryLock(&m1);
 80053ce:	483c      	ldr	r0, [pc, #240]	; (80054c0 <rt_test_006_005_execute.lto_priv.96+0x100>)
 80053d0:	f005 ff26 	bl	800b220 <chMtxTryLock>
    test_assert(b, "already locked");
 80053d4:	493b      	ldr	r1, [pc, #236]	; (80054c4 <rt_test_006_005_execute.lto_priv.96+0x104>)
 80053d6:	f007 feeb 	bl	800d1b0 <_test_assert>
 80053da:	2800      	cmp	r0, #0
 80053dc:	d16a      	bne.n	80054b4 <rt_test_006_005_execute.lto_priv.96+0xf4>
  test_set_step(3);
 80053de:	2203      	movs	r2, #3
 80053e0:	4b36      	ldr	r3, [pc, #216]	; (80054bc <rt_test_006_005_execute.lto_priv.96+0xfc>)
 80053e2:	601a      	str	r2, [r3, #0]
    b = chMtxTryLock(&m1);
 80053e4:	4836      	ldr	r0, [pc, #216]	; (80054c0 <rt_test_006_005_execute.lto_priv.96+0x100>)
 80053e6:	f005 ff1b 	bl	800b220 <chMtxTryLock>
    test_assert(!b, "not locked");
 80053ea:	f080 0001 	eor.w	r0, r0, #1
 80053ee:	4936      	ldr	r1, [pc, #216]	; (80054c8 <rt_test_006_005_execute.lto_priv.96+0x108>)
 80053f0:	b2c0      	uxtb	r0, r0
 80053f2:	f007 fedd 	bl	800d1b0 <_test_assert>
 80053f6:	2800      	cmp	r0, #0
 80053f8:	d15c      	bne.n	80054b4 <rt_test_006_005_execute.lto_priv.96+0xf4>
  test_set_step(4);
 80053fa:	2204      	movs	r2, #4
 80053fc:	4b2f      	ldr	r3, [pc, #188]	; (80054bc <rt_test_006_005_execute.lto_priv.96+0xfc>)
 80053fe:	601a      	str	r2, [r3, #0]
    chMtxUnlock(&m1);
 8005400:	4d2f      	ldr	r5, [pc, #188]	; (80054c0 <rt_test_006_005_execute.lto_priv.96+0x100>)
 8005402:	4628      	mov	r0, r5
 8005404:	f006 f8e4 	bl	800b5d0 <chMtxUnlock>
    test_assert(m1.owner == NULL, "still owned");
 8005408:	68a8      	ldr	r0, [r5, #8]
 800540a:	4930      	ldr	r1, [pc, #192]	; (80054cc <rt_test_006_005_execute.lto_priv.96+0x10c>)
 800540c:	fab0 f080 	clz	r0, r0
 8005410:	0940      	lsrs	r0, r0, #5
 8005412:	f007 fecd 	bl	800d1b0 <_test_assert>
 8005416:	2800      	cmp	r0, #0
 8005418:	d14c      	bne.n	80054b4 <rt_test_006_005_execute.lto_priv.96+0xf4>
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next == (const thread_t *)tqp);
 800541a:	6828      	ldr	r0, [r5, #0]
    test_assert(queue_isempty(&m1.queue), "queue not empty");
 800541c:	492c      	ldr	r1, [pc, #176]	; (80054d0 <rt_test_006_005_execute.lto_priv.96+0x110>)
 800541e:	42a8      	cmp	r0, r5
 8005420:	bf14      	ite	ne
 8005422:	2000      	movne	r0, #0
 8005424:	2001      	moveq	r0, #1
 8005426:	f007 fec3 	bl	800d1b0 <_test_assert>
 800542a:	2800      	cmp	r0, #0
 800542c:	d142      	bne.n	80054b4 <rt_test_006_005_execute.lto_priv.96+0xf4>
  test_set_step(5);
 800542e:	2205      	movs	r2, #5
 8005430:	4b22      	ldr	r3, [pc, #136]	; (80054bc <rt_test_006_005_execute.lto_priv.96+0xfc>)
 8005432:	601a      	str	r2, [r3, #0]
  return ch.rlist.current;
 8005434:	4b20      	ldr	r3, [pc, #128]	; (80054b8 <rt_test_006_005_execute.lto_priv.96+0xf8>)
 8005436:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 8005438:	6898      	ldr	r0, [r3, #8]
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 800543a:	4926      	ldr	r1, [pc, #152]	; (80054d4 <rt_test_006_005_execute.lto_priv.96+0x114>)
 800543c:	4284      	cmp	r4, r0
 800543e:	bf14      	ite	ne
 8005440:	2000      	movne	r0, #0
 8005442:	2001      	moveq	r0, #1
 8005444:	f007 feb4 	bl	800d1b0 <_test_assert>
 8005448:	2800      	cmp	r0, #0
 800544a:	d133      	bne.n	80054b4 <rt_test_006_005_execute.lto_priv.96+0xf4>
  test_set_step(6);
 800544c:	2206      	movs	r2, #6
 800544e:	4b1b      	ldr	r3, [pc, #108]	; (80054bc <rt_test_006_005_execute.lto_priv.96+0xfc>)
 8005450:	601a      	str	r2, [r3, #0]
    b = chMtxTryLock(&m1);
 8005452:	4628      	mov	r0, r5
 8005454:	f005 fee4 	bl	800b220 <chMtxTryLock>
    test_assert(b, "already locked");
 8005458:	491a      	ldr	r1, [pc, #104]	; (80054c4 <rt_test_006_005_execute.lto_priv.96+0x104>)
 800545a:	f007 fea9 	bl	800d1b0 <_test_assert>
 800545e:	bb48      	cbnz	r0, 80054b4 <rt_test_006_005_execute.lto_priv.96+0xf4>
    b = chMtxTryLock(&m1);
 8005460:	4628      	mov	r0, r5
 8005462:	f005 fedd 	bl	800b220 <chMtxTryLock>
    test_assert(!b, "not locked");
 8005466:	f080 0001 	eor.w	r0, r0, #1
 800546a:	4917      	ldr	r1, [pc, #92]	; (80054c8 <rt_test_006_005_execute.lto_priv.96+0x108>)
 800546c:	b2c0      	uxtb	r0, r0
 800546e:	f007 fe9f 	bl	800d1b0 <_test_assert>
 8005472:	b9f8      	cbnz	r0, 80054b4 <rt_test_006_005_execute.lto_priv.96+0xf4>
    chMtxUnlockAll();
 8005474:	f006 f884 	bl	800b580 <chMtxUnlockAll>
    test_assert(m1.owner == NULL, "still owned");
 8005478:	68a8      	ldr	r0, [r5, #8]
 800547a:	4914      	ldr	r1, [pc, #80]	; (80054cc <rt_test_006_005_execute.lto_priv.96+0x10c>)
 800547c:	fab0 f080 	clz	r0, r0
 8005480:	0940      	lsrs	r0, r0, #5
 8005482:	f007 fe95 	bl	800d1b0 <_test_assert>
 8005486:	b9a8      	cbnz	r0, 80054b4 <rt_test_006_005_execute.lto_priv.96+0xf4>
 8005488:	6828      	ldr	r0, [r5, #0]
    test_assert(queue_isempty(&m1.queue), "queue not empty");
 800548a:	4911      	ldr	r1, [pc, #68]	; (80054d0 <rt_test_006_005_execute.lto_priv.96+0x110>)
 800548c:	42a8      	cmp	r0, r5
 800548e:	bf14      	ite	ne
 8005490:	2000      	movne	r0, #0
 8005492:	2001      	moveq	r0, #1
 8005494:	f007 fe8c 	bl	800d1b0 <_test_assert>
 8005498:	b960      	cbnz	r0, 80054b4 <rt_test_006_005_execute.lto_priv.96+0xf4>
  test_set_step(7);
 800549a:	2207      	movs	r2, #7
 800549c:	4b07      	ldr	r3, [pc, #28]	; (80054bc <rt_test_006_005_execute.lto_priv.96+0xfc>)
 800549e:	601a      	str	r2, [r3, #0]
  return ch.rlist.current;
 80054a0:	4b05      	ldr	r3, [pc, #20]	; (80054b8 <rt_test_006_005_execute.lto_priv.96+0xf8>)
 80054a2:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 80054a4:	6898      	ldr	r0, [r3, #8]
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 80054a6:	490b      	ldr	r1, [pc, #44]	; (80054d4 <rt_test_006_005_execute.lto_priv.96+0x114>)
 80054a8:	4284      	cmp	r4, r0
 80054aa:	bf14      	ite	ne
 80054ac:	2000      	movne	r0, #0
 80054ae:	2001      	moveq	r0, #1
 80054b0:	f007 fe7e 	bl	800d1b0 <_test_assert>
 80054b4:	bd38      	pop	{r3, r4, r5, pc}
 80054b6:	bf00      	nop
 80054b8:	20003aec 	.word	0x20003aec
 80054bc:	20003e04 	.word	0x20003e04
 80054c0:	20002458 	.word	0x20002458
 80054c4:	0800e834 	.word	0x0800e834
 80054c8:	0800e844 	.word	0x0800e844
 80054cc:	0800e850 	.word	0x0800e850
 80054d0:	0800e85c 	.word	0x0800e85c
 80054d4:	0800e86c 	.word	0x0800e86c
	...

080054e0 <rt_test_006_004_execute.lto_priv.94>:
static void rt_test_006_004_execute(void) {
 80054e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80054e4:	b082      	sub	sp, #8
  test_set_step(1);
 80054e6:	4e41      	ldr	r6, [pc, #260]	; (80055ec <rt_test_006_004_execute.lto_priv.94+0x10c>)
  return ch.rlist.current;
 80054e8:	4d41      	ldr	r5, [pc, #260]	; (80055f0 <rt_test_006_004_execute.lto_priv.94+0x110>)
 80054ea:	69ab      	ldr	r3, [r5, #24]
  return chThdGetSelfX()->prio;
 80054ec:	689c      	ldr	r4, [r3, #8]
    pa = p + 1;
 80054ee:	f104 0901 	add.w	r9, r4, #1
    pb = p + 2;
 80054f2:	f104 0a02 	add.w	sl, r4, #2
  test_set_step(2);
 80054f6:	2302      	movs	r3, #2
 80054f8:	6033      	str	r3, [r6, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 80054fa:	f8df 8118 	ldr.w	r8, [pc, #280]	; 8005614 <rt_test_006_004_execute.lto_priv.94+0x134>
 80054fe:	4b3d      	ldr	r3, [pc, #244]	; (80055f4 <rt_test_006_004_execute.lto_priv.94+0x114>)
 8005500:	9300      	str	r3, [sp, #0]
 8005502:	4b3d      	ldr	r3, [pc, #244]	; (80055f8 <rt_test_006_004_execute.lto_priv.94+0x118>)
 8005504:	464a      	mov	r2, r9
 8005506:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800550a:	4640      	mov	r0, r8
 800550c:	f006 f930 	bl	800b770 <chThdCreateStatic>
 8005510:	4f3a      	ldr	r7, [pc, #232]	; (80055fc <rt_test_006_004_execute.lto_priv.94+0x11c>)
 8005512:	6038      	str	r0, [r7, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 8005514:	4b3a      	ldr	r3, [pc, #232]	; (8005600 <rt_test_006_004_execute.lto_priv.94+0x120>)
 8005516:	9300      	str	r3, [sp, #0]
 8005518:	4b3a      	ldr	r3, [pc, #232]	; (8005604 <rt_test_006_004_execute.lto_priv.94+0x124>)
 800551a:	4652      	mov	r2, sl
 800551c:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8005520:	eb08 0001 	add.w	r0, r8, r1
 8005524:	f006 f924 	bl	800b770 <chThdCreateStatic>
 8005528:	6078      	str	r0, [r7, #4]
  test_set_step(3);
 800552a:	2303      	movs	r3, #3
 800552c:	6033      	str	r3, [r6, #0]
    chMtxLock(&m1);
 800552e:	4836      	ldr	r0, [pc, #216]	; (8005608 <rt_test_006_004_execute.lto_priv.94+0x128>)
 8005530:	f006 fa0e 	bl	800b950 <chMtxLock>
  return ch.rlist.current;
 8005534:	69ab      	ldr	r3, [r5, #24]
  return chThdGetSelfX()->prio;
 8005536:	6898      	ldr	r0, [r3, #8]
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 8005538:	4934      	ldr	r1, [pc, #208]	; (800560c <rt_test_006_004_execute.lto_priv.94+0x12c>)
 800553a:	4284      	cmp	r4, r0
 800553c:	bf14      	ite	ne
 800553e:	2000      	movne	r0, #0
 8005540:	2001      	moveq	r0, #1
 8005542:	f007 fe35 	bl	800d1b0 <_test_assert>
 8005546:	2800      	cmp	r0, #0
 8005548:	d14d      	bne.n	80055e6 <rt_test_006_004_execute.lto_priv.94+0x106>
  test_set_step(4);
 800554a:	2204      	movs	r2, #4
 800554c:	6032      	str	r2, [r6, #0]
    chThdSleepMilliseconds(100);
 800554e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8005552:	f006 fb7d 	bl	800bc50 <chThdSleep>
  return ch.rlist.current;
 8005556:	69ab      	ldr	r3, [r5, #24]
  return chThdGetSelfX()->prio;
 8005558:	6898      	ldr	r0, [r3, #8]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 800555a:	492c      	ldr	r1, [pc, #176]	; (800560c <rt_test_006_004_execute.lto_priv.94+0x12c>)
 800555c:	4581      	cmp	r9, r0
 800555e:	bf14      	ite	ne
 8005560:	2000      	movne	r0, #0
 8005562:	2001      	moveq	r0, #1
 8005564:	f007 fe24 	bl	800d1b0 <_test_assert>
 8005568:	2800      	cmp	r0, #0
 800556a:	d13c      	bne.n	80055e6 <rt_test_006_004_execute.lto_priv.94+0x106>
  test_set_step(5);
 800556c:	2205      	movs	r2, #5
 800556e:	6032      	str	r2, [r6, #0]
    chMtxLock(&m2);
 8005570:	4827      	ldr	r0, [pc, #156]	; (8005610 <rt_test_006_004_execute.lto_priv.94+0x130>)
 8005572:	f006 f9ed 	bl	800b950 <chMtxLock>
  return ch.rlist.current;
 8005576:	69ab      	ldr	r3, [r5, #24]
  return chThdGetSelfX()->prio;
 8005578:	6898      	ldr	r0, [r3, #8]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 800557a:	4924      	ldr	r1, [pc, #144]	; (800560c <rt_test_006_004_execute.lto_priv.94+0x12c>)
 800557c:	4581      	cmp	r9, r0
 800557e:	bf14      	ite	ne
 8005580:	2000      	movne	r0, #0
 8005582:	2001      	moveq	r0, #1
 8005584:	f007 fe14 	bl	800d1b0 <_test_assert>
 8005588:	2800      	cmp	r0, #0
 800558a:	d12c      	bne.n	80055e6 <rt_test_006_004_execute.lto_priv.94+0x106>
  test_set_step(6);
 800558c:	2206      	movs	r2, #6
 800558e:	6032      	str	r2, [r6, #0]
    chThdSleepMilliseconds(100);
 8005590:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8005594:	f006 fb5c 	bl	800bc50 <chThdSleep>
  return ch.rlist.current;
 8005598:	69ab      	ldr	r3, [r5, #24]
  return chThdGetSelfX()->prio;
 800559a:	6898      	ldr	r0, [r3, #8]
    test_assert(chThdGetPriorityX() == pb, "wrong priority level");
 800559c:	491b      	ldr	r1, [pc, #108]	; (800560c <rt_test_006_004_execute.lto_priv.94+0x12c>)
 800559e:	4582      	cmp	sl, r0
 80055a0:	bf14      	ite	ne
 80055a2:	2000      	movne	r0, #0
 80055a4:	2001      	moveq	r0, #1
 80055a6:	f007 fe03 	bl	800d1b0 <_test_assert>
 80055aa:	b9e0      	cbnz	r0, 80055e6 <rt_test_006_004_execute.lto_priv.94+0x106>
  test_set_step(7);
 80055ac:	2207      	movs	r2, #7
 80055ae:	6032      	str	r2, [r6, #0]
    chMtxUnlock(&m2);
 80055b0:	4817      	ldr	r0, [pc, #92]	; (8005610 <rt_test_006_004_execute.lto_priv.94+0x130>)
 80055b2:	f006 f80d 	bl	800b5d0 <chMtxUnlock>
  return ch.rlist.current;
 80055b6:	69ab      	ldr	r3, [r5, #24]
  return chThdGetSelfX()->prio;
 80055b8:	6898      	ldr	r0, [r3, #8]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 80055ba:	4914      	ldr	r1, [pc, #80]	; (800560c <rt_test_006_004_execute.lto_priv.94+0x12c>)
 80055bc:	4581      	cmp	r9, r0
 80055be:	bf14      	ite	ne
 80055c0:	2000      	movne	r0, #0
 80055c2:	2001      	moveq	r0, #1
 80055c4:	f007 fdf4 	bl	800d1b0 <_test_assert>
 80055c8:	b968      	cbnz	r0, 80055e6 <rt_test_006_004_execute.lto_priv.94+0x106>
  test_set_step(8);
 80055ca:	2208      	movs	r2, #8
 80055cc:	6032      	str	r2, [r6, #0]
    chMtxUnlock(&m1);
 80055ce:	480e      	ldr	r0, [pc, #56]	; (8005608 <rt_test_006_004_execute.lto_priv.94+0x128>)
 80055d0:	f005 fffe 	bl	800b5d0 <chMtxUnlock>
  return ch.rlist.current;
 80055d4:	69ab      	ldr	r3, [r5, #24]
  return chThdGetSelfX()->prio;
 80055d6:	6898      	ldr	r0, [r3, #8]
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 80055d8:	490c      	ldr	r1, [pc, #48]	; (800560c <rt_test_006_004_execute.lto_priv.94+0x12c>)
 80055da:	4284      	cmp	r4, r0
 80055dc:	bf14      	ite	ne
 80055de:	2000      	movne	r0, #0
 80055e0:	2001      	moveq	r0, #1
 80055e2:	f007 fde5 	bl	800d1b0 <_test_assert>
}
 80055e6:	b002      	add	sp, #8
 80055e8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80055ec:	20003e04 	.word	0x20003e04
 80055f0:	20003aec 	.word	0x20003aec
 80055f4:	0800e68c 	.word	0x0800e68c
 80055f8:	08007911 	.word	0x08007911
 80055fc:	20002f1c 	.word	0x20002f1c
 8005600:	0800e698 	.word	0x0800e698
 8005604:	080078e1 	.word	0x080078e1
 8005608:	20002458 	.word	0x20002458
 800560c:	0800e86c 	.word	0x0800e86c
 8005610:	20002448 	.word	0x20002448
 8005614:	200025f0 	.word	0x200025f0
	...

08005620 <otg_isoc_out_failed_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
 8005620:	b570      	push	{r4, r5, r6, lr}
 8005622:	4605      	mov	r5, r0
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8005624:	f8d0 6084 	ldr.w	r6, [r0, #132]	; 0x84

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8005628:	2400      	movs	r4, #0
 800562a:	e021      	b.n	8005670 <otg_isoc_out_failed_handler+0x50>
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 800562c:	4622      	mov	r2, r4
 800562e:	f104 0358 	add.w	r3, r4, #88	; 0x58
 8005632:	015b      	lsls	r3, r3, #5
 8005634:	58f3      	ldr	r3, [r6, r3]
 8005636:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 800563a:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800563e:	d115      	bne.n	800566c <otg_isoc_out_failed_handler+0x4c>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 8005640:	f104 0358 	add.w	r3, r4, #88	; 0x58
 8005644:	015b      	lsls	r3, r3, #5
 8005646:	58f3      	ldr	r3, [r6, r3]
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8005648:	2b00      	cmp	r3, #0
 800564a:	da0f      	bge.n	800566c <otg_isoc_out_failed_handler+0x4c>
      /* FIXME: Core stucks here */
      /*otgp->oe[ep].DOEPCTL |= (DOEPCTL_EPDIS | DOEPCTL_SNAK);
      while (otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA)
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
 800564c:	2301      	movs	r3, #1
 800564e:	fa03 f104 	lsl.w	r1, r3, r4
 8005652:	896b      	ldrh	r3, [r5, #10]
 8005654:	ea23 0301 	bic.w	r3, r3, r1
 8005658:	816b      	strh	r3, [r5, #10]
 800565a:	3202      	adds	r2, #2
 800565c:	eb05 0282 	add.w	r2, r5, r2, lsl #2
 8005660:	6853      	ldr	r3, [r2, #4]
 8005662:	68db      	ldr	r3, [r3, #12]
 8005664:	b113      	cbz	r3, 800566c <otg_isoc_out_failed_handler+0x4c>
 8005666:	4621      	mov	r1, r4
 8005668:	4628      	mov	r0, r5
 800566a:	4798      	blx	r3
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800566c:	3401      	adds	r4, #1
 800566e:	b2e4      	uxtb	r4, r4
 8005670:	f8d5 3088 	ldr.w	r3, [r5, #136]	; 0x88
 8005674:	689b      	ldr	r3, [r3, #8]
 8005676:	429c      	cmp	r4, r3
 8005678:	d9d8      	bls.n	800562c <otg_isoc_out_failed_handler+0xc>
    }
  }
}
 800567a:	bd70      	pop	{r4, r5, r6, pc}
 800567c:	0000      	movs	r0, r0
	...

08005680 <otg_fifo_read_to_buffer>:
                                    size_t max) {
 8005680:	b430      	push	{r4, r5}
  size_t i = 0;
 8005682:	2400      	movs	r4, #0
  uint32_t w = 0;
 8005684:	4625      	mov	r5, r4
 8005686:	e009      	b.n	800569c <otg_fifo_read_to_buffer+0x1c>
    if ((i & 3) == 0){
 8005688:	f014 0f03 	tst.w	r4, #3
 800568c:	d100      	bne.n	8005690 <otg_fifo_read_to_buffer+0x10>
      w = *fifop;
 800568e:	6805      	ldr	r5, [r0, #0]
    if (i < max) {
 8005690:	429c      	cmp	r4, r3
 8005692:	d202      	bcs.n	800569a <otg_fifo_read_to_buffer+0x1a>
      *buf++ = (uint8_t)w;
 8005694:	700d      	strb	r5, [r1, #0]
      w >>= 8;
 8005696:	0a2d      	lsrs	r5, r5, #8
      *buf++ = (uint8_t)w;
 8005698:	3101      	adds	r1, #1
    i++;
 800569a:	3401      	adds	r4, #1
  while (i < n) {
 800569c:	4294      	cmp	r4, r2
 800569e:	d3f3      	bcc.n	8005688 <otg_fifo_read_to_buffer+0x8>
}
 80056a0:	bc30      	pop	{r4, r5}
 80056a2:	4770      	bx	lr
	...

080056b0 <otg_rxfifo_handler>:
static void otg_rxfifo_handler(USBDriver *usbp) {
 80056b0:	b570      	push	{r4, r5, r6, lr}
  sts = usbp->otg->GRXSTSP;
 80056b2:	f8d0 6084 	ldr.w	r6, [r0, #132]	; 0x84
 80056b6:	6a33      	ldr	r3, [r6, #32]
  cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 80056b8:	f3c3 150a 	ubfx	r5, r3, #4, #11
  ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 80056bc:	f003 040f 	and.w	r4, r3, #15
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 80056c0:	f403 13f0 	and.w	r3, r3, #1966080	; 0x1e0000
 80056c4:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 80056c8:	d00e      	beq.n	80056e8 <otg_rxfifo_handler+0x38>
 80056ca:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
 80056ce:	d123      	bne.n	8005718 <otg_rxfifo_handler+0x68>
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 80056d0:	3402      	adds	r4, #2
 80056d2:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 80056d6:	6861      	ldr	r1, [r4, #4]
 80056d8:	2308      	movs	r3, #8
 80056da:	462a      	mov	r2, r5
 80056dc:	6a09      	ldr	r1, [r1, #32]
 80056de:	f506 5080 	add.w	r0, r6, #4096	; 0x1000
 80056e2:	f7ff ffcd 	bl	8005680 <otg_fifo_read_to_buffer>
 80056e6:	bd70      	pop	{r4, r5, r6, pc}
                            usbp->epc[ep]->out_state->rxbuf,
 80056e8:	3402      	adds	r4, #2
 80056ea:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 80056ee:	6863      	ldr	r3, [r4, #4]
 80056f0:	6999      	ldr	r1, [r3, #24]
                            usbp->epc[ep]->out_state->rxsize -
 80056f2:	680a      	ldr	r2, [r1, #0]
                            usbp->epc[ep]->out_state->rxcnt);
 80056f4:	684b      	ldr	r3, [r1, #4]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 80056f6:	1ad3      	subs	r3, r2, r3
 80056f8:	462a      	mov	r2, r5
 80056fa:	6889      	ldr	r1, [r1, #8]
 80056fc:	f506 5080 	add.w	r0, r6, #4096	; 0x1000
 8005700:	f7ff ffbe 	bl	8005680 <otg_fifo_read_to_buffer>
    usbp->epc[ep]->out_state->rxbuf += cnt;
 8005704:	6863      	ldr	r3, [r4, #4]
 8005706:	699a      	ldr	r2, [r3, #24]
 8005708:	6893      	ldr	r3, [r2, #8]
 800570a:	442b      	add	r3, r5
 800570c:	6093      	str	r3, [r2, #8]
    usbp->epc[ep]->out_state->rxcnt += cnt;
 800570e:	6863      	ldr	r3, [r4, #4]
 8005710:	699b      	ldr	r3, [r3, #24]
 8005712:	685a      	ldr	r2, [r3, #4]
 8005714:	4415      	add	r5, r2
 8005716:	605d      	str	r5, [r3, #4]
 8005718:	bd70      	pop	{r4, r5, r6, pc}
 800571a:	bf00      	nop
 800571c:	0000      	movs	r0, r0
	...

08005720 <otg_fifo_write_from_buffer>:
    *fifop = *((uint32_t *)buf);
 8005720:	680b      	ldr	r3, [r1, #0]
 8005722:	6003      	str	r3, [r0, #0]
    if (n <= 4) {
 8005724:	2a04      	cmp	r2, #4
 8005726:	d902      	bls.n	800572e <otg_fifo_write_from_buffer+0xe>
    n -= 4;
 8005728:	3a04      	subs	r2, #4
    buf += 4;
 800572a:	3104      	adds	r1, #4
 800572c:	e7f8      	b.n	8005720 <otg_fifo_write_from_buffer>
 800572e:	4770      	bx	lr

08005730 <otg_txfifo_handler>:
static bool otg_txfifo_handler(USBDriver *usbp, usbep_t ep) {
 8005730:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005732:	4606      	mov	r6, r0
 8005734:	460d      	mov	r5, r1
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8005736:	1cab      	adds	r3, r5, #2
 8005738:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 800573c:	685a      	ldr	r2, [r3, #4]
 800573e:	6951      	ldr	r1, [r2, #20]
 8005740:	6848      	ldr	r0, [r1, #4]
 8005742:	680b      	ldr	r3, [r1, #0]
 8005744:	4298      	cmp	r0, r3
 8005746:	d30b      	bcc.n	8005760 <otg_txfifo_handler+0x30>
      usbp->otg->DIEPEMPMSK &= ~DIEPEMPMSK_INEPTXFEM(ep);
 8005748:	f8d6 2084 	ldr.w	r2, [r6, #132]	; 0x84
 800574c:	f8d2 3834 	ldr.w	r3, [r2, #2100]	; 0x834
 8005750:	2001      	movs	r0, #1
 8005752:	fa00 f405 	lsl.w	r4, r0, r5
 8005756:	ea23 0404 	bic.w	r4, r3, r4
 800575a:	f8c2 4834 	str.w	r4, [r2, #2100]	; 0x834
 800575e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8005760:	1a1b      	subs	r3, r3, r0
    if (n > usbp->epc[ep]->in_maxsize)
 8005762:	8a14      	ldrh	r4, [r2, #16]
 8005764:	42a3      	cmp	r3, r4
 8005766:	d800      	bhi.n	800576a <otg_txfifo_handler+0x3a>
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8005768:	461c      	mov	r4, r3
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 800576a:	f8d6 7084 	ldr.w	r7, [r6, #132]	; 0x84
 800576e:	eb07 1345 	add.w	r3, r7, r5, lsl #5
 8005772:	f8d3 3918 	ldr.w	r3, [r3, #2328]	; 0x918
 8005776:	b29b      	uxth	r3, r3
 8005778:	ebb4 0f83 	cmp.w	r4, r3, lsl #2
 800577c:	d814      	bhi.n	80057a8 <otg_txfifo_handler+0x78>
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 800577e:	1c68      	adds	r0, r5, #1
 8005780:	4622      	mov	r2, r4
 8005782:	6889      	ldr	r1, [r1, #8]
 8005784:	eb07 3000 	add.w	r0, r7, r0, lsl #12
 8005788:	f7ff ffca 	bl	8005720 <otg_fifo_write_from_buffer>
    usbp->epc[ep]->in_state->txbuf += n;
 800578c:	1cab      	adds	r3, r5, #2
 800578e:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8005792:	685a      	ldr	r2, [r3, #4]
 8005794:	6951      	ldr	r1, [r2, #20]
 8005796:	688a      	ldr	r2, [r1, #8]
 8005798:	4422      	add	r2, r4
 800579a:	608a      	str	r2, [r1, #8]
    usbp->epc[ep]->in_state->txcnt += n;
 800579c:	685b      	ldr	r3, [r3, #4]
 800579e:	695b      	ldr	r3, [r3, #20]
 80057a0:	685a      	ldr	r2, [r3, #4]
 80057a2:	4414      	add	r4, r2
 80057a4:	605c      	str	r4, [r3, #4]
 80057a6:	e7c6      	b.n	8005736 <otg_txfifo_handler+0x6>
      return false;
 80057a8:	2000      	movs	r0, #0
}
 80057aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80057ac:	0000      	movs	r0, r0
	...

080057b0 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80057b0:	4a0b      	ldr	r2, [pc, #44]	; (80057e0 <hal_lld_backup_domain_init+0x30>)
 80057b2:	6813      	ldr	r3, [r2, #0]
 80057b4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80057b8:	6013      	str	r3, [r2, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 80057ba:	4b0a      	ldr	r3, [pc, #40]	; (80057e4 <hal_lld_backup_domain_init+0x34>)
 80057bc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80057be:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80057c2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80057c6:	d005      	beq.n	80057d4 <hal_lld_backup_domain_init+0x24>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 80057c8:	4b06      	ldr	r3, [pc, #24]	; (80057e4 <hal_lld_backup_domain_init+0x34>)
 80057ca:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80057ce:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 80057d0:	2200      	movs	r2, #0
 80057d2:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 80057d4:	4a02      	ldr	r2, [pc, #8]	; (80057e0 <hal_lld_backup_domain_init+0x30>)
 80057d6:	6853      	ldr	r3, [r2, #4]
 80057d8:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80057dc:	6053      	str	r3, [r2, #4]
 80057de:	4770      	bx	lr
 80057e0:	40007000 	.word	0x40007000
 80057e4:	40023800 	.word	0x40023800
	...

080057f0 <_usb_wakeup>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {
 80057f0:	b508      	push	{r3, lr}

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;
 80057f2:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 80057f6:	7003      	strb	r3, [r0, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 80057f8:	6843      	ldr	r3, [r0, #4]
 80057fa:	681b      	ldr	r3, [r3, #0]
 80057fc:	b10b      	cbz	r3, 8005802 <_usb_wakeup+0x12>
 80057fe:	2105      	movs	r1, #5
 8005800:	4798      	blx	r3
 8005802:	bd08      	pop	{r3, pc}
	...

08005810 <_usb_suspend>:
void _usb_suspend(USBDriver *usbp) {
 8005810:	b508      	push	{r3, lr}
  usbp->saved_state = usbp->state;
 8005812:	7803      	ldrb	r3, [r0, #0]
 8005814:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  usbp->state       = USB_SUSPENDED;
 8005818:	2305      	movs	r3, #5
 800581a:	7003      	strb	r3, [r0, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 800581c:	6843      	ldr	r3, [r0, #4]
 800581e:	681b      	ldr	r3, [r3, #0]
 8005820:	b10b      	cbz	r3, 8005826 <_usb_suspend+0x16>
 8005822:	2104      	movs	r1, #4
 8005824:	4798      	blx	r3
 8005826:	bd08      	pop	{r3, pc}
	...

08005830 <otg_epout_handler>:
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8005830:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005832:	4606      	mov	r6, r0
 8005834:	460d      	mov	r5, r1
  stm32_otg_t *otgp = usbp->otg;
 8005836:	f8d0 7084 	ldr.w	r7, [r0, #132]	; 0x84
  uint32_t epint = otgp->oe[ep].DOEPINT;
 800583a:	eb07 1341 	add.w	r3, r7, r1, lsl #5
 800583e:	f8d3 4b08 	ldr.w	r4, [r3, #2824]	; 0xb08
  otgp->oe[ep].DOEPINT = epint;
 8005842:	f8c3 4b08 	str.w	r4, [r3, #2824]	; 0xb08
  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8005846:	f014 0f08 	tst.w	r4, #8
 800584a:	d00a      	beq.n	8005862 <otg_epout_handler+0x32>
 800584c:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 8005850:	f013 0f08 	tst.w	r3, #8
 8005854:	d005      	beq.n	8005862 <otg_epout_handler+0x32>
    _usb_isr_invoke_setup_cb(usbp, ep);
 8005856:	1c8b      	adds	r3, r1, #2
 8005858:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800585c:	685b      	ldr	r3, [r3, #4]
 800585e:	685b      	ldr	r3, [r3, #4]
 8005860:	4798      	blx	r3
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 8005862:	f014 0f01 	tst.w	r4, #1
 8005866:	d02f      	beq.n	80058c8 <otg_epout_handler+0x98>
 8005868:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 800586c:	f013 0f01 	tst.w	r3, #1
 8005870:	d02a      	beq.n	80058c8 <otg_epout_handler+0x98>
    osp = usbp->epc[ep]->out_state;
 8005872:	1cab      	adds	r3, r5, #2
 8005874:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8005878:	6859      	ldr	r1, [r3, #4]
 800587a:	698b      	ldr	r3, [r1, #24]
    if (ep == 0) {
 800587c:	b9c5      	cbnz	r5, 80058b0 <otg_epout_handler+0x80>
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 800587e:	685c      	ldr	r4, [r3, #4]
 8005880:	8a4a      	ldrh	r2, [r1, #18]
 8005882:	fbb4 f0f2 	udiv	r0, r4, r2
 8005886:	fb02 4210 	mls	r2, r2, r0, r4
 800588a:	b98a      	cbnz	r2, 80058b0 <otg_epout_handler+0x80>
          (osp->rxsize < osp->totsize)) {
 800588c:	6818      	ldr	r0, [r3, #0]
 800588e:	68da      	ldr	r2, [r3, #12]
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8005890:	4290      	cmp	r0, r2
 8005892:	d20d      	bcs.n	80058b0 <otg_epout_handler+0x80>
        osp->rxsize = osp->totsize - osp->rxsize;
 8005894:	1a12      	subs	r2, r2, r0
 8005896:	601a      	str	r2, [r3, #0]
        osp->rxcnt  = 0;
 8005898:	2400      	movs	r4, #0
 800589a:	605c      	str	r4, [r3, #4]
 800589c:	2320      	movs	r3, #32
 800589e:	f383 8811 	msr	BASEPRI, r3
        usb_lld_start_out(usbp, ep);
 80058a2:	4629      	mov	r1, r5
 80058a4:	4630      	mov	r0, r6
 80058a6:	f001 fc33 	bl	8007110 <usb_lld_start_out>
 80058aa:	f384 8811 	msr	BASEPRI, r4
 80058ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    _usb_isr_invoke_out_cb(usbp, ep);
 80058b0:	2301      	movs	r3, #1
 80058b2:	fa03 f205 	lsl.w	r2, r3, r5
 80058b6:	8973      	ldrh	r3, [r6, #10]
 80058b8:	ea23 0302 	bic.w	r3, r3, r2
 80058bc:	8173      	strh	r3, [r6, #10]
 80058be:	68cb      	ldr	r3, [r1, #12]
 80058c0:	b113      	cbz	r3, 80058c8 <otg_epout_handler+0x98>
 80058c2:	4629      	mov	r1, r5
 80058c4:	4630      	mov	r0, r6
 80058c6:	4798      	blx	r3
 80058c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80058ca:	bf00      	nop
 80058cc:	0000      	movs	r0, r0
	...

080058d0 <otg_epin_handler>:
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 80058d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80058d4:	4607      	mov	r7, r0
 80058d6:	460d      	mov	r5, r1
  stm32_otg_t *otgp = usbp->otg;
 80058d8:	f8d0 6084 	ldr.w	r6, [r0, #132]	; 0x84
  uint32_t epint = otgp->ie[ep].DIEPINT;
 80058dc:	eb06 1341 	add.w	r3, r6, r1, lsl #5
 80058e0:	f8d3 4908 	ldr.w	r4, [r3, #2312]	; 0x908
  otgp->ie[ep].DIEPINT = epint;
 80058e4:	f8c3 4908 	str.w	r4, [r3, #2312]	; 0x908
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 80058e8:	f014 0f01 	tst.w	r4, #1
 80058ec:	d029      	beq.n	8005942 <otg_epin_handler+0x72>
 80058ee:	f8d6 3810 	ldr.w	r3, [r6, #2064]	; 0x810
 80058f2:	f013 0f01 	tst.w	r3, #1
 80058f6:	d024      	beq.n	8005942 <otg_epin_handler+0x72>
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 80058f8:	1c8b      	adds	r3, r1, #2
 80058fa:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80058fe:	6859      	ldr	r1, [r3, #4]
 8005900:	694b      	ldr	r3, [r1, #20]
    if (isp->txsize < isp->totsize) {
 8005902:	6818      	ldr	r0, [r3, #0]
 8005904:	68da      	ldr	r2, [r3, #12]
 8005906:	4290      	cmp	r0, r2
 8005908:	d20f      	bcs.n	800592a <otg_epin_handler+0x5a>
      isp->txsize = isp->totsize - isp->txsize;
 800590a:	1a12      	subs	r2, r2, r0
 800590c:	601a      	str	r2, [r3, #0]
      isp->txcnt  = 0;
 800590e:	f04f 0800 	mov.w	r8, #0
 8005912:	f8c3 8004 	str.w	r8, [r3, #4]
 8005916:	2320      	movs	r3, #32
 8005918:	f383 8811 	msr	BASEPRI, r3
      usb_lld_start_in(usbp, ep);
 800591c:	4629      	mov	r1, r5
 800591e:	4638      	mov	r0, r7
 8005920:	f001 fb96 	bl	8007050 <usb_lld_start_in>
 8005924:	f388 8811 	msr	BASEPRI, r8
 8005928:	e00b      	b.n	8005942 <otg_epin_handler+0x72>
      _usb_isr_invoke_in_cb(usbp, ep);
 800592a:	2301      	movs	r3, #1
 800592c:	fa03 f205 	lsl.w	r2, r3, r5
 8005930:	893b      	ldrh	r3, [r7, #8]
 8005932:	ea23 0302 	bic.w	r3, r3, r2
 8005936:	813b      	strh	r3, [r7, #8]
 8005938:	688b      	ldr	r3, [r1, #8]
 800593a:	b113      	cbz	r3, 8005942 <otg_epin_handler+0x72>
 800593c:	4629      	mov	r1, r5
 800593e:	4638      	mov	r0, r7
 8005940:	4798      	blx	r3
  if ((epint & DIEPINT_TXFE) &&
 8005942:	f014 0f80 	tst.w	r4, #128	; 0x80
 8005946:	d009      	beq.n	800595c <otg_epin_handler+0x8c>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 8005948:	f8d6 2834 	ldr.w	r2, [r6, #2100]	; 0x834
 800594c:	2301      	movs	r3, #1
 800594e:	40ab      	lsls	r3, r5
  if ((epint & DIEPINT_TXFE) &&
 8005950:	421a      	tst	r2, r3
 8005952:	d003      	beq.n	800595c <otg_epin_handler+0x8c>
    otg_txfifo_handler(usbp, ep);
 8005954:	4629      	mov	r1, r5
 8005956:	4638      	mov	r0, r7
 8005958:	f7ff feea 	bl	8005730 <otg_txfifo_handler>
 800595c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08005960 <otg_core_reset>:
static void otg_core_reset(USBDriver *usbp) {
 8005960:	b510      	push	{r4, lr}
  stm32_otg_t *otgp = usbp->otg;
 8005962:	f8d0 4084 	ldr.w	r4, [r0, #132]	; 0x84
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 8005966:	6923      	ldr	r3, [r4, #16]
 8005968:	2b00      	cmp	r3, #0
 800596a:	dafc      	bge.n	8005966 <otg_core_reset+0x6>
  otgp->GRSTCTL = GRSTCTL_CSRST;
 800596c:	2301      	movs	r3, #1
 800596e:	6123      	str	r3, [r4, #16]
  chSysPolledDelayX(cycles);
 8005970:	200c      	movs	r0, #12
 8005972:	f001 f825 	bl	80069c0 <chSysPolledDelayX>
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 8005976:	6923      	ldr	r3, [r4, #16]
 8005978:	f013 0f01 	tst.w	r3, #1
 800597c:	d1fb      	bne.n	8005976 <otg_core_reset+0x16>
 800597e:	2012      	movs	r0, #18
 8005980:	f001 f81e 	bl	80069c0 <chSysPolledDelayX>
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 8005984:	6923      	ldr	r3, [r4, #16]
 8005986:	2b00      	cmp	r3, #0
 8005988:	dafc      	bge.n	8005984 <otg_core_reset+0x24>
}
 800598a:	bd10      	pop	{r4, pc}
 800598c:	0000      	movs	r0, r0
	...

08005990 <_usb_reset>:
void _usb_reset(USBDriver *usbp) {
 8005990:	b510      	push	{r4, lr}
 8005992:	4604      	mov	r4, r0
  usbp->state         = USB_READY;
 8005994:	2302      	movs	r3, #2
 8005996:	7003      	strb	r3, [r0, #0]
  usbp->status        = 0;
 8005998:	2300      	movs	r3, #0
 800599a:	f8a0 307c 	strh.w	r3, [r0, #124]	; 0x7c
  usbp->address       = 0;
 800599e:	f880 307e 	strb.w	r3, [r0, #126]	; 0x7e
  usbp->configuration = 0;
 80059a2:	f880 307f 	strb.w	r3, [r0, #127]	; 0x7f
  usbp->transmitting  = 0;
 80059a6:	8103      	strh	r3, [r0, #8]
  usbp->receiving     = 0;
 80059a8:	8143      	strh	r3, [r0, #10]
 80059aa:	e005      	b.n	80059b8 <_usb_reset+0x28>
    usbp->epc[i] = NULL;
 80059ac:	1c9a      	adds	r2, r3, #2
 80059ae:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 80059b2:	2100      	movs	r1, #0
 80059b4:	6051      	str	r1, [r2, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 80059b6:	3301      	adds	r3, #1
 80059b8:	2b07      	cmp	r3, #7
 80059ba:	d9f7      	bls.n	80059ac <_usb_reset+0x1c>
  usbp->ep0state = USB_EP0_STP_WAITING;
 80059bc:	2300      	movs	r3, #0
 80059be:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
  usb_lld_reset(usbp);
 80059c2:	4620      	mov	r0, r4
 80059c4:	f001 fcf4 	bl	80073b0 <usb_lld_reset>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 80059c8:	6863      	ldr	r3, [r4, #4]
 80059ca:	681b      	ldr	r3, [r3, #0]
 80059cc:	b113      	cbz	r3, 80059d4 <_usb_reset+0x44>
 80059ce:	2100      	movs	r1, #0
 80059d0:	4620      	mov	r0, r4
 80059d2:	4798      	blx	r3
 80059d4:	bd10      	pop	{r4, pc}
 80059d6:	bf00      	nop
	...

080059e0 <usb_lld_init>:
/**
 * @brief   Low level USB driver initialization.
 *
 * @notapi
 */
void usb_lld_init(void) {
 80059e0:	b510      	push	{r4, lr}
  USBD1.otgparams = &fsparams;

#endif

#if STM32_USB_USE_OTG2
  usbObjectInit(&USBD2);
 80059e2:	4c05      	ldr	r4, [pc, #20]	; (80059f8 <usb_lld_init+0x18>)
 80059e4:	4620      	mov	r0, r4
 80059e6:	f7fd fa43 	bl	8002e70 <usbObjectInit>
  USBD2.otg       = OTG_HS;
 80059ea:	4b04      	ldr	r3, [pc, #16]	; (80059fc <usb_lld_init+0x1c>)
 80059ec:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  USBD2.otgparams = &hsparams;
 80059f0:	4b03      	ldr	r3, [pc, #12]	; (8005a00 <usb_lld_init+0x20>)
 80059f2:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
 80059f6:	bd10      	pop	{r4, pc}
 80059f8:	200035cc 	.word	0x200035cc
 80059fc:	40040000 	.word	0x40040000
 8005a00:	0800e890 	.word	0x0800e890
	...

08005a10 <otg_ram_alloc.lto_priv.144>:
  next = usbp->pmnext;
 8005a10:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c
  usbp->pmnext += size;
 8005a14:	4419      	add	r1, r3
 8005a16:	f8c0 108c 	str.w	r1, [r0, #140]	; 0x8c
}
 8005a1a:	4618      	mov	r0, r3
 8005a1c:	4770      	bx	lr
 8005a1e:	bf00      	nop

08005a20 <otg_ram_reset.lto_priv.142>:
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8005a20:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
 8005a24:	681b      	ldr	r3, [r3, #0]
 8005a26:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
 8005a2a:	4770      	bx	lr
 8005a2c:	0000      	movs	r0, r0
	...

08005a30 <otg_txfifo_flush.lto_priv.143>:
static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
 8005a30:	b508      	push	{r3, lr}
  stm32_otg_t *otgp = usbp->otg;
 8005a32:	f8d0 2084 	ldr.w	r2, [r0, #132]	; 0x84
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8005a36:	0189      	lsls	r1, r1, #6
 8005a38:	f041 0120 	orr.w	r1, r1, #32
 8005a3c:	6111      	str	r1, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8005a3e:	6913      	ldr	r3, [r2, #16]
 8005a40:	f013 0f20 	tst.w	r3, #32
 8005a44:	d1fb      	bne.n	8005a3e <otg_txfifo_flush.lto_priv.143+0xe>
 8005a46:	2012      	movs	r0, #18
 8005a48:	f000 ffba 	bl	80069c0 <chSysPolledDelayX>
 8005a4c:	bd08      	pop	{r3, pc}
 8005a4e:	bf00      	nop

08005a50 <otg_isoc_in_failed_handler>:
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
 8005a50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005a52:	4607      	mov	r7, r0
  stm32_otg_t *otgp = usbp->otg;
 8005a54:	f8d0 5084 	ldr.w	r5, [r0, #132]	; 0x84
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8005a58:	2400      	movs	r4, #0
 8005a5a:	e035      	b.n	8005ac8 <otg_isoc_in_failed_handler+0x78>
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8005a5c:	4626      	mov	r6, r4
 8005a5e:	f104 0348 	add.w	r3, r4, #72	; 0x48
 8005a62:	015b      	lsls	r3, r3, #5
 8005a64:	58eb      	ldr	r3, [r5, r3]
 8005a66:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8005a6a:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8005a6e:	d129      	bne.n	8005ac4 <otg_isoc_in_failed_handler+0x74>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 8005a70:	f104 0348 	add.w	r3, r4, #72	; 0x48
 8005a74:	015b      	lsls	r3, r3, #5
 8005a76:	58eb      	ldr	r3, [r5, r3]
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8005a78:	2b00      	cmp	r3, #0
 8005a7a:	da23      	bge.n	8005ac4 <otg_isoc_in_failed_handler+0x74>
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 8005a7c:	f104 0348 	add.w	r3, r4, #72	; 0x48
 8005a80:	015b      	lsls	r3, r3, #5
 8005a82:	58ea      	ldr	r2, [r5, r3]
 8005a84:	f042 4290 	orr.w	r2, r2, #1207959552	; 0x48000000
 8005a88:	50ea      	str	r2, [r5, r3]
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 8005a8a:	f106 0348 	add.w	r3, r6, #72	; 0x48
 8005a8e:	015b      	lsls	r3, r3, #5
 8005a90:	58eb      	ldr	r3, [r5, r3]
 8005a92:	2b00      	cmp	r3, #0
 8005a94:	dbf9      	blt.n	8005a8a <otg_isoc_in_failed_handler+0x3a>
      otg_txfifo_flush(usbp, ep);
 8005a96:	4638      	mov	r0, r7
 8005a98:	f7ff ffca 	bl	8005a30 <otg_txfifo_flush.lto_priv.143>
      _usb_isr_invoke_in_cb(usbp, ep);
 8005a9c:	2301      	movs	r3, #1
 8005a9e:	fa03 f206 	lsl.w	r2, r3, r6
 8005aa2:	893b      	ldrh	r3, [r7, #8]
 8005aa4:	ea23 0302 	bic.w	r3, r3, r2
 8005aa8:	813b      	strh	r3, [r7, #8]
 8005aaa:	3602      	adds	r6, #2
 8005aac:	eb07 0686 	add.w	r6, r7, r6, lsl #2
 8005ab0:	6873      	ldr	r3, [r6, #4]
 8005ab2:	689b      	ldr	r3, [r3, #8]
 8005ab4:	b113      	cbz	r3, 8005abc <otg_isoc_in_failed_handler+0x6c>
 8005ab6:	4621      	mov	r1, r4
 8005ab8:	4638      	mov	r0, r7
 8005aba:	4798      	blx	r3
      otg_txfifo_handler(usbp, ep);
 8005abc:	4621      	mov	r1, r4
 8005abe:	4638      	mov	r0, r7
 8005ac0:	f7ff fe36 	bl	8005730 <otg_txfifo_handler>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8005ac4:	3401      	adds	r4, #1
 8005ac6:	b2e4      	uxtb	r4, r4
 8005ac8:	4621      	mov	r1, r4
 8005aca:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8005ace:	689b      	ldr	r3, [r3, #8]
 8005ad0:	429c      	cmp	r4, r3
 8005ad2:	d9c3      	bls.n	8005a5c <otg_isoc_in_failed_handler+0xc>
}
 8005ad4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005ad6:	bf00      	nop
	...

08005ae0 <usb_lld_serve_interrupt>:
static void usb_lld_serve_interrupt(USBDriver *usbp) {
 8005ae0:	b570      	push	{r4, r5, r6, lr}
 8005ae2:	4606      	mov	r6, r0
  stm32_otg_t *otgp = usbp->otg;
 8005ae4:	f8d0 5084 	ldr.w	r5, [r0, #132]	; 0x84
  sts  = otgp->GINTSTS;
 8005ae8:	696c      	ldr	r4, [r5, #20]
  sts &= otgp->GINTMSK;
 8005aea:	69ab      	ldr	r3, [r5, #24]
 8005aec:	401c      	ands	r4, r3
  otgp->GINTSTS = sts;
 8005aee:	616c      	str	r4, [r5, #20]
  if (sts & GINTSTS_USBRST) {
 8005af0:	f414 5f80 	tst.w	r4, #4096	; 0x1000
 8005af4:	d002      	beq.n	8005afc <usb_lld_serve_interrupt+0x1c>
    _usb_reset(usbp);
 8005af6:	f7ff ff4b 	bl	8005990 <_usb_reset>
 8005afa:	bd70      	pop	{r4, r5, r6, pc}
  if (sts & GINTSTS_WKUPINT) {
 8005afc:	2c00      	cmp	r4, #0
 8005afe:	da13      	bge.n	8005b28 <usb_lld_serve_interrupt+0x48>
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 8005b00:	f8d5 3e00 	ldr.w	r3, [r5, #3584]	; 0xe00
 8005b04:	f013 0f03 	tst.w	r3, #3
 8005b08:	d005      	beq.n	8005b16 <usb_lld_serve_interrupt+0x36>
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 8005b0a:	f8d5 3e00 	ldr.w	r3, [r5, #3584]	; 0xe00
 8005b0e:	f023 0303 	bic.w	r3, r3, #3
 8005b12:	f8c5 3e00 	str.w	r3, [r5, #3584]	; 0xe00
    otgp->DCTL &= ~DCTL_RWUSIG;
 8005b16:	f8d5 3804 	ldr.w	r3, [r5, #2052]	; 0x804
 8005b1a:	f023 0301 	bic.w	r3, r3, #1
 8005b1e:	f8c5 3804 	str.w	r3, [r5, #2052]	; 0x804
    _usb_wakeup(usbp);
 8005b22:	4630      	mov	r0, r6
 8005b24:	f7ff fe64 	bl	80057f0 <_usb_wakeup>
  if (sts & GINTSTS_USBSUSP) {
 8005b28:	f414 6f00 	tst.w	r4, #2048	; 0x800
 8005b2c:	d002      	beq.n	8005b34 <usb_lld_serve_interrupt+0x54>
    _usb_suspend(usbp);
 8005b2e:	4630      	mov	r0, r6
 8005b30:	f7ff fe6e 	bl	8005810 <_usb_suspend>
  if (sts & GINTSTS_ENUMDNE) {
 8005b34:	f414 5f00 	tst.w	r4, #8192	; 0x2000
 8005b38:	d011      	beq.n	8005b5e <usb_lld_serve_interrupt+0x7e>
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 8005b3a:	f8d5 3808 	ldr.w	r3, [r5, #2056]	; 0x808
 8005b3e:	f013 0f06 	tst.w	r3, #6
 8005b42:	d106      	bne.n	8005b52 <usb_lld_serve_interrupt+0x72>
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8005b44:	68eb      	ldr	r3, [r5, #12]
 8005b46:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8005b4a:	f443 5310 	orr.w	r3, r3, #9216	; 0x2400
 8005b4e:	60eb      	str	r3, [r5, #12]
 8005b50:	e005      	b.n	8005b5e <usb_lld_serve_interrupt+0x7e>
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8005b52:	68eb      	ldr	r3, [r5, #12]
 8005b54:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8005b58:	f443 53a0 	orr.w	r3, r3, #5120	; 0x1400
 8005b5c:	60eb      	str	r3, [r5, #12]
  if (sts & GINTSTS_SOF) {
 8005b5e:	f014 0f08 	tst.w	r4, #8
 8005b62:	d004      	beq.n	8005b6e <usb_lld_serve_interrupt+0x8e>
    _usb_isr_invoke_sof_cb(usbp);
 8005b64:	6873      	ldr	r3, [r6, #4]
 8005b66:	68db      	ldr	r3, [r3, #12]
 8005b68:	b10b      	cbz	r3, 8005b6e <usb_lld_serve_interrupt+0x8e>
 8005b6a:	4630      	mov	r0, r6
 8005b6c:	4798      	blx	r3
  if (sts & GINTSTS_IISOIXFR) {
 8005b6e:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
 8005b72:	d002      	beq.n	8005b7a <usb_lld_serve_interrupt+0x9a>
    otg_isoc_in_failed_handler(usbp);
 8005b74:	4630      	mov	r0, r6
 8005b76:	f7ff ff6b 	bl	8005a50 <otg_isoc_in_failed_handler>
  if (sts & GINTSTS_IISOOXFR) {
 8005b7a:	f414 1f00 	tst.w	r4, #2097152	; 0x200000
 8005b7e:	d002      	beq.n	8005b86 <usb_lld_serve_interrupt+0xa6>
    otg_isoc_out_failed_handler(usbp);
 8005b80:	4630      	mov	r0, r6
 8005b82:	f7ff fd4d 	bl	8005620 <otg_isoc_out_failed_handler>
  if ((sts & GINTSTS_RXFLVL) != 0U) {
 8005b86:	f014 0f10 	tst.w	r4, #16
 8005b8a:	d002      	beq.n	8005b92 <usb_lld_serve_interrupt+0xb2>
    otg_rxfifo_handler(usbp);
 8005b8c:	4630      	mov	r0, r6
 8005b8e:	f7ff fd8f 	bl	80056b0 <otg_rxfifo_handler>
  src = otgp->DAINT;
 8005b92:	f8d5 5818 	ldr.w	r5, [r5, #2072]	; 0x818
  if (sts & GINTSTS_OEPINT) {
 8005b96:	f414 2f00 	tst.w	r4, #524288	; 0x80000
 8005b9a:	d037      	beq.n	8005c0c <usb_lld_serve_interrupt+0x12c>
    if (src & (1 << 16))
 8005b9c:	f415 3f80 	tst.w	r5, #65536	; 0x10000
 8005ba0:	d003      	beq.n	8005baa <usb_lld_serve_interrupt+0xca>
      otg_epout_handler(usbp, 0);
 8005ba2:	2100      	movs	r1, #0
 8005ba4:	4630      	mov	r0, r6
 8005ba6:	f7ff fe43 	bl	8005830 <otg_epout_handler>
    if (src & (1 << 17))
 8005baa:	f415 3f00 	tst.w	r5, #131072	; 0x20000
 8005bae:	d003      	beq.n	8005bb8 <usb_lld_serve_interrupt+0xd8>
      otg_epout_handler(usbp, 1);
 8005bb0:	2101      	movs	r1, #1
 8005bb2:	4630      	mov	r0, r6
 8005bb4:	f7ff fe3c 	bl	8005830 <otg_epout_handler>
    if (src & (1 << 18))
 8005bb8:	f415 2f80 	tst.w	r5, #262144	; 0x40000
 8005bbc:	d003      	beq.n	8005bc6 <usb_lld_serve_interrupt+0xe6>
      otg_epout_handler(usbp, 2);
 8005bbe:	2102      	movs	r1, #2
 8005bc0:	4630      	mov	r0, r6
 8005bc2:	f7ff fe35 	bl	8005830 <otg_epout_handler>
    if (src & (1 << 19))
 8005bc6:	f415 2f00 	tst.w	r5, #524288	; 0x80000
 8005bca:	d003      	beq.n	8005bd4 <usb_lld_serve_interrupt+0xf4>
      otg_epout_handler(usbp, 3);
 8005bcc:	2103      	movs	r1, #3
 8005bce:	4630      	mov	r0, r6
 8005bd0:	f7ff fe2e 	bl	8005830 <otg_epout_handler>
    if (src & (1 << 20))
 8005bd4:	f415 1f80 	tst.w	r5, #1048576	; 0x100000
 8005bd8:	d003      	beq.n	8005be2 <usb_lld_serve_interrupt+0x102>
      otg_epout_handler(usbp, 4);
 8005bda:	2104      	movs	r1, #4
 8005bdc:	4630      	mov	r0, r6
 8005bde:	f7ff fe27 	bl	8005830 <otg_epout_handler>
    if (src & (1 << 21))
 8005be2:	f415 1f00 	tst.w	r5, #2097152	; 0x200000
 8005be6:	d003      	beq.n	8005bf0 <usb_lld_serve_interrupt+0x110>
      otg_epout_handler(usbp, 5);
 8005be8:	2105      	movs	r1, #5
 8005bea:	4630      	mov	r0, r6
 8005bec:	f7ff fe20 	bl	8005830 <otg_epout_handler>
    if (src & (1 << 22))
 8005bf0:	f415 0f80 	tst.w	r5, #4194304	; 0x400000
 8005bf4:	d003      	beq.n	8005bfe <usb_lld_serve_interrupt+0x11e>
      otg_epout_handler(usbp, 6);
 8005bf6:	2106      	movs	r1, #6
 8005bf8:	4630      	mov	r0, r6
 8005bfa:	f7ff fe19 	bl	8005830 <otg_epout_handler>
    if (src & (1 << 23))
 8005bfe:	f415 0f00 	tst.w	r5, #8388608	; 0x800000
 8005c02:	d003      	beq.n	8005c0c <usb_lld_serve_interrupt+0x12c>
      otg_epout_handler(usbp, 7);
 8005c04:	2107      	movs	r1, #7
 8005c06:	4630      	mov	r0, r6
 8005c08:	f7ff fe12 	bl	8005830 <otg_epout_handler>
  if (sts & GINTSTS_IEPINT) {
 8005c0c:	f414 2f80 	tst.w	r4, #262144	; 0x40000
 8005c10:	d037      	beq.n	8005c82 <usb_lld_serve_interrupt+0x1a2>
    if (src & (1 << 0))
 8005c12:	f015 0f01 	tst.w	r5, #1
 8005c16:	d003      	beq.n	8005c20 <usb_lld_serve_interrupt+0x140>
      otg_epin_handler(usbp, 0);
 8005c18:	2100      	movs	r1, #0
 8005c1a:	4630      	mov	r0, r6
 8005c1c:	f7ff fe58 	bl	80058d0 <otg_epin_handler>
    if (src & (1 << 1))
 8005c20:	f015 0f02 	tst.w	r5, #2
 8005c24:	d003      	beq.n	8005c2e <usb_lld_serve_interrupt+0x14e>
      otg_epin_handler(usbp, 1);
 8005c26:	2101      	movs	r1, #1
 8005c28:	4630      	mov	r0, r6
 8005c2a:	f7ff fe51 	bl	80058d0 <otg_epin_handler>
    if (src & (1 << 2))
 8005c2e:	f015 0f04 	tst.w	r5, #4
 8005c32:	d003      	beq.n	8005c3c <usb_lld_serve_interrupt+0x15c>
      otg_epin_handler(usbp, 2);
 8005c34:	2102      	movs	r1, #2
 8005c36:	4630      	mov	r0, r6
 8005c38:	f7ff fe4a 	bl	80058d0 <otg_epin_handler>
    if (src & (1 << 3))
 8005c3c:	f015 0f08 	tst.w	r5, #8
 8005c40:	d003      	beq.n	8005c4a <usb_lld_serve_interrupt+0x16a>
      otg_epin_handler(usbp, 3);
 8005c42:	2103      	movs	r1, #3
 8005c44:	4630      	mov	r0, r6
 8005c46:	f7ff fe43 	bl	80058d0 <otg_epin_handler>
    if (src & (1 << 4))
 8005c4a:	f015 0f10 	tst.w	r5, #16
 8005c4e:	d003      	beq.n	8005c58 <usb_lld_serve_interrupt+0x178>
      otg_epin_handler(usbp, 4);
 8005c50:	2104      	movs	r1, #4
 8005c52:	4630      	mov	r0, r6
 8005c54:	f7ff fe3c 	bl	80058d0 <otg_epin_handler>
    if (src & (1 << 5))
 8005c58:	f015 0f20 	tst.w	r5, #32
 8005c5c:	d003      	beq.n	8005c66 <usb_lld_serve_interrupt+0x186>
      otg_epin_handler(usbp, 5);
 8005c5e:	2105      	movs	r1, #5
 8005c60:	4630      	mov	r0, r6
 8005c62:	f7ff fe35 	bl	80058d0 <otg_epin_handler>
    if (src & (1 << 6))
 8005c66:	f015 0f40 	tst.w	r5, #64	; 0x40
 8005c6a:	d003      	beq.n	8005c74 <usb_lld_serve_interrupt+0x194>
      otg_epin_handler(usbp, 6);
 8005c6c:	2106      	movs	r1, #6
 8005c6e:	4630      	mov	r0, r6
 8005c70:	f7ff fe2e 	bl	80058d0 <otg_epin_handler>
    if (src & (1 << 7))
 8005c74:	f015 0f80 	tst.w	r5, #128	; 0x80
 8005c78:	d003      	beq.n	8005c82 <usb_lld_serve_interrupt+0x1a2>
      otg_epin_handler(usbp, 7);
 8005c7a:	2107      	movs	r1, #7
 8005c7c:	4630      	mov	r0, r6
 8005c7e:	f7ff fe27 	bl	80058d0 <otg_epin_handler>
 8005c82:	bd70      	pop	{r4, r5, r6, pc}
	...

08005c90 <Vector174>:
OSAL_IRQ_HANDLER(STM32_OTG2_HANDLER) {
 8005c90:	b508      	push	{r3, lr}
  usb_lld_serve_interrupt(&USBD2);
 8005c92:	4803      	ldr	r0, [pc, #12]	; (8005ca0 <Vector174+0x10>)
 8005c94:	f7ff ff24 	bl	8005ae0 <usb_lld_serve_interrupt>
  OSAL_IRQ_EPILOGUE();
 8005c98:	f003 f8fa 	bl	8008e90 <_port_irq_epilogue>
 8005c9c:	bd08      	pop	{r3, pc}
 8005c9e:	bf00      	nop
 8005ca0:	200035cc 	.word	0x200035cc
	...

08005cb0 <otg_rxfifo_flush.lto_priv.145>:
static void otg_rxfifo_flush(USBDriver *usbp) {
 8005cb0:	b508      	push	{r3, lr}
  stm32_otg_t *otgp = usbp->otg;
 8005cb2:	f8d0 2084 	ldr.w	r2, [r0, #132]	; 0x84
  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 8005cb6:	2310      	movs	r3, #16
 8005cb8:	6113      	str	r3, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 8005cba:	6913      	ldr	r3, [r2, #16]
 8005cbc:	f013 0f10 	tst.w	r3, #16
 8005cc0:	d1fb      	bne.n	8005cba <otg_rxfifo_flush.lto_priv.145+0xa>
 8005cc2:	2012      	movs	r0, #18
 8005cc4:	f000 fe7c 	bl	80069c0 <chSysPolledDelayX>
 8005cc8:	bd08      	pop	{r3, pc}
 8005cca:	bf00      	nop
 8005ccc:	0000      	movs	r0, r0
	...

08005cd0 <otg_disable_ep.lto_priv.141>:
static void otg_disable_ep(USBDriver *usbp) {
 8005cd0:	b470      	push	{r4, r5, r6}
  stm32_otg_t *otgp = usbp->otg;
 8005cd2:	f8d0 5084 	ldr.w	r5, [r0, #132]	; 0x84
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8005cd6:	2300      	movs	r3, #0
 8005cd8:	e015      	b.n	8005d06 <otg_disable_ep.lto_priv.141+0x36>
    otgp->ie[i].DIEPCTL = 0;
 8005cda:	f103 0248 	add.w	r2, r3, #72	; 0x48
 8005cde:	0152      	lsls	r2, r2, #5
 8005ce0:	2100      	movs	r1, #0
 8005ce2:	50a9      	str	r1, [r5, r2]
    otgp->ie[i].DIEPTSIZ = 0;
 8005ce4:	eb05 1243 	add.w	r2, r5, r3, lsl #5
 8005ce8:	f8c2 1910 	str.w	r1, [r2, #2320]	; 0x910
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8005cec:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 8005cf0:	f8c2 6908 	str.w	r6, [r2, #2312]	; 0x908
    otgp->oe[i].DOEPCTL = 0;
 8005cf4:	f103 0458 	add.w	r4, r3, #88	; 0x58
 8005cf8:	0164      	lsls	r4, r4, #5
 8005cfa:	5129      	str	r1, [r5, r4]
    otgp->oe[i].DOEPTSIZ = 0;
 8005cfc:	f8c2 1b10 	str.w	r1, [r2, #2832]	; 0xb10
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 8005d00:	f8c2 6b08 	str.w	r6, [r2, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8005d04:	3301      	adds	r3, #1
 8005d06:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8005d0a:	6892      	ldr	r2, [r2, #8]
 8005d0c:	4293      	cmp	r3, r2
 8005d0e:	d9e4      	bls.n	8005cda <otg_disable_ep.lto_priv.141+0xa>
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8005d10:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8005d14:	f8c5 381c 	str.w	r3, [r5, #2076]	; 0x81c
}
 8005d18:	bc70      	pop	{r4, r5, r6}
 8005d1a:	4770      	bx	lr
 8005d1c:	0000      	movs	r0, r0
	...

08005d20 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8005d20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8005d24:	f002 0a03 	and.w	sl, r2, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8005d28:	f3c2 0c80 	ubfx	ip, r2, #2, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8005d2c:	f3c2 0ec1 	ubfx	lr, r2, #3, #2
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8005d30:	f3c2 1741 	ubfx	r7, r2, #5, #2
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8005d34:	f3c2 12c3 	ubfx	r2, r2, #7, #4
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8005d38:	4656      	mov	r6, sl
  uint32_t bit     = 0;
 8005d3a:	2400      	movs	r4, #0
  while (true) {
    if ((mask & 1) != 0) {
 8005d3c:	f011 0f01 	tst.w	r1, #1
 8005d40:	d04a      	beq.n	8005dd8 <_pal_lld_setgroupmode+0xb8>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8005d42:	f004 0807 	and.w	r8, r4, #7
 8005d46:	ea4f 0888 	mov.w	r8, r8, lsl #2
 8005d4a:	fa02 f908 	lsl.w	r9, r2, r8
      m1 = 1 << bit;
 8005d4e:	2501      	movs	r5, #1
 8005d50:	fa05 fb04 	lsl.w	fp, r5, r4
      m2 = 3 << (bit * 2);
 8005d54:	fa04 f305 	lsl.w	r3, r4, r5
 8005d58:	2503      	movs	r5, #3
 8005d5a:	fa05 f303 	lsl.w	r3, r5, r3
      m4 = 15 << ((bit & 7) * 4);
 8005d5e:	250f      	movs	r5, #15
 8005d60:	fa05 f808 	lsl.w	r8, r5, r8
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8005d64:	6845      	ldr	r5, [r0, #4]
 8005d66:	ea25 050b 	bic.w	r5, r5, fp
 8005d6a:	ea4c 0505 	orr.w	r5, ip, r5
 8005d6e:	6045      	str	r5, [r0, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8005d70:	6885      	ldr	r5, [r0, #8]
 8005d72:	43db      	mvns	r3, r3
 8005d74:	401d      	ands	r5, r3
 8005d76:	ea4e 0505 	orr.w	r5, lr, r5
 8005d7a:	6085      	str	r5, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8005d7c:	68c5      	ldr	r5, [r0, #12]
 8005d7e:	401d      	ands	r5, r3
 8005d80:	433d      	orrs	r5, r7
 8005d82:	60c5      	str	r5, [r0, #12]
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 8005d84:	f1ba 0f02 	cmp.w	sl, #2
 8005d88:	d113      	bne.n	8005db2 <_pal_lld_setgroupmode+0x92>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 8005d8a:	2c07      	cmp	r4, #7
 8005d8c:	d806      	bhi.n	8005d9c <_pal_lld_setgroupmode+0x7c>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8005d8e:	6a05      	ldr	r5, [r0, #32]
 8005d90:	ea25 0808 	bic.w	r8, r5, r8
 8005d94:	ea49 0508 	orr.w	r5, r9, r8
 8005d98:	6205      	str	r5, [r0, #32]
 8005d9a:	e005      	b.n	8005da8 <_pal_lld_setgroupmode+0x88>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8005d9c:	6a45      	ldr	r5, [r0, #36]	; 0x24
 8005d9e:	ea25 0808 	bic.w	r8, r5, r8
 8005da2:	ea49 0508 	orr.w	r5, r9, r8
 8005da6:	6245      	str	r5, [r0, #36]	; 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 8005da8:	6805      	ldr	r5, [r0, #0]
 8005daa:	402b      	ands	r3, r5
 8005dac:	4333      	orrs	r3, r6
 8005dae:	6003      	str	r3, [r0, #0]
 8005db0:	e012      	b.n	8005dd8 <_pal_lld_setgroupmode+0xb8>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 8005db2:	6805      	ldr	r5, [r0, #0]
 8005db4:	402b      	ands	r3, r5
 8005db6:	4333      	orrs	r3, r6
 8005db8:	6003      	str	r3, [r0, #0]
        if (bit < 8)
 8005dba:	2c07      	cmp	r4, #7
 8005dbc:	d806      	bhi.n	8005dcc <_pal_lld_setgroupmode+0xac>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8005dbe:	6a03      	ldr	r3, [r0, #32]
 8005dc0:	ea23 0808 	bic.w	r8, r3, r8
 8005dc4:	ea49 0308 	orr.w	r3, r9, r8
 8005dc8:	6203      	str	r3, [r0, #32]
 8005dca:	e005      	b.n	8005dd8 <_pal_lld_setgroupmode+0xb8>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8005dcc:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8005dce:	ea23 0808 	bic.w	r8, r3, r8
 8005dd2:	ea49 0308 	orr.w	r3, r9, r8
 8005dd6:	6243      	str	r3, [r0, #36]	; 0x24
      }
    }
    mask >>= 1;
    if (!mask)
 8005dd8:	0849      	lsrs	r1, r1, #1
 8005dda:	d007      	beq.n	8005dec <_pal_lld_setgroupmode+0xcc>
      return;
    otyper <<= 1;
 8005ddc:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
    ospeedr <<= 2;
 8005de0:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
    pupdr <<= 2;
 8005de4:	00bf      	lsls	r7, r7, #2
    moder <<= 2;
 8005de6:	00b6      	lsls	r6, r6, #2
    bit++;
 8005de8:	3401      	adds	r4, #1
 8005dea:	e7a7      	b.n	8005d3c <_pal_lld_setgroupmode+0x1c>
 8005dec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08005df0 <stm32_clock_init>:
#if !STM32_NO_INIT
  /* PWR clock enable.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCAPBEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCAPBEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8005df0:	4b48      	ldr	r3, [pc, #288]	; (8005f14 <stm32_clock_init+0x124>)
 8005df2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8005df6:	641a      	str	r2, [r3, #64]	; 0x40
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8005df8:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8005dfc:	4a46      	ldr	r2, [pc, #280]	; (8005f18 <stm32_clock_init+0x128>)
 8005dfe:	6011      	str	r1, [r2, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8005e00:	681a      	ldr	r2, [r3, #0]
 8005e02:	f042 0201 	orr.w	r2, r2, #1
 8005e06:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8005e08:	4b42      	ldr	r3, [pc, #264]	; (8005f14 <stm32_clock_init+0x124>)
 8005e0a:	681b      	ldr	r3, [r3, #0]
 8005e0c:	f013 0f02 	tst.w	r3, #2
 8005e10:	d0fa      	beq.n	8005e08 <stm32_clock_init+0x18>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8005e12:	4a40      	ldr	r2, [pc, #256]	; (8005f14 <stm32_clock_init+0x124>)
 8005e14:	6893      	ldr	r3, [r2, #8]
 8005e16:	f023 0303 	bic.w	r3, r3, #3
 8005e1a:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8005e1c:	4b3d      	ldr	r3, [pc, #244]	; (8005f14 <stm32_clock_init+0x124>)
 8005e1e:	689b      	ldr	r3, [r3, #8]
 8005e20:	f013 0f0c 	tst.w	r3, #12
 8005e24:	d1fa      	bne.n	8005e1c <stm32_clock_init+0x2c>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8005e26:	4b3b      	ldr	r3, [pc, #236]	; (8005f14 <stm32_clock_init+0x124>)
 8005e28:	681a      	ldr	r2, [r3, #0]
 8005e2a:	f002 02f9 	and.w	r2, r2, #249	; 0xf9
 8005e2e:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8005e30:	2200      	movs	r2, #0
 8005e32:	609a      	str	r2, [r3, #8]
  
#if STM32_HSE_ENABLED
  /* HSE activation.*/
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
 8005e34:	681a      	ldr	r2, [r3, #0]
 8005e36:	f442 22a0 	orr.w	r2, r2, #327680	; 0x50000
 8005e3a:	601a      	str	r2, [r3, #0]
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8005e3c:	4b35      	ldr	r3, [pc, #212]	; (8005f14 <stm32_clock_init+0x124>)
 8005e3e:	681b      	ldr	r3, [r3, #0]
 8005e40:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8005e44:	d0fa      	beq.n	8005e3c <stm32_clock_init+0x4c>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8005e46:	4a33      	ldr	r2, [pc, #204]	; (8005f14 <stm32_clock_init+0x124>)
 8005e48:	6f53      	ldr	r3, [r2, #116]	; 0x74
 8005e4a:	f043 0301 	orr.w	r3, r3, #1
 8005e4e:	6753      	str	r3, [r2, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8005e50:	4b30      	ldr	r3, [pc, #192]	; (8005f14 <stm32_clock_init+0x124>)
 8005e52:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8005e54:	f013 0f02 	tst.w	r3, #2
 8005e58:	d0fa      	beq.n	8005e50 <stm32_clock_init+0x60>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 8005e5a:	4b2e      	ldr	r3, [pc, #184]	; (8005f14 <stm32_clock_init+0x124>)
 8005e5c:	4a2f      	ldr	r2, [pc, #188]	; (8005f1c <stm32_clock_init+0x12c>)
 8005e5e:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8005e60:	681a      	ldr	r2, [r3, #0]
 8005e62:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8005e66:	601a      	str	r2, [r3, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8005e68:	4b2b      	ldr	r3, [pc, #172]	; (8005f18 <stm32_clock_init+0x128>)
 8005e6a:	685b      	ldr	r3, [r3, #4]
 8005e6c:	f413 4f80 	tst.w	r3, #16384	; 0x4000
 8005e70:	d0fa      	beq.n	8005e68 <stm32_clock_init+0x78>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8005e72:	4b28      	ldr	r3, [pc, #160]	; (8005f14 <stm32_clock_init+0x124>)
 8005e74:	681b      	ldr	r3, [r3, #0]
 8005e76:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8005e7a:	d0fa      	beq.n	8005e72 <stm32_clock_init+0x82>
    ;
#endif /* STM32_ACTIVATE_PLL */

#if STM32_ACTIVATE_PLLI2S
  /* PLLI2S activation.*/
  RCC->PLLI2SCFGR = STM32_PLLI2SR | STM32_PLLI2SN | STM32_PLLI2SP |
 8005e7c:	4b25      	ldr	r3, [pc, #148]	; (8005f14 <stm32_clock_init+0x124>)
 8005e7e:	4a28      	ldr	r2, [pc, #160]	; (8005f20 <stm32_clock_init+0x130>)
 8005e80:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                    STM32_PLLI2SSRC | STM32_PLLI2SQ | STM32_PLLI2SM;
  RCC->CR |= RCC_CR_PLLI2SON;
 8005e84:	681a      	ldr	r2, [r3, #0]
 8005e86:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8005e8a:	601a      	str	r2, [r3, #0]

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLI2SRDY))
 8005e8c:	4b21      	ldr	r3, [pc, #132]	; (8005f14 <stm32_clock_init+0x124>)
 8005e8e:	681b      	ldr	r3, [r3, #0]
 8005e90:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8005e94:	d0fa      	beq.n	8005e8c <stm32_clock_init+0x9c>
    ;
#endif /* STM32_ACTIVATE_PLLI2S */

#if STM32_ACTIVATE_PLLSAI
  /* PLLSAI activation.*/
  RCC->PLLSAICFGR = STM32_PLLSAIR | STM32_PLLSAIN | STM32_PLLSAIP |
 8005e96:	4b1f      	ldr	r3, [pc, #124]	; (8005f14 <stm32_clock_init+0x124>)
 8005e98:	4a22      	ldr	r2, [pc, #136]	; (8005f24 <stm32_clock_init+0x134>)
 8005e9a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
                    STM32_PLLSAIQ | STM32_PLLSAIM;
  RCC->CR |= RCC_CR_PLLSAION;
 8005e9e:	681a      	ldr	r2, [r3, #0]
 8005ea0:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8005ea4:	601a      	str	r2, [r3, #0]

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
 8005ea6:	4b1b      	ldr	r3, [pc, #108]	; (8005f14 <stm32_clock_init+0x124>)
 8005ea8:	681b      	ldr	r3, [r3, #0]
 8005eaa:	f013 5f00 	tst.w	r3, #536870912	; 0x20000000
 8005eae:	d0fa      	beq.n	8005ea6 <stm32_clock_init+0xb6>
    ;
#endif /* STM32_ACTIVATE_PLLSAI */

  /* Other clock-related settings (dividers, MCO etc).*/
#if !defined(STM32F413xx)
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8005eb0:	4b18      	ldr	r3, [pc, #96]	; (8005f14 <stm32_clock_init+0x124>)
 8005eb2:	4a1d      	ldr	r2, [pc, #116]	; (8005f28 <stm32_clock_init+0x138>)
 8005eb4:	609a      	str	r2, [r3, #8]
  /* Special case, in those devices STM32_CK48MSEL is located in the
     DCKCFGR register.*/
    dckcfgr |= STM32_CK48MSEL;
#endif
#if !defined(STM32F413xx)
    RCC->DCKCFGR = dckcfgr |
 8005eb6:	4a1d      	ldr	r2, [pc, #116]	; (8005f2c <stm32_clock_init+0x13c>)
 8005eb8:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  }
#endif

#if STM32_HAS_RCC_DCKCFGR2
  /* DCKCFGR2 register initialization.*/
  RCC->DCKCFGR2 = STM32_CK48MSEL;
 8005ebc:	2200      	movs	r2, #0
 8005ebe:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8005ec2:	4b1b      	ldr	r3, [pc, #108]	; (8005f30 <stm32_clock_init+0x140>)
 8005ec4:	681a      	ldr	r2, [r3, #0]
 8005ec6:	4b1b      	ldr	r3, [pc, #108]	; (8005f34 <stm32_clock_init+0x144>)
 8005ec8:	429a      	cmp	r2, r3
 8005eca:	d109      	bne.n	8005ee0 <stm32_clock_init+0xf0>
 8005ecc:	4b1a      	ldr	r3, [pc, #104]	; (8005f38 <stm32_clock_init+0x148>)
 8005ece:	681a      	ldr	r2, [r3, #0]
 8005ed0:	4b1a      	ldr	r3, [pc, #104]	; (8005f3c <stm32_clock_init+0x14c>)
 8005ed2:	429a      	cmp	r2, r3
 8005ed4:	d104      	bne.n	8005ee0 <stm32_clock_init+0xf0>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 8005ed6:	f44f 7282 	mov.w	r2, #260	; 0x104
 8005eda:	4b19      	ldr	r3, [pc, #100]	; (8005f40 <stm32_clock_init+0x150>)
 8005edc:	601a      	str	r2, [r3, #0]
 8005ede:	e003      	b.n	8005ee8 <stm32_clock_init+0xf8>
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8005ee0:	f240 7204 	movw	r2, #1796	; 0x704
 8005ee4:	4b16      	ldr	r3, [pc, #88]	; (8005f40 <stm32_clock_init+0x150>)
 8005ee6:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8005ee8:	4a0a      	ldr	r2, [pc, #40]	; (8005f14 <stm32_clock_init+0x124>)
 8005eea:	6893      	ldr	r3, [r2, #8]
 8005eec:	f043 0302 	orr.w	r3, r3, #2
 8005ef0:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8005ef2:	4b08      	ldr	r3, [pc, #32]	; (8005f14 <stm32_clock_init+0x124>)
 8005ef4:	689b      	ldr	r3, [r3, #8]
 8005ef6:	f003 030c 	and.w	r3, r3, #12
 8005efa:	2b08      	cmp	r3, #8
 8005efc:	d1f9      	bne.n	8005ef2 <stm32_clock_init+0x102>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 8005efe:	4b05      	ldr	r3, [pc, #20]	; (8005f14 <stm32_clock_init+0x124>)
 8005f00:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8005f02:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8005f06:	645a      	str	r2, [r3, #68]	; 0x44
 8005f08:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8005f0a:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8005f0e:	665a      	str	r2, [r3, #100]	; 0x64
 8005f10:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8005f12:	4770      	bx	lr
 8005f14:	40023800 	.word	0x40023800
 8005f18:	40007000 	.word	0x40007000
 8005f1c:	06402404 	.word	0x06402404
 8005f20:	44413004 	.word	0x44413004
 8005f24:	44033004 	.word	0x44033004
 8005f28:	40089400 	.word	0x40089400
 8005f2c:	00800003 	.word	0x00800003
 8005f30:	e0042000 	.word	0xe0042000
 8005f34:	20006411 	.word	0x20006411
 8005f38:	e000ed00 	.word	0xe000ed00
 8005f3c:	410fc241 	.word	0x410fc241
 8005f40:	40023c00 	.word	0x40023c00
	...

08005f50 <nvicEnableVector>:

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8005f50:	0109      	lsls	r1, r1, #4
 8005f52:	b2c9      	uxtb	r1, r1
 8005f54:	4a08      	ldr	r2, [pc, #32]	; (8005f78 <nvicEnableVector+0x28>)
 8005f56:	1813      	adds	r3, r2, r0
 8005f58:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8005f5c:	0941      	lsrs	r1, r0, #5
 8005f5e:	f000 001f 	and.w	r0, r0, #31
 8005f62:	2301      	movs	r3, #1
 8005f64:	fa03 f000 	lsl.w	r0, r3, r0
 8005f68:	f101 0360 	add.w	r3, r1, #96	; 0x60
 8005f6c:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8005f70:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
 8005f74:	4770      	bx	lr
 8005f76:	bf00      	nop
 8005f78:	e000e100 	.word	0xe000e100
 8005f7c:	00000000 	.word	0x00000000

08005f80 <usb_lld_start>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
 8005f80:	b570      	push	{r4, r5, r6, lr}
  stm32_otg_t *otgp = usbp->otg;
 8005f82:	f8d0 5084 	ldr.w	r5, [r0, #132]	; 0x84

  if (usbp->state == USB_STOP) {
 8005f86:	7803      	ldrb	r3, [r0, #0]
 8005f88:	2b01      	cmp	r3, #1
 8005f8a:	d14c      	bne.n	8006026 <usb_lld_start+0xa6>
 8005f8c:	4604      	mov	r4, r0
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
    }
#endif

#if STM32_USB_USE_OTG2
    if (&USBD2 == usbp) {
 8005f8e:	4b26      	ldr	r3, [pc, #152]	; (8006028 <usb_lld_start+0xa8>)
 8005f90:	4298      	cmp	r0, r3
 8005f92:	d124      	bne.n	8005fde <usb_lld_start+0x5e>
      /* OTG HS clock enable and reset.*/
      rccEnableOTG_HS(true);
 8005f94:	4b25      	ldr	r3, [pc, #148]	; (800602c <usb_lld_start+0xac>)
 8005f96:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005f98:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8005f9c:	631a      	str	r2, [r3, #48]	; 0x30
 8005f9e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8005fa0:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8005fa4:	651a      	str	r2, [r3, #80]	; 0x50
 8005fa6:	6d1a      	ldr	r2, [r3, #80]	; 0x50
      rccResetOTG_HS();
 8005fa8:	691a      	ldr	r2, [r3, #16]
 8005faa:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8005fae:	611a      	str	r2, [r3, #16]
 8005fb0:	691a      	ldr	r2, [r3, #16]
 8005fb2:	f022 5200 	bic.w	r2, r2, #536870912	; 0x20000000
 8005fb6:	611a      	str	r2, [r3, #16]
 8005fb8:	691a      	ldr	r2, [r3, #16]
#if defined(BOARD_OTG2_USES_ULPI)
      rccEnableOTG_HSULPI(true);
#else
      /* Workaround for the problem described here:
         http://forum.chibios.org/phpbb/viewtopic.php?f=16&t=1798.*/
      rccDisableOTG_HSULPI();
 8005fba:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005fbc:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 8005fc0:	631a      	str	r2, [r3, #48]	; 0x30
 8005fc2:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8005fc4:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 8005fc8:	651a      	str	r2, [r3, #80]	; 0x50
 8005fca:	6d1b      	ldr	r3, [r3, #80]	; 0x50
#endif

      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG2_NUMBER, STM32_USB_OTG2_IRQ_PRIORITY);
 8005fcc:	210e      	movs	r1, #14
 8005fce:	204d      	movs	r0, #77	; 0x4d
 8005fd0:	f7ff ffbe 	bl	8005f50 <nvicEnableVector>
#if defined(BOARD_OTG2_USES_ULPI)
      /* High speed ULPI PHY.*/
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_HS) |
                      GUSBCFG_SRPCAP | GUSBCFG_HNPCAP;
#else
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 8005fd4:	4b16      	ldr	r3, [pc, #88]	; (8006030 <usb_lld_start+0xb0>)
 8005fd6:	60eb      	str	r3, [r5, #12]
      /* USB 2.0 High Speed PHY in FS mode.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_HS_FS;
#endif
#else
      /* 48MHz 1.1 PHY.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 8005fd8:	4b16      	ldr	r3, [pc, #88]	; (8006034 <usb_lld_start+0xb4>)
 8005fda:	f8c5 3800 	str.w	r3, [r5, #2048]	; 0x800
#endif
    }
#endif

    /* PHY enabled.*/
    otgp->PCGCCTL = 0;
 8005fde:	2600      	movs	r6, #0
 8005fe0:	f8c5 6e00 	str.w	r6, [r5, #3584]	; 0xe00

    /* VBUS sensing and transceiver enabled.*/
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 8005fe4:	23c0      	movs	r3, #192	; 0xc0
 8005fe6:	602b      	str	r3, [r5, #0]
    if (&USBD2 == usbp) {
      otgp->GCCFG = 0;
    }
#endif
#else
    otgp->GCCFG = GCCFG_INIT_VALUE;
 8005fe8:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005fec:	63ab      	str	r3, [r5, #56]	; 0x38
#endif

    /* Soft core reset.*/
    otg_core_reset(usbp);
 8005fee:	4620      	mov	r0, r4
 8005ff0:	f7ff fcb6 	bl	8005960 <otg_core_reset>

    /* Interrupts on TXFIFOs half empty.*/
    otgp->GAHBCFG = 0;
 8005ff4:	60ae      	str	r6, [r5, #8]

    /* Endpoints re-initialization.*/
    otg_disable_ep(usbp);
 8005ff6:	4620      	mov	r0, r4
 8005ff8:	f7ff fe6a 	bl	8005cd0 <otg_disable_ep.lto_priv.141>

    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
 8005ffc:	f8c5 6810 	str.w	r6, [r5, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
 8006000:	f8c5 6814 	str.w	r6, [r5, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 8006004:	f8c5 681c 	str.w	r6, [r5, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 8006008:	6863      	ldr	r3, [r4, #4]
 800600a:	68db      	ldr	r3, [r3, #12]
 800600c:	b913      	cbnz	r3, 8006014 <usb_lld_start+0x94>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 800600e:	4b0a      	ldr	r3, [pc, #40]	; (8006038 <usb_lld_start+0xb8>)
 8006010:	61ab      	str	r3, [r5, #24]
 8006012:	e001      	b.n	8006018 <usb_lld_start+0x98>
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8006014:	4b09      	ldr	r3, [pc, #36]	; (800603c <usb_lld_start+0xbc>)
 8006016:	61ab      	str	r3, [r5, #24]
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM |
                       GINTMSK_SOFM;

    /* Clears all pending IRQs, if any. */
    otgp->GINTSTS  = 0xFFFFFFFF;
 8006018:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800601c:	616b      	str	r3, [r5, #20]

    /* Global interrupts enable.*/
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 800601e:	68ab      	ldr	r3, [r5, #8]
 8006020:	f043 0301 	orr.w	r3, r3, #1
 8006024:	60ab      	str	r3, [r5, #8]
 8006026:	bd70      	pop	{r4, r5, r6, pc}
 8006028:	200035cc 	.word	0x200035cc
 800602c:	40023800 	.word	0x40023800
 8006030:	40001440 	.word	0x40001440
 8006034:	02200003 	.word	0x02200003
 8006038:	c0303c00 	.word	0xc0303c00
 800603c:	c0303c08 	.word	0xc0303c08

08006040 <irqInit>:
/**
 * @brief   Enables IRQ sources.
 *
 * @notapi
 */
void irqInit(void) {
 8006040:	b508      	push	{r3, lr}

#if HAL_USE_PAL
  nvicEnableVector(EXTI0_IRQn, STM32_IRQ_EXTI0_PRIORITY);
 8006042:	2106      	movs	r1, #6
 8006044:	4608      	mov	r0, r1
 8006046:	f7ff ff83 	bl	8005f50 <nvicEnableVector>
  nvicEnableVector(EXTI1_IRQn, STM32_IRQ_EXTI1_PRIORITY);
 800604a:	2106      	movs	r1, #6
 800604c:	2007      	movs	r0, #7
 800604e:	f7ff ff7f 	bl	8005f50 <nvicEnableVector>
  nvicEnableVector(EXTI2_IRQn, STM32_IRQ_EXTI2_PRIORITY);
 8006052:	2106      	movs	r1, #6
 8006054:	2008      	movs	r0, #8
 8006056:	f7ff ff7b 	bl	8005f50 <nvicEnableVector>
  nvicEnableVector(EXTI3_IRQn, STM32_IRQ_EXTI3_PRIORITY);
 800605a:	2106      	movs	r1, #6
 800605c:	2009      	movs	r0, #9
 800605e:	f7ff ff77 	bl	8005f50 <nvicEnableVector>
  nvicEnableVector(EXTI4_IRQn, STM32_IRQ_EXTI4_PRIORITY);
 8006062:	2106      	movs	r1, #6
 8006064:	200a      	movs	r0, #10
 8006066:	f7ff ff73 	bl	8005f50 <nvicEnableVector>
  nvicEnableVector(EXTI9_5_IRQn, STM32_IRQ_EXTI5_9_PRIORITY);
 800606a:	2106      	movs	r1, #6
 800606c:	2017      	movs	r0, #23
 800606e:	f7ff ff6f 	bl	8005f50 <nvicEnableVector>
  nvicEnableVector(EXTI15_10_IRQn, STM32_IRQ_EXTI10_15_PRIORITY);
 8006072:	2106      	movs	r1, #6
 8006074:	2028      	movs	r0, #40	; 0x28
 8006076:	f7ff ff6b 	bl	8005f50 <nvicEnableVector>
 800607a:	bd08      	pop	{r3, pc}
 800607c:	0000      	movs	r0, r0
	...

08006080 <hal_lld_init>:
void hal_lld_init(void) {
 8006080:	b508      	push	{r3, lr}
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8006082:	4b16      	ldr	r3, [pc, #88]	; (80060dc <hal_lld_init+0x5c>)
 8006084:	691a      	ldr	r2, [r3, #16]
 8006086:	f062 02ff 	orn	r2, r2, #255	; 0xff
 800608a:	611a      	str	r2, [r3, #16]
 800608c:	691a      	ldr	r2, [r3, #16]
 800608e:	b2d2      	uxtb	r2, r2
 8006090:	611a      	str	r2, [r3, #16]
 8006092:	691a      	ldr	r2, [r3, #16]
  rccResetAHB2(~0);
 8006094:	695a      	ldr	r2, [r3, #20]
 8006096:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800609a:	6158      	str	r0, [r3, #20]
 800609c:	695a      	ldr	r2, [r3, #20]
 800609e:	2100      	movs	r1, #0
 80060a0:	6159      	str	r1, [r3, #20]
 80060a2:	695a      	ldr	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 80060a4:	6a1a      	ldr	r2, [r3, #32]
 80060a6:	f062 5280 	orn	r2, r2, #268435456	; 0x10000000
 80060aa:	621a      	str	r2, [r3, #32]
 80060ac:	6a1a      	ldr	r2, [r3, #32]
 80060ae:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 80060b2:	621a      	str	r2, [r3, #32]
 80060b4:	6a1a      	ldr	r2, [r3, #32]
  rccResetAPB2(~0);
 80060b6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80060b8:	6258      	str	r0, [r3, #36]	; 0x24
 80060ba:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80060bc:	6259      	str	r1, [r3, #36]	; 0x24
 80060be:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  rccEnablePWRInterface(true);
 80060c0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80060c2:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80060c6:	641a      	str	r2, [r3, #64]	; 0x40
 80060c8:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80060ca:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80060ce:	661a      	str	r2, [r3, #96]	; 0x60
 80060d0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  hal_lld_backup_domain_init();
 80060d2:	f7ff fb6d 	bl	80057b0 <hal_lld_backup_domain_init>
  irqInit();
 80060d6:	f7ff ffb3 	bl	8006040 <irqInit>
 80060da:	bd08      	pop	{r3, pc}
 80060dc:	40023800 	.word	0x40023800

080060e0 <qeiGetCount>:
 80060e0:	2320      	movs	r3, #32
 80060e2:	f383 8811 	msr	BASEPRI, r3
 */
qeicnt_t qeiGetCount(QEIDriver *qeip) {
  qeicnt_t cnt;

  osalSysLock();
  cnt = qeiGetCountI(qeip);
 80060e6:	6883      	ldr	r3, [r0, #8]
 80060e8:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80060ea:	b200      	sxth	r0, r0
 80060ec:	2300      	movs	r3, #0
 80060ee:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();

  return cnt;
}
 80060f2:	4770      	bx	lr
	...

08006100 <qeiEnable>:
void qeiEnable(QEIDriver *qeip) {
 8006100:	b510      	push	{r4, lr}
 8006102:	4604      	mov	r4, r0
 8006104:	2320      	movs	r3, #32
 8006106:	f383 8811 	msr	BASEPRI, r3
  qei_lld_enable(qeip);
 800610a:	f000 fd81 	bl	8006c10 <qei_lld_enable>
  qeip->state = QEI_ACTIVE;
 800610e:	2303      	movs	r3, #3
 8006110:	7023      	strb	r3, [r4, #0]
 8006112:	2300      	movs	r3, #0
 8006114:	f383 8811 	msr	BASEPRI, r3
 8006118:	bd10      	pop	{r4, pc}
 800611a:	bf00      	nop
 800611c:	0000      	movs	r0, r0
	...

08006120 <qeiStart>:
void qeiStart(QEIDriver *qeip, const QEIConfig *config) {
 8006120:	b510      	push	{r4, lr}
 8006122:	4604      	mov	r4, r0
 8006124:	2320      	movs	r3, #32
 8006126:	f383 8811 	msr	BASEPRI, r3
  qeip->config = config;
 800612a:	6041      	str	r1, [r0, #4]
  qei_lld_start(qeip);
 800612c:	f000 fd78 	bl	8006c20 <qei_lld_start>
  qeip->state = QEI_READY;
 8006130:	2302      	movs	r3, #2
 8006132:	7023      	strb	r3, [r4, #0]
 8006134:	2300      	movs	r3, #0
 8006136:	f383 8811 	msr	BASEPRI, r3
 800613a:	bd10      	pop	{r4, pc}
 800613c:	0000      	movs	r0, r0
	...

08006140 <qeiObjectInit>:
  qeip->state = QEI_STOP;
 8006140:	2301      	movs	r3, #1
 8006142:	7003      	strb	r3, [r0, #0]
  qeip->last = 0;
 8006144:	2300      	movs	r3, #0
 8006146:	8043      	strh	r3, [r0, #2]
  qeip->config = NULL;
 8006148:	6043      	str	r3, [r0, #4]
 800614a:	4770      	bx	lr
 800614c:	0000      	movs	r0, r0
	...

08006150 <qeiInit>:
void qeiInit(void) {
 8006150:	b508      	push	{r3, lr}
  qei_lld_init();
 8006152:	f000 fdcd 	bl	8006cf0 <qei_lld_init>
 8006156:	bd08      	pop	{r3, pc}
	...

08006160 <usbStartTransmitI>:
                       const uint8_t *buf, size_t n) {
 8006160:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006162:	460e      	mov	r6, r1
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8006164:	2501      	movs	r5, #1
 8006166:	408d      	lsls	r5, r1
 8006168:	b2ad      	uxth	r5, r5
 800616a:	8907      	ldrh	r7, [r0, #8]
 800616c:	433d      	orrs	r5, r7
 800616e:	8105      	strh	r5, [r0, #8]
  isp = usbp->epc[ep]->in_state;
 8006170:	3602      	adds	r6, #2
 8006172:	eb00 0486 	add.w	r4, r0, r6, lsl #2
 8006176:	6864      	ldr	r4, [r4, #4]
 8006178:	6964      	ldr	r4, [r4, #20]
  isp->txbuf  = buf;
 800617a:	60a2      	str	r2, [r4, #8]
  isp->txsize = n;
 800617c:	6023      	str	r3, [r4, #0]
  isp->txcnt  = 0;
 800617e:	2300      	movs	r3, #0
 8006180:	6063      	str	r3, [r4, #4]
  usb_lld_start_in(usbp, ep);
 8006182:	f000 ff65 	bl	8007050 <usb_lld_start_in>
 8006186:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08006190 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8006190:	b510      	push	{r4, lr}
 8006192:	4604      	mov	r4, r0

  (void)ep;
  switch (usbp->ep0state) {
 8006194:	f890 3064 	ldrb.w	r3, [r0, #100]	; 0x64
 8006198:	2b15      	cmp	r3, #21
 800619a:	d836      	bhi.n	800620a <_usb_ep0out+0x7a>
 800619c:	e8df f003 	tbb	[pc, r3]
 80061a0:	35353525 	.word	0x35353525
 80061a4:	35253535 	.word	0x35253535
 80061a8:	25252535 	.word	0x25252535
 80061ac:	35353535 	.word	0x35353535
 80061b0:	35353535 	.word	0x35353535
 80061b4:	0b1a      	.short	0x0b1a
  case USB_EP0_OUT_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_IN_SENDING_STS;
 80061b6:	230b      	movs	r3, #11
 80061b8:	f880 3064 	strb.w	r3, [r0, #100]	; 0x64
 80061bc:	2320      	movs	r3, #32
 80061be:	f383 8811 	msr	BASEPRI, r3
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
    usbStartTransmitI(usbp, 0, NULL, 0);
 80061c2:	2300      	movs	r3, #0
 80061c4:	461a      	mov	r2, r3
 80061c6:	4619      	mov	r1, r3
 80061c8:	f7ff ffca 	bl	8006160 <usbStartTransmitI>
 80061cc:	2300      	movs	r3, #0
 80061ce:	f383 8811 	msr	BASEPRI, r3
 80061d2:	bd10      	pop	{r4, pc}
    return;
  case USB_EP0_OUT_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 80061d4:	68c3      	ldr	r3, [r0, #12]
 80061d6:	699b      	ldr	r3, [r3, #24]
 80061d8:	685b      	ldr	r3, [r3, #4]
 80061da:	b9b3      	cbnz	r3, 800620a <_usb_ep0out+0x7a>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 80061dc:	6f03      	ldr	r3, [r0, #112]	; 0x70
 80061de:	b103      	cbz	r3, 80061e2 <_usb_ep0out+0x52>
      usbp->ep0endcb(usbp);
 80061e0:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_STP_WAITING;
 80061e2:	2300      	movs	r3, #0
 80061e4:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 80061e8:	bd10      	pop	{r4, pc}
    /* Falls through.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 80061ea:	2100      	movs	r1, #0
 80061ec:	f000 ff10 	bl	8007010 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 80061f0:	2100      	movs	r1, #0
 80061f2:	4620      	mov	r0, r4
 80061f4:	f000 ff1c 	bl	8007030 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 80061f8:	6863      	ldr	r3, [r4, #4]
 80061fa:	681b      	ldr	r3, [r3, #0]
 80061fc:	b113      	cbz	r3, 8006204 <_usb_ep0out+0x74>
 80061fe:	2106      	movs	r1, #6
 8006200:	4620      	mov	r0, r4
 8006202:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8006204:	2306      	movs	r3, #6
 8006206:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 800620a:	bd10      	pop	{r4, pc}
 800620c:	0000      	movs	r0, r0
	...

08006210 <usbStartReceiveI>:
                      uint8_t *buf, size_t n) {
 8006210:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006212:	460e      	mov	r6, r1
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8006214:	2501      	movs	r5, #1
 8006216:	408d      	lsls	r5, r1
 8006218:	b2ad      	uxth	r5, r5
 800621a:	8947      	ldrh	r7, [r0, #10]
 800621c:	433d      	orrs	r5, r7
 800621e:	8145      	strh	r5, [r0, #10]
  osp = usbp->epc[ep]->out_state;
 8006220:	3602      	adds	r6, #2
 8006222:	eb00 0486 	add.w	r4, r0, r6, lsl #2
 8006226:	6864      	ldr	r4, [r4, #4]
 8006228:	69a4      	ldr	r4, [r4, #24]
  osp->rxbuf  = buf;
 800622a:	60a2      	str	r2, [r4, #8]
  osp->rxsize = n;
 800622c:	6023      	str	r3, [r4, #0]
  osp->rxcnt  = 0;
 800622e:	2300      	movs	r3, #0
 8006230:	6063      	str	r3, [r4, #4]
  usb_lld_start_out(usbp, ep);
 8006232:	f000 ff6d 	bl	8007110 <usb_lld_start_out>
 8006236:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08006240 <_usb_ep0in>:
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8006240:	b510      	push	{r4, lr}
 8006242:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
 8006244:	f890 3064 	ldrb.w	r3, [r0, #100]	; 0x64
 8006248:	2b15      	cmp	r3, #21
 800624a:	d850      	bhi.n	80062ee <_usb_ep0in+0xae>
 800624c:	e8df f003 	tbb	[pc, r3]
 8006250:	4f4f4f3f 	.word	0x4f4f4f3f
 8006254:	4f3f4f4f 	.word	0x4f3f4f4f
 8006258:	38280b4f 	.word	0x38280b4f
 800625c:	4f4f4f4f 	.word	0x4f4f4f4f
 8006260:	4f4f4f4f 	.word	0x4f4f4f4f
 8006264:	3f3f      	.short	0x3f3f
    max = (size_t)get_hword(&usbp->setup[6]);
 8006266:	307a      	adds	r0, #122	; 0x7a
 8006268:	f7fc fe1a 	bl	8002ea0 <get_hword.lto_priv.146>
    if ((usbp->ep0n < max) &&
 800626c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800626e:	4298      	cmp	r0, r3
 8006270:	d916      	bls.n	80062a0 <_usb_ep0in+0x60>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 8006272:	68e2      	ldr	r2, [r4, #12]
 8006274:	8a11      	ldrh	r1, [r2, #16]
 8006276:	fbb3 f2f1 	udiv	r2, r3, r1
 800627a:	fb01 3312 	mls	r3, r1, r2, r3
    if ((usbp->ep0n < max) &&
 800627e:	b97b      	cbnz	r3, 80062a0 <_usb_ep0in+0x60>
 8006280:	2320      	movs	r3, #32
 8006282:	f383 8811 	msr	BASEPRI, r3
      usbStartTransmitI(usbp, 0, NULL, 0);
 8006286:	2300      	movs	r3, #0
 8006288:	461a      	mov	r2, r3
 800628a:	4619      	mov	r1, r3
 800628c:	4620      	mov	r0, r4
 800628e:	f7ff ff67 	bl	8006160 <usbStartTransmitI>
 8006292:	2300      	movs	r3, #0
 8006294:	f383 8811 	msr	BASEPRI, r3
      usbp->ep0state = USB_EP0_IN_WAITING_TX0;
 8006298:	230a      	movs	r3, #10
 800629a:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 800629e:	bd10      	pop	{r4, pc}
    usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 80062a0:	2314      	movs	r3, #20
 80062a2:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 80062a6:	2320      	movs	r3, #32
 80062a8:	f383 8811 	msr	BASEPRI, r3
    usbStartReceiveI(usbp, 0, NULL, 0);
 80062ac:	2300      	movs	r3, #0
 80062ae:	461a      	mov	r2, r3
 80062b0:	4619      	mov	r1, r3
 80062b2:	4620      	mov	r0, r4
 80062b4:	f7ff ffac 	bl	8006210 <usbStartReceiveI>
 80062b8:	2300      	movs	r3, #0
 80062ba:	f383 8811 	msr	BASEPRI, r3
 80062be:	bd10      	pop	{r4, pc}
    if (usbp->ep0endcb != NULL) {
 80062c0:	6f03      	ldr	r3, [r0, #112]	; 0x70
 80062c2:	b103      	cbz	r3, 80062c6 <_usb_ep0in+0x86>
      usbp->ep0endcb(usbp);
 80062c4:	4798      	blx	r3
    usbp->ep0state = USB_EP0_STP_WAITING;
 80062c6:	2300      	movs	r3, #0
 80062c8:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 80062cc:	bd10      	pop	{r4, pc}
    usb_lld_stall_in(usbp, 0);
 80062ce:	2100      	movs	r1, #0
 80062d0:	f000 fe9e 	bl	8007010 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 80062d4:	2100      	movs	r1, #0
 80062d6:	4620      	mov	r0, r4
 80062d8:	f000 feaa 	bl	8007030 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 80062dc:	6863      	ldr	r3, [r4, #4]
 80062de:	681b      	ldr	r3, [r3, #0]
 80062e0:	b113      	cbz	r3, 80062e8 <_usb_ep0in+0xa8>
 80062e2:	2106      	movs	r1, #6
 80062e4:	4620      	mov	r0, r4
 80062e6:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 80062e8:	2306      	movs	r3, #6
 80062ea:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 80062ee:	bd10      	pop	{r4, pc}

080062f0 <_usb_ep0setup>:
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 80062f0:	b510      	push	{r4, lr}
 80062f2:	4604      	mov	r4, r0
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 80062f4:	f890 3064 	ldrb.w	r3, [r0, #100]	; 0x64
 80062f8:	b113      	cbz	r3, 8006300 <_usb_ep0setup+0x10>
    usbp->ep0state = USB_EP0_STP_WAITING;
 80062fa:	2300      	movs	r3, #0
 80062fc:	f880 3064 	strb.w	r3, [r0, #100]	; 0x64
  usbReadSetup(usbp, ep, usbp->setup);
 8006300:	f104 0274 	add.w	r2, r4, #116	; 0x74
 8006304:	4620      	mov	r0, r4
 8006306:	f000 ff53 	bl	80071b0 <usb_lld_read_setup>
  if ((usbp->config->requests_hook_cb == NULL) ||
 800630a:	6863      	ldr	r3, [r4, #4]
 800630c:	689b      	ldr	r3, [r3, #8]
 800630e:	b113      	cbz	r3, 8006316 <_usb_ep0setup+0x26>
      !(usbp->config->requests_hook_cb(usbp))) {
 8006310:	4620      	mov	r0, r4
 8006312:	4798      	blx	r3
  if ((usbp->config->requests_hook_cb == NULL) ||
 8006314:	b9d0      	cbnz	r0, 800634c <_usb_ep0setup+0x5c>
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8006316:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 800631a:	f013 0f60 	tst.w	r3, #96	; 0x60
 800631e:	d103      	bne.n	8006328 <_usb_ep0setup+0x38>
        !default_handler(usbp)) {
 8006320:	4620      	mov	r0, r4
 8006322:	f7fc fdc5 	bl	8002eb0 <default_handler.lto_priv.147>
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8006326:	b988      	cbnz	r0, 800634c <_usb_ep0setup+0x5c>
      usb_lld_stall_in(usbp, 0);
 8006328:	2100      	movs	r1, #0
 800632a:	4620      	mov	r0, r4
 800632c:	f000 fe70 	bl	8007010 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
 8006330:	2100      	movs	r1, #0
 8006332:	4620      	mov	r0, r4
 8006334:	f000 fe7c 	bl	8007030 <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8006338:	6863      	ldr	r3, [r4, #4]
 800633a:	681b      	ldr	r3, [r3, #0]
 800633c:	b113      	cbz	r3, 8006344 <_usb_ep0setup+0x54>
 800633e:	2106      	movs	r1, #6
 8006340:	4620      	mov	r0, r4
 8006342:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 8006344:	2306      	movs	r3, #6
 8006346:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 800634a:	bd10      	pop	{r4, pc}
  max = (size_t)get_hword(&usbp->setup[6]);
 800634c:	f104 007a 	add.w	r0, r4, #122	; 0x7a
 8006350:	f7fc fda6 	bl	8002ea0 <get_hword.lto_priv.146>
  if (usbp->ep0n > max) {
 8006354:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8006356:	4298      	cmp	r0, r3
 8006358:	d200      	bcs.n	800635c <_usb_ep0setup+0x6c>
    usbp->ep0n = max;
 800635a:	66e0      	str	r0, [r4, #108]	; 0x6c
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 800635c:	f994 3074 	ldrsb.w	r3, [r4, #116]	; 0x74
 8006360:	2b00      	cmp	r3, #0
 8006362:	da21      	bge.n	80063a8 <_usb_ep0setup+0xb8>
    if (usbp->ep0n != 0U) {
 8006364:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8006366:	b17b      	cbz	r3, 8006388 <_usb_ep0setup+0x98>
      usbp->ep0state = USB_EP0_IN_TX;
 8006368:	2309      	movs	r3, #9
 800636a:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 800636e:	2320      	movs	r3, #32
 8006370:	f383 8811 	msr	BASEPRI, r3
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8006374:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8006376:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 8006378:	2100      	movs	r1, #0
 800637a:	4620      	mov	r0, r4
 800637c:	f7ff fef0 	bl	8006160 <usbStartTransmitI>
 8006380:	2300      	movs	r3, #0
 8006382:	f383 8811 	msr	BASEPRI, r3
 8006386:	bd10      	pop	{r4, pc}
      usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 8006388:	2314      	movs	r3, #20
 800638a:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 800638e:	2320      	movs	r3, #32
 8006390:	f383 8811 	msr	BASEPRI, r3
      usbStartReceiveI(usbp, 0, NULL, 0);
 8006394:	2300      	movs	r3, #0
 8006396:	461a      	mov	r2, r3
 8006398:	4619      	mov	r1, r3
 800639a:	4620      	mov	r0, r4
 800639c:	f7ff ff38 	bl	8006210 <usbStartReceiveI>
 80063a0:	2300      	movs	r3, #0
 80063a2:	f383 8811 	msr	BASEPRI, r3
 80063a6:	bd10      	pop	{r4, pc}
    if (usbp->ep0n != 0U) {
 80063a8:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80063aa:	b17b      	cbz	r3, 80063cc <_usb_ep0setup+0xdc>
      usbp->ep0state = USB_EP0_OUT_RX;
 80063ac:	2315      	movs	r3, #21
 80063ae:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 80063b2:	2320      	movs	r3, #32
 80063b4:	f383 8811 	msr	BASEPRI, r3
      usbStartReceiveI(usbp, 0, (uint8_t *)usbp->ep0next, usbp->ep0n);
 80063b8:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80063ba:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 80063bc:	2100      	movs	r1, #0
 80063be:	4620      	mov	r0, r4
 80063c0:	f7ff ff26 	bl	8006210 <usbStartReceiveI>
 80063c4:	2300      	movs	r3, #0
 80063c6:	f383 8811 	msr	BASEPRI, r3
 80063ca:	bd10      	pop	{r4, pc}
      usbp->ep0state = USB_EP0_IN_SENDING_STS;
 80063cc:	230b      	movs	r3, #11
 80063ce:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 80063d2:	2320      	movs	r3, #32
 80063d4:	f383 8811 	msr	BASEPRI, r3
      usbStartTransmitI(usbp, 0, NULL, 0);
 80063d8:	2300      	movs	r3, #0
 80063da:	461a      	mov	r2, r3
 80063dc:	4619      	mov	r1, r3
 80063de:	4620      	mov	r0, r4
 80063e0:	f7ff febe 	bl	8006160 <usbStartTransmitI>
 80063e4:	2300      	movs	r3, #0
 80063e6:	f383 8811 	msr	BASEPRI, r3
 80063ea:	bd10      	pop	{r4, pc}
 80063ec:	0000      	movs	r0, r0
	...

080063f0 <usbDisableEndpointsI>:
void usbDisableEndpointsI(USBDriver *usbp) {
 80063f0:	b508      	push	{r3, lr}
  usbp->transmitting &= 1U;
 80063f2:	8903      	ldrh	r3, [r0, #8]
 80063f4:	f003 0301 	and.w	r3, r3, #1
 80063f8:	8103      	strh	r3, [r0, #8]
  usbp->receiving    &= 1U;
 80063fa:	8943      	ldrh	r3, [r0, #10]
 80063fc:	f003 0301 	and.w	r3, r3, #1
 8006400:	8143      	strh	r3, [r0, #10]
  for (i = 1; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006402:	2301      	movs	r3, #1
 8006404:	e005      	b.n	8006412 <usbDisableEndpointsI+0x22>
    usbp->epc[i] = NULL;
 8006406:	1c9a      	adds	r2, r3, #2
 8006408:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 800640c:	2100      	movs	r1, #0
 800640e:	6051      	str	r1, [r2, #4]
  for (i = 1; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006410:	3301      	adds	r3, #1
 8006412:	2b07      	cmp	r3, #7
 8006414:	d9f7      	bls.n	8006406 <usbDisableEndpointsI+0x16>
  usb_lld_disable_endpoints(usbp);
 8006416:	f000 ff0b 	bl	8007230 <usb_lld_disable_endpoints>
 800641a:	bd08      	pop	{r3, pc}
 800641c:	0000      	movs	r0, r0
	...

08006420 <usbInitEndpointI>:
                      const USBEndpointConfig *epcp) {
 8006420:	b510      	push	{r4, lr}
  usbp->epc[ep] = epcp;
 8006422:	1c8b      	adds	r3, r1, #2
 8006424:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8006428:	605a      	str	r2, [r3, #4]
  if (epcp->in_state != NULL) {
 800642a:	6953      	ldr	r3, [r2, #20]
 800642c:	b123      	cbz	r3, 8006438 <usbInitEndpointI+0x18>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 800642e:	2400      	movs	r4, #0
 8006430:	601c      	str	r4, [r3, #0]
 8006432:	605c      	str	r4, [r3, #4]
 8006434:	609c      	str	r4, [r3, #8]
 8006436:	60dc      	str	r4, [r3, #12]
  if (epcp->out_state != NULL) {
 8006438:	6993      	ldr	r3, [r2, #24]
 800643a:	b123      	cbz	r3, 8006446 <usbInitEndpointI+0x26>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 800643c:	2200      	movs	r2, #0
 800643e:	601a      	str	r2, [r3, #0]
 8006440:	605a      	str	r2, [r3, #4]
 8006442:	609a      	str	r2, [r3, #8]
 8006444:	60da      	str	r2, [r3, #12]
  usb_lld_init_endpoint(usbp, ep);
 8006446:	f000 fefb 	bl	8007240 <usb_lld_init_endpoint>
 800644a:	bd10      	pop	{r4, pc}
 800644c:	0000      	movs	r0, r0
	...

08006450 <_scheduler_init>:
  tqp->next = (thread_t *)tqp;
 8006450:	4b03      	ldr	r3, [pc, #12]	; (8006460 <_scheduler_init+0x10>)
 8006452:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8006454:	605b      	str	r3, [r3, #4]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 8006456:	2200      	movs	r2, #0
 8006458:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
 800645a:	611b      	str	r3, [r3, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
 800645c:	615b      	str	r3, [r3, #20]
 800645e:	4770      	bx	lr
 8006460:	20003aec 	.word	0x20003aec
	...

08006470 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8006470:	4b05      	ldr	r3, [pc, #20]	; (8006488 <_vt_init+0x18>)
 8006472:	f103 021c 	add.w	r2, r3, #28
 8006476:	61da      	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8006478:	621a      	str	r2, [r3, #32]
  ch.vtlist.delta = (sysinterval_t)-1;
 800647a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800647e:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8006480:	2200      	movs	r2, #0
 8006482:	629a      	str	r2, [r3, #40]	; 0x28
 8006484:	4770      	bx	lr
 8006486:	bf00      	nop
 8006488:	20003aec 	.word	0x20003aec
 800648c:	00000000 	.word	0x00000000

08006490 <chSysIsCounterWithinX>:
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return (bool)((cnt - start) < (end - start));
 8006490:	1a40      	subs	r0, r0, r1
 8006492:	1a52      	subs	r2, r2, r1
}
 8006494:	4290      	cmp	r0, r2
 8006496:	bf2c      	ite	cs
 8006498:	2000      	movcs	r0, #0
 800649a:	2001      	movcc	r0, #1
 800649c:	4770      	bx	lr
 800649e:	bf00      	nop

080064a0 <_idle_thread>:
static void _idle_thread(void *p) {
 80064a0:	e7fe      	b.n	80064a0 <_idle_thread>
 80064a2:	bf00      	nop
	...

080064b0 <gpio_init>:
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80064b0:	684b      	ldr	r3, [r1, #4]
 80064b2:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80064b4:	688b      	ldr	r3, [r1, #8]
 80064b6:	6083      	str	r3, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 80064b8:	68cb      	ldr	r3, [r1, #12]
 80064ba:	60c3      	str	r3, [r0, #12]
  gpiop->ODR     = config->odr;
 80064bc:	690b      	ldr	r3, [r1, #16]
 80064be:	6143      	str	r3, [r0, #20]
  gpiop->AFRL    = config->afrl;
 80064c0:	694b      	ldr	r3, [r1, #20]
 80064c2:	6203      	str	r3, [r0, #32]
  gpiop->AFRH    = config->afrh;
 80064c4:	698b      	ldr	r3, [r1, #24]
 80064c6:	6243      	str	r3, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80064c8:	680b      	ldr	r3, [r1, #0]
 80064ca:	6003      	str	r3, [r0, #0]
 80064cc:	4770      	bx	lr
 80064ce:	bf00      	nop

080064d0 <stm32_gpio_init>:
}

static void stm32_gpio_init(void) {
 80064d0:	b510      	push	{r4, lr}

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
 80064d2:	4b1e      	ldr	r3, [pc, #120]	; (800654c <stm32_gpio_init+0x7c>)
 80064d4:	691a      	ldr	r2, [r3, #16]
 80064d6:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
 80064da:	611a      	str	r2, [r3, #16]
 80064dc:	691a      	ldr	r2, [r3, #16]
 80064de:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 80064e2:	611a      	str	r2, [r3, #16]
 80064e4:	691a      	ldr	r2, [r3, #16]
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 80064e6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80064e8:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
 80064ec:	631a      	str	r2, [r3, #48]	; 0x30
 80064ee:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80064f0:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
 80064f4:	651a      	str	r2, [r3, #80]	; 0x50
 80064f6:	6d1b      	ldr	r3, [r3, #80]	; 0x50

  /* Initializing all the defined GPIO ports.*/
#if STM32_HAS_GPIOA
  gpio_init(GPIOA, &gpio_default_config.PAData);
 80064f8:	4c15      	ldr	r4, [pc, #84]	; (8006550 <stm32_gpio_init+0x80>)
 80064fa:	4621      	mov	r1, r4
 80064fc:	4815      	ldr	r0, [pc, #84]	; (8006554 <stm32_gpio_init+0x84>)
 80064fe:	f7ff ffd7 	bl	80064b0 <gpio_init>
#endif
#if STM32_HAS_GPIOB
  gpio_init(GPIOB, &gpio_default_config.PBData);
 8006502:	f104 011c 	add.w	r1, r4, #28
 8006506:	4814      	ldr	r0, [pc, #80]	; (8006558 <stm32_gpio_init+0x88>)
 8006508:	f7ff ffd2 	bl	80064b0 <gpio_init>
#endif
#if STM32_HAS_GPIOC
  gpio_init(GPIOC, &gpio_default_config.PCData);
 800650c:	f104 0138 	add.w	r1, r4, #56	; 0x38
 8006510:	4812      	ldr	r0, [pc, #72]	; (800655c <stm32_gpio_init+0x8c>)
 8006512:	f7ff ffcd 	bl	80064b0 <gpio_init>
#endif
#if STM32_HAS_GPIOD
  gpio_init(GPIOD, &gpio_default_config.PDData);
 8006516:	f104 0154 	add.w	r1, r4, #84	; 0x54
 800651a:	4811      	ldr	r0, [pc, #68]	; (8006560 <stm32_gpio_init+0x90>)
 800651c:	f7ff ffc8 	bl	80064b0 <gpio_init>
#endif
#if STM32_HAS_GPIOE
  gpio_init(GPIOE, &gpio_default_config.PEData);
 8006520:	f104 0170 	add.w	r1, r4, #112	; 0x70
 8006524:	480f      	ldr	r0, [pc, #60]	; (8006564 <stm32_gpio_init+0x94>)
 8006526:	f7ff ffc3 	bl	80064b0 <gpio_init>
#endif
#if STM32_HAS_GPIOF
  gpio_init(GPIOF, &gpio_default_config.PFData);
 800652a:	f104 018c 	add.w	r1, r4, #140	; 0x8c
 800652e:	480e      	ldr	r0, [pc, #56]	; (8006568 <stm32_gpio_init+0x98>)
 8006530:	f7ff ffbe 	bl	80064b0 <gpio_init>
#endif
#if STM32_HAS_GPIOG
  gpio_init(GPIOG, &gpio_default_config.PGData);
 8006534:	f104 01a8 	add.w	r1, r4, #168	; 0xa8
 8006538:	480c      	ldr	r0, [pc, #48]	; (800656c <stm32_gpio_init+0x9c>)
 800653a:	f7ff ffb9 	bl	80064b0 <gpio_init>
#endif
#if STM32_HAS_GPIOH
  gpio_init(GPIOH, &gpio_default_config.PHData);
 800653e:	f104 01c4 	add.w	r1, r4, #196	; 0xc4
 8006542:	480b      	ldr	r0, [pc, #44]	; (8006570 <stm32_gpio_init+0xa0>)
 8006544:	f7ff ffb4 	bl	80064b0 <gpio_init>
 8006548:	bd10      	pop	{r4, pc}
 800654a:	bf00      	nop
 800654c:	40023800 	.word	0x40023800
 8006550:	0800e8b4 	.word	0x0800e8b4
 8006554:	40020000 	.word	0x40020000
 8006558:	40020400 	.word	0x40020400
 800655c:	40020800 	.word	0x40020800
 8006560:	40020c00 	.word	0x40020c00
 8006564:	40021000 	.word	0x40021000
 8006568:	40021400 	.word	0x40021400
 800656c:	40021800 	.word	0x40021800
 8006570:	40021c00 	.word	0x40021c00
	...

08006580 <notify2>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
 8006580:	4a02      	ldr	r2, [pc, #8]	; (800658c <notify2+0xc>)
 8006582:	68d3      	ldr	r3, [r2, #12]
 8006584:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8006588:	60d3      	str	r3, [r2, #12]
 800658a:	4770      	bx	lr
 800658c:	40004400 	.word	0x40004400

08006590 <usart_init>:
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
 8006590:	b410      	push	{r4}
  USART_TypeDef *u = sdp->usart;
 8006592:	6f43      	ldr	r3, [r0, #116]	; 0x74
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 8006594:	4a1e      	ldr	r2, [pc, #120]	; (8006610 <usart_init+0x80>)
 8006596:	4293      	cmp	r3, r2
 8006598:	d003      	beq.n	80065a2 <usart_init+0x12>
 800659a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800659e:	4293      	cmp	r3, r2
 80065a0:	d104      	bne.n	80065ac <usart_init+0x1c>
    fck = STM32_PCLK2 / config->speed;
 80065a2:	680c      	ldr	r4, [r1, #0]
 80065a4:	4a1b      	ldr	r2, [pc, #108]	; (8006614 <usart_init+0x84>)
 80065a6:	fbb2 f2f4 	udiv	r2, r2, r4
 80065aa:	e003      	b.n	80065b4 <usart_init+0x24>
    fck = STM32_PCLK1 / config->speed;
 80065ac:	680c      	ldr	r4, [r1, #0]
 80065ae:	4a1a      	ldr	r2, [pc, #104]	; (8006618 <usart_init+0x88>)
 80065b0:	fbb2 f2f4 	udiv	r2, r2, r4
  if (config->cr1 & USART_CR1_OVER8)
 80065b4:	f9b1 4004 	ldrsh.w	r4, [r1, #4]
 80065b8:	2c00      	cmp	r4, #0
 80065ba:	da05      	bge.n	80065c8 <usart_init+0x38>
    fck = ((fck & ~7) * 2) | (fck & 7);
 80065bc:	f022 0407 	bic.w	r4, r2, #7
 80065c0:	f002 0207 	and.w	r2, r2, #7
 80065c4:	ea42 0244 	orr.w	r2, r2, r4, lsl #1
  u->BRR = fck;
 80065c8:	609a      	str	r2, [r3, #8]
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80065ca:	88ca      	ldrh	r2, [r1, #6]
 80065cc:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80065d0:	611a      	str	r2, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80065d2:	890a      	ldrh	r2, [r1, #8]
 80065d4:	f042 0201 	orr.w	r2, r2, #1
 80065d8:	615a      	str	r2, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 80065da:	888a      	ldrh	r2, [r1, #4]
 80065dc:	f442 5204 	orr.w	r2, r2, #8448	; 0x2100
 80065e0:	f042 022c 	orr.w	r2, r2, #44	; 0x2c
 80065e4:	60da      	str	r2, [r3, #12]
  u->SR = 0;
 80065e6:	2200      	movs	r2, #0
 80065e8:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 80065ea:	681a      	ldr	r2, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 80065ec:	685b      	ldr	r3, [r3, #4]
  if ((config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_PCE) {
 80065ee:	888b      	ldrh	r3, [r1, #4]
 80065f0:	f403 53a0 	and.w	r3, r3, #5120	; 0x1400
 80065f4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80065f8:	d103      	bne.n	8006602 <usart_init+0x72>
    sdp->rxmask = 0x7F;
 80065fa:	237f      	movs	r3, #127	; 0x7f
 80065fc:	f880 3078 	strb.w	r3, [r0, #120]	; 0x78
 8006600:	e002      	b.n	8006608 <usart_init+0x78>
    sdp->rxmask = 0xFF;
 8006602:	23ff      	movs	r3, #255	; 0xff
 8006604:	f880 3078 	strb.w	r3, [r0, #120]	; 0x78
}
 8006608:	f85d 4b04 	ldr.w	r4, [sp], #4
 800660c:	4770      	bx	lr
 800660e:	bf00      	nop
 8006610:	40011000 	.word	0x40011000
 8006614:	044aa200 	.word	0x044aa200
 8006618:	02255100 	.word	0x02255100
 800661c:	00000000 	.word	0x00000000

08006620 <pwm_lld_serve_interrupt>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 8006620:	b538      	push	{r3, r4, r5, lr}
 8006622:	4605      	mov	r5, r0
  uint32_t sr;

  sr  = pwmp->tim->SR;
 8006624:	6983      	ldr	r3, [r0, #24]
 8006626:	691c      	ldr	r4, [r3, #16]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8006628:	68da      	ldr	r2, [r3, #12]
 800662a:	b2d2      	uxtb	r2, r2
 800662c:	4014      	ands	r4, r2
  pwmp->tim->SR = ~sr;
 800662e:	43e2      	mvns	r2, r4
 8006630:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8006632:	f014 0f02 	tst.w	r4, #2
 8006636:	d003      	beq.n	8006640 <pwm_lld_serve_interrupt+0x20>
      (pwmp->config->channels[0].callback != NULL))
 8006638:	6843      	ldr	r3, [r0, #4]
 800663a:	691b      	ldr	r3, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 800663c:	b103      	cbz	r3, 8006640 <pwm_lld_serve_interrupt+0x20>
    pwmp->config->channels[0].callback(pwmp);
 800663e:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8006640:	f014 0f04 	tst.w	r4, #4
 8006644:	d004      	beq.n	8006650 <pwm_lld_serve_interrupt+0x30>
      (pwmp->config->channels[1].callback != NULL))
 8006646:	686b      	ldr	r3, [r5, #4]
 8006648:	699b      	ldr	r3, [r3, #24]
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 800664a:	b10b      	cbz	r3, 8006650 <pwm_lld_serve_interrupt+0x30>
    pwmp->config->channels[1].callback(pwmp);
 800664c:	4628      	mov	r0, r5
 800664e:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8006650:	f014 0f08 	tst.w	r4, #8
 8006654:	d004      	beq.n	8006660 <pwm_lld_serve_interrupt+0x40>
      (pwmp->config->channels[2].callback != NULL))
 8006656:	686b      	ldr	r3, [r5, #4]
 8006658:	6a1b      	ldr	r3, [r3, #32]
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 800665a:	b10b      	cbz	r3, 8006660 <pwm_lld_serve_interrupt+0x40>
    pwmp->config->channels[2].callback(pwmp);
 800665c:	4628      	mov	r0, r5
 800665e:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8006660:	f014 0f10 	tst.w	r4, #16
 8006664:	d004      	beq.n	8006670 <pwm_lld_serve_interrupt+0x50>
      (pwmp->config->channels[3].callback != NULL))
 8006666:	686b      	ldr	r3, [r5, #4]
 8006668:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 800666a:	b10b      	cbz	r3, 8006670 <pwm_lld_serve_interrupt+0x50>
    pwmp->config->channels[3].callback(pwmp);
 800666c:	4628      	mov	r0, r5
 800666e:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 8006670:	f014 0f01 	tst.w	r4, #1
 8006674:	d004      	beq.n	8006680 <pwm_lld_serve_interrupt+0x60>
 8006676:	686b      	ldr	r3, [r5, #4]
 8006678:	689b      	ldr	r3, [r3, #8]
 800667a:	b10b      	cbz	r3, 8006680 <pwm_lld_serve_interrupt+0x60>
    pwmp->config->callback(pwmp);
 800667c:	4628      	mov	r0, r5
 800667e:	4798      	blx	r3
 8006680:	bd38      	pop	{r3, r4, r5, pc}
 8006682:	bf00      	nop
	...

08006690 <chSysTimerHandlerI>:
void chSysTimerHandlerI(void) {
 8006690:	b570      	push	{r4, r5, r6, lr}
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
 8006692:	4b21      	ldr	r3, [pc, #132]	; (8006718 <chSysTimerHandlerI+0x88>)
 8006694:	69dc      	ldr	r4, [r3, #28]
 8006696:	4b21      	ldr	r3, [pc, #132]	; (800671c <chSysTimerHandlerI+0x8c>)
 8006698:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  while (true) {

    /* Getting the system time as reference.*/
    now = chVTGetSystemTimeX();
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
 800669a:	4a1f      	ldr	r2, [pc, #124]	; (8006718 <chSysTimerHandlerI+0x88>)
 800669c:	6a95      	ldr	r5, [r2, #40]	; 0x28
  return (sysinterval_t)((systime_t)(end - start));
 800669e:	1b5d      	subs	r5, r3, r5

    /* The list scan is limited by the timers header having
       "ch.vtlist.vt_delta == (sysinterval_t)-1" which is
       greater than all deltas.*/
    if (nowdelta < vtp->delta) {
 80066a0:	68a2      	ldr	r2, [r4, #8]
 80066a2:	4295      	cmp	r5, r2
 80066a4:	d322      	bcc.n	80066ec <chSysTimerHandlerI+0x5c>
    /* Consuming all timers between "vtp->lasttime" and now.*/
    do {
      vtfunc_t fn;

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
 80066a6:	68a2      	ldr	r2, [r4, #8]
 80066a8:	4b1b      	ldr	r3, [pc, #108]	; (8006718 <chSysTimerHandlerI+0x88>)
 80066aa:	6a99      	ldr	r1, [r3, #40]	; 0x28
 80066ac:	440a      	add	r2, r1
 80066ae:	629a      	str	r2, [r3, #40]	; 0x28
      nowdelta -= vtp->delta;
 80066b0:	68a2      	ldr	r2, [r4, #8]
 80066b2:	1aad      	subs	r5, r5, r2

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 80066b4:	6821      	ldr	r1, [r4, #0]
 80066b6:	f103 021c 	add.w	r2, r3, #28
 80066ba:	604a      	str	r2, [r1, #4]
      ch.vtlist.next = vtp->next;
 80066bc:	6821      	ldr	r1, [r4, #0]
 80066be:	61d9      	str	r1, [r3, #28]
      fn = vtp->func;
 80066c0:	68e6      	ldr	r6, [r4, #12]
      vtp->func = NULL;
 80066c2:	2100      	movs	r1, #0
 80066c4:	60e1      	str	r1, [r4, #12]

      /* if the list becomes empty then the timer is stopped.*/
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 80066c6:	69db      	ldr	r3, [r3, #28]
 80066c8:	4293      	cmp	r3, r2
 80066ca:	d101      	bne.n	80066d0 <chSysTimerHandlerI+0x40>
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
 80066cc:	f7fc feb0 	bl	8003430 <stStopAlarm>
 80066d0:	2300      	movs	r3, #0
 80066d2:	f383 8811 	msr	BASEPRI, r3
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
 80066d6:	6920      	ldr	r0, [r4, #16]
 80066d8:	47b0      	blx	r6
 80066da:	2320      	movs	r3, #32
 80066dc:	f383 8811 	msr	BASEPRI, r3
      chSysLockFromISR();

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
 80066e0:	4b0d      	ldr	r3, [pc, #52]	; (8006718 <chSysTimerHandlerI+0x88>)
 80066e2:	69dc      	ldr	r4, [r3, #28]
    }
    while (vtp->delta <= nowdelta);
 80066e4:	68a3      	ldr	r3, [r4, #8]
 80066e6:	429d      	cmp	r5, r3
 80066e8:	d2dd      	bcs.n	80066a6 <chSysTimerHandlerI+0x16>
 80066ea:	e7d4      	b.n	8006696 <chSysTimerHandlerI+0x6>
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 80066ec:	490a      	ldr	r1, [pc, #40]	; (8006718 <chSysTimerHandlerI+0x88>)
 80066ee:	f851 2f1c 	ldr.w	r2, [r1, #28]!
 80066f2:	428a      	cmp	r2, r1
 80066f4:	d00e      	beq.n	8006714 <chSysTimerHandlerI+0x84>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
 80066f6:	4808      	ldr	r0, [pc, #32]	; (8006718 <chSysTimerHandlerI+0x88>)
 80066f8:	6283      	str	r3, [r0, #40]	; 0x28
  ch.vtlist.next->delta -= nowdelta;
 80066fa:	6891      	ldr	r1, [r2, #8]
 80066fc:	1b49      	subs	r1, r1, r5
 80066fe:	6091      	str	r1, [r2, #8]

  /* Recalculating the next alarm time.*/
  delta = chTimeDiffX(now, chTimeAddX(ch.vtlist.lasttime, vtp->delta));
 8006700:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8006702:	68a2      	ldr	r2, [r4, #8]
  return systime + (systime_t)interval;
 8006704:	4410      	add	r0, r2
  return (sysinterval_t)((systime_t)(end - start));
 8006706:	1ac0      	subs	r0, r0, r3
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8006708:	2801      	cmp	r0, #1
 800670a:	d800      	bhi.n	800670e <chSysTimerHandlerI+0x7e>
    delta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 800670c:	2002      	movs	r0, #2
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 800670e:	4418      	add	r0, r3
 8006710:	f7fc fe86 	bl	8003420 <stSetAlarm>
 8006714:	bd70      	pop	{r4, r5, r6, pc}
 8006716:	bf00      	nop
 8006718:	20003aec 	.word	0x20003aec
 800671c:	40000c00 	.word	0x40000c00

08006720 <set_error>:
static void set_error(SerialDriver *sdp, uint16_t sr) {
 8006720:	b508      	push	{r3, lr}
 8006722:	460b      	mov	r3, r1
  if (sr & USART_SR_ORE)
 8006724:	f001 0208 	and.w	r2, r1, #8
 8006728:	b292      	uxth	r2, r2
 800672a:	b90a      	cbnz	r2, 8006730 <set_error+0x10>
  eventflags_t sts = 0;
 800672c:	2100      	movs	r1, #0
 800672e:	e000      	b.n	8006732 <set_error+0x12>
    sts |= SD_OVERRUN_ERROR;
 8006730:	2180      	movs	r1, #128	; 0x80
  if (sr & USART_SR_PE)
 8006732:	f013 0f01 	tst.w	r3, #1
 8006736:	d001      	beq.n	800673c <set_error+0x1c>
    sts |= SD_PARITY_ERROR;
 8006738:	f041 0120 	orr.w	r1, r1, #32
  if (sr & USART_SR_FE)
 800673c:	f003 0202 	and.w	r2, r3, #2
 8006740:	b292      	uxth	r2, r2
 8006742:	b10a      	cbz	r2, 8006748 <set_error+0x28>
    sts |= SD_FRAMING_ERROR;
 8006744:	f041 0140 	orr.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 8006748:	f003 0304 	and.w	r3, r3, #4
 800674c:	b29b      	uxth	r3, r3
 800674e:	b10b      	cbz	r3, 8006754 <set_error+0x34>
    sts |= SD_NOISE_ERROR;
 8006750:	f441 7180 	orr.w	r1, r1, #256	; 0x100
  chEvtBroadcastFlagsI(esp, flags);
 8006754:	3004      	adds	r0, #4
 8006756:	f004 fcbb 	bl	800b0d0 <chEvtBroadcastFlagsI>
 800675a:	bd08      	pop	{r3, pc}
 800675c:	0000      	movs	r0, r0
	...

08006760 <serve_interrupt>:
static void serve_interrupt(SerialDriver *sdp) {
 8006760:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006762:	4606      	mov	r6, r0
  USART_TypeDef *u = sdp->usart;
 8006764:	6f45      	ldr	r5, [r0, #116]	; 0x74
  uint16_t cr1 = u->CR1;
 8006766:	68ef      	ldr	r7, [r5, #12]
  uint16_t sr = u->SR;
 8006768:	682b      	ldr	r3, [r5, #0]
 800676a:	b29c      	uxth	r4, r3
  if (sr & USART_SR_LBD) {
 800676c:	f413 7f80 	tst.w	r3, #256	; 0x100
 8006770:	d00d      	beq.n	800678e <serve_interrupt+0x2e>
 8006772:	2320      	movs	r3, #32
 8006774:	f383 8811 	msr	BASEPRI, r3
 8006778:	f44f 7100 	mov.w	r1, #512	; 0x200
 800677c:	3004      	adds	r0, #4
 800677e:	f004 fca7 	bl	800b0d0 <chEvtBroadcastFlagsI>
    u->SR = ~USART_SR_LBD;
 8006782:	f46f 7380 	mvn.w	r3, #256	; 0x100
 8006786:	602b      	str	r3, [r5, #0]
 8006788:	2300      	movs	r3, #0
 800678a:	f383 8811 	msr	BASEPRI, r3
 800678e:	2320      	movs	r3, #32
 8006790:	f383 8811 	msr	BASEPRI, r3
 8006794:	e013      	b.n	80067be <serve_interrupt+0x5e>
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 8006796:	f014 0f0f 	tst.w	r4, #15
 800679a:	d003      	beq.n	80067a4 <serve_interrupt+0x44>
      set_error(sdp, sr);
 800679c:	4621      	mov	r1, r4
 800679e:	4630      	mov	r0, r6
 80067a0:	f7ff ffbe 	bl	8006720 <set_error>
    b = (uint8_t)u->DR & sdp->rxmask;
 80067a4:	6869      	ldr	r1, [r5, #4]
 80067a6:	f896 3078 	ldrb.w	r3, [r6, #120]	; 0x78
 80067aa:	4019      	ands	r1, r3
    if (sr & USART_SR_RXNE)
 80067ac:	f004 0420 	and.w	r4, r4, #32
 80067b0:	b2a4      	uxth	r4, r4
 80067b2:	b114      	cbz	r4, 80067ba <serve_interrupt+0x5a>
      sdIncomingDataI(sdp, b);
 80067b4:	4630      	mov	r0, r6
 80067b6:	f7fc fd7b 	bl	80032b0 <sdIncomingDataI>
    sr = u->SR;
 80067ba:	682c      	ldr	r4, [r5, #0]
 80067bc:	b2a4      	uxth	r4, r4
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80067be:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 80067c2:	d1e8      	bne.n	8006796 <serve_interrupt+0x36>
 80067c4:	2300      	movs	r3, #0
 80067c6:	f383 8811 	msr	BASEPRI, r3
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 80067ca:	f017 0f80 	tst.w	r7, #128	; 0x80
 80067ce:	d019      	beq.n	8006804 <serve_interrupt+0xa4>
 80067d0:	f004 0380 	and.w	r3, r4, #128	; 0x80
 80067d4:	b29b      	uxth	r3, r3
 80067d6:	b1ab      	cbz	r3, 8006804 <serve_interrupt+0xa4>
 80067d8:	2320      	movs	r3, #32
 80067da:	f383 8811 	msr	BASEPRI, r3
    b = oqGetI(&sdp->oqueue);
 80067de:	f106 0030 	add.w	r0, r6, #48	; 0x30
 80067e2:	f7fc fddd 	bl	80033a0 <oqGetI>
    if (b < MSG_OK) {
 80067e6:	2800      	cmp	r0, #0
 80067e8:	da08      	bge.n	80067fc <serve_interrupt+0x9c>
 80067ea:	2108      	movs	r1, #8
 80067ec:	1d30      	adds	r0, r6, #4
 80067ee:	f004 fc6f 	bl	800b0d0 <chEvtBroadcastFlagsI>
      u->CR1 = cr1 & ~USART_CR1_TXEIE;
 80067f2:	f64f 737f 	movw	r3, #65407	; 0xff7f
 80067f6:	403b      	ands	r3, r7
 80067f8:	60eb      	str	r3, [r5, #12]
 80067fa:	e000      	b.n	80067fe <serve_interrupt+0x9e>
      u->DR = b;
 80067fc:	6068      	str	r0, [r5, #4]
 80067fe:	2300      	movs	r3, #0
 8006800:	f383 8811 	msr	BASEPRI, r3
  if ((cr1 & USART_CR1_TCIE) && (sr & USART_SR_TC)) {
 8006804:	f017 0f40 	tst.w	r7, #64	; 0x40
 8006808:	d01d      	beq.n	8006846 <serve_interrupt+0xe6>
 800680a:	f004 0440 	and.w	r4, r4, #64	; 0x40
 800680e:	b2a4      	uxth	r4, r4
 8006810:	b1cc      	cbz	r4, 8006846 <serve_interrupt+0xe6>
 8006812:	2320      	movs	r3, #32
 8006814:	f383 8811 	msr	BASEPRI, r3
    if (oqIsEmptyI(&sdp->oqueue)) {
 8006818:	6c72      	ldr	r2, [r6, #68]	; 0x44
 800681a:	6cb3      	ldr	r3, [r6, #72]	; 0x48
 800681c:	429a      	cmp	r2, r3
 800681e:	d102      	bne.n	8006826 <serve_interrupt+0xc6>
 8006820:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 8006822:	b913      	cbnz	r3, 800682a <serve_interrupt+0xca>
 8006824:	e002      	b.n	800682c <serve_interrupt+0xcc>
 8006826:	2300      	movs	r3, #0
 8006828:	e000      	b.n	800682c <serve_interrupt+0xcc>
 800682a:	2301      	movs	r3, #1
 800682c:	b143      	cbz	r3, 8006840 <serve_interrupt+0xe0>
 800682e:	2110      	movs	r1, #16
 8006830:	1d30      	adds	r0, r6, #4
 8006832:	f004 fc4d 	bl	800b0d0 <chEvtBroadcastFlagsI>
      u->CR1 = cr1 & ~USART_CR1_TCIE;
 8006836:	f027 0740 	bic.w	r7, r7, #64	; 0x40
 800683a:	043f      	lsls	r7, r7, #16
 800683c:	0c3f      	lsrs	r7, r7, #16
 800683e:	60ef      	str	r7, [r5, #12]
 8006840:	2300      	movs	r3, #0
 8006842:	f383 8811 	msr	BASEPRI, r3
 8006846:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08006850 <chSchReadyAheadI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8006850:	2300      	movs	r3, #0
 8006852:	f880 3020 	strb.w	r3, [r0, #32]
  cp = (thread_t *)&ch.rlist.queue;
 8006856:	4b06      	ldr	r3, [pc, #24]	; (8006870 <chSchReadyAheadI+0x20>)
  do {
    cp = cp->queue.next;
 8006858:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
 800685a:	6899      	ldr	r1, [r3, #8]
 800685c:	6882      	ldr	r2, [r0, #8]
 800685e:	4291      	cmp	r1, r2
 8006860:	d8fa      	bhi.n	8006858 <chSchReadyAheadI+0x8>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8006862:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8006864:	685a      	ldr	r2, [r3, #4]
 8006866:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8006868:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 800686a:	6058      	str	r0, [r3, #4]

  return tp;
}
 800686c:	4770      	bx	lr
 800686e:	bf00      	nop
 8006870:	20003aec 	.word	0x20003aec
	...

08006880 <chSchReadyI>:
  tp->state = CH_STATE_READY;
 8006880:	2300      	movs	r3, #0
 8006882:	f880 3020 	strb.w	r3, [r0, #32]
  cp = (thread_t *)&ch.rlist.queue;
 8006886:	4b06      	ldr	r3, [pc, #24]	; (80068a0 <chSchReadyI+0x20>)
    cp = cp->queue.next;
 8006888:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 800688a:	6899      	ldr	r1, [r3, #8]
 800688c:	6882      	ldr	r2, [r0, #8]
 800688e:	4291      	cmp	r1, r2
 8006890:	d2fa      	bcs.n	8006888 <chSchReadyI+0x8>
  tp->queue.next             = cp;
 8006892:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8006894:	685a      	ldr	r2, [r3, #4]
 8006896:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8006898:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 800689a:	6058      	str	r0, [r3, #4]
}
 800689c:	4770      	bx	lr
 800689e:	bf00      	nop
 80068a0:	20003aec 	.word	0x20003aec
	...

080068b0 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 80068b0:	b508      	push	{r3, lr}
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 80068b2:	4b1c      	ldr	r3, [pc, #112]	; (8006924 <chVTDoResetI+0x74>)
 80068b4:	69db      	ldr	r3, [r3, #28]
 80068b6:	4283      	cmp	r3, r0
 80068b8:	d010      	beq.n	80068dc <chVTDoResetI+0x2c>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 80068ba:	6843      	ldr	r3, [r0, #4]
 80068bc:	6802      	ldr	r2, [r0, #0]
 80068be:	601a      	str	r2, [r3, #0]
    vtp->next->prev = vtp->prev;
 80068c0:	6803      	ldr	r3, [r0, #0]
 80068c2:	6842      	ldr	r2, [r0, #4]
 80068c4:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 80068c6:	2300      	movs	r3, #0
 80068c8:	60c3      	str	r3, [r0, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 80068ca:	6803      	ldr	r3, [r0, #0]
 80068cc:	4a16      	ldr	r2, [pc, #88]	; (8006928 <chVTDoResetI+0x78>)
 80068ce:	4293      	cmp	r3, r2
 80068d0:	d026      	beq.n	8006920 <chVTDoResetI+0x70>
      vtp->next->delta += vtp->delta;
 80068d2:	6882      	ldr	r2, [r0, #8]
 80068d4:	6899      	ldr	r1, [r3, #8]
 80068d6:	440a      	add	r2, r1
 80068d8:	609a      	str	r2, [r3, #8]
 80068da:	bd08      	pop	{r3, pc}

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 80068dc:	6801      	ldr	r1, [r0, #0]
 80068de:	4a11      	ldr	r2, [pc, #68]	; (8006924 <chVTDoResetI+0x74>)
 80068e0:	4613      	mov	r3, r2
 80068e2:	f843 1f1c 	str.w	r1, [r3, #28]!
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 80068e6:	604b      	str	r3, [r1, #4]
  vtp->func = NULL;
 80068e8:	2100      	movs	r1, #0
 80068ea:	60c1      	str	r1, [r0, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80068ec:	69d2      	ldr	r2, [r2, #28]
 80068ee:	429a      	cmp	r2, r3
 80068f0:	d102      	bne.n	80068f8 <chVTDoResetI+0x48>
  stStopAlarm();
 80068f2:	f7fc fd9d 	bl	8003430 <stStopAlarm>
 80068f6:	bd08      	pop	{r3, pc}

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 80068f8:	6883      	ldr	r3, [r0, #8]
 80068fa:	6891      	ldr	r1, [r2, #8]
 80068fc:	440b      	add	r3, r1
 80068fe:	6093      	str	r3, [r2, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 8006900:	4a08      	ldr	r2, [pc, #32]	; (8006924 <chVTDoResetI+0x74>)
 8006902:	6a90      	ldr	r0, [r2, #40]	; 0x28
 8006904:	4b09      	ldr	r3, [pc, #36]	; (800692c <chVTDoResetI+0x7c>)
 8006906:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006908:	1a1b      	subs	r3, r3, r0

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 800690a:	69d2      	ldr	r2, [r2, #28]
 800690c:	6892      	ldr	r2, [r2, #8]
 800690e:	4293      	cmp	r3, r2
 8006910:	d206      	bcs.n	8006920 <chVTDoResetI+0x70>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8006912:	1ad1      	subs	r1, r2, r3

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8006914:	2901      	cmp	r1, #1
 8006916:	d800      	bhi.n	800691a <chVTDoResetI+0x6a>
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8006918:	1c9a      	adds	r2, r3, #2
  stSetAlarm(time);
 800691a:	4410      	add	r0, r2
 800691c:	f7fc fd80 	bl	8003420 <stSetAlarm>
 8006920:	bd08      	pop	{r3, pc}
 8006922:	bf00      	nop
 8006924:	20003aec 	.word	0x20003aec
 8006928:	20003b08 	.word	0x20003b08
 800692c:	40000c00 	.word	0x40000c00

08006930 <chVTDoSetI>:
                vtfunc_t vtfunc, void *par) {
 8006930:	b570      	push	{r4, r5, r6, lr}
 8006932:	4606      	mov	r6, r0
  vtp->par = par;
 8006934:	6103      	str	r3, [r0, #16]
  vtp->func = vtfunc;
 8006936:	60c2      	str	r2, [r0, #12]
 8006938:	4b1d      	ldr	r3, [pc, #116]	; (80069b0 <chVTDoSetI+0x80>)
 800693a:	6a5c      	ldr	r4, [r3, #36]	; 0x24
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 800693c:	2901      	cmp	r1, #1
 800693e:	d800      	bhi.n	8006942 <chVTDoSetI+0x12>
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8006940:	2102      	movs	r1, #2
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8006942:	4b1c      	ldr	r3, [pc, #112]	; (80069b4 <chVTDoSetI+0x84>)
 8006944:	f853 5f1c 	ldr.w	r5, [r3, #28]!
 8006948:	429d      	cmp	r5, r3
 800694a:	d10d      	bne.n	8006968 <chVTDoSetI+0x38>
      ch.vtlist.lasttime = now;
 800694c:	4b19      	ldr	r3, [pc, #100]	; (80069b4 <chVTDoSetI+0x84>)
 800694e:	629c      	str	r4, [r3, #40]	; 0x28
      ch.vtlist.next = vtp;
 8006950:	61de      	str	r6, [r3, #28]
      ch.vtlist.prev = vtp;
 8006952:	621e      	str	r6, [r3, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8006954:	f103 021c 	add.w	r2, r3, #28
 8006958:	6032      	str	r2, [r6, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 800695a:	6072      	str	r2, [r6, #4]
      vtp->delta = delay;
 800695c:	60b1      	str	r1, [r6, #8]
      port_timer_start_alarm(chTimeAddX(ch.vtlist.lasttime, delay));
 800695e:	6a98      	ldr	r0, [r3, #40]	; 0x28
  stStartAlarm(time);
 8006960:	4408      	add	r0, r1
 8006962:	f7fc fd6d 	bl	8003440 <stStartAlarm>
 8006966:	bd70      	pop	{r4, r5, r6, pc}
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 8006968:	4b12      	ldr	r3, [pc, #72]	; (80069b4 <chVTDoSetI+0x84>)
 800696a:	6a98      	ldr	r0, [r3, #40]	; 0x28
 800696c:	1a24      	subs	r4, r4, r0
    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 800696e:	190c      	adds	r4, r1, r4
 8006970:	d303      	bcc.n	800697a <chVTDoSetI+0x4a>
      delta -= p->delta;
 8006972:	68ab      	ldr	r3, [r5, #8]
 8006974:	1ae4      	subs	r4, r4, r3
      p = p->next;
 8006976:	682d      	ldr	r5, [r5, #0]
 8006978:	e008      	b.n	800698c <chVTDoSetI+0x5c>
    else if (delta < p->delta) {
 800697a:	68ab      	ldr	r3, [r5, #8]
 800697c:	429c      	cmp	r4, r3
 800697e:	d205      	bcs.n	800698c <chVTDoSetI+0x5c>
  stSetAlarm(time);
 8006980:	4420      	add	r0, r4
 8006982:	f7fc fd4d 	bl	8003420 <stSetAlarm>
 8006986:	e001      	b.n	800698c <chVTDoSetI+0x5c>
    delta -= p->delta;
 8006988:	1ae4      	subs	r4, r4, r3
    p = p->next;
 800698a:	682d      	ldr	r5, [r5, #0]
  while (p->delta < delta) {
 800698c:	68ab      	ldr	r3, [r5, #8]
 800698e:	429c      	cmp	r4, r3
 8006990:	d8fa      	bhi.n	8006988 <chVTDoSetI+0x58>
  vtp->next = p;
 8006992:	6035      	str	r5, [r6, #0]
  vtp->prev = vtp->next->prev;
 8006994:	686b      	ldr	r3, [r5, #4]
 8006996:	6073      	str	r3, [r6, #4]
  vtp->prev->next = vtp;
 8006998:	601e      	str	r6, [r3, #0]
  p->prev = vtp;
 800699a:	606e      	str	r6, [r5, #4]
  vtp->delta = delta;
 800699c:	60b4      	str	r4, [r6, #8]
  p->delta -= delta;
 800699e:	68a9      	ldr	r1, [r5, #8]
 80069a0:	1b09      	subs	r1, r1, r4
 80069a2:	60a9      	str	r1, [r5, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 80069a4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80069a8:	4b02      	ldr	r3, [pc, #8]	; (80069b4 <chVTDoSetI+0x84>)
 80069aa:	625a      	str	r2, [r3, #36]	; 0x24
 80069ac:	bd70      	pop	{r4, r5, r6, pc}
 80069ae:	bf00      	nop
 80069b0:	40000c00 	.word	0x40000c00
 80069b4:	20003aec 	.word	0x20003aec
	...

080069c0 <chSysPolledDelayX>:
 *
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
void chSysPolledDelayX(rtcnt_t cycles) {
 80069c0:	b538      	push	{r3, r4, r5, lr}
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80069c2:	4b06      	ldr	r3, [pc, #24]	; (80069dc <chSysPolledDelayX+0x1c>)
 80069c4:	685c      	ldr	r4, [r3, #4]
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;
 80069c6:	1905      	adds	r5, r0, r4
 80069c8:	4b04      	ldr	r3, [pc, #16]	; (80069dc <chSysPolledDelayX+0x1c>)
 80069ca:	6858      	ldr	r0, [r3, #4]

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 80069cc:	462a      	mov	r2, r5
 80069ce:	4621      	mov	r1, r4
 80069d0:	f7ff fd5e 	bl	8006490 <chSysIsCounterWithinX>
 80069d4:	2800      	cmp	r0, #0
 80069d6:	d1f7      	bne.n	80069c8 <chSysPolledDelayX+0x8>
  }
}
 80069d8:	bd38      	pop	{r3, r4, r5, pc}
 80069da:	bf00      	nop
 80069dc:	e0001000 	.word	0xe0001000

080069e0 <chSysRestoreStatusX>:
  if (port_irq_enabled(sts)) {
 80069e0:	b978      	cbnz	r0, 8006a02 <chSysRestoreStatusX+0x22>
void chSysRestoreStatusX(syssts_t sts) {
 80069e2:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80069e4:	f3ef 8305 	mrs	r3, IPSR
  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 80069e8:	f3c3 0308 	ubfx	r3, r3, #0, #9
    if (port_is_isr_context()) {
 80069ec:	b11b      	cbz	r3, 80069f6 <chSysRestoreStatusX+0x16>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80069ee:	2300      	movs	r3, #0
 80069f0:	f383 8811 	msr	BASEPRI, r3
 80069f4:	bd08      	pop	{r3, pc}
      chSchRescheduleS();
 80069f6:	f004 fd93 	bl	800b520 <chSchRescheduleS>
 80069fa:	2300      	movs	r3, #0
 80069fc:	f383 8811 	msr	BASEPRI, r3
 8006a00:	bd08      	pop	{r3, pc}
 8006a02:	4770      	bx	lr
	...

08006a10 <chSysGetStatusAndLockX>:
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8006a10:	f3ef 8011 	mrs	r0, BASEPRI
  if (port_irq_enabled(sts)) {
 8006a14:	b958      	cbnz	r0, 8006a2e <chSysGetStatusAndLockX+0x1e>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8006a16:	f3ef 8305 	mrs	r3, IPSR
 8006a1a:	f3c3 0308 	ubfx	r3, r3, #0, #9
    if (port_is_isr_context()) {
 8006a1e:	b11b      	cbz	r3, 8006a28 <chSysGetStatusAndLockX+0x18>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8006a20:	2320      	movs	r3, #32
 8006a22:	f383 8811 	msr	BASEPRI, r3
 8006a26:	4770      	bx	lr
 8006a28:	2320      	movs	r3, #32
 8006a2a:	f383 8811 	msr	BASEPRI, r3
}
 8006a2e:	4770      	bx	lr

08006a30 <chSysIntegrityCheckI>:
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 8006a30:	f010 0f01 	tst.w	r0, #1
 8006a34:	d010      	beq.n	8006a58 <chSysIntegrityCheckI+0x28>
    tp = ch.rlist.queue.next;
 8006a36:	4b22      	ldr	r3, [pc, #136]	; (8006ac0 <chSysIntegrityCheckI+0x90>)
 8006a38:	681a      	ldr	r2, [r3, #0]
    n = (cnt_t)0;
 8006a3a:	2300      	movs	r3, #0
 8006a3c:	e001      	b.n	8006a42 <chSysIntegrityCheckI+0x12>
      n++;
 8006a3e:	3301      	adds	r3, #1
      tp = tp->queue.next;
 8006a40:	6812      	ldr	r2, [r2, #0]
    while (tp != (thread_t *)&ch.rlist.queue) {
 8006a42:	491f      	ldr	r1, [pc, #124]	; (8006ac0 <chSysIntegrityCheckI+0x90>)
 8006a44:	428a      	cmp	r2, r1
 8006a46:	d1fa      	bne.n	8006a3e <chSysIntegrityCheckI+0xe>
    tp = ch.rlist.queue.prev;
 8006a48:	684a      	ldr	r2, [r1, #4]
 8006a4a:	e001      	b.n	8006a50 <chSysIntegrityCheckI+0x20>
      n--;
 8006a4c:	3b01      	subs	r3, #1
      tp = tp->queue.prev;
 8006a4e:	6852      	ldr	r2, [r2, #4]
    while (tp != (thread_t *)&ch.rlist.queue) {
 8006a50:	491b      	ldr	r1, [pc, #108]	; (8006ac0 <chSysIntegrityCheckI+0x90>)
 8006a52:	428a      	cmp	r2, r1
 8006a54:	d1fa      	bne.n	8006a4c <chSysIntegrityCheckI+0x1c>
    if (n != (cnt_t)0) {
 8006a56:	bb5b      	cbnz	r3, 8006ab0 <chSysIntegrityCheckI+0x80>
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 8006a58:	f010 0f02 	tst.w	r0, #2
 8006a5c:	d012      	beq.n	8006a84 <chSysIntegrityCheckI+0x54>
    vtp = ch.vtlist.next;
 8006a5e:	4b18      	ldr	r3, [pc, #96]	; (8006ac0 <chSysIntegrityCheckI+0x90>)
 8006a60:	69da      	ldr	r2, [r3, #28]
    n = (cnt_t)0;
 8006a62:	2300      	movs	r3, #0
 8006a64:	e001      	b.n	8006a6a <chSysIntegrityCheckI+0x3a>
      n++;
 8006a66:	3301      	adds	r3, #1
      vtp = vtp->next;
 8006a68:	6812      	ldr	r2, [r2, #0]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8006a6a:	4916      	ldr	r1, [pc, #88]	; (8006ac4 <chSysIntegrityCheckI+0x94>)
 8006a6c:	428a      	cmp	r2, r1
 8006a6e:	d1fa      	bne.n	8006a66 <chSysIntegrityCheckI+0x36>
    vtp = ch.vtlist.prev;
 8006a70:	f1a1 021c 	sub.w	r2, r1, #28
 8006a74:	6a12      	ldr	r2, [r2, #32]
 8006a76:	e001      	b.n	8006a7c <chSysIntegrityCheckI+0x4c>
      n--;
 8006a78:	3b01      	subs	r3, #1
      vtp = vtp->prev;
 8006a7a:	6852      	ldr	r2, [r2, #4]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8006a7c:	4911      	ldr	r1, [pc, #68]	; (8006ac4 <chSysIntegrityCheckI+0x94>)
 8006a7e:	428a      	cmp	r2, r1
 8006a80:	d1fa      	bne.n	8006a78 <chSysIntegrityCheckI+0x48>
    if (n != (cnt_t)0) {
 8006a82:	b9bb      	cbnz	r3, 8006ab4 <chSysIntegrityCheckI+0x84>
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 8006a84:	f010 0f04 	tst.w	r0, #4
 8006a88:	d016      	beq.n	8006ab8 <chSysIntegrityCheckI+0x88>
    tp = ch.rlist.newer;
 8006a8a:	4b0d      	ldr	r3, [pc, #52]	; (8006ac0 <chSysIntegrityCheckI+0x90>)
 8006a8c:	691a      	ldr	r2, [r3, #16]
    n = (cnt_t)0;
 8006a8e:	2300      	movs	r3, #0
 8006a90:	e001      	b.n	8006a96 <chSysIntegrityCheckI+0x66>
      n++;
 8006a92:	3301      	adds	r3, #1
      tp = tp->newer;
 8006a94:	6912      	ldr	r2, [r2, #16]
    while (tp != (thread_t *)&ch.rlist) {
 8006a96:	490a      	ldr	r1, [pc, #40]	; (8006ac0 <chSysIntegrityCheckI+0x90>)
 8006a98:	428a      	cmp	r2, r1
 8006a9a:	d1fa      	bne.n	8006a92 <chSysIntegrityCheckI+0x62>
    tp = ch.rlist.older;
 8006a9c:	694a      	ldr	r2, [r1, #20]
 8006a9e:	e001      	b.n	8006aa4 <chSysIntegrityCheckI+0x74>
      n--;
 8006aa0:	3b01      	subs	r3, #1
      tp = tp->older;
 8006aa2:	6952      	ldr	r2, [r2, #20]
    while (tp != (thread_t *)&ch.rlist) {
 8006aa4:	4906      	ldr	r1, [pc, #24]	; (8006ac0 <chSysIntegrityCheckI+0x90>)
 8006aa6:	428a      	cmp	r2, r1
 8006aa8:	d1fa      	bne.n	8006aa0 <chSysIntegrityCheckI+0x70>
    if (n != (cnt_t)0) {
 8006aaa:	b93b      	cbnz	r3, 8006abc <chSysIntegrityCheckI+0x8c>
  return false;
 8006aac:	2000      	movs	r0, #0
 8006aae:	4770      	bx	lr
      return true;
 8006ab0:	2001      	movs	r0, #1
 8006ab2:	4770      	bx	lr
      return true;
 8006ab4:	2001      	movs	r0, #1
 8006ab6:	4770      	bx	lr
  return false;
 8006ab8:	2000      	movs	r0, #0
 8006aba:	4770      	bx	lr
      return true;
 8006abc:	2001      	movs	r0, #1
}
 8006abe:	4770      	bx	lr
 8006ac0:	20003aec 	.word	0x20003aec
 8006ac4:	20003b08 	.word	0x20003b08
	...

08006ad0 <chSysHalt>:
  __ASM volatile ("cpsid i" : : : "memory");
 8006ad0:	b672      	cpsid	i
  ch.dbg.panic_msg = reason;
 8006ad2:	4b01      	ldr	r3, [pc, #4]	; (8006ad8 <chSysHalt+0x8>)
 8006ad4:	62d8      	str	r0, [r3, #44]	; 0x2c
 8006ad6:	e7fe      	b.n	8006ad6 <chSysHalt+0x6>
 8006ad8:	20003aec 	.word	0x20003aec
 8006adc:	00000000 	.word	0x00000000

08006ae0 <chSysInit>:
void chSysInit(void) {
 8006ae0:	b510      	push	{r4, lr}
  _scheduler_init();
 8006ae2:	f7ff fcb5 	bl	8006450 <_scheduler_init>
  _vt_init();
 8006ae6:	f7ff fcc3 	bl	8006470 <_vt_init>
  _tm_init();
 8006aea:	f004 fbf1 	bl	800b2d0 <_tm_init>
  _core_init();
 8006aee:	f003 f88f 	bl	8009c10 <_core_init>
  _heap_init();
 8006af2:	f003 f875 	bl	8009be0 <_heap_init>
  _factory_init();
 8006af6:	f002 fbfb 	bl	80092f0 <_factory_init>
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8006afa:	4c16      	ldr	r4, [pc, #88]	; (8006b54 <chSysInit+0x74>)
 8006afc:	2280      	movs	r2, #128	; 0x80
 8006afe:	4916      	ldr	r1, [pc, #88]	; (8006b58 <chSysInit+0x78>)
 8006b00:	4620      	mov	r0, r4
 8006b02:	f004 fc9d 	bl	800b440 <_thread_init>
 8006b06:	f844 0c18 	str.w	r0, [r4, #-24]
  currp->wabase = NULL;
 8006b0a:	2400      	movs	r4, #0
 8006b0c:	61c4      	str	r4, [r0, #28]
  currp->state = CH_STATE_CURRENT;
 8006b0e:	2301      	movs	r3, #1
 8006b10:	f880 3020 	strb.w	r3, [r0, #32]
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8006b14:	4b11      	ldr	r3, [pc, #68]	; (8006b5c <chSysInit+0x7c>)
 8006b16:	68d9      	ldr	r1, [r3, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8006b18:	f421 61e0 	bic.w	r1, r1, #1792	; 0x700
 8006b1c:	0409      	lsls	r1, r1, #16
 8006b1e:	0c09      	lsrs	r1, r1, #16
  reg_value  =  (reg_value                                   |
 8006b20:	4a0f      	ldr	r2, [pc, #60]	; (8006b60 <chSysInit+0x80>)
 8006b22:	430a      	orrs	r2, r1
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
  SCB->AIRCR =  reg_value;
 8006b24:	60da      	str	r2, [r3, #12]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8006b26:	490f      	ldr	r1, [pc, #60]	; (8006b64 <chSysInit+0x84>)
 8006b28:	68ca      	ldr	r2, [r1, #12]
 8006b2a:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8006b2e:	60ca      	str	r2, [r1, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8006b30:	490d      	ldr	r1, [pc, #52]	; (8006b68 <chSysInit+0x88>)
 8006b32:	680a      	ldr	r2, [r1, #0]
 8006b34:	f042 0201 	orr.w	r2, r2, #1
 8006b38:	600a      	str	r2, [r1, #0]
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8006b3a:	2210      	movs	r2, #16
 8006b3c:	77da      	strb	r2, [r3, #31]
 8006b3e:	2220      	movs	r2, #32
 8006b40:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8006b44:	f384 8811 	msr	BASEPRI, r4
  __ASM volatile ("cpsie i" : : : "memory");
 8006b48:	b662      	cpsie	i
    (void) chThdCreate(&idle_descriptor);
 8006b4a:	4808      	ldr	r0, [pc, #32]	; (8006b6c <chSysInit+0x8c>)
 8006b4c:	f004 fe38 	bl	800b7c0 <chThdCreate>
 8006b50:	bd10      	pop	{r4, pc}
 8006b52:	bf00      	nop
 8006b54:	20003b1c 	.word	0x20003b1c
 8006b58:	0800e89c 	.word	0x0800e89c
 8006b5c:	e000ed00 	.word	0xe000ed00
 8006b60:	05fa0300 	.word	0x05fa0300
 8006b64:	e000edf0 	.word	0xe000edf0
 8006b68:	e0001000 	.word	0xe0001000
 8006b6c:	0800e9cc 	.word	0x0800e9cc

08006b70 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 8006b70:	b508      	push	{r3, lr}

  stm32_gpio_init();
 8006b72:	f7ff fcad 	bl	80064d0 <stm32_gpio_init>
  stm32_clock_init();
 8006b76:	f7ff f93b 	bl	8005df0 <stm32_clock_init>
 8006b7a:	bd08      	pop	{r3, pc}
 8006b7c:	0000      	movs	r0, r0
	...

08006b80 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8006b80:	b538      	push	{r3, r4, r5, lr}
 8006b82:	4604      	mov	r4, r0

  if (config == NULL)
 8006b84:	460d      	mov	r5, r1
 8006b86:	b901      	cbnz	r1, 8006b8a <sd_lld_start+0xa>
    config = &default_config;
 8006b88:	4d0c      	ldr	r5, [pc, #48]	; (8006bbc <sd_lld_start+0x3c>)

  if (sdp->state == SD_STOP) {
 8006b8a:	7a23      	ldrb	r3, [r4, #8]
 8006b8c:	2b01      	cmp	r3, #1
 8006b8e:	d110      	bne.n	8006bb2 <sd_lld_start+0x32>
      rccEnableUSART1(true);
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
 8006b90:	4b0b      	ldr	r3, [pc, #44]	; (8006bc0 <sd_lld_start+0x40>)
 8006b92:	429c      	cmp	r4, r3
 8006b94:	d10d      	bne.n	8006bb2 <sd_lld_start+0x32>
      rccEnableUSART2(true);
 8006b96:	4b0b      	ldr	r3, [pc, #44]	; (8006bc4 <sd_lld_start+0x44>)
 8006b98:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8006b9a:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8006b9e:	641a      	str	r2, [r3, #64]	; 0x40
 8006ba0:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8006ba2:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8006ba6:	661a      	str	r2, [r3, #96]	; 0x60
 8006ba8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
 8006baa:	210c      	movs	r1, #12
 8006bac:	2026      	movs	r0, #38	; 0x26
 8006bae:	f7ff f9cf 	bl	8005f50 <nvicEnableVector>
      rccEnableUART8(true);
      nvicEnableVector(STM32_UART8_NUMBER, STM32_SERIAL_UART8_PRIORITY);
    }
#endif
  }
  usart_init(sdp, config);
 8006bb2:	4629      	mov	r1, r5
 8006bb4:	4620      	mov	r0, r4
 8006bb6:	f7ff fceb 	bl	8006590 <usart_init>
 8006bba:	bd38      	pop	{r3, r4, r5, pc}
 8006bbc:	0800e994 	.word	0x0800e994
 8006bc0:	20003b80 	.word	0x20003b80
 8006bc4:	40023800 	.word	0x40023800
	...

08006bd0 <sd_lld_init>:
void sd_lld_init(void) {
 8006bd0:	b510      	push	{r4, lr}
  sdObjectInit(&SD2, NULL, notify2);
 8006bd2:	4c04      	ldr	r4, [pc, #16]	; (8006be4 <sd_lld_init+0x14>)
 8006bd4:	4a04      	ldr	r2, [pc, #16]	; (8006be8 <sd_lld_init+0x18>)
 8006bd6:	2100      	movs	r1, #0
 8006bd8:	4620      	mov	r0, r4
 8006bda:	f7fc fb91 	bl	8003300 <sdObjectInit>
  SD2.usart = USART2;
 8006bde:	4b03      	ldr	r3, [pc, #12]	; (8006bec <sd_lld_init+0x1c>)
 8006be0:	6763      	str	r3, [r4, #116]	; 0x74
 8006be2:	bd10      	pop	{r4, pc}
 8006be4:	20003b80 	.word	0x20003b80
 8006be8:	08006581 	.word	0x08006581
 8006bec:	40004400 	.word	0x40004400

08006bf0 <VectorD8>:
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8006bf0:	b508      	push	{r3, lr}
  serve_interrupt(&SD2);
 8006bf2:	4803      	ldr	r0, [pc, #12]	; (8006c00 <VectorD8+0x10>)
 8006bf4:	f7ff fdb4 	bl	8006760 <serve_interrupt>
  OSAL_IRQ_EPILOGUE();
 8006bf8:	f002 f94a 	bl	8008e90 <_port_irq_epilogue>
 8006bfc:	bd08      	pop	{r3, pc}
 8006bfe:	bf00      	nop
 8006c00:	20003b80 	.word	0x20003b80
	...

08006c10 <qei_lld_enable>:
 *
 * @notapi
 */
void qei_lld_enable(QEIDriver *qeip) {

  qeip->tim->CR1 = TIM_CR1_CEN;            /* Timer enabled. */
 8006c10:	6883      	ldr	r3, [r0, #8]
 8006c12:	2201      	movs	r2, #1
 8006c14:	601a      	str	r2, [r3, #0]
 8006c16:	4770      	bx	lr
	...

08006c20 <qei_lld_start>:
  if (qeip->state == QEI_STOP) {
 8006c20:	7803      	ldrb	r3, [r0, #0]
 8006c22:	2b01      	cmp	r3, #1
 8006c24:	d12b      	bne.n	8006c7e <qei_lld_start+0x5e>
    if (&QEID2 == qeip) {
 8006c26:	4b2e      	ldr	r3, [pc, #184]	; (8006ce0 <qei_lld_start+0xc0>)
 8006c28:	4298      	cmp	r0, r3
 8006c2a:	d112      	bne.n	8006c52 <qei_lld_start+0x32>
      rccEnableTIM2(FALSE);
 8006c2c:	4b2d      	ldr	r3, [pc, #180]	; (8006ce4 <qei_lld_start+0xc4>)
 8006c2e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8006c30:	f042 0201 	orr.w	r2, r2, #1
 8006c34:	641a      	str	r2, [r3, #64]	; 0x40
 8006c36:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8006c38:	f022 0201 	bic.w	r2, r2, #1
 8006c3c:	661a      	str	r2, [r3, #96]	; 0x60
 8006c3e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
      rccResetTIM2();
 8006c40:	6a1a      	ldr	r2, [r3, #32]
 8006c42:	f042 0201 	orr.w	r2, r2, #1
 8006c46:	621a      	str	r2, [r3, #32]
 8006c48:	6a1a      	ldr	r2, [r3, #32]
 8006c4a:	f022 0201 	bic.w	r2, r2, #1
 8006c4e:	621a      	str	r2, [r3, #32]
 8006c50:	6a1b      	ldr	r3, [r3, #32]
    if (&QEID3 == qeip) {
 8006c52:	4b25      	ldr	r3, [pc, #148]	; (8006ce8 <qei_lld_start+0xc8>)
 8006c54:	4298      	cmp	r0, r3
 8006c56:	d112      	bne.n	8006c7e <qei_lld_start+0x5e>
      rccEnableTIM3(FALSE);
 8006c58:	4b22      	ldr	r3, [pc, #136]	; (8006ce4 <qei_lld_start+0xc4>)
 8006c5a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8006c5c:	f042 0202 	orr.w	r2, r2, #2
 8006c60:	641a      	str	r2, [r3, #64]	; 0x40
 8006c62:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8006c64:	f022 0202 	bic.w	r2, r2, #2
 8006c68:	661a      	str	r2, [r3, #96]	; 0x60
 8006c6a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
      rccResetTIM3();
 8006c6c:	6a1a      	ldr	r2, [r3, #32]
 8006c6e:	f042 0202 	orr.w	r2, r2, #2
 8006c72:	621a      	str	r2, [r3, #32]
 8006c74:	6a1a      	ldr	r2, [r3, #32]
 8006c76:	f022 0202 	bic.w	r2, r2, #2
 8006c7a:	621a      	str	r2, [r3, #32]
 8006c7c:	6a1b      	ldr	r3, [r3, #32]
  qeip->tim->CR1  = 0;                      /* Initially stopped. */
 8006c7e:	6882      	ldr	r2, [r0, #8]
 8006c80:	2300      	movs	r3, #0
 8006c82:	6013      	str	r3, [r2, #0]
  qeip->tim->CR2  = 0;
 8006c84:	6882      	ldr	r2, [r0, #8]
 8006c86:	6053      	str	r3, [r2, #4]
  qeip->tim->PSC  = 0;
 8006c88:	6882      	ldr	r2, [r0, #8]
 8006c8a:	6293      	str	r3, [r2, #40]	; 0x28
  qeip->tim->DIER = 0;
 8006c8c:	6882      	ldr	r2, [r0, #8]
 8006c8e:	60d3      	str	r3, [r2, #12]
  qeip->tim->ARR  = 0xFFFF;
 8006c90:	6883      	ldr	r3, [r0, #8]
 8006c92:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8006c96:	62da      	str	r2, [r3, #44]	; 0x2c
   qeip->tim->CCMR1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
 8006c98:	6882      	ldr	r2, [r0, #8]
 8006c9a:	6993      	ldr	r3, [r2, #24]
 8006c9c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8006ca0:	f043 0301 	orr.w	r3, r3, #1
 8006ca4:	6193      	str	r3, [r2, #24]
  if (qeip->config->mode == QEI_MODE_QUADRATURE) {
 8006ca6:	6843      	ldr	r3, [r0, #4]
 8006ca8:	781a      	ldrb	r2, [r3, #0]
 8006caa:	b952      	cbnz	r2, 8006cc2 <qei_lld_start+0xa2>
    if (qeip->config->resolution == QEI_BOTH_EDGES)
 8006cac:	785b      	ldrb	r3, [r3, #1]
 8006cae:	2b01      	cmp	r3, #1
 8006cb0:	d103      	bne.n	8006cba <qei_lld_start+0x9a>
      qeip->tim->SMCR = TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0;
 8006cb2:	6883      	ldr	r3, [r0, #8]
 8006cb4:	2203      	movs	r2, #3
 8006cb6:	609a      	str	r2, [r3, #8]
 8006cb8:	e006      	b.n	8006cc8 <qei_lld_start+0xa8>
      qeip->tim->SMCR = TIM_SMCR_SMS_0;
 8006cba:	6883      	ldr	r3, [r0, #8]
 8006cbc:	2201      	movs	r2, #1
 8006cbe:	609a      	str	r2, [r3, #8]
 8006cc0:	e002      	b.n	8006cc8 <qei_lld_start+0xa8>
    qeip->tim->SMCR = TIM_SMCR_SMS_0;
 8006cc2:	6883      	ldr	r3, [r0, #8]
 8006cc4:	2201      	movs	r2, #1
 8006cc6:	609a      	str	r2, [r3, #8]
  if (qeip->config->dirinv == QEI_DIRINV_TRUE)
 8006cc8:	6843      	ldr	r3, [r0, #4]
 8006cca:	789b      	ldrb	r3, [r3, #2]
 8006ccc:	2b01      	cmp	r3, #1
 8006cce:	d103      	bne.n	8006cd8 <qei_lld_start+0xb8>
    qeip->tim->CCER = TIM_CCER_CC1E | TIM_CCER_CC1P | TIM_CCER_CC2E;
 8006cd0:	6883      	ldr	r3, [r0, #8]
 8006cd2:	2213      	movs	r2, #19
 8006cd4:	621a      	str	r2, [r3, #32]
 8006cd6:	4770      	bx	lr
    qeip->tim->CCER = TIM_CCER_CC1E | TIM_CCER_CC2E;
 8006cd8:	6883      	ldr	r3, [r0, #8]
 8006cda:	2211      	movs	r2, #17
 8006cdc:	621a      	str	r2, [r3, #32]
 8006cde:	4770      	bx	lr
 8006ce0:	20003df8 	.word	0x20003df8
 8006ce4:	40023800 	.word	0x40023800
 8006ce8:	20003dec 	.word	0x20003dec
 8006cec:	00000000 	.word	0x00000000

08006cf0 <qei_lld_init>:
void qei_lld_init(void) {
 8006cf0:	b510      	push	{r4, lr}
  qeiObjectInit(&QEID2);
 8006cf2:	4c07      	ldr	r4, [pc, #28]	; (8006d10 <qei_lld_init+0x20>)
 8006cf4:	4620      	mov	r0, r4
 8006cf6:	f7ff fa23 	bl	8006140 <qeiObjectInit>
  QEID2.tim = STM32_TIM2;
 8006cfa:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006cfe:	60a3      	str	r3, [r4, #8]
  qeiObjectInit(&QEID3);
 8006d00:	4c04      	ldr	r4, [pc, #16]	; (8006d14 <qei_lld_init+0x24>)
 8006d02:	4620      	mov	r0, r4
 8006d04:	f7ff fa1c 	bl	8006140 <qeiObjectInit>
  QEID3.tim = STM32_TIM3;
 8006d08:	4b03      	ldr	r3, [pc, #12]	; (8006d18 <qei_lld_init+0x28>)
 8006d0a:	60a3      	str	r3, [r4, #8]
 8006d0c:	bd10      	pop	{r4, pc}
 8006d0e:	bf00      	nop
 8006d10:	20003df8 	.word	0x20003df8
 8006d14:	20003dec 	.word	0x20003dec
 8006d18:	40000400 	.word	0x40000400
 8006d1c:	00000000 	.word	0x00000000

08006d20 <pwm_lld_enable_channel>:
  pwmp->tim->CCR[channel] = width;
 8006d20:	6983      	ldr	r3, [r0, #24]
 8006d22:	310c      	adds	r1, #12
 8006d24:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8006d28:	605a      	str	r2, [r3, #4]
 8006d2a:	4770      	bx	lr
 8006d2c:	0000      	movs	r0, r0
	...

08006d30 <pwm_lld_start>:
void pwm_lld_start(PWMDriver *pwmp) {
 8006d30:	b510      	push	{r4, lr}
 8006d32:	4604      	mov	r4, r0
  if (pwmp->state == PWM_STOP) {
 8006d34:	7803      	ldrb	r3, [r0, #0]
 8006d36:	2b01      	cmp	r3, #1
 8006d38:	d142      	bne.n	8006dc0 <pwm_lld_start+0x90>
    if (&PWMD4 == pwmp) {
 8006d3a:	4b53      	ldr	r3, [pc, #332]	; (8006e88 <pwm_lld_start+0x158>)
 8006d3c:	4298      	cmp	r0, r3
 8006d3e:	d118      	bne.n	8006d72 <pwm_lld_start+0x42>
      rccEnableTIM4(true);
 8006d40:	4b52      	ldr	r3, [pc, #328]	; (8006e8c <pwm_lld_start+0x15c>)
 8006d42:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8006d44:	f042 0204 	orr.w	r2, r2, #4
 8006d48:	641a      	str	r2, [r3, #64]	; 0x40
 8006d4a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8006d4c:	f042 0204 	orr.w	r2, r2, #4
 8006d50:	661a      	str	r2, [r3, #96]	; 0x60
 8006d52:	6e1a      	ldr	r2, [r3, #96]	; 0x60
      rccResetTIM4();
 8006d54:	6a1a      	ldr	r2, [r3, #32]
 8006d56:	f042 0204 	orr.w	r2, r2, #4
 8006d5a:	621a      	str	r2, [r3, #32]
 8006d5c:	6a1a      	ldr	r2, [r3, #32]
 8006d5e:	f022 0204 	bic.w	r2, r2, #4
 8006d62:	621a      	str	r2, [r3, #32]
 8006d64:	6a1b      	ldr	r3, [r3, #32]
      nvicEnableVector(STM32_TIM4_NUMBER, STM32_PWM_TIM4_IRQ_PRIORITY);
 8006d66:	2107      	movs	r1, #7
 8006d68:	201e      	movs	r0, #30
 8006d6a:	f7ff f8f1 	bl	8005f50 <nvicEnableVector>
      pwmp->clock = STM32_TIMCLK1;
 8006d6e:	4b48      	ldr	r3, [pc, #288]	; (8006e90 <pwm_lld_start+0x160>)
 8006d70:	6163      	str	r3, [r4, #20]
    if (&PWMD8 == pwmp) {
 8006d72:	4b48      	ldr	r3, [pc, #288]	; (8006e94 <pwm_lld_start+0x164>)
 8006d74:	429c      	cmp	r4, r3
 8006d76:	d11c      	bne.n	8006db2 <pwm_lld_start+0x82>
      rccEnableTIM8(true);
 8006d78:	4b44      	ldr	r3, [pc, #272]	; (8006e8c <pwm_lld_start+0x15c>)
 8006d7a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8006d7c:	f042 0202 	orr.w	r2, r2, #2
 8006d80:	645a      	str	r2, [r3, #68]	; 0x44
 8006d82:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8006d84:	f042 0202 	orr.w	r2, r2, #2
 8006d88:	665a      	str	r2, [r3, #100]	; 0x64
 8006d8a:	6e5a      	ldr	r2, [r3, #100]	; 0x64
      rccResetTIM8();
 8006d8c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8006d8e:	f042 0202 	orr.w	r2, r2, #2
 8006d92:	625a      	str	r2, [r3, #36]	; 0x24
 8006d94:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8006d96:	f022 0202 	bic.w	r2, r2, #2
 8006d9a:	625a      	str	r2, [r3, #36]	; 0x24
 8006d9c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
      nvicEnableVector(STM32_TIM8_UP_NUMBER, STM32_PWM_TIM8_IRQ_PRIORITY);
 8006d9e:	2107      	movs	r1, #7
 8006da0:	202c      	movs	r0, #44	; 0x2c
 8006da2:	f7ff f8d5 	bl	8005f50 <nvicEnableVector>
      nvicEnableVector(STM32_TIM8_CC_NUMBER, STM32_PWM_TIM8_IRQ_PRIORITY);
 8006da6:	2107      	movs	r1, #7
 8006da8:	202e      	movs	r0, #46	; 0x2e
 8006daa:	f7ff f8d1 	bl	8005f50 <nvicEnableVector>
      pwmp->clock = STM32_TIMCLK2;
 8006dae:	4b3a      	ldr	r3, [pc, #232]	; (8006e98 <pwm_lld_start+0x168>)
 8006db0:	6163      	str	r3, [r4, #20]
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
 8006db2:	69a2      	ldr	r2, [r4, #24]
 8006db4:	f646 0368 	movw	r3, #26728	; 0x6868
 8006db8:	6193      	str	r3, [r2, #24]
    pwmp->tim->CCMR2 = STM32_TIM_CCMR2_OC3M(6) | STM32_TIM_CCMR2_OC3PE |
 8006dba:	69a2      	ldr	r2, [r4, #24]
 8006dbc:	61d3      	str	r3, [r2, #28]
 8006dbe:	e00c      	b.n	8006dda <pwm_lld_start+0xaa>
    pwmp->tim->CR1    = 0;                  /* Timer disabled.              */
 8006dc0:	6982      	ldr	r2, [r0, #24]
 8006dc2:	2300      	movs	r3, #0
 8006dc4:	6013      	str	r3, [r2, #0]
    pwmp->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
 8006dc6:	6982      	ldr	r2, [r0, #24]
 8006dc8:	6353      	str	r3, [r2, #52]	; 0x34
    pwmp->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
 8006dca:	6982      	ldr	r2, [r0, #24]
 8006dcc:	6393      	str	r3, [r2, #56]	; 0x38
    pwmp->tim->CCR[2] = 0;                  /* Comparator 3 disabled.       */
 8006dce:	6982      	ldr	r2, [r0, #24]
 8006dd0:	63d3      	str	r3, [r2, #60]	; 0x3c
    pwmp->tim->CCR[3] = 0;                  /* Comparator 4 disabled.       */
 8006dd2:	6982      	ldr	r2, [r0, #24]
 8006dd4:	6413      	str	r3, [r2, #64]	; 0x40
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
 8006dd6:	6982      	ldr	r2, [r0, #24]
 8006dd8:	6253      	str	r3, [r2, #36]	; 0x24
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 8006dda:	6963      	ldr	r3, [r4, #20]
 8006ddc:	6862      	ldr	r2, [r4, #4]
 8006dde:	6812      	ldr	r2, [r2, #0]
 8006de0:	fbb3 f3f2 	udiv	r3, r3, r2
 8006de4:	3b01      	subs	r3, #1
  pwmp->tim->PSC  = psc;
 8006de6:	69a2      	ldr	r2, [r4, #24]
 8006de8:	6293      	str	r3, [r2, #40]	; 0x28
  pwmp->tim->ARR  = pwmp->period - 1;
 8006dea:	69a2      	ldr	r2, [r4, #24]
 8006dec:	68a3      	ldr	r3, [r4, #8]
 8006dee:	3b01      	subs	r3, #1
 8006df0:	62d3      	str	r3, [r2, #44]	; 0x2c
  pwmp->tim->CR2  = pwmp->config->cr2;
 8006df2:	69a3      	ldr	r3, [r4, #24]
 8006df4:	6862      	ldr	r2, [r4, #4]
 8006df6:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8006df8:	605a      	str	r2, [r3, #4]
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 8006dfa:	6862      	ldr	r2, [r4, #4]
 8006dfc:	68d3      	ldr	r3, [r2, #12]
 8006dfe:	f003 030f 	and.w	r3, r3, #15
 8006e02:	2b01      	cmp	r3, #1
 8006e04:	d002      	beq.n	8006e0c <pwm_lld_start+0xdc>
 8006e06:	2b02      	cmp	r3, #2
 8006e08:	d002      	beq.n	8006e10 <pwm_lld_start+0xe0>
 8006e0a:	e005      	b.n	8006e18 <pwm_lld_start+0xe8>
  ccer = 0;
 8006e0c:	2300      	movs	r3, #0
 8006e0e:	e000      	b.n	8006e12 <pwm_lld_start+0xe2>
    ccer |= STM32_TIM_CCER_CC1P;
 8006e10:	2302      	movs	r3, #2
    ccer |= STM32_TIM_CCER_CC1E;
 8006e12:	f043 0301 	orr.w	r3, r3, #1
 8006e16:	e000      	b.n	8006e1a <pwm_lld_start+0xea>
  ccer = 0;
 8006e18:	2300      	movs	r3, #0
  switch (pwmp->config->channels[1].mode & PWM_OUTPUT_MASK) {
 8006e1a:	6951      	ldr	r1, [r2, #20]
 8006e1c:	f001 010f 	and.w	r1, r1, #15
 8006e20:	2901      	cmp	r1, #1
 8006e22:	d003      	beq.n	8006e2c <pwm_lld_start+0xfc>
 8006e24:	2902      	cmp	r1, #2
 8006e26:	d103      	bne.n	8006e30 <pwm_lld_start+0x100>
    ccer |= STM32_TIM_CCER_CC2P;
 8006e28:	f043 0320 	orr.w	r3, r3, #32
    ccer |= STM32_TIM_CCER_CC2E;
 8006e2c:	f043 0310 	orr.w	r3, r3, #16
  switch (pwmp->config->channels[2].mode & PWM_OUTPUT_MASK) {
 8006e30:	69d1      	ldr	r1, [r2, #28]
 8006e32:	f001 010f 	and.w	r1, r1, #15
 8006e36:	2901      	cmp	r1, #1
 8006e38:	d003      	beq.n	8006e42 <pwm_lld_start+0x112>
 8006e3a:	2902      	cmp	r1, #2
 8006e3c:	d103      	bne.n	8006e46 <pwm_lld_start+0x116>
    ccer |= STM32_TIM_CCER_CC3P;
 8006e3e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    ccer |= STM32_TIM_CCER_CC3E;
 8006e42:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  switch (pwmp->config->channels[3].mode & PWM_OUTPUT_MASK) {
 8006e46:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8006e48:	f002 020f 	and.w	r2, r2, #15
 8006e4c:	2a01      	cmp	r2, #1
 8006e4e:	d003      	beq.n	8006e58 <pwm_lld_start+0x128>
 8006e50:	2a02      	cmp	r2, #2
 8006e52:	d103      	bne.n	8006e5c <pwm_lld_start+0x12c>
    ccer |= STM32_TIM_CCER_CC4P;
 8006e54:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    ccer |= STM32_TIM_CCER_CC4E;
 8006e58:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  pwmp->tim->CCER  = ccer;
 8006e5c:	69a2      	ldr	r2, [r4, #24]
 8006e5e:	6213      	str	r3, [r2, #32]
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 8006e60:	69a3      	ldr	r3, [r4, #24]
 8006e62:	2201      	movs	r2, #1
 8006e64:	615a      	str	r2, [r3, #20]
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 8006e66:	69a3      	ldr	r3, [r4, #24]
 8006e68:	2200      	movs	r2, #0
 8006e6a:	611a      	str	r2, [r3, #16]
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 8006e6c:	69a2      	ldr	r2, [r4, #24]
 8006e6e:	6863      	ldr	r3, [r4, #4]
 8006e70:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006e72:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 8006e76:	60d3      	str	r3, [r2, #12]
  pwmp->tim->BDTR  = STM32_TIM_BDTR_MOE;
 8006e78:	69a3      	ldr	r3, [r4, #24]
 8006e7a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8006e7e:	645a      	str	r2, [r3, #68]	; 0x44
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
 8006e80:	69a3      	ldr	r3, [r4, #24]
 8006e82:	2285      	movs	r2, #133	; 0x85
 8006e84:	601a      	str	r2, [r3, #0]
 8006e86:	bd10      	pop	{r4, pc}
 8006e88:	20003b64 	.word	0x20003b64
 8006e8c:	40023800 	.word	0x40023800
 8006e90:	044aa200 	.word	0x044aa200
 8006e94:	20003bfc 	.word	0x20003bfc
 8006e98:	08954400 	.word	0x08954400
 8006e9c:	00000000 	.word	0x00000000

08006ea0 <pwm_lld_init>:
void pwm_lld_init(void) {
 8006ea0:	b538      	push	{r3, r4, r5, lr}
  pwmObjectInit(&PWMD4);
 8006ea2:	4c08      	ldr	r4, [pc, #32]	; (8006ec4 <pwm_lld_init+0x24>)
 8006ea4:	4620      	mov	r0, r4
 8006ea6:	f7fc fa73 	bl	8003390 <pwmObjectInit>
  PWMD4.channels = STM32_TIM4_CHANNELS;
 8006eaa:	2504      	movs	r5, #4
 8006eac:	7425      	strb	r5, [r4, #16]
  PWMD4.tim = STM32_TIM4;
 8006eae:	4b06      	ldr	r3, [pc, #24]	; (8006ec8 <pwm_lld_init+0x28>)
 8006eb0:	61a3      	str	r3, [r4, #24]
  pwmObjectInit(&PWMD8);
 8006eb2:	4c06      	ldr	r4, [pc, #24]	; (8006ecc <pwm_lld_init+0x2c>)
 8006eb4:	4620      	mov	r0, r4
 8006eb6:	f7fc fa6b 	bl	8003390 <pwmObjectInit>
  PWMD8.channels = STM32_TIM8_CHANNELS;
 8006eba:	7425      	strb	r5, [r4, #16]
  PWMD8.tim = STM32_TIM8;
 8006ebc:	4b04      	ldr	r3, [pc, #16]	; (8006ed0 <pwm_lld_init+0x30>)
 8006ebe:	61a3      	str	r3, [r4, #24]
 8006ec0:	bd38      	pop	{r3, r4, r5, pc}
 8006ec2:	bf00      	nop
 8006ec4:	20003b64 	.word	0x20003b64
 8006ec8:	40000800 	.word	0x40000800
 8006ecc:	20003bfc 	.word	0x20003bfc
 8006ed0:	40010400 	.word	0x40010400
	...

08006ee0 <VectorF8>:
OSAL_IRQ_HANDLER(STM32_TIM8_CC_HANDLER) {
 8006ee0:	b508      	push	{r3, lr}
  pwm_lld_serve_interrupt(&PWMD8);
 8006ee2:	4803      	ldr	r0, [pc, #12]	; (8006ef0 <VectorF8+0x10>)
 8006ee4:	f7ff fb9c 	bl	8006620 <pwm_lld_serve_interrupt>
  OSAL_IRQ_EPILOGUE();
 8006ee8:	f001 ffd2 	bl	8008e90 <_port_irq_epilogue>
 8006eec:	bd08      	pop	{r3, pc}
 8006eee:	bf00      	nop
 8006ef0:	20003bfc 	.word	0x20003bfc
	...

08006f00 <VectorF0>:
OSAL_IRQ_HANDLER(STM32_TIM8_UP_HANDLER) {
 8006f00:	b508      	push	{r3, lr}
  pwm_lld_serve_interrupt(&PWMD8);
 8006f02:	4803      	ldr	r0, [pc, #12]	; (8006f10 <VectorF0+0x10>)
 8006f04:	f7ff fb8c 	bl	8006620 <pwm_lld_serve_interrupt>
  OSAL_IRQ_EPILOGUE();
 8006f08:	f001 ffc2 	bl	8008e90 <_port_irq_epilogue>
 8006f0c:	bd08      	pop	{r3, pc}
 8006f0e:	bf00      	nop
 8006f10:	20003bfc 	.word	0x20003bfc
	...

08006f20 <VectorB8>:
OSAL_IRQ_HANDLER(STM32_TIM4_HANDLER) {
 8006f20:	b508      	push	{r3, lr}
  pwm_lld_serve_interrupt(&PWMD4);
 8006f22:	4803      	ldr	r0, [pc, #12]	; (8006f30 <VectorB8+0x10>)
 8006f24:	f7ff fb7c 	bl	8006620 <pwm_lld_serve_interrupt>
  OSAL_IRQ_EPILOGUE();
 8006f28:	f001 ffb2 	bl	8008e90 <_port_irq_epilogue>
 8006f2c:	bd08      	pop	{r3, pc}
 8006f2e:	bf00      	nop
 8006f30:	20003b64 	.word	0x20003b64
	...

08006f40 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8006f40:	b508      	push	{r3, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8006f42:	4b11      	ldr	r3, [pc, #68]	; (8006f88 <st_lld_init+0x48>)
 8006f44:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8006f46:	f042 0208 	orr.w	r2, r2, #8
 8006f4a:	641a      	str	r2, [r3, #64]	; 0x40
 8006f4c:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8006f4e:	f042 0208 	orr.w	r2, r2, #8
 8006f52:	661a      	str	r2, [r3, #96]	; 0x60
 8006f54:	6e1b      	ldr	r3, [r3, #96]	; 0x60

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8006f56:	4a0d      	ldr	r2, [pc, #52]	; (8006f8c <st_lld_init+0x4c>)
 8006f58:	6893      	ldr	r3, [r2, #8]
 8006f5a:	f043 0308 	orr.w	r3, r3, #8
 8006f5e:	6093      	str	r3, [r2, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8006f60:	4b0b      	ldr	r3, [pc, #44]	; (8006f90 <st_lld_init+0x50>)
 8006f62:	f641 421f 	movw	r2, #7199	; 0x1c1f
 8006f66:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8006f68:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8006f6c:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8006f6e:	2200      	movs	r2, #0
 8006f70:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8006f72:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8006f74:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8006f76:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8006f78:	2201      	movs	r2, #1
 8006f7a:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8006f7c:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8006f7e:	2108      	movs	r1, #8
 8006f80:	2032      	movs	r0, #50	; 0x32
 8006f82:	f7fe ffe5 	bl	8005f50 <nvicEnableVector>
 8006f86:	bd08      	pop	{r3, pc}
 8006f88:	40023800 	.word	0x40023800
 8006f8c:	e0042000 	.word	0xe0042000
 8006f90:	40000c00 	.word	0x40000c00
	...

08006fa0 <Vector108>:
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8006fa0:	b510      	push	{r4, lr}
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8006fa2:	4b09      	ldr	r3, [pc, #36]	; (8006fc8 <Vector108+0x28>)
 8006fa4:	691b      	ldr	r3, [r3, #16]
 8006fa6:	f013 0f02 	tst.w	r3, #2
 8006faa:	d009      	beq.n	8006fc0 <Vector108+0x20>
    STM32_ST_TIM->SR = 0U;
 8006fac:	2400      	movs	r4, #0
 8006fae:	4b06      	ldr	r3, [pc, #24]	; (8006fc8 <Vector108+0x28>)
 8006fb0:	611c      	str	r4, [r3, #16]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8006fb2:	2320      	movs	r3, #32
 8006fb4:	f383 8811 	msr	BASEPRI, r3
  chSysTimerHandlerI();
 8006fb8:	f7ff fb6a 	bl	8006690 <chSysTimerHandlerI>
 8006fbc:	f384 8811 	msr	BASEPRI, r4
  OSAL_IRQ_EPILOGUE();
 8006fc0:	f001 ff66 	bl	8008e90 <_port_irq_epilogue>
 8006fc4:	bd10      	pop	{r4, pc}
 8006fc6:	bf00      	nop
 8006fc8:	40000c00 	.word	0x40000c00
 8006fcc:	00000000 	.word	0x00000000

08006fd0 <usb_lld_clear_in>:
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 8006fd0:	f8d0 2084 	ldr.w	r2, [r0, #132]	; 0x84
 8006fd4:	3148      	adds	r1, #72	; 0x48
 8006fd6:	0149      	lsls	r1, r1, #5
 8006fd8:	5853      	ldr	r3, [r2, r1]
 8006fda:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8006fde:	5053      	str	r3, [r2, r1]
 8006fe0:	4770      	bx	lr
 8006fe2:	bf00      	nop
	...

08006ff0 <usb_lld_clear_out>:
  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 8006ff0:	f8d0 2084 	ldr.w	r2, [r0, #132]	; 0x84
 8006ff4:	3158      	adds	r1, #88	; 0x58
 8006ff6:	0149      	lsls	r1, r1, #5
 8006ff8:	5853      	ldr	r3, [r2, r1]
 8006ffa:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8006ffe:	5053      	str	r3, [r2, r1]
 8007000:	4770      	bx	lr
 8007002:	bf00      	nop
	...

08007010 <usb_lld_stall_in>:
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8007010:	f8d0 2084 	ldr.w	r2, [r0, #132]	; 0x84
 8007014:	3148      	adds	r1, #72	; 0x48
 8007016:	0149      	lsls	r1, r1, #5
 8007018:	5853      	ldr	r3, [r2, r1]
 800701a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800701e:	5053      	str	r3, [r2, r1]
 8007020:	4770      	bx	lr
 8007022:	bf00      	nop
	...

08007030 <usb_lld_stall_out>:
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8007030:	f8d0 2084 	ldr.w	r2, [r0, #132]	; 0x84
 8007034:	3158      	adds	r1, #88	; 0x58
 8007036:	0149      	lsls	r1, r1, #5
 8007038:	5853      	ldr	r3, [r2, r1]
 800703a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800703e:	5053      	str	r3, [r2, r1]
 8007040:	4770      	bx	lr
 8007042:	bf00      	nop
	...

08007050 <usb_lld_start_in>:
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8007050:	b410      	push	{r4}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8007052:	1c8b      	adds	r3, r1, #2
 8007054:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8007058:	685b      	ldr	r3, [r3, #4]
 800705a:	695b      	ldr	r3, [r3, #20]
  isp->totsize = isp->txsize;
 800705c:	681a      	ldr	r2, [r3, #0]
 800705e:	60da      	str	r2, [r3, #12]
  if (isp->txsize == 0) {
 8007060:	b942      	cbnz	r2, 8007074 <usb_lld_start_in+0x24>
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 8007062:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
 8007066:	eb03 1341 	add.w	r3, r3, r1, lsl #5
 800706a:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 800706e:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
 8007072:	e018      	b.n	80070a6 <usb_lld_start_in+0x56>
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 8007074:	b919      	cbnz	r1, 800707e <usb_lld_start_in+0x2e>
 8007076:	2a40      	cmp	r2, #64	; 0x40
 8007078:	d901      	bls.n	800707e <usb_lld_start_in+0x2e>
      isp->txsize = EP0_MAX_INSIZE;
 800707a:	2240      	movs	r2, #64	; 0x40
 800707c:	601a      	str	r2, [r3, #0]
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 800707e:	681b      	ldr	r3, [r3, #0]
 8007080:	1c8a      	adds	r2, r1, #2
 8007082:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8007086:	6852      	ldr	r2, [r2, #4]
 8007088:	8a14      	ldrh	r4, [r2, #16]
 800708a:	191a      	adds	r2, r3, r4
 800708c:	3a01      	subs	r2, #1
 800708e:	fbb2 f2f4 	udiv	r2, r2, r4
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8007092:	f8d0 4084 	ldr.w	r4, [r0, #132]	; 0x84
 8007096:	ea43 43c2 	orr.w	r3, r3, r2, lsl #19
 800709a:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800709e:	eb04 1441 	add.w	r4, r4, r1, lsl #5
 80070a2:	f8c4 3910 	str.w	r3, [r4, #2320]	; 0x910
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 80070a6:	1c8b      	adds	r3, r1, #2
 80070a8:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80070ac:	685b      	ldr	r3, [r3, #4]
 80070ae:	681b      	ldr	r3, [r3, #0]
 80070b0:	f003 0303 	and.w	r3, r3, #3
 80070b4:	2b01      	cmp	r3, #1
 80070b6:	d115      	bne.n	80070e4 <usb_lld_start_in+0x94>
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 80070b8:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
 80070bc:	f8d3 2808 	ldr.w	r2, [r3, #2056]	; 0x808
 80070c0:	f412 7f80 	tst.w	r2, #256	; 0x100
 80070c4:	d007      	beq.n	80070d6 <usb_lld_start_in+0x86>
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 80070c6:	f101 0248 	add.w	r2, r1, #72	; 0x48
 80070ca:	0152      	lsls	r2, r2, #5
 80070cc:	589c      	ldr	r4, [r3, r2]
 80070ce:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
 80070d2:	509c      	str	r4, [r3, r2]
 80070d4:	e006      	b.n	80070e4 <usb_lld_start_in+0x94>
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 80070d6:	f101 0248 	add.w	r2, r1, #72	; 0x48
 80070da:	0152      	lsls	r2, r2, #5
 80070dc:	589c      	ldr	r4, [r3, r2]
 80070de:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
 80070e2:	509c      	str	r4, [r3, r2]
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 80070e4:	f8d0 4084 	ldr.w	r4, [r0, #132]	; 0x84
 80070e8:	f101 0348 	add.w	r3, r1, #72	; 0x48
 80070ec:	015b      	lsls	r3, r3, #5
 80070ee:	58e2      	ldr	r2, [r4, r3]
 80070f0:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 80070f4:	50e2      	str	r2, [r4, r3]
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 80070f6:	f8d0 2084 	ldr.w	r2, [r0, #132]	; 0x84
 80070fa:	f8d2 0834 	ldr.w	r0, [r2, #2100]	; 0x834
 80070fe:	2301      	movs	r3, #1
 8007100:	fa03 f101 	lsl.w	r1, r3, r1
 8007104:	4301      	orrs	r1, r0
 8007106:	f8c2 1834 	str.w	r1, [r2, #2100]	; 0x834
}
 800710a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800710e:	4770      	bx	lr

08007110 <usb_lld_start_out>:
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 8007110:	b430      	push	{r4, r5}
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8007112:	1c8b      	adds	r3, r1, #2
 8007114:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8007118:	685b      	ldr	r3, [r3, #4]
 800711a:	699b      	ldr	r3, [r3, #24]
  osp->totsize = osp->rxsize;
 800711c:	681a      	ldr	r2, [r3, #0]
 800711e:	60da      	str	r2, [r3, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 8007120:	b919      	cbnz	r1, 800712a <usb_lld_start_out+0x1a>
 8007122:	2a40      	cmp	r2, #64	; 0x40
 8007124:	d901      	bls.n	800712a <usb_lld_start_out+0x1a>
      osp->rxsize = EP0_MAX_OUTSIZE;
 8007126:	2240      	movs	r2, #64	; 0x40
 8007128:	601a      	str	r2, [r3, #0]
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 800712a:	681a      	ldr	r2, [r3, #0]
 800712c:	1c8c      	adds	r4, r1, #2
 800712e:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 8007132:	6863      	ldr	r3, [r4, #4]
 8007134:	8a5b      	ldrh	r3, [r3, #18]
 8007136:	441a      	add	r2, r3
 8007138:	3a01      	subs	r2, #1
 800713a:	fbb2 f2f3 	udiv	r2, r2, r3
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 800713e:	fb02 f303 	mul.w	r3, r2, r3
 8007142:	3303      	adds	r3, #3
 8007144:	f023 0303 	bic.w	r3, r3, #3
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8007148:	f8d0 5084 	ldr.w	r5, [r0, #132]	; 0x84
 800714c:	ea43 43c2 	orr.w	r3, r3, r2, lsl #19
 8007150:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
 8007154:	eb05 1541 	add.w	r5, r5, r1, lsl #5
 8007158:	f8c5 3b10 	str.w	r3, [r5, #2832]	; 0xb10
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 800715c:	6863      	ldr	r3, [r4, #4]
 800715e:	681b      	ldr	r3, [r3, #0]
 8007160:	f003 0303 	and.w	r3, r3, #3
 8007164:	2b01      	cmp	r3, #1
 8007166:	d115      	bne.n	8007194 <usb_lld_start_out+0x84>
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8007168:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
 800716c:	f8d3 2808 	ldr.w	r2, [r3, #2056]	; 0x808
 8007170:	f412 7f80 	tst.w	r2, #256	; 0x100
 8007174:	d007      	beq.n	8007186 <usb_lld_start_out+0x76>
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 8007176:	f101 0258 	add.w	r2, r1, #88	; 0x58
 800717a:	0152      	lsls	r2, r2, #5
 800717c:	589c      	ldr	r4, [r3, r2]
 800717e:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
 8007182:	509c      	str	r4, [r3, r2]
 8007184:	e006      	b.n	8007194 <usb_lld_start_out+0x84>
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 8007186:	f101 0258 	add.w	r2, r1, #88	; 0x58
 800718a:	0152      	lsls	r2, r2, #5
 800718c:	589c      	ldr	r4, [r3, r2]
 800718e:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
 8007192:	509c      	str	r4, [r3, r2]
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 8007194:	f8d0 2084 	ldr.w	r2, [r0, #132]	; 0x84
 8007198:	3158      	adds	r1, #88	; 0x58
 800719a:	0149      	lsls	r1, r1, #5
 800719c:	5853      	ldr	r3, [r2, r1]
 800719e:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 80071a2:	5053      	str	r3, [r2, r1]
}
 80071a4:	bc30      	pop	{r4, r5}
 80071a6:	4770      	bx	lr
	...

080071b0 <usb_lld_read_setup>:
  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 80071b0:	3102      	adds	r1, #2
 80071b2:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 80071b6:	6843      	ldr	r3, [r0, #4]
 80071b8:	6a1b      	ldr	r3, [r3, #32]
 80071ba:	6819      	ldr	r1, [r3, #0]
 80071bc:	685b      	ldr	r3, [r3, #4]
 80071be:	6011      	str	r1, [r2, #0]
 80071c0:	6053      	str	r3, [r2, #4]
 80071c2:	4770      	bx	lr
	...

080071d0 <usb_lld_get_status_in>:
  ctl = usbp->otg->ie[ep].DIEPCTL;
 80071d0:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
 80071d4:	3148      	adds	r1, #72	; 0x48
 80071d6:	0149      	lsls	r1, r1, #5
 80071d8:	585b      	ldr	r3, [r3, r1]
  if (!(ctl & DIEPCTL_USBAEP))
 80071da:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 80071de:	d004      	beq.n	80071ea <usb_lld_get_status_in+0x1a>
  if (ctl & DIEPCTL_STALL)
 80071e0:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
 80071e4:	d003      	beq.n	80071ee <usb_lld_get_status_in+0x1e>
    return EP_STATUS_STALLED;
 80071e6:	2001      	movs	r0, #1
 80071e8:	4770      	bx	lr
    return EP_STATUS_DISABLED;
 80071ea:	2000      	movs	r0, #0
 80071ec:	4770      	bx	lr
  return EP_STATUS_ACTIVE;
 80071ee:	2002      	movs	r0, #2
}
 80071f0:	4770      	bx	lr
 80071f2:	bf00      	nop
	...

08007200 <usb_lld_get_status_out>:
  ctl = usbp->otg->oe[ep].DOEPCTL;
 8007200:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
 8007204:	3158      	adds	r1, #88	; 0x58
 8007206:	0149      	lsls	r1, r1, #5
 8007208:	585b      	ldr	r3, [r3, r1]
  if (!(ctl & DOEPCTL_USBAEP))
 800720a:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 800720e:	d004      	beq.n	800721a <usb_lld_get_status_out+0x1a>
  if (ctl & DOEPCTL_STALL)
 8007210:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
 8007214:	d003      	beq.n	800721e <usb_lld_get_status_out+0x1e>
    return EP_STATUS_STALLED;
 8007216:	2001      	movs	r0, #1
 8007218:	4770      	bx	lr
    return EP_STATUS_DISABLED;
 800721a:	2000      	movs	r0, #0
 800721c:	4770      	bx	lr
  return EP_STATUS_ACTIVE;
 800721e:	2002      	movs	r0, #2
}
 8007220:	4770      	bx	lr
 8007222:	bf00      	nop
	...

08007230 <usb_lld_disable_endpoints>:
void usb_lld_disable_endpoints(USBDriver *usbp) {
 8007230:	b510      	push	{r4, lr}
 8007232:	4604      	mov	r4, r0
  otg_ram_reset(usbp);
 8007234:	f7fe fbf4 	bl	8005a20 <otg_ram_reset.lto_priv.142>
  otg_disable_ep(usbp);
 8007238:	4620      	mov	r0, r4
 800723a:	f7fe fd49 	bl	8005cd0 <otg_disable_ep.lto_priv.141>
 800723e:	bd10      	pop	{r4, pc}

08007240 <usb_lld_init_endpoint>:
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8007240:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 8007244:	f8d0 5084 	ldr.w	r5, [r0, #132]	; 0x84
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8007248:	1c8b      	adds	r3, r1, #2
 800724a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800724e:	685b      	ldr	r3, [r3, #4]
 8007250:	681b      	ldr	r3, [r3, #0]
 8007252:	f003 0303 	and.w	r3, r3, #3
 8007256:	2b03      	cmp	r3, #3
 8007258:	f200 808a 	bhi.w	8007370 <usb_lld_init_endpoint+0x130>
 800725c:	e8df f003 	tbb	[pc, r3]
 8007260:	06040802 	.word	0x06040802
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
 8007264:	4f43      	ldr	r7, [pc, #268]	; (8007374 <usb_lld_init_endpoint+0x134>)
 8007266:	e004      	b.n	8007272 <usb_lld_init_endpoint+0x32>
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
 8007268:	4f43      	ldr	r7, [pc, #268]	; (8007378 <usb_lld_init_endpoint+0x138>)
 800726a:	e002      	b.n	8007272 <usb_lld_init_endpoint+0x32>
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
 800726c:	4f43      	ldr	r7, [pc, #268]	; (800737c <usb_lld_init_endpoint+0x13c>)
 800726e:	e000      	b.n	8007272 <usb_lld_init_endpoint+0x32>
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_ISO;
 8007270:	4f43      	ldr	r7, [pc, #268]	; (8007380 <usb_lld_init_endpoint+0x140>)
  otgp->oe[ep].DOEPTSIZ = 0;
 8007272:	eb05 1341 	add.w	r3, r5, r1, lsl #5
 8007276:	2200      	movs	r2, #0
 8007278:	f8c3 2b10 	str.w	r2, [r3, #2832]	; 0xb10
  if (usbp->epc[ep]->out_state != NULL) {
 800727c:	1c8b      	adds	r3, r1, #2
 800727e:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8007282:	685b      	ldr	r3, [r3, #4]
 8007284:	699a      	ldr	r2, [r3, #24]
 8007286:	b182      	cbz	r2, 80072aa <usb_lld_init_endpoint+0x6a>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 8007288:	8a5a      	ldrh	r2, [r3, #18]
 800728a:	433a      	orrs	r2, r7
 800728c:	f101 0358 	add.w	r3, r1, #88	; 0x58
 8007290:	015b      	lsls	r3, r3, #5
 8007292:	50ea      	str	r2, [r5, r3]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 8007294:	f8d5 481c 	ldr.w	r4, [r5, #2076]	; 0x81c
 8007298:	f101 0310 	add.w	r3, r1, #16
 800729c:	2201      	movs	r2, #1
 800729e:	fa02 f303 	lsl.w	r3, r2, r3
 80072a2:	4323      	orrs	r3, r4
 80072a4:	f8c5 381c 	str.w	r3, [r5, #2076]	; 0x81c
 80072a8:	e010      	b.n	80072cc <usb_lld_init_endpoint+0x8c>
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 80072aa:	f101 0358 	add.w	r3, r1, #88	; 0x58
 80072ae:	015b      	lsls	r3, r3, #5
 80072b0:	58ea      	ldr	r2, [r5, r3]
 80072b2:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80072b6:	50ea      	str	r2, [r5, r3]
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 80072b8:	f8d5 281c 	ldr.w	r2, [r5, #2076]	; 0x81c
 80072bc:	f101 0410 	add.w	r4, r1, #16
 80072c0:	2301      	movs	r3, #1
 80072c2:	40a3      	lsls	r3, r4
 80072c4:	ea22 0303 	bic.w	r3, r2, r3
 80072c8:	f8c5 381c 	str.w	r3, [r5, #2076]	; 0x81c
 80072cc:	460c      	mov	r4, r1
 80072ce:	4606      	mov	r6, r0
  otgp->ie[ep].DIEPTSIZ = 0;
 80072d0:	eb05 1341 	add.w	r3, r5, r1, lsl #5
 80072d4:	2200      	movs	r2, #0
 80072d6:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
  if (usbp->epc[ep]->in_state != NULL) {
 80072da:	1c8b      	adds	r3, r1, #2
 80072dc:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80072e0:	685b      	ldr	r3, [r3, #4]
 80072e2:	695a      	ldr	r2, [r3, #20]
 80072e4:	b362      	cbz	r2, 8007340 <usb_lld_init_endpoint+0x100>
    fsize = usbp->epc[ep]->in_maxsize / 4;
 80072e6:	8a19      	ldrh	r1, [r3, #16]
 80072e8:	0889      	lsrs	r1, r1, #2
    if (usbp->epc[ep]->in_multiplier > 1)
 80072ea:	8b9b      	ldrh	r3, [r3, #28]
 80072ec:	2b01      	cmp	r3, #1
 80072ee:	d901      	bls.n	80072f4 <usb_lld_init_endpoint+0xb4>
      fsize *= usbp->epc[ep]->in_multiplier;
 80072f0:	fb03 f101 	mul.w	r1, r3, r1
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 80072f4:	ea4f 4801 	mov.w	r8, r1, lsl #16
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
 80072f8:	4630      	mov	r0, r6
 80072fa:	f7fe fb89 	bl	8005a10 <otg_ram_alloc.lto_priv.144>
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 80072fe:	ea48 0000 	orr.w	r0, r8, r0
 8007302:	f104 033f 	add.w	r3, r4, #63	; 0x3f
 8007306:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 800730a:	6058      	str	r0, [r3, #4]
    otg_txfifo_flush(usbp, ep);
 800730c:	4621      	mov	r1, r4
 800730e:	4630      	mov	r0, r6
 8007310:	f7fe fb8e 	bl	8005a30 <otg_txfifo_flush.lto_priv.143>
    otgp->ie[ep].DIEPCTL = ctl |
 8007314:	ea47 5384 	orr.w	r3, r7, r4, lsl #22
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 8007318:	1ca0      	adds	r0, r4, #2
 800731a:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 800731e:	6842      	ldr	r2, [r0, #4]
 8007320:	8a12      	ldrh	r2, [r2, #16]
                           DIEPCTL_TXFNUM(ep) |
 8007322:	4313      	orrs	r3, r2
    otgp->ie[ep].DIEPCTL = ctl |
 8007324:	f104 0248 	add.w	r2, r4, #72	; 0x48
 8007328:	0152      	lsls	r2, r2, #5
 800732a:	50ab      	str	r3, [r5, r2]
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 800732c:	f8d5 381c 	ldr.w	r3, [r5, #2076]	; 0x81c
 8007330:	2101      	movs	r1, #1
 8007332:	fa01 f404 	lsl.w	r4, r1, r4
 8007336:	431c      	orrs	r4, r3
 8007338:	f8c5 481c 	str.w	r4, [r5, #2076]	; 0x81c
 800733c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 8007340:	f101 033f 	add.w	r3, r1, #63	; 0x3f
 8007344:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8007348:	4a0e      	ldr	r2, [pc, #56]	; (8007384 <usb_lld_init_endpoint+0x144>)
 800734a:	605a      	str	r2, [r3, #4]
    otg_txfifo_flush(usbp, ep);
 800734c:	f7fe fb70 	bl	8005a30 <otg_txfifo_flush.lto_priv.143>
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 8007350:	f104 0348 	add.w	r3, r4, #72	; 0x48
 8007354:	015b      	lsls	r3, r3, #5
 8007356:	58ea      	ldr	r2, [r5, r3]
 8007358:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800735c:	50ea      	str	r2, [r5, r3]
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 800735e:	f8d5 381c 	ldr.w	r3, [r5, #2076]	; 0x81c
 8007362:	2201      	movs	r2, #1
 8007364:	fa02 f404 	lsl.w	r4, r2, r4
 8007368:	ea23 0404 	bic.w	r4, r3, r4
 800736c:	f8c5 481c 	str.w	r4, [r5, #2076]	; 0x81c
 8007370:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8007374:	10008000 	.word	0x10008000
 8007378:	10088000 	.word	0x10088000
 800737c:	100c8000 	.word	0x100c8000
 8007380:	10048000 	.word	0x10048000
 8007384:	02000400 	.word	0x02000400
	...

08007390 <usb_lld_set_address>:
  stm32_otg_t *otgp = usbp->otg;
 8007390:	f8d0 2084 	ldr.w	r2, [r0, #132]	; 0x84
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 8007394:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
 8007398:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 800739c:	f890 107e 	ldrb.w	r1, [r0, #126]	; 0x7e
 80073a0:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 80073a4:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
 80073a8:	4770      	bx	lr
 80073aa:	bf00      	nop
 80073ac:	0000      	movs	r0, r0
	...

080073b0 <usb_lld_reset>:
void usb_lld_reset(USBDriver *usbp) {
 80073b0:	b538      	push	{r3, r4, r5, lr}
 80073b2:	4605      	mov	r5, r0
  stm32_otg_t *otgp = usbp->otg;
 80073b4:	f8d0 4084 	ldr.w	r4, [r0, #132]	; 0x84
  otg_txfifo_flush(usbp, 0);
 80073b8:	2100      	movs	r1, #0
 80073ba:	f7fe fb39 	bl	8005a30 <otg_txfifo_flush.lto_priv.143>
  otgp->DIEPEMPMSK = 0;
 80073be:	2300      	movs	r3, #0
 80073c0:	f8c4 3834 	str.w	r3, [r4, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80073c4:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 80073c8:	f8c4 281c 	str.w	r2, [r4, #2076]	; 0x81c
 80073cc:	e012      	b.n	80073f4 <usb_lld_reset+0x44>
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 80073ce:	f103 0248 	add.w	r2, r3, #72	; 0x48
 80073d2:	0152      	lsls	r2, r2, #5
 80073d4:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
 80073d8:	50a1      	str	r1, [r4, r2]
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 80073da:	f103 0258 	add.w	r2, r3, #88	; 0x58
 80073de:	0152      	lsls	r2, r2, #5
 80073e0:	50a1      	str	r1, [r4, r2]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80073e2:	eb04 1243 	add.w	r2, r4, r3, lsl #5
 80073e6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80073ea:	f8c2 1908 	str.w	r1, [r2, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 80073ee:	f8c2 1b08 	str.w	r1, [r2, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80073f2:	3301      	adds	r3, #1
 80073f4:	f8d5 2088 	ldr.w	r2, [r5, #136]	; 0x88
 80073f8:	6892      	ldr	r2, [r2, #8]
 80073fa:	4293      	cmp	r3, r2
 80073fc:	d9e7      	bls.n	80073ce <usb_lld_reset+0x1e>
  otg_ram_reset(usbp);
 80073fe:	4628      	mov	r0, r5
 8007400:	f7fe fb0e 	bl	8005a20 <otg_ram_reset.lto_priv.142>
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 8007404:	f8d5 3088 	ldr.w	r3, [r5, #136]	; 0x88
 8007408:	681b      	ldr	r3, [r3, #0]
 800740a:	6263      	str	r3, [r4, #36]	; 0x24
  otg_rxfifo_flush(usbp);
 800740c:	4628      	mov	r0, r5
 800740e:	f7fe fc4f 	bl	8005cb0 <otg_rxfifo_flush.lto_priv.145>
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8007412:	f8d4 3800 	ldr.w	r3, [r4, #2048]	; 0x800
 8007416:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 800741a:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 800741e:	69a3      	ldr	r3, [r4, #24]
 8007420:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 8007424:	f043 0310 	orr.w	r3, r3, #16
 8007428:	61a3      	str	r3, [r4, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 800742a:	2309      	movs	r3, #9
 800742c:	f8c4 3810 	str.w	r3, [r4, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 8007430:	f8c4 3814 	str.w	r3, [r4, #2068]	; 0x814
  usbp->epc[0] = &ep0config;
 8007434:	4b0a      	ldr	r3, [pc, #40]	; (8007460 <usb_lld_reset+0xb0>)
 8007436:	60eb      	str	r3, [r5, #12]
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
 8007438:	f04f 43c0 	mov.w	r3, #1610612736	; 0x60000000
 800743c:	f8c4 3b10 	str.w	r3, [r4, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8007440:	4b08      	ldr	r3, [pc, #32]	; (8007464 <usb_lld_reset+0xb4>)
 8007442:	f8c4 3b00 	str.w	r3, [r4, #2816]	; 0xb00
  otgp->ie[0].DIEPTSIZ = 0;
 8007446:	2200      	movs	r2, #0
 8007448:	f8c4 2910 	str.w	r2, [r4, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 800744c:	f8c4 3900 	str.w	r3, [r4, #2304]	; 0x900
                   DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
 8007450:	2110      	movs	r1, #16
 8007452:	4628      	mov	r0, r5
 8007454:	f7fe fadc 	bl	8005a10 <otg_ram_alloc.lto_priv.144>
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8007458:	f440 1080 	orr.w	r0, r0, #1048576	; 0x100000
 800745c:	62a0      	str	r0, [r4, #40]	; 0x28
 800745e:	bd38      	pop	{r3, r4, r5, pc}
 8007460:	0800e9a8 	.word	0x0800e9a8
 8007464:	10008040 	.word	0x10008040
	...

08007470 <rt_test_004_001_setup.lto_priv.74>:
 *   the state of the reference are tested.
 * .
 */

static void rt_test_004_001_setup(void) {
  tr1 = NULL;
 8007470:	2200      	movs	r2, #0
 8007472:	4b01      	ldr	r3, [pc, #4]	; (8007478 <rt_test_004_001_setup.lto_priv.74+0x8>)
 8007474:	601a      	str	r2, [r3, #0]
 8007476:	4770      	bx	lr
 8007478:	20003100 	.word	0x20003100
 800747c:	00000000 	.word	0x00000000

08007480 <rt_test_002_004_execute.lto_priv.69>:

static void rt_test_002_004_execute(void) {

  /* [2.4.1] A System Tick Counter increment is expected, the test
     simply hangs if it does not happen.*/
  test_set_step(1);
 8007480:	2201      	movs	r2, #1
 8007482:	4b04      	ldr	r3, [pc, #16]	; (8007494 <rt_test_002_004_execute.lto_priv.69+0x14>)
 8007484:	601a      	str	r2, [r3, #0]
 8007486:	4b04      	ldr	r3, [pc, #16]	; (8007498 <rt_test_002_004_execute.lto_priv.69+0x18>)
 8007488:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800748a:	4b03      	ldr	r3, [pc, #12]	; (8007498 <rt_test_002_004_execute.lto_priv.69+0x18>)
 800748c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  {
    systime_t time = chVTGetSystemTimeX();
    while (time == chVTGetSystemTimeX()) {
 800748e:	4293      	cmp	r3, r2
 8007490:	d0fb      	beq.n	800748a <rt_test_002_004_execute.lto_priv.69+0xa>
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    }
  }
}
 8007492:	4770      	bx	lr
 8007494:	20003e04 	.word	0x20003e04
 8007498:	40000c00 	.word	0x40000c00
 800749c:	00000000 	.word	0x00000000

080074a0 <rt_test_002_003_execute.lto_priv.68>:
  test_set_step(1);
 80074a0:	2201      	movs	r2, #1
 80074a2:	4b07      	ldr	r3, [pc, #28]	; (80074c0 <rt_test_002_003_execute.lto_priv.68+0x20>)
 80074a4:	601a      	str	r2, [r3, #0]
 80074a6:	2320      	movs	r3, #32
 80074a8:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
 80074ac:	b662      	cpsie	i
  __ASM volatile ("cpsid i" : : : "memory");
 80074ae:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80074b0:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
 80074b4:	b662      	cpsie	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80074b6:	2300      	movs	r3, #0
 80074b8:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
 80074bc:	b662      	cpsie	i
 80074be:	4770      	bx	lr
 80074c0:	20003e04 	.word	0x20003e04
	...

080074d0 <rt_test_005_006_teardown.lto_priv.88>:
 * - [5.6.6] Signaling the binary semaphore again, the internal state
 *   must not change from "not taken".
 * .
 */

static void rt_test_005_006_teardown(void) {
 80074d0:	b508      	push	{r3, lr}
  test_wait_threads();
 80074d2:	f005 fa35 	bl	800c940 <test_wait_threads>
 80074d6:	bd08      	pop	{r3, pc}
	...

080074e0 <rt_test_005_005_teardown.lto_priv.86>:
static void rt_test_005_005_teardown(void) {
 80074e0:	b508      	push	{r3, lr}
  test_wait_threads();
 80074e2:	f005 fa2d 	bl	800c940 <test_wait_threads>
 80074e6:	bd08      	pop	{r3, pc}
	...

080074f0 <rt_test_003_002_execute.lto_priv.71>:
 * - [3.2.3] Creating 5 threads with pseudo-random priority, execution
 *   sequence is tested.
 * .
 */

static void rt_test_003_002_execute(void) {
 80074f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80074f2:	b083      	sub	sp, #12

  /* [3.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
 80074f4:	2201      	movs	r2, #1
 80074f6:	4b75      	ldr	r3, [pc, #468]	; (80076cc <rt_test_003_002_execute.lto_priv.71+0x1dc>)
 80074f8:	601a      	str	r2, [r3, #0]
  return ch.rlist.current;
 80074fa:	4f75      	ldr	r7, [pc, #468]	; (80076d0 <rt_test_003_002_execute.lto_priv.71+0x1e0>)
 80074fc:	69bb      	ldr	r3, [r7, #24]
  return chThdGetSelfX()->prio;
 80074fe:	689a      	ldr	r2, [r3, #8]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8007500:	4e74      	ldr	r6, [pc, #464]	; (80076d4 <rt_test_003_002_execute.lto_priv.71+0x1e4>)
 8007502:	4d75      	ldr	r5, [pc, #468]	; (80076d8 <rt_test_003_002_execute.lto_priv.71+0x1e8>)
 8007504:	4b75      	ldr	r3, [pc, #468]	; (80076dc <rt_test_003_002_execute.lto_priv.71+0x1ec>)
 8007506:	9300      	str	r3, [sp, #0]
 8007508:	4633      	mov	r3, r6
 800750a:	3a05      	subs	r2, #5
 800750c:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007510:	4628      	mov	r0, r5
 8007512:	f004 f92d 	bl	800b770 <chThdCreateStatic>
 8007516:	4c72      	ldr	r4, [pc, #456]	; (80076e0 <rt_test_003_002_execute.lto_priv.71+0x1f0>)
 8007518:	6020      	str	r0, [r4, #0]
  return ch.rlist.current;
 800751a:	69bb      	ldr	r3, [r7, #24]
  return chThdGetSelfX()->prio;
 800751c:	689a      	ldr	r2, [r3, #8]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800751e:	4b71      	ldr	r3, [pc, #452]	; (80076e4 <rt_test_003_002_execute.lto_priv.71+0x1f4>)
 8007520:	9300      	str	r3, [sp, #0]
 8007522:	4633      	mov	r3, r6
 8007524:	3a04      	subs	r2, #4
 8007526:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800752a:	1868      	adds	r0, r5, r1
 800752c:	f004 f920 	bl	800b770 <chThdCreateStatic>
 8007530:	6060      	str	r0, [r4, #4]
  return ch.rlist.current;
 8007532:	69bb      	ldr	r3, [r7, #24]
  return chThdGetSelfX()->prio;
 8007534:	689a      	ldr	r2, [r3, #8]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8007536:	4b6c      	ldr	r3, [pc, #432]	; (80076e8 <rt_test_003_002_execute.lto_priv.71+0x1f8>)
 8007538:	9300      	str	r3, [sp, #0]
 800753a:	4633      	mov	r3, r6
 800753c:	3a03      	subs	r2, #3
 800753e:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007542:	f505 7068 	add.w	r0, r5, #928	; 0x3a0
 8007546:	f004 f913 	bl	800b770 <chThdCreateStatic>
 800754a:	60a0      	str	r0, [r4, #8]
  return ch.rlist.current;
 800754c:	69bb      	ldr	r3, [r7, #24]
  return chThdGetSelfX()->prio;
 800754e:	689a      	ldr	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8007550:	4b66      	ldr	r3, [pc, #408]	; (80076ec <rt_test_003_002_execute.lto_priv.71+0x1fc>)
 8007552:	9300      	str	r3, [sp, #0]
 8007554:	4633      	mov	r3, r6
 8007556:	3a02      	subs	r2, #2
 8007558:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800755c:	f505 60ae 	add.w	r0, r5, #1392	; 0x570
 8007560:	f004 f906 	bl	800b770 <chThdCreateStatic>
 8007564:	60e0      	str	r0, [r4, #12]
  return ch.rlist.current;
 8007566:	69bb      	ldr	r3, [r7, #24]
  return chThdGetSelfX()->prio;
 8007568:	689a      	ldr	r2, [r3, #8]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800756a:	4b61      	ldr	r3, [pc, #388]	; (80076f0 <rt_test_003_002_execute.lto_priv.71+0x200>)
 800756c:	9300      	str	r3, [sp, #0]
 800756e:	4633      	mov	r3, r6
 8007570:	3a01      	subs	r2, #1
 8007572:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007576:	f505 60e8 	add.w	r0, r5, #1856	; 0x740
 800757a:	f004 f8f9 	bl	800b770 <chThdCreateStatic>
 800757e:	6120      	str	r0, [r4, #16]
    test_wait_threads();
 8007580:	f005 f9de 	bl	800c940 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8007584:	495b      	ldr	r1, [pc, #364]	; (80076f4 <rt_test_003_002_execute.lto_priv.71+0x204>)
 8007586:	485c      	ldr	r0, [pc, #368]	; (80076f8 <rt_test_003_002_execute.lto_priv.71+0x208>)
 8007588:	f005 fdea 	bl	800d160 <_test_assert_sequence>
 800758c:	2800      	cmp	r0, #0
 800758e:	f040 809b 	bne.w	80076c8 <rt_test_003_002_execute.lto_priv.71+0x1d8>
  }

  /* [3.2.2] Creating 5 threads with decreasing priority, execution
     sequence is tested.*/
  test_set_step(2);
 8007592:	2202      	movs	r2, #2
 8007594:	4b4d      	ldr	r3, [pc, #308]	; (80076cc <rt_test_003_002_execute.lto_priv.71+0x1dc>)
 8007596:	601a      	str	r2, [r3, #0]
  return ch.rlist.current;
 8007598:	69bb      	ldr	r3, [r7, #24]
  return chThdGetSelfX()->prio;
 800759a:	689a      	ldr	r2, [r3, #8]
  {
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800759c:	f505 65e8 	add.w	r5, r5, #1856	; 0x740
 80075a0:	4b53      	ldr	r3, [pc, #332]	; (80076f0 <rt_test_003_002_execute.lto_priv.71+0x200>)
 80075a2:	9300      	str	r3, [sp, #0]
 80075a4:	4633      	mov	r3, r6
 80075a6:	3a01      	subs	r2, #1
 80075a8:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80075ac:	4628      	mov	r0, r5
 80075ae:	f004 f8df 	bl	800b770 <chThdCreateStatic>
 80075b2:	6120      	str	r0, [r4, #16]
  return ch.rlist.current;
 80075b4:	69bb      	ldr	r3, [r7, #24]
  return chThdGetSelfX()->prio;
 80075b6:	689a      	ldr	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 80075b8:	4b4c      	ldr	r3, [pc, #304]	; (80076ec <rt_test_003_002_execute.lto_priv.71+0x1fc>)
 80075ba:	9300      	str	r3, [sp, #0]
 80075bc:	4633      	mov	r3, r6
 80075be:	3a02      	subs	r2, #2
 80075c0:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80075c4:	f5a5 70e8 	sub.w	r0, r5, #464	; 0x1d0
 80075c8:	f004 f8d2 	bl	800b770 <chThdCreateStatic>
 80075cc:	60e0      	str	r0, [r4, #12]
  return ch.rlist.current;
 80075ce:	69bb      	ldr	r3, [r7, #24]
  return chThdGetSelfX()->prio;
 80075d0:	689a      	ldr	r2, [r3, #8]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80075d2:	4b45      	ldr	r3, [pc, #276]	; (80076e8 <rt_test_003_002_execute.lto_priv.71+0x1f8>)
 80075d4:	9300      	str	r3, [sp, #0]
 80075d6:	4633      	mov	r3, r6
 80075d8:	3a03      	subs	r2, #3
 80075da:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80075de:	f5a5 7068 	sub.w	r0, r5, #928	; 0x3a0
 80075e2:	f004 f8c5 	bl	800b770 <chThdCreateStatic>
 80075e6:	60a0      	str	r0, [r4, #8]
  return ch.rlist.current;
 80075e8:	69bb      	ldr	r3, [r7, #24]
  return chThdGetSelfX()->prio;
 80075ea:	689a      	ldr	r2, [r3, #8]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80075ec:	4b3d      	ldr	r3, [pc, #244]	; (80076e4 <rt_test_003_002_execute.lto_priv.71+0x1f4>)
 80075ee:	9300      	str	r3, [sp, #0]
 80075f0:	4633      	mov	r3, r6
 80075f2:	3a04      	subs	r2, #4
 80075f4:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80075f8:	f5a5 60ae 	sub.w	r0, r5, #1392	; 0x570
 80075fc:	f004 f8b8 	bl	800b770 <chThdCreateStatic>
 8007600:	6060      	str	r0, [r4, #4]
  return ch.rlist.current;
 8007602:	69bb      	ldr	r3, [r7, #24]
  return chThdGetSelfX()->prio;
 8007604:	689a      	ldr	r2, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8007606:	4b35      	ldr	r3, [pc, #212]	; (80076dc <rt_test_003_002_execute.lto_priv.71+0x1ec>)
 8007608:	9300      	str	r3, [sp, #0]
 800760a:	4633      	mov	r3, r6
 800760c:	3a05      	subs	r2, #5
 800760e:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007612:	f5a5 60e8 	sub.w	r0, r5, #1856	; 0x740
 8007616:	f004 f8ab 	bl	800b770 <chThdCreateStatic>
 800761a:	6020      	str	r0, [r4, #0]
    test_wait_threads();
 800761c:	f005 f990 	bl	800c940 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8007620:	4934      	ldr	r1, [pc, #208]	; (80076f4 <rt_test_003_002_execute.lto_priv.71+0x204>)
 8007622:	4835      	ldr	r0, [pc, #212]	; (80076f8 <rt_test_003_002_execute.lto_priv.71+0x208>)
 8007624:	f005 fd9c 	bl	800d160 <_test_assert_sequence>
 8007628:	2800      	cmp	r0, #0
 800762a:	d14d      	bne.n	80076c8 <rt_test_003_002_execute.lto_priv.71+0x1d8>
  }

  /* [3.2.3] Creating 5 threads with pseudo-random priority, execution
     sequence is tested.*/
  test_set_step(3);
 800762c:	2203      	movs	r2, #3
 800762e:	4b27      	ldr	r3, [pc, #156]	; (80076cc <rt_test_003_002_execute.lto_priv.71+0x1dc>)
 8007630:	601a      	str	r2, [r3, #0]
  return ch.rlist.current;
 8007632:	463d      	mov	r5, r7
 8007634:	69bb      	ldr	r3, [r7, #24]
  return chThdGetSelfX()->prio;
 8007636:	689a      	ldr	r2, [r3, #8]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8007638:	4637      	mov	r7, r6
 800763a:	4c30      	ldr	r4, [pc, #192]	; (80076fc <rt_test_003_002_execute.lto_priv.71+0x20c>)
 800763c:	4b29      	ldr	r3, [pc, #164]	; (80076e4 <rt_test_003_002_execute.lto_priv.71+0x1f4>)
 800763e:	9300      	str	r3, [sp, #0]
 8007640:	4633      	mov	r3, r6
 8007642:	3a04      	subs	r2, #4
 8007644:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007648:	4620      	mov	r0, r4
 800764a:	f004 f891 	bl	800b770 <chThdCreateStatic>
 800764e:	4e24      	ldr	r6, [pc, #144]	; (80076e0 <rt_test_003_002_execute.lto_priv.71+0x1f0>)
 8007650:	6070      	str	r0, [r6, #4]
  return ch.rlist.current;
 8007652:	69ab      	ldr	r3, [r5, #24]
  return chThdGetSelfX()->prio;
 8007654:	689a      	ldr	r2, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8007656:	f5a4 74e8 	sub.w	r4, r4, #464	; 0x1d0
 800765a:	4b20      	ldr	r3, [pc, #128]	; (80076dc <rt_test_003_002_execute.lto_priv.71+0x1ec>)
 800765c:	9300      	str	r3, [sp, #0]
 800765e:	463b      	mov	r3, r7
 8007660:	3a05      	subs	r2, #5
 8007662:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007666:	4620      	mov	r0, r4
 8007668:	f004 f882 	bl	800b770 <chThdCreateStatic>
 800766c:	6030      	str	r0, [r6, #0]
  return ch.rlist.current;
 800766e:	69ab      	ldr	r3, [r5, #24]
  return chThdGetSelfX()->prio;
 8007670:	689a      	ldr	r2, [r3, #8]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8007672:	4b1f      	ldr	r3, [pc, #124]	; (80076f0 <rt_test_003_002_execute.lto_priv.71+0x200>)
 8007674:	9300      	str	r3, [sp, #0]
 8007676:	463b      	mov	r3, r7
 8007678:	3a01      	subs	r2, #1
 800767a:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800767e:	f504 60e8 	add.w	r0, r4, #1856	; 0x740
 8007682:	f004 f875 	bl	800b770 <chThdCreateStatic>
 8007686:	6130      	str	r0, [r6, #16]
  return ch.rlist.current;
 8007688:	69ab      	ldr	r3, [r5, #24]
  return chThdGetSelfX()->prio;
 800768a:	689a      	ldr	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800768c:	4b17      	ldr	r3, [pc, #92]	; (80076ec <rt_test_003_002_execute.lto_priv.71+0x1fc>)
 800768e:	9300      	str	r3, [sp, #0]
 8007690:	463b      	mov	r3, r7
 8007692:	3a02      	subs	r2, #2
 8007694:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007698:	f504 60ae 	add.w	r0, r4, #1392	; 0x570
 800769c:	f004 f868 	bl	800b770 <chThdCreateStatic>
 80076a0:	60f0      	str	r0, [r6, #12]
  return ch.rlist.current;
 80076a2:	69ab      	ldr	r3, [r5, #24]
  return chThdGetSelfX()->prio;
 80076a4:	689a      	ldr	r2, [r3, #8]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80076a6:	4b10      	ldr	r3, [pc, #64]	; (80076e8 <rt_test_003_002_execute.lto_priv.71+0x1f8>)
 80076a8:	9300      	str	r3, [sp, #0]
 80076aa:	463b      	mov	r3, r7
 80076ac:	3a03      	subs	r2, #3
 80076ae:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80076b2:	f504 7068 	add.w	r0, r4, #928	; 0x3a0
 80076b6:	f004 f85b 	bl	800b770 <chThdCreateStatic>
 80076ba:	60b0      	str	r0, [r6, #8]
    test_wait_threads();
 80076bc:	f005 f940 	bl	800c940 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 80076c0:	490c      	ldr	r1, [pc, #48]	; (80076f4 <rt_test_003_002_execute.lto_priv.71+0x204>)
 80076c2:	480d      	ldr	r0, [pc, #52]	; (80076f8 <rt_test_003_002_execute.lto_priv.71+0x208>)
 80076c4:	f005 fd4c 	bl	800d160 <_test_assert_sequence>
  }
}
 80076c8:	b003      	add	sp, #12
 80076ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80076cc:	20003e04 	.word	0x20003e04
 80076d0:	20003aec 	.word	0x20003aec
 80076d4:	08007851 	.word	0x08007851
 80076d8:	200025f0 	.word	0x200025f0
 80076dc:	0800e830 	.word	0x0800e830
 80076e0:	20002f1c 	.word	0x20002f1c
 80076e4:	0800fa8c 	.word	0x0800fa8c
 80076e8:	08010ec4 	.word	0x08010ec4
 80076ec:	0800e698 	.word	0x0800e698
 80076f0:	0800e68c 	.word	0x0800e68c
 80076f4:	0800e6e8 	.word	0x0800e6e8
 80076f8:	0800e82c 	.word	0x0800e82c
 80076fc:	200027c0 	.word	0x200027c0

08007700 <rt_test_006_001_execute.lto_priv.91>:
static void rt_test_006_001_execute(void) {
 8007700:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8007704:	b082      	sub	sp, #8
  test_set_step(1);
 8007706:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 80077fc <rt_test_006_001_execute.lto_priv.91+0xfc>
  return ch.rlist.current;
 800770a:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 8007800 <rt_test_006_001_execute.lto_priv.91+0x100>
 800770e:	f8d9 3018 	ldr.w	r3, [r9, #24]
  return chThdGetSelfX()->prio;
 8007712:	689c      	ldr	r4, [r3, #8]
  test_set_step(2);
 8007714:	2302      	movs	r3, #2
 8007716:	f8c8 3000 	str.w	r3, [r8]
    chMtxLock(&m1);
 800771a:	f8df a0e8 	ldr.w	sl, [pc, #232]	; 8007804 <rt_test_006_001_execute.lto_priv.91+0x104>
 800771e:	4650      	mov	r0, sl
 8007720:	f004 f916 	bl	800b950 <chMtxLock>
  test_set_step(3);
 8007724:	2303      	movs	r3, #3
 8007726:	f8c8 3000 	str.w	r3, [r8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 800772a:	4f29      	ldr	r7, [pc, #164]	; (80077d0 <rt_test_006_001_execute.lto_priv.91+0xd0>)
 800772c:	4e29      	ldr	r6, [pc, #164]	; (80077d4 <rt_test_006_001_execute.lto_priv.91+0xd4>)
 800772e:	4b2a      	ldr	r3, [pc, #168]	; (80077d8 <rt_test_006_001_execute.lto_priv.91+0xd8>)
 8007730:	9300      	str	r3, [sp, #0]
 8007732:	463b      	mov	r3, r7
 8007734:	1c62      	adds	r2, r4, #1
 8007736:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800773a:	4630      	mov	r0, r6
 800773c:	f004 f818 	bl	800b770 <chThdCreateStatic>
 8007740:	4d26      	ldr	r5, [pc, #152]	; (80077dc <rt_test_006_001_execute.lto_priv.91+0xdc>)
 8007742:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 8007744:	4b26      	ldr	r3, [pc, #152]	; (80077e0 <rt_test_006_001_execute.lto_priv.91+0xe0>)
 8007746:	9300      	str	r3, [sp, #0]
 8007748:	463b      	mov	r3, r7
 800774a:	1ca2      	adds	r2, r4, #2
 800774c:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007750:	1870      	adds	r0, r6, r1
 8007752:	f004 f80d 	bl	800b770 <chThdCreateStatic>
 8007756:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8007758:	4b22      	ldr	r3, [pc, #136]	; (80077e4 <rt_test_006_001_execute.lto_priv.91+0xe4>)
 800775a:	9300      	str	r3, [sp, #0]
 800775c:	463b      	mov	r3, r7
 800775e:	1ce2      	adds	r2, r4, #3
 8007760:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007764:	f506 7068 	add.w	r0, r6, #928	; 0x3a0
 8007768:	f004 f802 	bl	800b770 <chThdCreateStatic>
 800776c:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 800776e:	4b1e      	ldr	r3, [pc, #120]	; (80077e8 <rt_test_006_001_execute.lto_priv.91+0xe8>)
 8007770:	9300      	str	r3, [sp, #0]
 8007772:	463b      	mov	r3, r7
 8007774:	1d22      	adds	r2, r4, #4
 8007776:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800777a:	f506 60ae 	add.w	r0, r6, #1392	; 0x570
 800777e:	f003 fff7 	bl	800b770 <chThdCreateStatic>
 8007782:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8007784:	4b19      	ldr	r3, [pc, #100]	; (80077ec <rt_test_006_001_execute.lto_priv.91+0xec>)
 8007786:	9300      	str	r3, [sp, #0]
 8007788:	463b      	mov	r3, r7
 800778a:	1d62      	adds	r2, r4, #5
 800778c:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007790:	f506 60e8 	add.w	r0, r6, #1856	; 0x740
 8007794:	f003 ffec 	bl	800b770 <chThdCreateStatic>
 8007798:	6128      	str	r0, [r5, #16]
  test_set_step(4);
 800779a:	2304      	movs	r3, #4
 800779c:	f8c8 3000 	str.w	r3, [r8]
    chMtxUnlock(&m1);
 80077a0:	4650      	mov	r0, sl
 80077a2:	f003 ff15 	bl	800b5d0 <chMtxUnlock>
    test_wait_threads();
 80077a6:	f005 f8cb 	bl	800c940 <test_wait_threads>
  return ch.rlist.current;
 80077aa:	f8d9 3018 	ldr.w	r3, [r9, #24]
  return chThdGetSelfX()->prio;
 80077ae:	6898      	ldr	r0, [r3, #8]
    test_assert(prio == chThdGetPriorityX(), "wrong priority level");
 80077b0:	490f      	ldr	r1, [pc, #60]	; (80077f0 <rt_test_006_001_execute.lto_priv.91+0xf0>)
 80077b2:	42a0      	cmp	r0, r4
 80077b4:	bf14      	ite	ne
 80077b6:	2000      	movne	r0, #0
 80077b8:	2001      	moveq	r0, #1
 80077ba:	f005 fcf9 	bl	800d1b0 <_test_assert>
 80077be:	b918      	cbnz	r0, 80077c8 <rt_test_006_001_execute.lto_priv.91+0xc8>
    test_assert_sequence("ABCDE", "invalid sequence");
 80077c0:	490c      	ldr	r1, [pc, #48]	; (80077f4 <rt_test_006_001_execute.lto_priv.91+0xf4>)
 80077c2:	480d      	ldr	r0, [pc, #52]	; (80077f8 <rt_test_006_001_execute.lto_priv.91+0xf8>)
 80077c4:	f005 fccc 	bl	800d160 <_test_assert_sequence>
}
 80077c8:	b002      	add	sp, #8
 80077ca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80077ce:	bf00      	nop
 80077d0:	08007811 	.word	0x08007811
 80077d4:	200025f0 	.word	0x200025f0
 80077d8:	0800e830 	.word	0x0800e830
 80077dc:	20002f1c 	.word	0x20002f1c
 80077e0:	0800fa8c 	.word	0x0800fa8c
 80077e4:	08010ec4 	.word	0x08010ec4
 80077e8:	0800e698 	.word	0x0800e698
 80077ec:	0800e68c 	.word	0x0800e68c
 80077f0:	0800e86c 	.word	0x0800e86c
 80077f4:	0800e6e8 	.word	0x0800e6e8
 80077f8:	0800e82c 	.word	0x0800e82c
 80077fc:	20003e04 	.word	0x20003e04
 8007800:	20003aec 	.word	0x20003aec
 8007804:	20002458 	.word	0x20002458
	...

08007810 <thread1.lto_priv.15>:
static THD_FUNCTION(thread1, p) {
 8007810:	b538      	push	{r3, r4, r5, lr}
 8007812:	4605      	mov	r5, r0
  chMtxLock(&m1);
 8007814:	4c05      	ldr	r4, [pc, #20]	; (800782c <thread1.lto_priv.15+0x1c>)
 8007816:	4620      	mov	r0, r4
 8007818:	f004 f89a 	bl	800b950 <chMtxLock>
  test_emit_token(*(char *)p);
 800781c:	7828      	ldrb	r0, [r5, #0]
 800781e:	f005 f8b7 	bl	800c990 <test_emit_token>
  chMtxUnlock(&m1);
 8007822:	4620      	mov	r0, r4
 8007824:	f003 fed4 	bl	800b5d0 <chMtxUnlock>
 8007828:	bd38      	pop	{r3, r4, r5, pc}
 800782a:	bf00      	nop
 800782c:	20002458 	.word	0x20002458

08007830 <thread9.lto_priv.9>:
static THD_FUNCTION(thread9, p) {
 8007830:	b538      	push	{r3, r4, r5, lr}
 8007832:	4605      	mov	r5, r0
  chMtxLock(&m2);
 8007834:	4c05      	ldr	r4, [pc, #20]	; (800784c <thread9.lto_priv.9+0x1c>)
 8007836:	4620      	mov	r0, r4
 8007838:	f004 f88a 	bl	800b950 <chMtxLock>
  test_emit_token(*(char *)p);
 800783c:	7828      	ldrb	r0, [r5, #0]
 800783e:	f005 f8a7 	bl	800c990 <test_emit_token>
  chMtxUnlock(&m2);
 8007842:	4620      	mov	r0, r4
 8007844:	f003 fec4 	bl	800b5d0 <chMtxUnlock>
 8007848:	bd38      	pop	{r3, r4, r5, pc}
 800784a:	bf00      	nop
 800784c:	20002448 	.word	0x20002448

08007850 <thread>:
static THD_FUNCTION(thread, p) {
 8007850:	b508      	push	{r3, lr}
  test_emit_token(*(char *)p);
 8007852:	7800      	ldrb	r0, [r0, #0]
 8007854:	f005 f89c 	bl	800c990 <test_emit_token>
 8007858:	bd08      	pop	{r3, pc}
 800785a:	bf00      	nop
 800785c:	0000      	movs	r0, r0
	...

08007860 <rt_test_006_001_setup.lto_priv.90>:
static void rt_test_006_001_setup(void) {
 8007860:	b508      	push	{r3, lr}
  chMtxObjectInit(&m1);
 8007862:	4802      	ldr	r0, [pc, #8]	; (800786c <rt_test_006_001_setup.lto_priv.90+0xc>)
 8007864:	f003 fcec 	bl	800b240 <chMtxObjectInit>
 8007868:	bd08      	pop	{r3, pc}
 800786a:	bf00      	nop
 800786c:	20002458 	.word	0x20002458

08007870 <thread8.lto_priv.7>:
static THD_FUNCTION(thread8, p) {
 8007870:	b570      	push	{r4, r5, r6, lr}
 8007872:	4606      	mov	r6, r0
  chMtxLock(&m2);
 8007874:	4c0b      	ldr	r4, [pc, #44]	; (80078a4 <thread8.lto_priv.7+0x34>)
 8007876:	4620      	mov	r0, r4
 8007878:	f004 f86a 	bl	800b950 <chMtxLock>
  chMtxLock(&m1);
 800787c:	4d0a      	ldr	r5, [pc, #40]	; (80078a8 <thread8.lto_priv.7+0x38>)
 800787e:	4628      	mov	r0, r5
 8007880:	f004 f866 	bl	800b950 <chMtxLock>
  chCondWaitTimeout(&c1, TIME_INFINITE);
 8007884:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8007888:	4808      	ldr	r0, [pc, #32]	; (80078ac <thread8.lto_priv.7+0x3c>)
 800788a:	f004 f961 	bl	800bb50 <chCondWaitTimeout>
  test_emit_token(*(char *)p);
 800788e:	7830      	ldrb	r0, [r6, #0]
 8007890:	f005 f87e 	bl	800c990 <test_emit_token>
  chMtxUnlock(&m1);
 8007894:	4628      	mov	r0, r5
 8007896:	f003 fe9b 	bl	800b5d0 <chMtxUnlock>
  chMtxUnlock(&m2);
 800789a:	4620      	mov	r0, r4
 800789c:	f003 fe98 	bl	800b5d0 <chMtxUnlock>
 80078a0:	bd70      	pop	{r4, r5, r6, pc}
 80078a2:	bf00      	nop
 80078a4:	20002448 	.word	0x20002448
 80078a8:	20002458 	.word	0x20002458
 80078ac:	2000246c 	.word	0x2000246c

080078b0 <thread6.lto_priv.8>:
static THD_FUNCTION(thread6, p) {
 80078b0:	b538      	push	{r3, r4, r5, lr}
 80078b2:	4605      	mov	r5, r0
  chMtxLock(&m1);
 80078b4:	4c06      	ldr	r4, [pc, #24]	; (80078d0 <thread6.lto_priv.8+0x20>)
 80078b6:	4620      	mov	r0, r4
 80078b8:	f004 f84a 	bl	800b950 <chMtxLock>
  chCondWait(&c1);
 80078bc:	4805      	ldr	r0, [pc, #20]	; (80078d4 <thread6.lto_priv.8+0x24>)
 80078be:	f004 f837 	bl	800b930 <chCondWait>
  test_emit_token(*(char *)p);
 80078c2:	7828      	ldrb	r0, [r5, #0]
 80078c4:	f005 f864 	bl	800c990 <test_emit_token>
  chMtxUnlock(&m1);
 80078c8:	4620      	mov	r0, r4
 80078ca:	f003 fe81 	bl	800b5d0 <chMtxUnlock>
 80078ce:	bd38      	pop	{r3, r4, r5, pc}
 80078d0:	20002458 	.word	0x20002458
 80078d4:	2000246c 	.word	0x2000246c
	...

080078e0 <thread4B.lto_priv.11>:
static THD_FUNCTION(thread4B, p) {
 80078e0:	b510      	push	{r4, lr}
  chThdSleepMilliseconds(150);
 80078e2:	f240 50dc 	movw	r0, #1500	; 0x5dc
 80078e6:	f004 f9b3 	bl	800bc50 <chThdSleep>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80078ea:	2320      	movs	r3, #32
 80078ec:	f383 8811 	msr	BASEPRI, r3
  chMtxLockS(&m2);   /* For coverage of the chMtxLockS() function variant.*/
 80078f0:	4c06      	ldr	r4, [pc, #24]	; (800790c <thread4B.lto_priv.11+0x2c>)
 80078f2:	4620      	mov	r0, r4
 80078f4:	f003 ff8c 	bl	800b810 <chMtxLockS>
  chMtxUnlockS(&m2); /* For coverage of the chMtxUnlockS() function variant.*/
 80078f8:	4620      	mov	r0, r4
 80078fa:	f003 fc69 	bl	800b1d0 <chMtxUnlockS>
  chSchRescheduleS();
 80078fe:	f003 fe0f 	bl	800b520 <chSchRescheduleS>
 8007902:	2300      	movs	r3, #0
 8007904:	f383 8811 	msr	BASEPRI, r3
 8007908:	bd10      	pop	{r4, pc}
 800790a:	bf00      	nop
 800790c:	20002448 	.word	0x20002448

08007910 <thread4A.lto_priv.10>:
static THD_FUNCTION(thread4A, p) {
 8007910:	b510      	push	{r4, lr}
  chThdSleepMilliseconds(50);
 8007912:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8007916:	f004 f99b 	bl	800bc50 <chThdSleep>
  chMtxLock(&m1);
 800791a:	4c04      	ldr	r4, [pc, #16]	; (800792c <thread4A.lto_priv.10+0x1c>)
 800791c:	4620      	mov	r0, r4
 800791e:	f004 f817 	bl	800b950 <chMtxLock>
  chMtxUnlock(&m1);
 8007922:	4620      	mov	r0, r4
 8007924:	f003 fe54 	bl	800b5d0 <chMtxUnlock>
 8007928:	bd10      	pop	{r4, pc}
 800792a:	bf00      	nop
 800792c:	20002458 	.word	0x20002458

08007930 <thread1.lto_priv.14>:
static THD_FUNCTION(thread1, p) {
 8007930:	b510      	push	{r4, lr}
 8007932:	4604      	mov	r4, r0
  chSemWait(&sem1);
 8007934:	4803      	ldr	r0, [pc, #12]	; (8007944 <thread1.lto_priv.14+0x14>)
 8007936:	f004 f863 	bl	800ba00 <chSemWait>
  test_emit_token(*(char *)p);
 800793a:	7820      	ldrb	r0, [r4, #0]
 800793c:	f005 f828 	bl	800c990 <test_emit_token>
 8007940:	bd10      	pop	{r4, pc}
 8007942:	bf00      	nop
 8007944:	20003104 	.word	0x20003104
	...

08007950 <rt_test_005_001_teardown.lto_priv.77>:
static void rt_test_005_001_teardown(void) {
 8007950:	b508      	push	{r3, lr}
  chSemReset(&sem1, 0);
 8007952:	2100      	movs	r1, #0
 8007954:	4801      	ldr	r0, [pc, #4]	; (800795c <rt_test_005_001_teardown.lto_priv.77+0xc>)
 8007956:	f003 fe6b 	bl	800b630 <chSemReset>
 800795a:	bd08      	pop	{r3, pc}
 800795c:	20003104 	.word	0x20003104

08007960 <rt_test_005_005_setup.lto_priv.85>:
static void rt_test_005_005_setup(void) {
 8007960:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 0);
 8007962:	2100      	movs	r1, #0
 8007964:	4801      	ldr	r0, [pc, #4]	; (800796c <rt_test_005_005_setup.lto_priv.85+0xc>)
 8007966:	f003 fc9b 	bl	800b2a0 <chSemObjectInit>
 800796a:	bd08      	pop	{r3, pc}
 800796c:	20003104 	.word	0x20003104

08007970 <rt_test_005_004_setup.lto_priv.83>:
static void rt_test_005_004_setup(void) {
 8007970:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 0);
 8007972:	2100      	movs	r1, #0
 8007974:	4801      	ldr	r0, [pc, #4]	; (800797c <rt_test_005_004_setup.lto_priv.83+0xc>)
 8007976:	f003 fc93 	bl	800b2a0 <chSemObjectInit>
 800797a:	bd08      	pop	{r3, pc}
 800797c:	20003104 	.word	0x20003104

08007980 <rt_test_005_003_setup.lto_priv.81>:
static void rt_test_005_003_setup(void) {
 8007980:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 0);
 8007982:	2100      	movs	r1, #0
 8007984:	4801      	ldr	r0, [pc, #4]	; (800798c <rt_test_005_003_setup.lto_priv.81+0xc>)
 8007986:	f003 fc8b 	bl	800b2a0 <chSemObjectInit>
 800798a:	bd08      	pop	{r3, pc}
 800798c:	20003104 	.word	0x20003104

08007990 <rt_test_005_002_setup.lto_priv.79>:
static void rt_test_005_002_setup(void) {
 8007990:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 0);
 8007992:	2100      	movs	r1, #0
 8007994:	4801      	ldr	r0, [pc, #4]	; (800799c <rt_test_005_002_setup.lto_priv.79+0xc>)
 8007996:	f003 fc83 	bl	800b2a0 <chSemObjectInit>
 800799a:	bd08      	pop	{r3, pc}
 800799c:	20003104 	.word	0x20003104

080079a0 <rt_test_005_001_setup.lto_priv.76>:
static void rt_test_005_001_setup(void) {
 80079a0:	b508      	push	{r3, lr}
  chSemObjectInit(&sem1, 1);
 80079a2:	2101      	movs	r1, #1
 80079a4:	4801      	ldr	r0, [pc, #4]	; (80079ac <rt_test_005_001_setup.lto_priv.76+0xc>)
 80079a6:	f003 fc7b 	bl	800b2a0 <chSemObjectInit>
 80079aa:	bd08      	pop	{r3, pc}
 80079ac:	20003104 	.word	0x20003104

080079b0 <rt_test_005_006_execute.lto_priv.89>:
}

static void rt_test_005_006_execute(void) {
 80079b0:	b530      	push	{r4, r5, lr}
 80079b2:	b087      	sub	sp, #28
  binary_semaphore_t bsem;
  msg_t msg;

  /* [5.6.1] Creating a binary semaphore in "taken" state, the state is
     checked.*/
  test_set_step(1);
 80079b4:	2201      	movs	r2, #1
 80079b6:	4b6a      	ldr	r3, [pc, #424]	; (8007b60 <rt_test_005_006_execute.lto_priv.89+0x1b0>)
 80079b8:	601a      	str	r2, [r3, #0]
 *
 * @init
 */
static inline void chBSemObjectInit(binary_semaphore_t *bsp, bool taken) {

  chSemObjectInit(&bsp->sem, taken ? (cnt_t)0 : (cnt_t)1);
 80079ba:	2100      	movs	r1, #0
 80079bc:	a803      	add	r0, sp, #12
 80079be:	f003 fc6f 	bl	800b2a0 <chSemObjectInit>
 80079c2:	2320      	movs	r3, #32
 80079c4:	f383 8811 	msr	BASEPRI, r3
  {
    chBSemObjectInit(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 80079c8:	4966      	ldr	r1, [pc, #408]	; (8007b64 <rt_test_005_006_execute.lto_priv.89+0x1b4>)
 80079ca:	9805      	ldr	r0, [sp, #20]
 80079cc:	2800      	cmp	r0, #0
 80079ce:	bfcc      	ite	gt
 80079d0:	2000      	movgt	r0, #0
 80079d2:	2001      	movle	r0, #1
 80079d4:	f005 fbec 	bl	800d1b0 <_test_assert>
 80079d8:	b118      	cbz	r0, 80079e2 <rt_test_005_006_execute.lto_priv.89+0x32>
 80079da:	2300      	movs	r3, #0
 80079dc:	f383 8811 	msr	BASEPRI, r3
 80079e0:	e0bb      	b.n	8007b5a <rt_test_005_006_execute.lto_priv.89+0x1aa>
 80079e2:	2100      	movs	r1, #0
 80079e4:	f381 8811 	msr	BASEPRI, r1
  }

  /* [5.6.2] Resetting the binary semaphore in "taken" state, the state
     must not change.*/
  test_set_step(2);
 80079e8:	2202      	movs	r2, #2
 80079ea:	4b5d      	ldr	r3, [pc, #372]	; (8007b60 <rt_test_005_006_execute.lto_priv.89+0x1b0>)
 80079ec:	601a      	str	r2, [r3, #0]
 *
 * @api
 */
static inline void chBSemReset(binary_semaphore_t *bsp, bool taken) {

  chSemReset(&bsp->sem, taken ? (cnt_t)0 : (cnt_t)1);
 80079ee:	a803      	add	r0, sp, #12
 80079f0:	f003 fe1e 	bl	800b630 <chSemReset>
 80079f4:	2320      	movs	r3, #32
 80079f6:	f383 8811 	msr	BASEPRI, r3
  {
    chBSemReset(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 80079fa:	495a      	ldr	r1, [pc, #360]	; (8007b64 <rt_test_005_006_execute.lto_priv.89+0x1b4>)
 80079fc:	9805      	ldr	r0, [sp, #20]
 80079fe:	2800      	cmp	r0, #0
 8007a00:	bfcc      	ite	gt
 8007a02:	2000      	movgt	r0, #0
 8007a04:	2001      	movle	r0, #1
 8007a06:	f005 fbd3 	bl	800d1b0 <_test_assert>
 8007a0a:	b118      	cbz	r0, 8007a14 <rt_test_005_006_execute.lto_priv.89+0x64>
 8007a0c:	2300      	movs	r3, #0
 8007a0e:	f383 8811 	msr	BASEPRI, r3
 8007a12:	e0a2      	b.n	8007b5a <rt_test_005_006_execute.lto_priv.89+0x1aa>
 8007a14:	2300      	movs	r3, #0
 8007a16:	f383 8811 	msr	BASEPRI, r3
  }

  /* [5.6.3] Starting a signaler thread at a lower priority.*/
  test_set_step(3);
 8007a1a:	4d51      	ldr	r5, [pc, #324]	; (8007b60 <rt_test_005_006_execute.lto_priv.89+0x1b0>)
 8007a1c:	2303      	movs	r3, #3
 8007a1e:	602b      	str	r3, [r5, #0]
  return ch.rlist.current;
 8007a20:	4b51      	ldr	r3, [pc, #324]	; (8007b68 <rt_test_005_006_execute.lto_priv.89+0x1b8>)
 8007a22:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 8007a24:	689a      	ldr	r2, [r3, #8]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8007a26:	ac03      	add	r4, sp, #12
 8007a28:	9400      	str	r4, [sp, #0]
 8007a2a:	4b50      	ldr	r3, [pc, #320]	; (8007b6c <rt_test_005_006_execute.lto_priv.89+0x1bc>)
 8007a2c:	3a01      	subs	r2, #1
 8007a2e:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007a32:	484f      	ldr	r0, [pc, #316]	; (8007b70 <rt_test_005_006_execute.lto_priv.89+0x1c0>)
 8007a34:	f003 fe9c 	bl	800b770 <chThdCreateStatic>
 8007a38:	4b4e      	ldr	r3, [pc, #312]	; (8007b74 <rt_test_005_006_execute.lto_priv.89+0x1c4>)
 8007a3a:	6018      	str	r0, [r3, #0]
                                   chThdGetPriorityX()-1, thread4, &bsem);
  }

  /* [5.6.4] Waiting for the binary semaphore to be signaled, the
     semaphore is expected to be taken.*/
  test_set_step(4);
 8007a3c:	2304      	movs	r3, #4
 8007a3e:	602b      	str	r3, [r5, #0]
  return chSemWait(&bsp->sem);
 8007a40:	4620      	mov	r0, r4
 8007a42:	f003 ffdd 	bl	800ba00 <chSemWait>
 8007a46:	4604      	mov	r4, r0
 8007a48:	2320      	movs	r3, #32
 8007a4a:	f383 8811 	msr	BASEPRI, r3
  {
    msg = chBSemWait(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 8007a4e:	4945      	ldr	r1, [pc, #276]	; (8007b64 <rt_test_005_006_execute.lto_priv.89+0x1b4>)
 8007a50:	9805      	ldr	r0, [sp, #20]
 8007a52:	2800      	cmp	r0, #0
 8007a54:	bfcc      	ite	gt
 8007a56:	2000      	movgt	r0, #0
 8007a58:	2001      	movle	r0, #1
 8007a5a:	f005 fba9 	bl	800d1b0 <_test_assert>
 8007a5e:	b118      	cbz	r0, 8007a68 <rt_test_005_006_execute.lto_priv.89+0xb8>
 8007a60:	2300      	movs	r3, #0
 8007a62:	f383 8811 	msr	BASEPRI, r3
 8007a66:	e078      	b.n	8007b5a <rt_test_005_006_execute.lto_priv.89+0x1aa>
 8007a68:	2300      	movs	r3, #0
 8007a6a:	f383 8811 	msr	BASEPRI, r3
    test_assert(msg == MSG_OK, "unexpected message");
 8007a6e:	4942      	ldr	r1, [pc, #264]	; (8007b78 <rt_test_005_006_execute.lto_priv.89+0x1c8>)
 8007a70:	fab4 f084 	clz	r0, r4
 8007a74:	0940      	lsrs	r0, r0, #5
 8007a76:	f005 fb9b 	bl	800d1b0 <_test_assert>
 8007a7a:	2800      	cmp	r0, #0
 8007a7c:	d16d      	bne.n	8007b5a <rt_test_005_006_execute.lto_priv.89+0x1aa>
  }

  /* [5.6.5] Signaling the binary semaphore, checking the binary
     semaphore state to be "not taken" and the underlying counter
     semaphore counter to be one.*/
  test_set_step(5);
 8007a7e:	2205      	movs	r2, #5
 8007a80:	4b37      	ldr	r3, [pc, #220]	; (8007b60 <rt_test_005_006_execute.lto_priv.89+0x1b0>)
 8007a82:	601a      	str	r2, [r3, #0]
 8007a84:	2320      	movs	r3, #32
 8007a86:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
 8007a8a:	9b05      	ldr	r3, [sp, #20]
 8007a8c:	2b00      	cmp	r3, #0
 8007a8e:	dc02      	bgt.n	8007a96 <rt_test_005_006_execute.lto_priv.89+0xe6>
    chSemSignalI(&bsp->sem);
 8007a90:	a803      	add	r0, sp, #12
 8007a92:	f003 fbf5 	bl	800b280 <chSemSignalI>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 8007a96:	f003 fd43 	bl	800b520 <chSchRescheduleS>
 8007a9a:	2300      	movs	r3, #0
 8007a9c:	f383 8811 	msr	BASEPRI, r3
 8007aa0:	2320      	movs	r3, #32
 8007aa2:	f383 8811 	msr	BASEPRI, r3
  {
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) ==false, "still taken");
 8007aa6:	4935      	ldr	r1, [pc, #212]	; (8007b7c <rt_test_005_006_execute.lto_priv.89+0x1cc>)
 8007aa8:	9805      	ldr	r0, [sp, #20]
 8007aaa:	2800      	cmp	r0, #0
 8007aac:	bfd4      	ite	le
 8007aae:	2000      	movle	r0, #0
 8007ab0:	2001      	movgt	r0, #1
 8007ab2:	f005 fb7d 	bl	800d1b0 <_test_assert>
 8007ab6:	b118      	cbz	r0, 8007ac0 <rt_test_005_006_execute.lto_priv.89+0x110>
 8007ab8:	2300      	movs	r3, #0
 8007aba:	f383 8811 	msr	BASEPRI, r3
 8007abe:	e04c      	b.n	8007b5a <rt_test_005_006_execute.lto_priv.89+0x1aa>
 8007ac0:	2300      	movs	r3, #0
 8007ac2:	f383 8811 	msr	BASEPRI, r3
 8007ac6:	2320      	movs	r3, #32
 8007ac8:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 8007acc:	492c      	ldr	r1, [pc, #176]	; (8007b80 <rt_test_005_006_execute.lto_priv.89+0x1d0>)
 8007ace:	9805      	ldr	r0, [sp, #20]
 8007ad0:	2801      	cmp	r0, #1
 8007ad2:	bf14      	ite	ne
 8007ad4:	2000      	movne	r0, #0
 8007ad6:	2001      	moveq	r0, #1
 8007ad8:	f005 fb6a 	bl	800d1b0 <_test_assert>
 8007adc:	b118      	cbz	r0, 8007ae6 <rt_test_005_006_execute.lto_priv.89+0x136>
 8007ade:	2300      	movs	r3, #0
 8007ae0:	f383 8811 	msr	BASEPRI, r3
 8007ae4:	e039      	b.n	8007b5a <rt_test_005_006_execute.lto_priv.89+0x1aa>
 8007ae6:	2300      	movs	r3, #0
 8007ae8:	f383 8811 	msr	BASEPRI, r3
  }

  /* [5.6.6] Signaling the binary semaphore again, the internal state
     must not change from "not taken".*/
  test_set_step(6);
 8007aec:	2206      	movs	r2, #6
 8007aee:	4b1c      	ldr	r3, [pc, #112]	; (8007b60 <rt_test_005_006_execute.lto_priv.89+0x1b0>)
 8007af0:	601a      	str	r2, [r3, #0]
 8007af2:	2320      	movs	r3, #32
 8007af4:	f383 8811 	msr	BASEPRI, r3
  if (bsp->sem.cnt < (cnt_t)1) {
 8007af8:	9b05      	ldr	r3, [sp, #20]
 8007afa:	2b00      	cmp	r3, #0
 8007afc:	dc02      	bgt.n	8007b04 <rt_test_005_006_execute.lto_priv.89+0x154>
    chSemSignalI(&bsp->sem);
 8007afe:	a803      	add	r0, sp, #12
 8007b00:	f003 fbbe 	bl	800b280 <chSemSignalI>
  chSchRescheduleS();
 8007b04:	f003 fd0c 	bl	800b520 <chSchRescheduleS>
 8007b08:	2300      	movs	r3, #0
 8007b0a:	f383 8811 	msr	BASEPRI, r3
 8007b0e:	2320      	movs	r3, #32
 8007b10:	f383 8811 	msr	BASEPRI, r3
  {
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
 8007b14:	491b      	ldr	r1, [pc, #108]	; (8007b84 <rt_test_005_006_execute.lto_priv.89+0x1d4>)
 8007b16:	9805      	ldr	r0, [sp, #20]
 8007b18:	2800      	cmp	r0, #0
 8007b1a:	bfd4      	ite	le
 8007b1c:	2000      	movle	r0, #0
 8007b1e:	2001      	movgt	r0, #1
 8007b20:	f005 fb46 	bl	800d1b0 <_test_assert>
 8007b24:	b118      	cbz	r0, 8007b2e <rt_test_005_006_execute.lto_priv.89+0x17e>
 8007b26:	2300      	movs	r3, #0
 8007b28:	f383 8811 	msr	BASEPRI, r3
 8007b2c:	e015      	b.n	8007b5a <rt_test_005_006_execute.lto_priv.89+0x1aa>
 8007b2e:	2300      	movs	r3, #0
 8007b30:	f383 8811 	msr	BASEPRI, r3
 8007b34:	2320      	movs	r3, #32
 8007b36:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 8007b3a:	4911      	ldr	r1, [pc, #68]	; (8007b80 <rt_test_005_006_execute.lto_priv.89+0x1d0>)
 8007b3c:	9805      	ldr	r0, [sp, #20]
 8007b3e:	2801      	cmp	r0, #1
 8007b40:	bf14      	ite	ne
 8007b42:	2000      	movne	r0, #0
 8007b44:	2001      	moveq	r0, #1
 8007b46:	f005 fb33 	bl	800d1b0 <_test_assert>
 8007b4a:	b118      	cbz	r0, 8007b54 <rt_test_005_006_execute.lto_priv.89+0x1a4>
 8007b4c:	2300      	movs	r3, #0
 8007b4e:	f383 8811 	msr	BASEPRI, r3
 8007b52:	e002      	b.n	8007b5a <rt_test_005_006_execute.lto_priv.89+0x1aa>
 8007b54:	2300      	movs	r3, #0
 8007b56:	f383 8811 	msr	BASEPRI, r3
  }
}
 8007b5a:	b007      	add	sp, #28
 8007b5c:	bd30      	pop	{r4, r5, pc}
 8007b5e:	bf00      	nop
 8007b60:	20003e04 	.word	0x20003e04
 8007b64:	0800e9e4 	.word	0x0800e9e4
 8007b68:	20003aec 	.word	0x20003aec
 8007b6c:	08007bc1 	.word	0x08007bc1
 8007b70:	200025f0 	.word	0x200025f0
 8007b74:	20002f1c 	.word	0x20002f1c
 8007b78:	0800e9f0 	.word	0x0800e9f0
 8007b7c:	0800ea04 	.word	0x0800ea04
 8007b80:	0800ea10 	.word	0x0800ea10
 8007b84:	0800e9e8 	.word	0x0800e9e8
	...

08007b90 <thread2>:
static THD_FUNCTION(thread2, p) {
 8007b90:	b508      	push	{r3, lr}
  chThdSleepMilliseconds(50);
 8007b92:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8007b96:	f004 f85b 	bl	800bc50 <chThdSleep>
 8007b9a:	2320      	movs	r3, #32
 8007b9c:	f383 8811 	msr	BASEPRI, r3
  chSemSignalI(&sem1); /* For coverage reasons */
 8007ba0:	4804      	ldr	r0, [pc, #16]	; (8007bb4 <thread2+0x24>)
 8007ba2:	f003 fb6d 	bl	800b280 <chSemSignalI>
  chSchRescheduleS();
 8007ba6:	f003 fcbb 	bl	800b520 <chSchRescheduleS>
 8007baa:	2300      	movs	r3, #0
 8007bac:	f383 8811 	msr	BASEPRI, r3
 8007bb0:	bd08      	pop	{r3, pc}
 8007bb2:	bf00      	nop
 8007bb4:	20003104 	.word	0x20003104
	...

08007bc0 <thread4>:
static THD_FUNCTION(thread4, p) {
 8007bc0:	b508      	push	{r3, lr}
 8007bc2:	2320      	movs	r3, #32
 8007bc4:	f383 8811 	msr	BASEPRI, r3
  if (bsp->sem.cnt < (cnt_t)1) {
 8007bc8:	6883      	ldr	r3, [r0, #8]
 8007bca:	2b00      	cmp	r3, #0
 8007bcc:	dc01      	bgt.n	8007bd2 <thread4+0x12>
    chSemSignalI(&bsp->sem);
 8007bce:	f003 fb57 	bl	800b280 <chSemSignalI>
  chSchRescheduleS();
 8007bd2:	f003 fca5 	bl	800b520 <chSchRescheduleS>
 8007bd6:	2300      	movs	r3, #0
 8007bd8:	f383 8811 	msr	BASEPRI, r3
 8007bdc:	bd08      	pop	{r3, pc}
 8007bde:	bf00      	nop

08007be0 <rt_test_005_005_execute.lto_priv.87>:
static void rt_test_005_005_execute(void) {
 8007be0:	b510      	push	{r4, lr}
 8007be2:	b082      	sub	sp, #8
  test_set_step(1);
 8007be4:	4c20      	ldr	r4, [pc, #128]	; (8007c68 <rt_test_005_005_execute.lto_priv.87+0x88>)
 8007be6:	2301      	movs	r3, #1
 8007be8:	6023      	str	r3, [r4, #0]
  return ch.rlist.current;
 8007bea:	4b20      	ldr	r3, [pc, #128]	; (8007c6c <rt_test_005_005_execute.lto_priv.87+0x8c>)
 8007bec:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 8007bee:	689a      	ldr	r2, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8007bf0:	2300      	movs	r3, #0
 8007bf2:	9300      	str	r3, [sp, #0]
 8007bf4:	4b1e      	ldr	r3, [pc, #120]	; (8007c70 <rt_test_005_005_execute.lto_priv.87+0x90>)
 8007bf6:	3201      	adds	r2, #1
 8007bf8:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007bfc:	481d      	ldr	r0, [pc, #116]	; (8007c74 <rt_test_005_005_execute.lto_priv.87+0x94>)
 8007bfe:	f003 fdb7 	bl	800b770 <chThdCreateStatic>
 8007c02:	4b1d      	ldr	r3, [pc, #116]	; (8007c78 <rt_test_005_005_execute.lto_priv.87+0x98>)
 8007c04:	6018      	str	r0, [r3, #0]
  test_set_step(2);
 8007c06:	2302      	movs	r3, #2
 8007c08:	6023      	str	r3, [r4, #0]
    chSemSignalWait(&sem1, &sem1);
 8007c0a:	4c1c      	ldr	r4, [pc, #112]	; (8007c7c <rt_test_005_005_execute.lto_priv.87+0x9c>)
 8007c0c:	4621      	mov	r1, r4
 8007c0e:	4620      	mov	r0, r4
 8007c10:	f003 feae 	bl	800b970 <chSemSignalWait>
  return (bool)(tqp->next == (const thread_t *)tqp);
 8007c14:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8007c16:	491a      	ldr	r1, [pc, #104]	; (8007c80 <rt_test_005_005_execute.lto_priv.87+0xa0>)
 8007c18:	42a0      	cmp	r0, r4
 8007c1a:	bf14      	ite	ne
 8007c1c:	2000      	movne	r0, #0
 8007c1e:	2001      	moveq	r0, #1
 8007c20:	f005 fac6 	bl	800d1b0 <_test_assert>
 8007c24:	b9f0      	cbnz	r0, 8007c64 <rt_test_005_005_execute.lto_priv.87+0x84>
    test_assert(sem1.cnt == 0, "counter not zero");
 8007c26:	68a0      	ldr	r0, [r4, #8]
 8007c28:	4916      	ldr	r1, [pc, #88]	; (8007c84 <rt_test_005_005_execute.lto_priv.87+0xa4>)
 8007c2a:	fab0 f080 	clz	r0, r0
 8007c2e:	0940      	lsrs	r0, r0, #5
 8007c30:	f005 fabe 	bl	800d1b0 <_test_assert>
 8007c34:	b9b0      	cbnz	r0, 8007c64 <rt_test_005_005_execute.lto_priv.87+0x84>
  test_set_step(3);
 8007c36:	2203      	movs	r2, #3
 8007c38:	4b0b      	ldr	r3, [pc, #44]	; (8007c68 <rt_test_005_005_execute.lto_priv.87+0x88>)
 8007c3a:	601a      	str	r2, [r3, #0]
    chSemSignalWait(&sem1, &sem1);
 8007c3c:	4621      	mov	r1, r4
 8007c3e:	4620      	mov	r0, r4
 8007c40:	f003 fe96 	bl	800b970 <chSemSignalWait>
 8007c44:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8007c46:	490e      	ldr	r1, [pc, #56]	; (8007c80 <rt_test_005_005_execute.lto_priv.87+0xa0>)
 8007c48:	42a0      	cmp	r0, r4
 8007c4a:	bf14      	ite	ne
 8007c4c:	2000      	movne	r0, #0
 8007c4e:	2001      	moveq	r0, #1
 8007c50:	f005 faae 	bl	800d1b0 <_test_assert>
 8007c54:	b930      	cbnz	r0, 8007c64 <rt_test_005_005_execute.lto_priv.87+0x84>
    test_assert(sem1.cnt == 0, "counter not zero");
 8007c56:	68a0      	ldr	r0, [r4, #8]
 8007c58:	490a      	ldr	r1, [pc, #40]	; (8007c84 <rt_test_005_005_execute.lto_priv.87+0xa4>)
 8007c5a:	fab0 f080 	clz	r0, r0
 8007c5e:	0940      	lsrs	r0, r0, #5
 8007c60:	f005 faa6 	bl	800d1b0 <_test_assert>
}
 8007c64:	b002      	add	sp, #8
 8007c66:	bd10      	pop	{r4, pc}
 8007c68:	20003e04 	.word	0x20003e04
 8007c6c:	20003aec 	.word	0x20003aec
 8007c70:	08007c91 	.word	0x08007c91
 8007c74:	200025f0 	.word	0x200025f0
 8007c78:	20002f1c 	.word	0x20002f1c
 8007c7c:	20003104 	.word	0x20003104
 8007c80:	0800e85c 	.word	0x0800e85c
 8007c84:	0800ea24 	.word	0x0800ea24
	...

08007c90 <thread3>:
static THD_FUNCTION(thread3, p) {
 8007c90:	b510      	push	{r4, lr}
  chSemWait(&sem1);
 8007c92:	4c04      	ldr	r4, [pc, #16]	; (8007ca4 <thread3+0x14>)
 8007c94:	4620      	mov	r0, r4
 8007c96:	f003 feb3 	bl	800ba00 <chSemWait>
  chSemSignal(&sem1);
 8007c9a:	4620      	mov	r0, r4
 8007c9c:	f003 fd30 	bl	800b700 <chSemSignal>
 8007ca0:	bd10      	pop	{r4, pc}
 8007ca2:	bf00      	nop
 8007ca4:	20003104 	.word	0x20003104
	...

08007cb0 <rt_test_005_002_execute.lto_priv.80>:
static void rt_test_005_002_execute(void) {
 8007cb0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007cb4:	b082      	sub	sp, #8
  test_set_step(1);
 8007cb6:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 8007db0 <rt_test_005_002_execute.lto_priv.80+0x100>
 8007cba:	2301      	movs	r3, #1
 8007cbc:	f8c8 3000 	str.w	r3, [r8]
  return ch.rlist.current;
 8007cc0:	4f2f      	ldr	r7, [pc, #188]	; (8007d80 <rt_test_005_002_execute.lto_priv.80+0xd0>)
 8007cc2:	69bb      	ldr	r3, [r7, #24]
  return chThdGetSelfX()->prio;
 8007cc4:	689a      	ldr	r2, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8007cc6:	4e2f      	ldr	r6, [pc, #188]	; (8007d84 <rt_test_005_002_execute.lto_priv.80+0xd4>)
 8007cc8:	4d2f      	ldr	r5, [pc, #188]	; (8007d88 <rt_test_005_002_execute.lto_priv.80+0xd8>)
 8007cca:	4b30      	ldr	r3, [pc, #192]	; (8007d8c <rt_test_005_002_execute.lto_priv.80+0xdc>)
 8007ccc:	9300      	str	r3, [sp, #0]
 8007cce:	4633      	mov	r3, r6
 8007cd0:	3205      	adds	r2, #5
 8007cd2:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007cd6:	4628      	mov	r0, r5
 8007cd8:	f003 fd4a 	bl	800b770 <chThdCreateStatic>
 8007cdc:	4c2c      	ldr	r4, [pc, #176]	; (8007d90 <rt_test_005_002_execute.lto_priv.80+0xe0>)
 8007cde:	6020      	str	r0, [r4, #0]
  return ch.rlist.current;
 8007ce0:	69bb      	ldr	r3, [r7, #24]
  return chThdGetSelfX()->prio;
 8007ce2:	689a      	ldr	r2, [r3, #8]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 8007ce4:	4b2b      	ldr	r3, [pc, #172]	; (8007d94 <rt_test_005_002_execute.lto_priv.80+0xe4>)
 8007ce6:	9300      	str	r3, [sp, #0]
 8007ce8:	4633      	mov	r3, r6
 8007cea:	3201      	adds	r2, #1
 8007cec:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007cf0:	1868      	adds	r0, r5, r1
 8007cf2:	f003 fd3d 	bl	800b770 <chThdCreateStatic>
 8007cf6:	6060      	str	r0, [r4, #4]
  return ch.rlist.current;
 8007cf8:	69bb      	ldr	r3, [r7, #24]
  return chThdGetSelfX()->prio;
 8007cfa:	689a      	ldr	r2, [r3, #8]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8007cfc:	4b26      	ldr	r3, [pc, #152]	; (8007d98 <rt_test_005_002_execute.lto_priv.80+0xe8>)
 8007cfe:	9300      	str	r3, [sp, #0]
 8007d00:	4633      	mov	r3, r6
 8007d02:	3203      	adds	r2, #3
 8007d04:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007d08:	f505 7068 	add.w	r0, r5, #928	; 0x3a0
 8007d0c:	f003 fd30 	bl	800b770 <chThdCreateStatic>
 8007d10:	60a0      	str	r0, [r4, #8]
  return ch.rlist.current;
 8007d12:	69bb      	ldr	r3, [r7, #24]
  return chThdGetSelfX()->prio;
 8007d14:	689a      	ldr	r2, [r3, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8007d16:	4b21      	ldr	r3, [pc, #132]	; (8007d9c <rt_test_005_002_execute.lto_priv.80+0xec>)
 8007d18:	9300      	str	r3, [sp, #0]
 8007d1a:	4633      	mov	r3, r6
 8007d1c:	3204      	adds	r2, #4
 8007d1e:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007d22:	f505 60ae 	add.w	r0, r5, #1392	; 0x570
 8007d26:	f003 fd23 	bl	800b770 <chThdCreateStatic>
 8007d2a:	60e0      	str	r0, [r4, #12]
  return ch.rlist.current;
 8007d2c:	69bb      	ldr	r3, [r7, #24]
  return chThdGetSelfX()->prio;
 8007d2e:	689a      	ldr	r2, [r3, #8]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8007d30:	4b1b      	ldr	r3, [pc, #108]	; (8007da0 <rt_test_005_002_execute.lto_priv.80+0xf0>)
 8007d32:	9300      	str	r3, [sp, #0]
 8007d34:	4633      	mov	r3, r6
 8007d36:	3202      	adds	r2, #2
 8007d38:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007d3c:	f505 60e8 	add.w	r0, r5, #1856	; 0x740
 8007d40:	f003 fd16 	bl	800b770 <chThdCreateStatic>
 8007d44:	6120      	str	r0, [r4, #16]
  test_set_step(2);
 8007d46:	2302      	movs	r3, #2
 8007d48:	f8c8 3000 	str.w	r3, [r8]
    chSemSignal(&sem1);
 8007d4c:	4c15      	ldr	r4, [pc, #84]	; (8007da4 <rt_test_005_002_execute.lto_priv.80+0xf4>)
 8007d4e:	4620      	mov	r0, r4
 8007d50:	f003 fcd6 	bl	800b700 <chSemSignal>
    chSemSignal(&sem1);
 8007d54:	4620      	mov	r0, r4
 8007d56:	f003 fcd3 	bl	800b700 <chSemSignal>
    chSemSignal(&sem1);
 8007d5a:	4620      	mov	r0, r4
 8007d5c:	f003 fcd0 	bl	800b700 <chSemSignal>
    chSemSignal(&sem1);
 8007d60:	4620      	mov	r0, r4
 8007d62:	f003 fccd 	bl	800b700 <chSemSignal>
    chSemSignal(&sem1);
 8007d66:	4620      	mov	r0, r4
 8007d68:	f003 fcca 	bl	800b700 <chSemSignal>
    test_wait_threads();
 8007d6c:	f004 fde8 	bl	800c940 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8007d70:	490d      	ldr	r1, [pc, #52]	; (8007da8 <rt_test_005_002_execute.lto_priv.80+0xf8>)
 8007d72:	480e      	ldr	r0, [pc, #56]	; (8007dac <rt_test_005_002_execute.lto_priv.80+0xfc>)
 8007d74:	f005 f9f4 	bl	800d160 <_test_assert_sequence>
}
 8007d78:	b002      	add	sp, #8
 8007d7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8007d7e:	bf00      	nop
 8007d80:	20003aec 	.word	0x20003aec
 8007d84:	08007931 	.word	0x08007931
 8007d88:	200025f0 	.word	0x200025f0
 8007d8c:	0800e68c 	.word	0x0800e68c
 8007d90:	20002f1c 	.word	0x20002f1c
 8007d94:	0800e698 	.word	0x0800e698
 8007d98:	08010ec4 	.word	0x08010ec4
 8007d9c:	0800fa8c 	.word	0x0800fa8c
 8007da0:	0800e830 	.word	0x0800e830
 8007da4:	20003104 	.word	0x20003104
 8007da8:	0800e6e8 	.word	0x0800e6e8
 8007dac:	0800e82c 	.word	0x0800e82c
 8007db0:	20003e04 	.word	0x20003e04
	...

08007dc0 <rt_test_005_001_execute.lto_priv.78>:
static void rt_test_005_001_execute(void) {
 8007dc0:	b538      	push	{r3, r4, r5, lr}
  test_set_step(1);
 8007dc2:	2201      	movs	r2, #1
 8007dc4:	4b2b      	ldr	r3, [pc, #172]	; (8007e74 <rt_test_005_001_execute.lto_priv.78+0xb4>)
 8007dc6:	601a      	str	r2, [r3, #0]
    msg = chSemWait(&sem1);
 8007dc8:	4c2b      	ldr	r4, [pc, #172]	; (8007e78 <rt_test_005_001_execute.lto_priv.78+0xb8>)
 8007dca:	4620      	mov	r0, r4
 8007dcc:	f003 fe18 	bl	800ba00 <chSemWait>
 8007dd0:	4605      	mov	r5, r0
 8007dd2:	2320      	movs	r3, #32
 8007dd4:	f383 8811 	msr	BASEPRI, r3
 */
static inline cnt_t chSemGetCounterI(const semaphore_t *sp) {

  chDbgCheckClassI();

  return sp->cnt;
 8007dd8:	68a0      	ldr	r0, [r4, #8]
    test_assert_lock(chSemGetCounterI(&sem1) == 0, "wrong counter value");
 8007dda:	4928      	ldr	r1, [pc, #160]	; (8007e7c <rt_test_005_001_execute.lto_priv.78+0xbc>)
 8007ddc:	fab0 f080 	clz	r0, r0
 8007de0:	0940      	lsrs	r0, r0, #5
 8007de2:	f005 f9e5 	bl	800d1b0 <_test_assert>
 8007de6:	b118      	cbz	r0, 8007df0 <rt_test_005_001_execute.lto_priv.78+0x30>
 8007de8:	2300      	movs	r3, #0
 8007dea:	f383 8811 	msr	BASEPRI, r3
 8007dee:	bd38      	pop	{r3, r4, r5, pc}
 8007df0:	2300      	movs	r3, #0
 8007df2:	f383 8811 	msr	BASEPRI, r3
    test_assert(MSG_OK == msg, "wrong returned message");
 8007df6:	4922      	ldr	r1, [pc, #136]	; (8007e80 <rt_test_005_001_execute.lto_priv.78+0xc0>)
 8007df8:	fab5 f085 	clz	r0, r5
 8007dfc:	0940      	lsrs	r0, r0, #5
 8007dfe:	f005 f9d7 	bl	800d1b0 <_test_assert>
 8007e02:	2800      	cmp	r0, #0
 8007e04:	d134      	bne.n	8007e70 <rt_test_005_001_execute.lto_priv.78+0xb0>
  test_set_step(2);
 8007e06:	2202      	movs	r2, #2
 8007e08:	4b1a      	ldr	r3, [pc, #104]	; (8007e74 <rt_test_005_001_execute.lto_priv.78+0xb4>)
 8007e0a:	601a      	str	r2, [r3, #0]
    chSemSignal(&sem1);
 8007e0c:	4c1a      	ldr	r4, [pc, #104]	; (8007e78 <rt_test_005_001_execute.lto_priv.78+0xb8>)
 8007e0e:	4620      	mov	r0, r4
 8007e10:	f003 fc76 	bl	800b700 <chSemSignal>
 8007e14:	2320      	movs	r3, #32
 8007e16:	f383 8811 	msr	BASEPRI, r3
 8007e1a:	68a0      	ldr	r0, [r4, #8]
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "wrong counter value");
 8007e1c:	4917      	ldr	r1, [pc, #92]	; (8007e7c <rt_test_005_001_execute.lto_priv.78+0xbc>)
 8007e1e:	2801      	cmp	r0, #1
 8007e20:	bf14      	ite	ne
 8007e22:	2000      	movne	r0, #0
 8007e24:	2001      	moveq	r0, #1
 8007e26:	f005 f9c3 	bl	800d1b0 <_test_assert>
 8007e2a:	b118      	cbz	r0, 8007e34 <rt_test_005_001_execute.lto_priv.78+0x74>
 8007e2c:	2300      	movs	r3, #0
 8007e2e:	f383 8811 	msr	BASEPRI, r3
 8007e32:	bd38      	pop	{r3, r4, r5, pc}
 8007e34:	2300      	movs	r3, #0
 8007e36:	f383 8811 	msr	BASEPRI, r3
  test_set_step(3);
 8007e3a:	2203      	movs	r2, #3
 8007e3c:	4b0d      	ldr	r3, [pc, #52]	; (8007e74 <rt_test_005_001_execute.lto_priv.78+0xb4>)
 8007e3e:	601a      	str	r2, [r3, #0]
    chSemReset(&sem1, 2);
 8007e40:	4c0d      	ldr	r4, [pc, #52]	; (8007e78 <rt_test_005_001_execute.lto_priv.78+0xb8>)
 8007e42:	2102      	movs	r1, #2
 8007e44:	4620      	mov	r0, r4
 8007e46:	f003 fbf3 	bl	800b630 <chSemReset>
 8007e4a:	2320      	movs	r3, #32
 8007e4c:	f383 8811 	msr	BASEPRI, r3
 8007e50:	68a0      	ldr	r0, [r4, #8]
    test_assert_lock(chSemGetCounterI(&sem1) == 2, "wrong counter value");
 8007e52:	490a      	ldr	r1, [pc, #40]	; (8007e7c <rt_test_005_001_execute.lto_priv.78+0xbc>)
 8007e54:	2802      	cmp	r0, #2
 8007e56:	bf14      	ite	ne
 8007e58:	2000      	movne	r0, #0
 8007e5a:	2001      	moveq	r0, #1
 8007e5c:	f005 f9a8 	bl	800d1b0 <_test_assert>
 8007e60:	b118      	cbz	r0, 8007e6a <rt_test_005_001_execute.lto_priv.78+0xaa>
 8007e62:	2300      	movs	r3, #0
 8007e64:	f383 8811 	msr	BASEPRI, r3
 8007e68:	bd38      	pop	{r3, r4, r5, pc}
 8007e6a:	2300      	movs	r3, #0
 8007e6c:	f383 8811 	msr	BASEPRI, r3
 8007e70:	bd38      	pop	{r3, r4, r5, pc}
 8007e72:	bf00      	nop
 8007e74:	20003e04 	.word	0x20003e04
 8007e78:	20003104 	.word	0x20003104
 8007e7c:	0800ea38 	.word	0x0800ea38
 8007e80:	0800ea4c 	.word	0x0800ea4c
	...

08007e90 <rt_test_005_004_execute.lto_priv.84>:
static void rt_test_005_004_execute(void) {
 8007e90:	b530      	push	{r4, r5, lr}
 8007e92:	b083      	sub	sp, #12
  test_set_step(1);
 8007e94:	4c1c      	ldr	r4, [pc, #112]	; (8007f08 <rt_test_005_004_execute.lto_priv.84+0x78>)
 8007e96:	2301      	movs	r3, #1
 8007e98:	6023      	str	r3, [r4, #0]
  return ch.rlist.current;
 8007e9a:	4b1c      	ldr	r3, [pc, #112]	; (8007f0c <rt_test_005_004_execute.lto_priv.84+0x7c>)
 8007e9c:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 8007e9e:	689a      	ldr	r2, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 8007ea0:	4b1b      	ldr	r3, [pc, #108]	; (8007f10 <rt_test_005_004_execute.lto_priv.84+0x80>)
 8007ea2:	9300      	str	r3, [sp, #0]
 8007ea4:	4b1b      	ldr	r3, [pc, #108]	; (8007f14 <rt_test_005_004_execute.lto_priv.84+0x84>)
 8007ea6:	3201      	adds	r2, #1
 8007ea8:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007eac:	481a      	ldr	r0, [pc, #104]	; (8007f18 <rt_test_005_004_execute.lto_priv.84+0x88>)
 8007eae:	f003 fc5f 	bl	800b770 <chThdCreateStatic>
 8007eb2:	4b1a      	ldr	r3, [pc, #104]	; (8007f1c <rt_test_005_004_execute.lto_priv.84+0x8c>)
 8007eb4:	6018      	str	r0, [r3, #0]
  test_set_step(2);
 8007eb6:	2102      	movs	r1, #2
 8007eb8:	6021      	str	r1, [r4, #0]
 8007eba:	2520      	movs	r5, #32
 8007ebc:	f385 8811 	msr	BASEPRI, r5
    chSemAddCounterI(&sem1, 2);
 8007ec0:	4c17      	ldr	r4, [pc, #92]	; (8007f20 <rt_test_005_004_execute.lto_priv.84+0x90>)
 8007ec2:	4620      	mov	r0, r4
 8007ec4:	f003 f9c4 	bl	800b250 <chSemAddCounterI>
    chSchRescheduleS();
 8007ec8:	f003 fb2a 	bl	800b520 <chSchRescheduleS>
 8007ecc:	2300      	movs	r3, #0
 8007ece:	f383 8811 	msr	BASEPRI, r3
    test_wait_threads();
 8007ed2:	f004 fd35 	bl	800c940 <test_wait_threads>
 8007ed6:	f385 8811 	msr	BASEPRI, r5
 8007eda:	68a0      	ldr	r0, [r4, #8]
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "invalid counter");
 8007edc:	4911      	ldr	r1, [pc, #68]	; (8007f24 <rt_test_005_004_execute.lto_priv.84+0x94>)
 8007ede:	2801      	cmp	r0, #1
 8007ee0:	bf14      	ite	ne
 8007ee2:	2000      	movne	r0, #0
 8007ee4:	2001      	moveq	r0, #1
 8007ee6:	f005 f963 	bl	800d1b0 <_test_assert>
 8007eea:	b118      	cbz	r0, 8007ef4 <rt_test_005_004_execute.lto_priv.84+0x64>
 8007eec:	2300      	movs	r3, #0
 8007eee:	f383 8811 	msr	BASEPRI, r3
 8007ef2:	e006      	b.n	8007f02 <rt_test_005_004_execute.lto_priv.84+0x72>
 8007ef4:	2300      	movs	r3, #0
 8007ef6:	f383 8811 	msr	BASEPRI, r3
    test_assert_sequence("A", "invalid sequence");
 8007efa:	490b      	ldr	r1, [pc, #44]	; (8007f28 <rt_test_005_004_execute.lto_priv.84+0x98>)
 8007efc:	4804      	ldr	r0, [pc, #16]	; (8007f10 <rt_test_005_004_execute.lto_priv.84+0x80>)
 8007efe:	f005 f92f 	bl	800d160 <_test_assert_sequence>
}
 8007f02:	b003      	add	sp, #12
 8007f04:	bd30      	pop	{r4, r5, pc}
 8007f06:	bf00      	nop
 8007f08:	20003e04 	.word	0x20003e04
 8007f0c:	20003aec 	.word	0x20003aec
 8007f10:	0800e68c 	.word	0x0800e68c
 8007f14:	08007931 	.word	0x08007931
 8007f18:	200025f0 	.word	0x200025f0
 8007f1c:	20002f1c 	.word	0x20002f1c
 8007f20:	20003104 	.word	0x20003104
 8007f24:	0800ea64 	.word	0x0800ea64
 8007f28:	0800e6e8 	.word	0x0800e6e8
 8007f2c:	00000000 	.word	0x00000000

08007f30 <rt_test_005_003_execute.lto_priv.82>:
static void rt_test_005_003_execute(void) {
 8007f30:	b570      	push	{r4, r5, r6, lr}
 8007f32:	b082      	sub	sp, #8
  test_set_step(1);
 8007f34:	2201      	movs	r2, #1
 8007f36:	4b4e      	ldr	r3, [pc, #312]	; (8008070 <rt_test_005_003_execute.lto_priv.82+0x140>)
 8007f38:	601a      	str	r2, [r3, #0]
    msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
 8007f3a:	2100      	movs	r1, #0
 8007f3c:	484d      	ldr	r0, [pc, #308]	; (8008074 <rt_test_005_003_execute.lto_priv.82+0x144>)
 8007f3e:	f003 fe37 	bl	800bbb0 <chSemWaitTimeout>
    test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 8007f42:	494d      	ldr	r1, [pc, #308]	; (8008078 <rt_test_005_003_execute.lto_priv.82+0x148>)
 8007f44:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 8007f48:	bf14      	ite	ne
 8007f4a:	2000      	movne	r0, #0
 8007f4c:	2001      	moveq	r0, #1
 8007f4e:	f005 f92f 	bl	800d1b0 <_test_assert>
 8007f52:	2800      	cmp	r0, #0
 8007f54:	f040 8089 	bne.w	800806a <rt_test_005_003_execute.lto_priv.82+0x13a>
 8007f58:	4b46      	ldr	r3, [pc, #280]	; (8008074 <rt_test_005_003_execute.lto_priv.82+0x144>)
 8007f5a:	6818      	ldr	r0, [r3, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8007f5c:	4947      	ldr	r1, [pc, #284]	; (800807c <rt_test_005_003_execute.lto_priv.82+0x14c>)
 8007f5e:	4298      	cmp	r0, r3
 8007f60:	bf14      	ite	ne
 8007f62:	2000      	movne	r0, #0
 8007f64:	2001      	moveq	r0, #1
 8007f66:	f005 f923 	bl	800d1b0 <_test_assert>
 8007f6a:	2800      	cmp	r0, #0
 8007f6c:	d17d      	bne.n	800806a <rt_test_005_003_execute.lto_priv.82+0x13a>
    test_assert(sem1.cnt == 0, "counter not zero");
 8007f6e:	4b41      	ldr	r3, [pc, #260]	; (8008074 <rt_test_005_003_execute.lto_priv.82+0x144>)
 8007f70:	6898      	ldr	r0, [r3, #8]
 8007f72:	4943      	ldr	r1, [pc, #268]	; (8008080 <rt_test_005_003_execute.lto_priv.82+0x150>)
 8007f74:	fab0 f080 	clz	r0, r0
 8007f78:	0940      	lsrs	r0, r0, #5
 8007f7a:	f005 f919 	bl	800d1b0 <_test_assert>
 8007f7e:	2800      	cmp	r0, #0
 8007f80:	d173      	bne.n	800806a <rt_test_005_003_execute.lto_priv.82+0x13a>
  test_set_step(2);
 8007f82:	2202      	movs	r2, #2
 8007f84:	4b3a      	ldr	r3, [pc, #232]	; (8008070 <rt_test_005_003_execute.lto_priv.82+0x140>)
 8007f86:	601a      	str	r2, [r3, #0]
  return ch.rlist.current;
 8007f88:	4b3e      	ldr	r3, [pc, #248]	; (8008084 <rt_test_005_003_execute.lto_priv.82+0x154>)
 8007f8a:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 8007f8c:	689a      	ldr	r2, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8007f8e:	2300      	movs	r3, #0
 8007f90:	9300      	str	r3, [sp, #0]
 8007f92:	4b3d      	ldr	r3, [pc, #244]	; (8008088 <rt_test_005_003_execute.lto_priv.82+0x158>)
 8007f94:	3a01      	subs	r2, #1
 8007f96:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8007f9a:	483c      	ldr	r0, [pc, #240]	; (800808c <rt_test_005_003_execute.lto_priv.82+0x15c>)
 8007f9c:	f003 fbe8 	bl	800b770 <chThdCreateStatic>
 8007fa0:	4b3b      	ldr	r3, [pc, #236]	; (8008090 <rt_test_005_003_execute.lto_priv.82+0x160>)
 8007fa2:	6018      	str	r0, [r3, #0]
    msg = chSemWaitTimeout(&sem1, TIME_MS2I(500));
 8007fa4:	f241 3188 	movw	r1, #5000	; 0x1388
 8007fa8:	4832      	ldr	r0, [pc, #200]	; (8008074 <rt_test_005_003_execute.lto_priv.82+0x144>)
 8007faa:	f003 fe01 	bl	800bbb0 <chSemWaitTimeout>
 8007fae:	4604      	mov	r4, r0
    test_wait_threads();
 8007fb0:	f004 fcc6 	bl	800c940 <test_wait_threads>
    test_assert(msg == MSG_OK, "wrong wake-up message");
 8007fb4:	4930      	ldr	r1, [pc, #192]	; (8008078 <rt_test_005_003_execute.lto_priv.82+0x148>)
 8007fb6:	fab4 f084 	clz	r0, r4
 8007fba:	0940      	lsrs	r0, r0, #5
 8007fbc:	f005 f8f8 	bl	800d1b0 <_test_assert>
 8007fc0:	2800      	cmp	r0, #0
 8007fc2:	d152      	bne.n	800806a <rt_test_005_003_execute.lto_priv.82+0x13a>
 8007fc4:	4b2b      	ldr	r3, [pc, #172]	; (8008074 <rt_test_005_003_execute.lto_priv.82+0x144>)
 8007fc6:	6818      	ldr	r0, [r3, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8007fc8:	492c      	ldr	r1, [pc, #176]	; (800807c <rt_test_005_003_execute.lto_priv.82+0x14c>)
 8007fca:	4298      	cmp	r0, r3
 8007fcc:	bf14      	ite	ne
 8007fce:	2000      	movne	r0, #0
 8007fd0:	2001      	moveq	r0, #1
 8007fd2:	f005 f8ed 	bl	800d1b0 <_test_assert>
 8007fd6:	2800      	cmp	r0, #0
 8007fd8:	d147      	bne.n	800806a <rt_test_005_003_execute.lto_priv.82+0x13a>
    test_assert(sem1.cnt == 0, "counter not zero");
 8007fda:	4b26      	ldr	r3, [pc, #152]	; (8008074 <rt_test_005_003_execute.lto_priv.82+0x144>)
 8007fdc:	6898      	ldr	r0, [r3, #8]
 8007fde:	4928      	ldr	r1, [pc, #160]	; (8008080 <rt_test_005_003_execute.lto_priv.82+0x150>)
 8007fe0:	fab0 f080 	clz	r0, r0
 8007fe4:	0940      	lsrs	r0, r0, #5
 8007fe6:	f005 f8e3 	bl	800d1b0 <_test_assert>
 8007fea:	2800      	cmp	r0, #0
 8007fec:	d13d      	bne.n	800806a <rt_test_005_003_execute.lto_priv.82+0x13a>
  test_set_step(3);
 8007fee:	2203      	movs	r2, #3
 8007ff0:	4b1f      	ldr	r3, [pc, #124]	; (8008070 <rt_test_005_003_execute.lto_priv.82+0x140>)
 8007ff2:	601a      	str	r2, [r3, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(5 * 50));
 8007ff4:	f004 fc94 	bl	800c920 <test_wait_tick>
 8007ff8:	4605      	mov	r5, r0
  return systime + (systime_t)interval;
 8007ffa:	f600 16c4 	addw	r6, r0, #2500	; 0x9c4
    for (i = 0; i < 5; i++) {
 8007ffe:	2400      	movs	r4, #0
 8008000:	e026      	b.n	8008050 <rt_test_005_003_execute.lto_priv.82+0x120>
      test_emit_token('A' + i);
 8008002:	f104 0041 	add.w	r0, r4, #65	; 0x41
 8008006:	b2c0      	uxtb	r0, r0
 8008008:	f004 fcc2 	bl	800c990 <test_emit_token>
      msg = chSemWaitTimeout(&sem1, TIME_MS2I(50));
 800800c:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8008010:	4818      	ldr	r0, [pc, #96]	; (8008074 <rt_test_005_003_execute.lto_priv.82+0x144>)
 8008012:	f003 fdcd 	bl	800bbb0 <chSemWaitTimeout>
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 8008016:	4918      	ldr	r1, [pc, #96]	; (8008078 <rt_test_005_003_execute.lto_priv.82+0x148>)
 8008018:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800801c:	bf14      	ite	ne
 800801e:	2000      	movne	r0, #0
 8008020:	2001      	moveq	r0, #1
 8008022:	f005 f8c5 	bl	800d1b0 <_test_assert>
 8008026:	bb00      	cbnz	r0, 800806a <rt_test_005_003_execute.lto_priv.82+0x13a>
 8008028:	4b12      	ldr	r3, [pc, #72]	; (8008074 <rt_test_005_003_execute.lto_priv.82+0x144>)
 800802a:	6818      	ldr	r0, [r3, #0]
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
 800802c:	4913      	ldr	r1, [pc, #76]	; (800807c <rt_test_005_003_execute.lto_priv.82+0x14c>)
 800802e:	4298      	cmp	r0, r3
 8008030:	bf14      	ite	ne
 8008032:	2000      	movne	r0, #0
 8008034:	2001      	moveq	r0, #1
 8008036:	f005 f8bb 	bl	800d1b0 <_test_assert>
 800803a:	b9b0      	cbnz	r0, 800806a <rt_test_005_003_execute.lto_priv.82+0x13a>
      test_assert(sem1.cnt == 0, "counter not zero");
 800803c:	4b0d      	ldr	r3, [pc, #52]	; (8008074 <rt_test_005_003_execute.lto_priv.82+0x144>)
 800803e:	6898      	ldr	r0, [r3, #8]
 8008040:	490f      	ldr	r1, [pc, #60]	; (8008080 <rt_test_005_003_execute.lto_priv.82+0x150>)
 8008042:	fab0 f080 	clz	r0, r0
 8008046:	0940      	lsrs	r0, r0, #5
 8008048:	f005 f8b2 	bl	800d1b0 <_test_assert>
 800804c:	b968      	cbnz	r0, 800806a <rt_test_005_003_execute.lto_priv.82+0x13a>
    for (i = 0; i < 5; i++) {
 800804e:	3401      	adds	r4, #1
 8008050:	2c04      	cmp	r4, #4
 8008052:	d9d6      	bls.n	8008002 <rt_test_005_003_execute.lto_priv.82+0xd2>
    test_assert_sequence("ABCDE", "invalid sequence");
 8008054:	490f      	ldr	r1, [pc, #60]	; (8008094 <rt_test_005_003_execute.lto_priv.82+0x164>)
 8008056:	4810      	ldr	r0, [pc, #64]	; (8008098 <rt_test_005_003_execute.lto_priv.82+0x168>)
 8008058:	f005 f882 	bl	800d160 <_test_assert_sequence>
 800805c:	b928      	cbnz	r0, 800806a <rt_test_005_003_execute.lto_priv.82+0x13a>
    test_assert_time_window(target_time,
 800805e:	4a0f      	ldr	r2, [pc, #60]	; (800809c <rt_test_005_003_execute.lto_priv.82+0x16c>)
 8008060:	f605 11d8 	addw	r1, r5, #2520	; 0x9d8
 8008064:	4630      	mov	r0, r6
 8008066:	f005 f96b 	bl	800d340 <_test_assert_time_window>
}
 800806a:	b002      	add	sp, #8
 800806c:	bd70      	pop	{r4, r5, r6, pc}
 800806e:	bf00      	nop
 8008070:	20003e04 	.word	0x20003e04
 8008074:	20003104 	.word	0x20003104
 8008078:	0800e500 	.word	0x0800e500
 800807c:	0800e85c 	.word	0x0800e85c
 8008080:	0800ea24 	.word	0x0800ea24
 8008084:	20003aec 	.word	0x20003aec
 8008088:	08007b91 	.word	0x08007b91
 800808c:	200025f0 	.word	0x200025f0
 8008090:	20002f1c 	.word	0x20002f1c
 8008094:	0800e6e8 	.word	0x0800e6e8
 8008098:	0800e82c 	.word	0x0800e82c
 800809c:	0800e788 	.word	0x0800e788

080080a0 <rt_test_004_001_execute.lto_priv.75>:
}

static void rt_test_004_001_execute(void) {
 80080a0:	b530      	push	{r4, r5, lr}
 80080a2:	b083      	sub	sp, #12
  msg_t msg;

  /* [4.1.1] The function chThdSuspendTimeoutS() is invoked, the thread
     is remotely resumed with message @p MSG_OK. On return the message
     and the state of the reference are tested.*/
  test_set_step(1);
 80080a4:	2201      	movs	r2, #1
 80080a6:	4b2e      	ldr	r3, [pc, #184]	; (8008160 <rt_test_004_001_execute.lto_priv.75+0xc0>)
 80080a8:	601a      	str	r2, [r3, #0]
  return ch.rlist.current;
 80080aa:	4b2e      	ldr	r3, [pc, #184]	; (8008164 <rt_test_004_001_execute.lto_priv.75+0xc4>)
 80080ac:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 80080ae:	689a      	ldr	r2, [r3, #8]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
 80080b0:	4b2d      	ldr	r3, [pc, #180]	; (8008168 <rt_test_004_001_execute.lto_priv.75+0xc8>)
 80080b2:	9300      	str	r3, [sp, #0]
 80080b4:	4b2d      	ldr	r3, [pc, #180]	; (800816c <rt_test_004_001_execute.lto_priv.75+0xcc>)
 80080b6:	3a01      	subs	r2, #1
 80080b8:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 80080bc:	482c      	ldr	r0, [pc, #176]	; (8008170 <rt_test_004_001_execute.lto_priv.75+0xd0>)
 80080be:	f003 fb57 	bl	800b770 <chThdCreateStatic>
 80080c2:	4b2c      	ldr	r3, [pc, #176]	; (8008174 <rt_test_004_001_execute.lto_priv.75+0xd4>)
 80080c4:	6018      	str	r0, [r3, #0]
 80080c6:	2320      	movs	r3, #32
 80080c8:	f383 8811 	msr	BASEPRI, r3
    chSysLock();
    msg = chThdSuspendTimeoutS(&tr1, TIME_INFINITE);
 80080cc:	4c2a      	ldr	r4, [pc, #168]	; (8008178 <rt_test_004_001_execute.lto_priv.75+0xd8>)
 80080ce:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80080d2:	4620      	mov	r0, r4
 80080d4:	f003 fd94 	bl	800bc00 <chThdSuspendTimeoutS>
 80080d8:	4605      	mov	r5, r0
 80080da:	2300      	movs	r3, #0
 80080dc:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    test_assert(NULL == tr1, "not NULL");
 80080e0:	6820      	ldr	r0, [r4, #0]
 80080e2:	4926      	ldr	r1, [pc, #152]	; (800817c <rt_test_004_001_execute.lto_priv.75+0xdc>)
 80080e4:	fab0 f080 	clz	r0, r0
 80080e8:	0940      	lsrs	r0, r0, #5
 80080ea:	f005 f861 	bl	800d1b0 <_test_assert>
 80080ee:	2800      	cmp	r0, #0
 80080f0:	d134      	bne.n	800815c <rt_test_004_001_execute.lto_priv.75+0xbc>
    test_assert(MSG_OK == msg,"wrong returned message");
 80080f2:	4923      	ldr	r1, [pc, #140]	; (8008180 <rt_test_004_001_execute.lto_priv.75+0xe0>)
 80080f4:	fab5 f085 	clz	r0, r5
 80080f8:	0940      	lsrs	r0, r0, #5
 80080fa:	f005 f859 	bl	800d1b0 <_test_assert>
 80080fe:	bb68      	cbnz	r0, 800815c <rt_test_004_001_execute.lto_priv.75+0xbc>
    test_wait_threads();
 8008100:	f004 fc1e 	bl	800c940 <test_wait_threads>
  }

  /* [4.1.2] The function chThdSuspendTimeoutS() is invoked, the thread
     is not resumed so a timeout must occur. On return the message and
     the state of the reference are tested.*/
  test_set_step(2);
 8008104:	2202      	movs	r2, #2
 8008106:	4b16      	ldr	r3, [pc, #88]	; (8008160 <rt_test_004_001_execute.lto_priv.75+0xc0>)
 8008108:	601a      	str	r2, [r3, #0]
 800810a:	2320      	movs	r3, #32
 800810c:	f383 8811 	msr	BASEPRI, r3
 8008110:	4b1c      	ldr	r3, [pc, #112]	; (8008184 <rt_test_004_001_execute.lto_priv.75+0xe4>)
 8008112:	6a5c      	ldr	r4, [r3, #36]	; 0x24
  {
    chSysLock();
    time = chVTGetSystemTimeX();
    msg = chThdSuspendTimeoutS(&tr1, TIME_MS2I(1000));
 8008114:	f242 7110 	movw	r1, #10000	; 0x2710
 8008118:	4817      	ldr	r0, [pc, #92]	; (8008178 <rt_test_004_001_execute.lto_priv.75+0xd8>)
 800811a:	f003 fd71 	bl	800bc00 <chThdSuspendTimeoutS>
 800811e:	4605      	mov	r5, r0
 8008120:	2300      	movs	r3, #0
 8008122:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    test_assert_time_window(chTimeAddX(time, TIME_MS2I(1000)),
 8008126:	4a18      	ldr	r2, [pc, #96]	; (8008188 <rt_test_004_001_execute.lto_priv.75+0xe8>)
 8008128:	f504 511c 	add.w	r1, r4, #9984	; 0x2700
 800812c:	3113      	adds	r1, #19
 800812e:	f504 501c 	add.w	r0, r4, #9984	; 0x2700
 8008132:	3010      	adds	r0, #16
 8008134:	f005 f904 	bl	800d340 <_test_assert_time_window>
 8008138:	b980      	cbnz	r0, 800815c <rt_test_004_001_execute.lto_priv.75+0xbc>
                            chTimeAddX(time, TIME_MS2I(1000) + CH_CFG_ST_TIMEDELTA + 1),
                            "out of time window");
    test_assert(NULL == tr1, "not NULL");
 800813a:	4b0f      	ldr	r3, [pc, #60]	; (8008178 <rt_test_004_001_execute.lto_priv.75+0xd8>)
 800813c:	6818      	ldr	r0, [r3, #0]
 800813e:	490f      	ldr	r1, [pc, #60]	; (800817c <rt_test_004_001_execute.lto_priv.75+0xdc>)
 8008140:	fab0 f080 	clz	r0, r0
 8008144:	0940      	lsrs	r0, r0, #5
 8008146:	f005 f833 	bl	800d1b0 <_test_assert>
 800814a:	b938      	cbnz	r0, 800815c <rt_test_004_001_execute.lto_priv.75+0xbc>
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
 800814c:	490c      	ldr	r1, [pc, #48]	; (8008180 <rt_test_004_001_execute.lto_priv.75+0xe0>)
 800814e:	f1b5 3fff 	cmp.w	r5, #4294967295	; 0xffffffff
 8008152:	bf14      	ite	ne
 8008154:	2000      	movne	r0, #0
 8008156:	2001      	moveq	r0, #1
 8008158:	f005 f82a 	bl	800d1b0 <_test_assert>
  }
}
 800815c:	b003      	add	sp, #12
 800815e:	bd30      	pop	{r4, r5, pc}
 8008160:	20003e04 	.word	0x20003e04
 8008164:	20003aec 	.word	0x20003aec
 8008168:	0800e68c 	.word	0x0800e68c
 800816c:	08008191 	.word	0x08008191
 8008170:	200025f0 	.word	0x200025f0
 8008174:	20002f1c 	.word	0x20002f1c
 8008178:	20003100 	.word	0x20003100
 800817c:	0800ea74 	.word	0x0800ea74
 8008180:	0800ea4c 	.word	0x0800ea4c
 8008184:	40000c00 	.word	0x40000c00
 8008188:	0800e788 	.word	0x0800e788
 800818c:	00000000 	.word	0x00000000

08008190 <thread1.lto_priv.13>:
static THD_FUNCTION(thread1, p) {
 8008190:	b510      	push	{r4, lr}
 8008192:	4604      	mov	r4, r0
 8008194:	2320      	movs	r3, #32
 8008196:	f383 8811 	msr	BASEPRI, r3
  chThdResumeI(&tr1, MSG_OK);
 800819a:	2100      	movs	r1, #0
 800819c:	4805      	ldr	r0, [pc, #20]	; (80081b4 <thread1.lto_priv.13+0x24>)
 800819e:	f003 f8cf 	bl	800b340 <chThdResumeI>
  chSchRescheduleS();
 80081a2:	f003 f9bd 	bl	800b520 <chSchRescheduleS>
 80081a6:	2300      	movs	r3, #0
 80081a8:	f383 8811 	msr	BASEPRI, r3
  test_emit_token(*(char *)p);
 80081ac:	7820      	ldrb	r0, [r4, #0]
 80081ae:	f004 fbef 	bl	800c990 <test_emit_token>
 80081b2:	bd10      	pop	{r4, pc}
 80081b4:	20003100 	.word	0x20003100
	...

080081c0 <rt_test_003_004_execute.lto_priv.73>:
 * - [3.4.3] Raising thread priority above the boosted level.
 * - [3.4.4] Restoring original conditions.
 * .
 */

static void rt_test_003_004_execute(void) {
 80081c0:	b570      	push	{r4, r5, r6, lr}
  tprio_t prio, p1;

  /* [3.4.1] Simulating a priority boost situation (prio > realprio).*/
  test_set_step(1);
 80081c2:	2201      	movs	r2, #1
 80081c4:	4b36      	ldr	r3, [pc, #216]	; (80082a0 <rt_test_003_004_execute.lto_priv.73+0xe0>)
 80081c6:	601a      	str	r2, [r3, #0]
  return ch.rlist.current;
 80081c8:	4b36      	ldr	r3, [pc, #216]	; (80082a4 <rt_test_003_004_execute.lto_priv.73+0xe4>)
 80081ca:	699a      	ldr	r2, [r3, #24]
  return chThdGetSelfX()->prio;
 80081cc:	6895      	ldr	r5, [r2, #8]
  {
    prio = chThdGetPriorityX();
    chThdGetSelfX()->prio += 2;
 80081ce:	1cac      	adds	r4, r5, #2
 80081d0:	6094      	str	r4, [r2, #8]
  return ch.rlist.current;
 80081d2:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 80081d4:	6898      	ldr	r0, [r3, #8]
    test_assert(chThdGetPriorityX() == prio + 2, "unexpected priority level");
 80081d6:	4934      	ldr	r1, [pc, #208]	; (80082a8 <rt_test_003_004_execute.lto_priv.73+0xe8>)
 80081d8:	4284      	cmp	r4, r0
 80081da:	bf14      	ite	ne
 80081dc:	2000      	movne	r0, #0
 80081de:	2001      	moveq	r0, #1
 80081e0:	f004 ffe6 	bl	800d1b0 <_test_assert>
 80081e4:	2800      	cmp	r0, #0
 80081e6:	d15a      	bne.n	800829e <rt_test_003_004_execute.lto_priv.73+0xde>
  }

  /* [3.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
 80081e8:	2202      	movs	r2, #2
 80081ea:	4b2d      	ldr	r3, [pc, #180]	; (80082a0 <rt_test_003_004_execute.lto_priv.73+0xe0>)
 80081ec:	601a      	str	r2, [r3, #0]
  {
    p1 = chThdSetPriority(prio + 1);
 80081ee:	1c6e      	adds	r6, r5, #1
 80081f0:	4630      	mov	r0, r6
 80081f2:	f003 fa2d 	bl	800b650 <chThdSetPriority>
    test_assert(p1 == prio, "unexpected returned priority level");
 80081f6:	492d      	ldr	r1, [pc, #180]	; (80082ac <rt_test_003_004_execute.lto_priv.73+0xec>)
 80081f8:	42a8      	cmp	r0, r5
 80081fa:	bf14      	ite	ne
 80081fc:	2000      	movne	r0, #0
 80081fe:	2001      	moveq	r0, #1
 8008200:	f004 ffd6 	bl	800d1b0 <_test_assert>
 8008204:	2800      	cmp	r0, #0
 8008206:	d14a      	bne.n	800829e <rt_test_003_004_execute.lto_priv.73+0xde>
  return ch.rlist.current;
 8008208:	4b26      	ldr	r3, [pc, #152]	; (80082a4 <rt_test_003_004_execute.lto_priv.73+0xe4>)
 800820a:	699b      	ldr	r3, [r3, #24]
    test_assert(chThdGetSelfX()->prio == prio + 2, "unexpected priority level");
 800820c:	6898      	ldr	r0, [r3, #8]
 800820e:	4926      	ldr	r1, [pc, #152]	; (80082a8 <rt_test_003_004_execute.lto_priv.73+0xe8>)
 8008210:	42a0      	cmp	r0, r4
 8008212:	bf14      	ite	ne
 8008214:	2000      	movne	r0, #0
 8008216:	2001      	moveq	r0, #1
 8008218:	f004 ffca 	bl	800d1b0 <_test_assert>
 800821c:	2800      	cmp	r0, #0
 800821e:	d13e      	bne.n	800829e <rt_test_003_004_execute.lto_priv.73+0xde>
 8008220:	4b20      	ldr	r3, [pc, #128]	; (80082a4 <rt_test_003_004_execute.lto_priv.73+0xe4>)
 8008222:	699b      	ldr	r3, [r3, #24]
    test_assert(chThdGetSelfX()->realprio == prio + 1, "unexpected returned real priority level");
 8008224:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8008226:	4922      	ldr	r1, [pc, #136]	; (80082b0 <rt_test_003_004_execute.lto_priv.73+0xf0>)
 8008228:	42b0      	cmp	r0, r6
 800822a:	bf14      	ite	ne
 800822c:	2000      	movne	r0, #0
 800822e:	2001      	moveq	r0, #1
 8008230:	f004 ffbe 	bl	800d1b0 <_test_assert>
 8008234:	2800      	cmp	r0, #0
 8008236:	d132      	bne.n	800829e <rt_test_003_004_execute.lto_priv.73+0xde>
  }

  /* [3.4.3] Raising thread priority above the boosted level.*/
  test_set_step(3);
 8008238:	2203      	movs	r2, #3
 800823a:	4b19      	ldr	r3, [pc, #100]	; (80082a0 <rt_test_003_004_execute.lto_priv.73+0xe0>)
 800823c:	601a      	str	r2, [r3, #0]
  {
    p1 = chThdSetPriority(prio + 3);
 800823e:	18ac      	adds	r4, r5, r2
 8008240:	4620      	mov	r0, r4
 8008242:	f003 fa05 	bl	800b650 <chThdSetPriority>
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 8008246:	4919      	ldr	r1, [pc, #100]	; (80082ac <rt_test_003_004_execute.lto_priv.73+0xec>)
 8008248:	4286      	cmp	r6, r0
 800824a:	bf14      	ite	ne
 800824c:	2000      	movne	r0, #0
 800824e:	2001      	moveq	r0, #1
 8008250:	f004 ffae 	bl	800d1b0 <_test_assert>
 8008254:	bb18      	cbnz	r0, 800829e <rt_test_003_004_execute.lto_priv.73+0xde>
 8008256:	4b13      	ldr	r3, [pc, #76]	; (80082a4 <rt_test_003_004_execute.lto_priv.73+0xe4>)
 8008258:	699b      	ldr	r3, [r3, #24]
    test_assert(chThdGetSelfX()->prio == prio + 3, "unexpected priority level");
 800825a:	6898      	ldr	r0, [r3, #8]
 800825c:	4912      	ldr	r1, [pc, #72]	; (80082a8 <rt_test_003_004_execute.lto_priv.73+0xe8>)
 800825e:	42a0      	cmp	r0, r4
 8008260:	bf14      	ite	ne
 8008262:	2000      	movne	r0, #0
 8008264:	2001      	moveq	r0, #1
 8008266:	f004 ffa3 	bl	800d1b0 <_test_assert>
 800826a:	b9c0      	cbnz	r0, 800829e <rt_test_003_004_execute.lto_priv.73+0xde>
 800826c:	4b0d      	ldr	r3, [pc, #52]	; (80082a4 <rt_test_003_004_execute.lto_priv.73+0xe4>)
 800826e:	699b      	ldr	r3, [r3, #24]
    test_assert(chThdGetSelfX()->realprio == prio + 3, "unexpected real priority level");
 8008270:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8008272:	4910      	ldr	r1, [pc, #64]	; (80082b4 <rt_test_003_004_execute.lto_priv.73+0xf4>)
 8008274:	42a0      	cmp	r0, r4
 8008276:	bf14      	ite	ne
 8008278:	2000      	movne	r0, #0
 800827a:	2001      	moveq	r0, #1
 800827c:	f004 ff98 	bl	800d1b0 <_test_assert>
 8008280:	b968      	cbnz	r0, 800829e <rt_test_003_004_execute.lto_priv.73+0xde>
  }

  /* [3.4.4] Restoring original conditions.*/
  test_set_step(4);
 8008282:	2204      	movs	r2, #4
 8008284:	4b06      	ldr	r3, [pc, #24]	; (80082a0 <rt_test_003_004_execute.lto_priv.73+0xe0>)
 8008286:	601a      	str	r2, [r3, #0]
 8008288:	2320      	movs	r3, #32
 800828a:	f383 8811 	msr	BASEPRI, r3
 800828e:	4b05      	ldr	r3, [pc, #20]	; (80082a4 <rt_test_003_004_execute.lto_priv.73+0xe4>)
 8008290:	699a      	ldr	r2, [r3, #24]
  {
    chSysLock();
    chThdGetSelfX()->prio = prio;
 8008292:	6095      	str	r5, [r2, #8]
 8008294:	699b      	ldr	r3, [r3, #24]
    chThdGetSelfX()->realprio = prio;
 8008296:	63dd      	str	r5, [r3, #60]	; 0x3c
 8008298:	2300      	movs	r3, #0
 800829a:	f383 8811 	msr	BASEPRI, r3
 800829e:	bd70      	pop	{r4, r5, r6, pc}
 80082a0:	20003e04 	.word	0x20003e04
 80082a4:	20003aec 	.word	0x20003aec
 80082a8:	0800ea80 	.word	0x0800ea80
 80082ac:	0800ea9c 	.word	0x0800ea9c
 80082b0:	0800eac0 	.word	0x0800eac0
 80082b4:	0800eae8 	.word	0x0800eae8
	...

080082c0 <rt_test_003_003_execute.lto_priv.72>:
static void rt_test_003_003_execute(void) {
 80082c0:	b570      	push	{r4, r5, r6, lr}
  test_set_step(1);
 80082c2:	2201      	movs	r2, #1
 80082c4:	4b1a      	ldr	r3, [pc, #104]	; (8008330 <rt_test_003_003_execute.lto_priv.72+0x70>)
 80082c6:	601a      	str	r2, [r3, #0]
 80082c8:	4b1a      	ldr	r3, [pc, #104]	; (8008334 <rt_test_003_003_execute.lto_priv.72+0x74>)
 80082ca:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 80082cc:	689c      	ldr	r4, [r3, #8]
    p1 = chThdSetPriority(prio + 1);
 80082ce:	18a5      	adds	r5, r4, r2
 80082d0:	4628      	mov	r0, r5
 80082d2:	f003 f9bd 	bl	800b650 <chThdSetPriority>
 80082d6:	4606      	mov	r6, r0
    test_assert(p1 == prio, "unexpected returned priority level");
 80082d8:	4917      	ldr	r1, [pc, #92]	; (8008338 <rt_test_003_003_execute.lto_priv.72+0x78>)
 80082da:	42a0      	cmp	r0, r4
 80082dc:	bf14      	ite	ne
 80082de:	2000      	movne	r0, #0
 80082e0:	2001      	moveq	r0, #1
 80082e2:	f004 ff65 	bl	800d1b0 <_test_assert>
 80082e6:	bb10      	cbnz	r0, 800832e <rt_test_003_003_execute.lto_priv.72+0x6e>
  return ch.rlist.current;
 80082e8:	4b12      	ldr	r3, [pc, #72]	; (8008334 <rt_test_003_003_execute.lto_priv.72+0x74>)
 80082ea:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 80082ec:	6898      	ldr	r0, [r3, #8]
    test_assert(chThdGetPriorityX() == prio + 1, "unexpected priority level");
 80082ee:	4913      	ldr	r1, [pc, #76]	; (800833c <rt_test_003_003_execute.lto_priv.72+0x7c>)
 80082f0:	4285      	cmp	r5, r0
 80082f2:	bf14      	ite	ne
 80082f4:	2000      	movne	r0, #0
 80082f6:	2001      	moveq	r0, #1
 80082f8:	f004 ff5a 	bl	800d1b0 <_test_assert>
 80082fc:	b9b8      	cbnz	r0, 800832e <rt_test_003_003_execute.lto_priv.72+0x6e>
  test_set_step(2);
 80082fe:	2202      	movs	r2, #2
 8008300:	4b0b      	ldr	r3, [pc, #44]	; (8008330 <rt_test_003_003_execute.lto_priv.72+0x70>)
 8008302:	601a      	str	r2, [r3, #0]
    p1 = chThdSetPriority(p1);
 8008304:	4630      	mov	r0, r6
 8008306:	f003 f9a3 	bl	800b650 <chThdSetPriority>
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 800830a:	490b      	ldr	r1, [pc, #44]	; (8008338 <rt_test_003_003_execute.lto_priv.72+0x78>)
 800830c:	4285      	cmp	r5, r0
 800830e:	bf14      	ite	ne
 8008310:	2000      	movne	r0, #0
 8008312:	2001      	moveq	r0, #1
 8008314:	f004 ff4c 	bl	800d1b0 <_test_assert>
 8008318:	b948      	cbnz	r0, 800832e <rt_test_003_003_execute.lto_priv.72+0x6e>
  return ch.rlist.current;
 800831a:	4b06      	ldr	r3, [pc, #24]	; (8008334 <rt_test_003_003_execute.lto_priv.72+0x74>)
 800831c:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 800831e:	6898      	ldr	r0, [r3, #8]
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
 8008320:	4906      	ldr	r1, [pc, #24]	; (800833c <rt_test_003_003_execute.lto_priv.72+0x7c>)
 8008322:	4284      	cmp	r4, r0
 8008324:	bf14      	ite	ne
 8008326:	2000      	movne	r0, #0
 8008328:	2001      	moveq	r0, #1
 800832a:	f004 ff41 	bl	800d1b0 <_test_assert>
 800832e:	bd70      	pop	{r4, r5, r6, pc}
 8008330:	20003e04 	.word	0x20003e04
 8008334:	20003aec 	.word	0x20003aec
 8008338:	0800ea9c 	.word	0x0800ea9c
 800833c:	0800ea80 	.word	0x0800ea80

08008340 <rt_test_003_001_execute.lto_priv.70>:
static void rt_test_003_001_execute(void) {
 8008340:	b538      	push	{r3, r4, r5, lr}
  test_set_step(1);
 8008342:	2201      	movs	r2, #1
 8008344:	4b2b      	ldr	r3, [pc, #172]	; (80083f4 <rt_test_003_001_execute.lto_priv.70+0xb4>)
 8008346:	601a      	str	r2, [r3, #0]
 8008348:	4b2b      	ldr	r3, [pc, #172]	; (80083f8 <rt_test_003_001_execute.lto_priv.70+0xb8>)
 800834a:	6a5c      	ldr	r4, [r3, #36]	; 0x24
    chThdSleep(100);
 800834c:	2064      	movs	r0, #100	; 0x64
 800834e:	f003 fc7f 	bl	800bc50 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, 100),
 8008352:	4a2a      	ldr	r2, [pc, #168]	; (80083fc <rt_test_003_001_execute.lto_priv.70+0xbc>)
 8008354:	f104 0167 	add.w	r1, r4, #103	; 0x67
 8008358:	f104 0064 	add.w	r0, r4, #100	; 0x64
 800835c:	f004 fff0 	bl	800d340 <_test_assert_time_window>
 8008360:	2800      	cmp	r0, #0
 8008362:	d145      	bne.n	80083f0 <rt_test_003_001_execute.lto_priv.70+0xb0>
  test_set_step(2);
 8008364:	2202      	movs	r2, #2
 8008366:	4b23      	ldr	r3, [pc, #140]	; (80083f4 <rt_test_003_001_execute.lto_priv.70+0xb4>)
 8008368:	601a      	str	r2, [r3, #0]
 800836a:	4b23      	ldr	r3, [pc, #140]	; (80083f8 <rt_test_003_001_execute.lto_priv.70+0xb8>)
 800836c:	6a5c      	ldr	r4, [r3, #36]	; 0x24
    chThdSleepMicroseconds(100000);
 800836e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8008372:	f003 fc6d 	bl	800bc50 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, TIME_US2I(100000)),
 8008376:	4a21      	ldr	r2, [pc, #132]	; (80083fc <rt_test_003_001_execute.lto_priv.70+0xbc>)
 8008378:	f204 31eb 	addw	r1, r4, #1003	; 0x3eb
 800837c:	f504 707a 	add.w	r0, r4, #1000	; 0x3e8
 8008380:	f004 ffde 	bl	800d340 <_test_assert_time_window>
 8008384:	2800      	cmp	r0, #0
 8008386:	d133      	bne.n	80083f0 <rt_test_003_001_execute.lto_priv.70+0xb0>
  test_set_step(3);
 8008388:	2203      	movs	r2, #3
 800838a:	4b1a      	ldr	r3, [pc, #104]	; (80083f4 <rt_test_003_001_execute.lto_priv.70+0xb4>)
 800838c:	601a      	str	r2, [r3, #0]
 800838e:	4b1a      	ldr	r3, [pc, #104]	; (80083f8 <rt_test_003_001_execute.lto_priv.70+0xb8>)
 8008390:	6a5c      	ldr	r4, [r3, #36]	; 0x24
    chThdSleepMilliseconds(100);
 8008392:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8008396:	f003 fc5b 	bl	800bc50 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, TIME_MS2I(100)),
 800839a:	4a18      	ldr	r2, [pc, #96]	; (80083fc <rt_test_003_001_execute.lto_priv.70+0xbc>)
 800839c:	f204 31eb 	addw	r1, r4, #1003	; 0x3eb
 80083a0:	f504 707a 	add.w	r0, r4, #1000	; 0x3e8
 80083a4:	f004 ffcc 	bl	800d340 <_test_assert_time_window>
 80083a8:	bb10      	cbnz	r0, 80083f0 <rt_test_003_001_execute.lto_priv.70+0xb0>
  test_set_step(4);
 80083aa:	2204      	movs	r2, #4
 80083ac:	4b11      	ldr	r3, [pc, #68]	; (80083f4 <rt_test_003_001_execute.lto_priv.70+0xb4>)
 80083ae:	601a      	str	r2, [r3, #0]
 80083b0:	4b11      	ldr	r3, [pc, #68]	; (80083f8 <rt_test_003_001_execute.lto_priv.70+0xb8>)
 80083b2:	6a5c      	ldr	r4, [r3, #36]	; 0x24
    chThdSleepSeconds(1);
 80083b4:	f242 7010 	movw	r0, #10000	; 0x2710
 80083b8:	f003 fc4a 	bl	800bc50 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, TIME_S2I(1)),
 80083bc:	4a0f      	ldr	r2, [pc, #60]	; (80083fc <rt_test_003_001_execute.lto_priv.70+0xbc>)
 80083be:	f504 511c 	add.w	r1, r4, #9984	; 0x2700
 80083c2:	3113      	adds	r1, #19
 80083c4:	f504 501c 	add.w	r0, r4, #9984	; 0x2700
 80083c8:	3010      	adds	r0, #16
 80083ca:	f004 ffb9 	bl	800d340 <_test_assert_time_window>
 80083ce:	b978      	cbnz	r0, 80083f0 <rt_test_003_001_execute.lto_priv.70+0xb0>
  test_set_step(5);
 80083d0:	2205      	movs	r2, #5
 80083d2:	4b08      	ldr	r3, [pc, #32]	; (80083f4 <rt_test_003_001_execute.lto_priv.70+0xb4>)
 80083d4:	601a      	str	r2, [r3, #0]
 80083d6:	4b08      	ldr	r3, [pc, #32]	; (80083f8 <rt_test_003_001_execute.lto_priv.70+0xb8>)
 80083d8:	6a5d      	ldr	r5, [r3, #36]	; 0x24
 80083da:	f105 0464 	add.w	r4, r5, #100	; 0x64
    chThdSleepUntil(chTimeAddX(time, 100));
 80083de:	4620      	mov	r0, r4
 80083e0:	f003 fc1e 	bl	800bc20 <chThdSleepUntil>
    test_assert_time_window(chTimeAddX(time, 100),
 80083e4:	4a05      	ldr	r2, [pc, #20]	; (80083fc <rt_test_003_001_execute.lto_priv.70+0xbc>)
 80083e6:	f105 0167 	add.w	r1, r5, #103	; 0x67
 80083ea:	4620      	mov	r0, r4
 80083ec:	f004 ffa8 	bl	800d340 <_test_assert_time_window>
 80083f0:	bd38      	pop	{r3, r4, r5, pc}
 80083f2:	bf00      	nop
 80083f4:	20003e04 	.word	0x20003e04
 80083f8:	40000c00 	.word	0x40000c00
 80083fc:	0800e788 	.word	0x0800e788

08008400 <get_descriptor.lto_priv.1>:
                                           uint8_t dindex,
                                           uint16_t lang) {

  (void)usbp;
  (void)lang;
  switch (dtype) {
 8008400:	2902      	cmp	r1, #2
 8008402:	d00d      	beq.n	8008420 <get_descriptor.lto_priv.1+0x20>
 8008404:	2903      	cmp	r1, #3
 8008406:	d003      	beq.n	8008410 <get_descriptor.lto_priv.1+0x10>
 8008408:	2901      	cmp	r1, #1
 800840a:	d107      	bne.n	800841c <get_descriptor.lto_priv.1+0x1c>
  case USB_DESCRIPTOR_DEVICE:
    return &vcom_device_descriptor;
 800840c:	4806      	ldr	r0, [pc, #24]	; (8008428 <get_descriptor.lto_priv.1+0x28>)
 800840e:	4770      	bx	lr
  case USB_DESCRIPTOR_CONFIGURATION:
    return &vcom_configuration_descriptor;
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
 8008410:	2a03      	cmp	r2, #3
 8008412:	d807      	bhi.n	8008424 <get_descriptor.lto_priv.1+0x24>
      return &vcom_strings[dindex];
 8008414:	4b05      	ldr	r3, [pc, #20]	; (800842c <get_descriptor.lto_priv.1+0x2c>)
 8008416:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
 800841a:	4770      	bx	lr
  }
  return NULL;
 800841c:	2000      	movs	r0, #0
 800841e:	4770      	bx	lr
    return &vcom_configuration_descriptor;
 8008420:	4803      	ldr	r0, [pc, #12]	; (8008430 <get_descriptor.lto_priv.1+0x30>)
 8008422:	4770      	bx	lr
  return NULL;
 8008424:	2000      	movs	r0, #0
}
 8008426:	4770      	bx	lr
 8008428:	0800fe48 	.word	0x0800fe48
 800842c:	0800fb44 	.word	0x0800fb44
 8008430:	0800fd54 	.word	0x0800fd54
	...

08008440 <long_to_string_with_divisor>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 8008440:	b4f0      	push	{r4, r5, r6, r7}
  int i;
  char *q;
  long l, ll;

  l = num;
  if (divisor == 0) {
 8008442:	461e      	mov	r6, r3
 8008444:	b903      	cbnz	r3, 8008448 <long_to_string_with_divisor+0x8>
    ll = num;
 8008446:	460e      	mov	r6, r1
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 8008448:	f100 030b 	add.w	r3, r0, #11
 800844c:	461c      	mov	r4, r3
  do {
    i = (int)(l % radix);
 800844e:	460f      	mov	r7, r1
 8008450:	fbb1 f5f2 	udiv	r5, r1, r2
 8008454:	fb02 1115 	mls	r1, r2, r5, r1
    i += '0';
 8008458:	f101 0530 	add.w	r5, r1, #48	; 0x30
    if (i > '9')
 800845c:	2d39      	cmp	r5, #57	; 0x39
 800845e:	dd01      	ble.n	8008464 <long_to_string_with_divisor+0x24>
      i += 'A' - '0' - 10;
 8008460:	f101 0537 	add.w	r5, r1, #55	; 0x37
    *--q = i;
 8008464:	f804 5d01 	strb.w	r5, [r4, #-1]!
    l /= radix;
 8008468:	fbb7 f1f2 	udiv	r1, r7, r2
  } while ((ll /= radix) != 0);
 800846c:	fbb6 f6f2 	udiv	r6, r6, r2
 8008470:	2e00      	cmp	r6, #0
 8008472:	d1ec      	bne.n	800844e <long_to_string_with_divisor+0xe>

  i = (int)(p + MAX_FILLER - q);
 8008474:	1b1b      	subs	r3, r3, r4
  do
    *p++ = *q++;
 8008476:	1c42      	adds	r2, r0, #1
 8008478:	7821      	ldrb	r1, [r4, #0]
 800847a:	7001      	strb	r1, [r0, #0]
 800847c:	4610      	mov	r0, r2
 800847e:	3401      	adds	r4, #1
  while (--i);
 8008480:	3b01      	subs	r3, #1
 8008482:	d1f8      	bne.n	8008476 <long_to_string_with_divisor+0x36>

  return p;
}
 8008484:	bcf0      	pop	{r4, r5, r6, r7}
 8008486:	4770      	bx	lr
	...

08008490 <ch_ltoa>:

static char *ch_ltoa(char *p, long num, unsigned radix) {
 8008490:	b508      	push	{r3, lr}

  return long_to_string_with_divisor(p, num, radix, 0);
 8008492:	2300      	movs	r3, #0
 8008494:	f7ff ffd4 	bl	8008440 <long_to_string_with_divisor>
}
 8008498:	bd08      	pop	{r3, pc}
 800849a:	bf00      	nop
 800849c:	0000      	movs	r0, r0
	...

080084a0 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 80084a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80084a4:	b087      	sub	sp, #28
 80084a6:	4607      	mov	r7, r0
 80084a8:	460d      	mov	r5, r1
 80084aa:	4691      	mov	r9, r2
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 80084ac:	2600      	movs	r6, #0
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 80084ae:	f105 0801 	add.w	r8, r5, #1
 80084b2:	7829      	ldrb	r1, [r5, #0]
    if (c == 0)
 80084b4:	2900      	cmp	r1, #0
 80084b6:	f000 8118 	beq.w	80086ea <chvprintf+0x24a>
      return n;
    if (c != '%') {
 80084ba:	2925      	cmp	r1, #37	; 0x25
 80084bc:	d006      	beq.n	80084cc <chvprintf+0x2c>
      streamPut(chp, (uint8_t)c);
 80084be:	683b      	ldr	r3, [r7, #0]
 80084c0:	68db      	ldr	r3, [r3, #12]
 80084c2:	4638      	mov	r0, r7
 80084c4:	4798      	blx	r3
      n++;
 80084c6:	3601      	adds	r6, #1
    c = *fmt++;
 80084c8:	4645      	mov	r5, r8
 80084ca:	e7f0      	b.n	80084ae <chvprintf+0xe>
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 80084cc:	786b      	ldrb	r3, [r5, #1]
 80084ce:	2b2d      	cmp	r3, #45	; 0x2d
 80084d0:	d104      	bne.n	80084dc <chvprintf+0x3c>
      fmt++;
 80084d2:	f105 0802 	add.w	r8, r5, #2
      left_align = TRUE;
 80084d6:	f04f 0b01 	mov.w	fp, #1
 80084da:	e001      	b.n	80084e0 <chvprintf+0x40>
    left_align = FALSE;
 80084dc:	f04f 0b00 	mov.w	fp, #0
    }
    filler = ' ';
    if (*fmt == '0') {
 80084e0:	f898 3000 	ldrb.w	r3, [r8]
 80084e4:	2b30      	cmp	r3, #48	; 0x30
 80084e6:	d103      	bne.n	80084f0 <chvprintf+0x50>
      fmt++;
 80084e8:	f108 0801 	add.w	r8, r8, #1
      filler = '0';
 80084ec:	9301      	str	r3, [sp, #4]
 80084ee:	e001      	b.n	80084f4 <chvprintf+0x54>
    filler = ' ';
 80084f0:	2320      	movs	r3, #32
 80084f2:	9301      	str	r3, [sp, #4]
    }
    width = 0;
 80084f4:	2400      	movs	r4, #0
    while (TRUE) {
      c = *fmt++;
 80084f6:	f108 0501 	add.w	r5, r8, #1
 80084fa:	f898 2000 	ldrb.w	r2, [r8]
      if (c >= '0' && c <= '9')
 80084fe:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8008502:	b2db      	uxtb	r3, r3
 8008504:	2b09      	cmp	r3, #9
 8008506:	d905      	bls.n	8008514 <chvprintf+0x74>
        c -= '0';
      else if (c == '*')
 8008508:	2a2a      	cmp	r2, #42	; 0x2a
 800850a:	d109      	bne.n	8008520 <chvprintf+0x80>
        c = va_arg(ap, int);
 800850c:	f899 3000 	ldrb.w	r3, [r9]
 8008510:	f109 0904 	add.w	r9, r9, #4
      else
        break;
      width = width * 10 + c;
 8008514:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8008518:	0062      	lsls	r2, r4, #1
 800851a:	18d4      	adds	r4, r2, r3
      c = *fmt++;
 800851c:	46a8      	mov	r8, r5
 800851e:	e7ea      	b.n	80084f6 <chvprintf+0x56>
    }
    precision = 0;
    if (c == '.') {
 8008520:	2a2e      	cmp	r2, #46	; 0x2e
 8008522:	d113      	bne.n	800854c <chvprintf+0xac>
 8008524:	2300      	movs	r3, #0
      while (TRUE) {
        c = *fmt++;
 8008526:	1c68      	adds	r0, r5, #1
 8008528:	782a      	ldrb	r2, [r5, #0]
        if (c >= '0' && c <= '9')
 800852a:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
 800852e:	b2c9      	uxtb	r1, r1
 8008530:	2909      	cmp	r1, #9
 8008532:	d905      	bls.n	8008540 <chvprintf+0xa0>
          c -= '0';
        else if (c == '*')
 8008534:	2a2a      	cmp	r2, #42	; 0x2a
 8008536:	d10b      	bne.n	8008550 <chvprintf+0xb0>
          c = va_arg(ap, int);
 8008538:	f899 1000 	ldrb.w	r1, [r9]
 800853c:	f109 0904 	add.w	r9, r9, #4
        else
          break;
        precision *= 10;
 8008540:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8008544:	005a      	lsls	r2, r3, #1
        precision += c;
 8008546:	188b      	adds	r3, r1, r2
        c = *fmt++;
 8008548:	4605      	mov	r5, r0
 800854a:	e7ec      	b.n	8008526 <chvprintf+0x86>
    precision = 0;
 800854c:	2300      	movs	r3, #0
 800854e:	e000      	b.n	8008552 <chvprintf+0xb2>
        c = *fmt++;
 8008550:	4605      	mov	r5, r0
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8008552:	2a6c      	cmp	r2, #108	; 0x6c
 8008554:	d001      	beq.n	800855a <chvprintf+0xba>
 8008556:	2a4c      	cmp	r2, #76	; 0x4c
 8008558:	d105      	bne.n	8008566 <chvprintf+0xc6>
      is_long = TRUE;
      if (*fmt)
 800855a:	7829      	ldrb	r1, [r5, #0]
 800855c:	b159      	cbz	r1, 8008576 <chvprintf+0xd6>
        c = *fmt++;
 800855e:	3501      	adds	r5, #1
 8008560:	460a      	mov	r2, r1
      is_long = TRUE;
 8008562:	2101      	movs	r1, #1
 8008564:	e008      	b.n	8008578 <chvprintf+0xd8>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');
 8008566:	f1a2 0141 	sub.w	r1, r2, #65	; 0x41
 800856a:	b2c9      	uxtb	r1, r1
 800856c:	2919      	cmp	r1, #25
 800856e:	bf8c      	ite	hi
 8008570:	2100      	movhi	r1, #0
 8008572:	2101      	movls	r1, #1
 8008574:	e000      	b.n	8008578 <chvprintf+0xd8>
      is_long = TRUE;
 8008576:	2101      	movs	r1, #1

    /* Command decoding.*/
    switch (c) {
 8008578:	f1a2 0044 	sub.w	r0, r2, #68	; 0x44
 800857c:	2834      	cmp	r0, #52	; 0x34
 800857e:	d86e      	bhi.n	800865e <chvprintf+0x1be>
 8008580:	e8df f000 	tbb	[pc, r0]
 8008584:	6d6d6d40 	.word	0x6d6d6d40
 8008588:	6d6d406d 	.word	0x6d6d406d
 800858c:	5a6d6d6d 	.word	0x5a6d6d6d
 8008590:	6d6d6d6d 	.word	0x6d6d6d6d
 8008594:	6d6d5c6d 	.word	0x6d6d5c6d
 8008598:	6d6d6d1b 	.word	0x6d6d6d1b
 800859c:	6d6d6d6d 	.word	0x6d6d6d6d
 80085a0:	1d6d6d6d 	.word	0x1d6d6d6d
 80085a4:	6d6d6d40 	.word	0x6d6d6d40
 80085a8:	6d6d406d 	.word	0x6d6d406d
 80085ac:	5a6d6d6d 	.word	0x5a6d6d6d
 80085b0:	2a6d6d6d 	.word	0x2a6d6d6d
 80085b4:	6d6d5c6d 	.word	0x6d6d5c6d
 80085b8:	1b          	.byte	0x1b
 80085b9:	00          	.byte	0x00
      p = ftoa(p, f, precision);
      break;
#endif
    case 'X':
    case 'x':
      c = 16;
 80085ba:	2210      	movs	r2, #16
 80085bc:	e03f      	b.n	800863e <chvprintf+0x19e>
      *p++ = va_arg(ap, int);
 80085be:	f8d9 3000 	ldr.w	r3, [r9]
 80085c2:	f109 0904 	add.w	r9, r9, #4
 80085c6:	f10d 0a18 	add.w	sl, sp, #24
 80085ca:	f80a 3d0c 	strb.w	r3, [sl, #-12]!
      filler = ' ';
 80085ce:	2320      	movs	r3, #32
 80085d0:	9301      	str	r3, [sp, #4]
      *p++ = va_arg(ap, int);
 80085d2:	f10d 000d 	add.w	r0, sp, #13
 80085d6:	e04b      	b.n	8008670 <chvprintf+0x1d0>
      if ((s = va_arg(ap, char *)) == 0)
 80085d8:	f8d9 a000 	ldr.w	sl, [r9]
 80085dc:	f109 0904 	add.w	r9, r9, #4
 80085e0:	f1ba 0f00 	cmp.w	sl, #0
 80085e4:	d101      	bne.n	80085ea <chvprintf+0x14a>
        s = "(null)";
 80085e6:	f8df a10c 	ldr.w	sl, [pc, #268]	; 80086f4 <chvprintf+0x254>
      if (precision == 0)
 80085ea:	b90b      	cbnz	r3, 80085f0 <chvprintf+0x150>
        precision = 32767;
 80085ec:	f647 73ff 	movw	r3, #32767	; 0x7fff
 80085f0:	4650      	mov	r0, sl
 80085f2:	e000      	b.n	80085f6 <chvprintf+0x156>
      for (p = s; *p && (--precision >= 0); p++)
 80085f4:	3001      	adds	r0, #1
 80085f6:	7802      	ldrb	r2, [r0, #0]
 80085f8:	b3c2      	cbz	r2, 800866c <chvprintf+0x1cc>
 80085fa:	3b01      	subs	r3, #1
 80085fc:	d5fa      	bpl.n	80085f4 <chvprintf+0x154>
      filler = ' ';
 80085fe:	2320      	movs	r3, #32
 8008600:	9301      	str	r3, [sp, #4]
 8008602:	e035      	b.n	8008670 <chvprintf+0x1d0>
      if (is_long)
 8008604:	b121      	cbz	r1, 8008610 <chvprintf+0x170>
        l = va_arg(ap, long);
 8008606:	f8d9 1000 	ldr.w	r1, [r9]
 800860a:	f109 0904 	add.w	r9, r9, #4
 800860e:	e003      	b.n	8008618 <chvprintf+0x178>
        l = va_arg(ap, int);
 8008610:	f8d9 1000 	ldr.w	r1, [r9]
 8008614:	f109 0904 	add.w	r9, r9, #4
      if (l < 0) {
 8008618:	2900      	cmp	r1, #0
 800861a:	da06      	bge.n	800862a <chvprintf+0x18a>
        *p++ = '-';
 800861c:	232d      	movs	r3, #45	; 0x2d
 800861e:	f88d 300c 	strb.w	r3, [sp, #12]
        l = -l;
 8008622:	4249      	negs	r1, r1
        *p++ = '-';
 8008624:	f10d 000d 	add.w	r0, sp, #13
 8008628:	e000      	b.n	800862c <chvprintf+0x18c>
    p = tmpbuf;
 800862a:	a803      	add	r0, sp, #12
      p = ch_ltoa(p, l, 10);
 800862c:	220a      	movs	r2, #10
 800862e:	f7ff ff2f 	bl	8008490 <ch_ltoa>
    s = tmpbuf;
 8008632:	f10d 0a0c 	add.w	sl, sp, #12
 8008636:	e01b      	b.n	8008670 <chvprintf+0x1d0>
    case 'u':
      c = 10;
      goto unsigned_common;
    case 'O':
    case 'o':
      c = 8;
 8008638:	2208      	movs	r2, #8
 800863a:	e000      	b.n	800863e <chvprintf+0x19e>
      c = 10;
 800863c:	220a      	movs	r2, #10
unsigned_common:
      if (is_long)
 800863e:	b121      	cbz	r1, 800864a <chvprintf+0x1aa>
        l = va_arg(ap, unsigned long);
 8008640:	f8d9 1000 	ldr.w	r1, [r9]
 8008644:	f109 0904 	add.w	r9, r9, #4
 8008648:	e003      	b.n	8008652 <chvprintf+0x1b2>
      else
        l = va_arg(ap, unsigned int);
 800864a:	f8d9 1000 	ldr.w	r1, [r9]
 800864e:	f109 0904 	add.w	r9, r9, #4
      p = ch_ltoa(p, l, c);
 8008652:	a803      	add	r0, sp, #12
 8008654:	f7ff ff1c 	bl	8008490 <ch_ltoa>
    s = tmpbuf;
 8008658:	f10d 0a0c 	add.w	sl, sp, #12
 800865c:	e008      	b.n	8008670 <chvprintf+0x1d0>
      break;
    default:
      *p++ = c;
 800865e:	f10d 0a18 	add.w	sl, sp, #24
 8008662:	f80a 2d0c 	strb.w	r2, [sl, #-12]!
 8008666:	f10d 000d 	add.w	r0, sp, #13
 800866a:	e001      	b.n	8008670 <chvprintf+0x1d0>
      filler = ' ';
 800866c:	2320      	movs	r3, #32
 800866e:	9301      	str	r3, [sp, #4]
      break;
    }
    i = (int)(p - s);
 8008670:	ebca 0800 	rsb	r8, sl, r0
    if ((width -= i) < 0)
 8008674:	ebb4 0408 	subs.w	r4, r4, r8
 8008678:	d500      	bpl.n	800867c <chvprintf+0x1dc>
      width = 0;
 800867a:	2400      	movs	r4, #0
    if (left_align == FALSE)
 800867c:	f1bb 0f00 	cmp.w	fp, #0
 8008680:	d100      	bne.n	8008684 <chvprintf+0x1e4>
      width = -width;
 8008682:	4264      	negs	r4, r4
    if (width < 0) {
 8008684:	2c00      	cmp	r4, #0
 8008686:	da22      	bge.n	80086ce <chvprintf+0x22e>
      if (*s == '-' && filler == '0') {
 8008688:	f89a 1000 	ldrb.w	r1, [sl]
 800868c:	292d      	cmp	r1, #45	; 0x2d
 800868e:	d10b      	bne.n	80086a8 <chvprintf+0x208>
 8008690:	9b01      	ldr	r3, [sp, #4]
 8008692:	2b30      	cmp	r3, #48	; 0x30
 8008694:	d108      	bne.n	80086a8 <chvprintf+0x208>
        streamPut(chp, (uint8_t)*s++);
 8008696:	f10a 0a01 	add.w	sl, sl, #1
 800869a:	683b      	ldr	r3, [r7, #0]
 800869c:	68db      	ldr	r3, [r3, #12]
 800869e:	4638      	mov	r0, r7
 80086a0:	4798      	blx	r3
        n++;
 80086a2:	3601      	adds	r6, #1
        i--;
 80086a4:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
      }
      do {
        streamPut(chp, (uint8_t)filler);
 80086a8:	683b      	ldr	r3, [r7, #0]
 80086aa:	68db      	ldr	r3, [r3, #12]
 80086ac:	9901      	ldr	r1, [sp, #4]
 80086ae:	4638      	mov	r0, r7
 80086b0:	4798      	blx	r3
        n++;
 80086b2:	3601      	adds	r6, #1
      } while (++width != 0);
 80086b4:	3401      	adds	r4, #1
 80086b6:	d1f7      	bne.n	80086a8 <chvprintf+0x208>
 80086b8:	e009      	b.n	80086ce <chvprintf+0x22e>
    }
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
 80086ba:	f10a 0b01 	add.w	fp, sl, #1
 80086be:	683b      	ldr	r3, [r7, #0]
 80086c0:	68db      	ldr	r3, [r3, #12]
 80086c2:	f89a 1000 	ldrb.w	r1, [sl]
 80086c6:	4638      	mov	r0, r7
 80086c8:	4798      	blx	r3
      n++;
 80086ca:	3601      	adds	r6, #1
      streamPut(chp, (uint8_t)*s++);
 80086cc:	46da      	mov	sl, fp
    while (--i >= 0) {
 80086ce:	f1b8 0801 	subs.w	r8, r8, #1
 80086d2:	d5f2      	bpl.n	80086ba <chvprintf+0x21a>
 80086d4:	e006      	b.n	80086e4 <chvprintf+0x244>
    }

    while (width) {
      streamPut(chp, (uint8_t)filler);
 80086d6:	683b      	ldr	r3, [r7, #0]
 80086d8:	68db      	ldr	r3, [r3, #12]
 80086da:	9901      	ldr	r1, [sp, #4]
 80086dc:	4638      	mov	r0, r7
 80086de:	4798      	blx	r3
      n++;
 80086e0:	3601      	adds	r6, #1
      width--;
 80086e2:	3c01      	subs	r4, #1
    while (width) {
 80086e4:	2c00      	cmp	r4, #0
 80086e6:	d1f6      	bne.n	80086d6 <chvprintf+0x236>
 80086e8:	e6e1      	b.n	80084ae <chvprintf+0xe>
    }
  }
}
 80086ea:	4630      	mov	r0, r6
 80086ec:	b007      	add	sp, #28
 80086ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80086f2:	bf00      	nop
 80086f4:	0800ee64 	.word	0x0800ee64
	...

08008700 <sof_handler.lto_priv.2>:
}

/*
 * Handles the USB driver global events.
 */
static void sof_handler(USBDriver *usbp) {
 8008700:	b508      	push	{r3, lr}
 8008702:	2320      	movs	r3, #32
 8008704:	f383 8811 	msr	BASEPRI, r3

  (void)usbp;

  osalSysLockFromISR();
  sduSOFHookI(&SDU1);
 8008708:	4803      	ldr	r0, [pc, #12]	; (8008718 <sof_handler.lto_priv.2+0x18>)
 800870a:	f7fa fd11 	bl	8003130 <sduSOFHookI>
 800870e:	2300      	movs	r3, #0
 8008710:	f383 8811 	msr	BASEPRI, r3
 8008714:	bd08      	pop	{r3, pc}
 8008716:	bf00      	nop
 8008718:	2000365c 	.word	0x2000365c
 800871c:	00000000 	.word	0x00000000

08008720 <usb_event.lto_priv.0>:
static void usb_event(USBDriver *usbp, usbevent_t event) {
 8008720:	b510      	push	{r4, lr}
  switch (event) {
 8008722:	2905      	cmp	r1, #5
 8008724:	d82b      	bhi.n	800877e <usb_event.lto_priv.0+0x5e>
 8008726:	e8df f001 	tbb	[pc, r1]
 800872a:	2a17      	.short	0x2a17
 800872c:	21171703 	.word	0x21171703
 8008730:	4604      	mov	r4, r0
 8008732:	2320      	movs	r3, #32
 8008734:	f383 8811 	msr	BASEPRI, r3
    usbInitEndpointI(usbp, USBD2_DATA_REQUEST_EP, &ep1config);
 8008738:	4a11      	ldr	r2, [pc, #68]	; (8008780 <usb_event.lto_priv.0+0x60>)
 800873a:	2101      	movs	r1, #1
 800873c:	f7fd fe70 	bl	8006420 <usbInitEndpointI>
    usbInitEndpointI(usbp, USBD2_INTERRUPT_REQUEST_EP, &ep2config);
 8008740:	4a10      	ldr	r2, [pc, #64]	; (8008784 <usb_event.lto_priv.0+0x64>)
 8008742:	2102      	movs	r1, #2
 8008744:	4620      	mov	r0, r4
 8008746:	f7fd fe6b 	bl	8006420 <usbInitEndpointI>
    sduConfigureHookI(&SDU1);
 800874a:	480f      	ldr	r0, [pc, #60]	; (8008788 <usb_event.lto_priv.0+0x68>)
 800874c:	f7fa fd18 	bl	8003180 <sduConfigureHookI>
 8008750:	2300      	movs	r3, #0
 8008752:	f383 8811 	msr	BASEPRI, r3
 8008756:	bd10      	pop	{r4, pc}
 8008758:	2320      	movs	r3, #32
 800875a:	f383 8811 	msr	BASEPRI, r3
    sduSuspendHookI(&SDU1);
 800875e:	480a      	ldr	r0, [pc, #40]	; (8008788 <usb_event.lto_priv.0+0x68>)
 8008760:	f7fa fd36 	bl	80031d0 <sduSuspendHookI>
 8008764:	2300      	movs	r3, #0
 8008766:	f383 8811 	msr	BASEPRI, r3
 800876a:	bd10      	pop	{r4, pc}
 800876c:	2320      	movs	r3, #32
 800876e:	f383 8811 	msr	BASEPRI, r3
    sduWakeupHookI(&SDU1);
 8008772:	4805      	ldr	r0, [pc, #20]	; (8008788 <usb_event.lto_priv.0+0x68>)
 8008774:	f7fa fd1c 	bl	80031b0 <sduWakeupHookI>
 8008778:	2300      	movs	r3, #0
 800877a:	f383 8811 	msr	BASEPRI, r3
 800877e:	bd10      	pop	{r4, pc}
 8008780:	0800eb80 	.word	0x0800eb80
 8008784:	0800fd84 	.word	0x0800fd84
 8008788:	2000365c 	.word	0x2000365c
 800878c:	00000000 	.word	0x00000000

08008790 <cmdexec>:
    scp++;
  }
}

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {
 8008790:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008792:	4604      	mov	r4, r0
 8008794:	460e      	mov	r6, r1
 8008796:	4615      	mov	r5, r2
 8008798:	461f      	mov	r7, r3
 800879a:	e00b      	b.n	80087b4 <cmdexec+0x24>

  while (scp->sc_name != NULL) {
    if (strcmp(scp->sc_name, name) == 0) {
 800879c:	4629      	mov	r1, r5
 800879e:	f7f9 f9d3 	bl	8001b48 <strcmp>
 80087a2:	b930      	cbnz	r0, 80087b2 <cmdexec+0x22>
      scp->sc_function(chp, argc, argv);
 80087a4:	6863      	ldr	r3, [r4, #4]
 80087a6:	9a06      	ldr	r2, [sp, #24]
 80087a8:	4639      	mov	r1, r7
 80087aa:	4630      	mov	r0, r6
 80087ac:	4798      	blx	r3
      return false;
 80087ae:	2000      	movs	r0, #0
 80087b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }
    scp++;
 80087b2:	3408      	adds	r4, #8
  while (scp->sc_name != NULL) {
 80087b4:	6820      	ldr	r0, [r4, #0]
 80087b6:	2800      	cmp	r0, #0
 80087b8:	d1f0      	bne.n	800879c <cmdexec+0xc>
  }
  return true;
 80087ba:	2001      	movs	r0, #1
}
 80087bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80087be:	bf00      	nop

080087c0 <test_rt>:
  } while (tp != NULL);
}
#endif

#if (SHELL_CMD_TEST_ENABLED == TRUE) || defined(__DOXYGEN__)
static THD_FUNCTION(test_rt, arg) {
 80087c0:	b508      	push	{r3, lr}
  BaseSequentialStream *chp = (BaseSequentialStream *)arg;
  test_execute(chp, &rt_test_suite);
 80087c2:	4902      	ldr	r1, [pc, #8]	; (80087cc <test_rt+0xc>)
 80087c4:	f004 fbdc 	bl	800cf80 <test_execute>
 80087c8:	bd08      	pop	{r3, pc}
 80087ca:	bf00      	nop
 80087cc:	0800fd5c 	.word	0x0800fd5c

080087d0 <test_oslib>:
}

static THD_FUNCTION(test_oslib, arg) {
 80087d0:	b508      	push	{r3, lr}
  BaseSequentialStream *chp = (BaseSequentialStream *)arg;
  test_execute(chp, &oslib_test_suite);
 80087d2:	4902      	ldr	r1, [pc, #8]	; (80087dc <test_oslib+0xc>)
 80087d4:	f004 fbd4 	bl	800cf80 <test_execute>
 80087d8:	bd08      	pop	{r3, pc}
 80087da:	bf00      	nop
 80087dc:	0800fbbc 	.word	0x0800fbbc

080087e0 <shellExit>:
 *
 * @param[in] msg       shell exit code
 *
 * @api
 */
void shellExit(msg_t msg) {
 80087e0:	b510      	push	{r4, lr}
 80087e2:	4604      	mov	r4, r0
 80087e4:	2320      	movs	r3, #32
 80087e6:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 80087ea:	2100      	movs	r1, #0
 80087ec:	4803      	ldr	r0, [pc, #12]	; (80087fc <shellExit+0x1c>)
 80087ee:	f002 fc6f 	bl	800b0d0 <chEvtBroadcastFlagsI>

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
  chEvtBroadcastI(&shell_terminated);
  chThdExitS(msg);
 80087f2:	4620      	mov	r0, r4
 80087f4:	f003 f934 	bl	800ba60 <chThdExitS>
 80087f8:	bd10      	pop	{r4, pc}
 80087fa:	bf00      	nop
 80087fc:	20003130 	.word	0x20003130

08008800 <parse_arguments>:
static char *parse_arguments(char *str, char **saveptr) {
 8008800:	b570      	push	{r4, r5, r6, lr}
  if (str != NULL)
 8008802:	b100      	cbz	r0, 8008806 <parse_arguments+0x6>
    *saveptr = str;
 8008804:	6008      	str	r0, [r1, #0]
  p = *saveptr;
 8008806:	680e      	ldr	r6, [r1, #0]
  if (!p) {
 8008808:	b1f6      	cbz	r6, 8008848 <parse_arguments+0x48>
 800880a:	460c      	mov	r4, r1
  p += strspn(p, " \t");
 800880c:	4910      	ldr	r1, [pc, #64]	; (8008850 <parse_arguments+0x50>)
 800880e:	4630      	mov	r0, r6
 8008810:	f7f9 fd7a 	bl	8002308 <strspn>
 8008814:	1835      	adds	r5, r6, r0
  if (*p == '"') {
 8008816:	5c33      	ldrb	r3, [r6, r0]
 8008818:	2b22      	cmp	r3, #34	; 0x22
 800881a:	d106      	bne.n	800882a <parse_arguments+0x2a>
    p++;
 800881c:	3501      	adds	r5, #1
    *saveptr = strpbrk(p, "\"");
 800881e:	2122      	movs	r1, #34	; 0x22
 8008820:	4628      	mov	r0, r5
 8008822:	f7f9 fc63 	bl	80020ec <strchr>
 8008826:	6020      	str	r0, [r4, #0]
 8008828:	e004      	b.n	8008834 <parse_arguments+0x34>
    *saveptr = strpbrk(p, " \t");
 800882a:	4909      	ldr	r1, [pc, #36]	; (8008850 <parse_arguments+0x50>)
 800882c:	4628      	mov	r0, r5
 800882e:	f7f9 fd49 	bl	80022c4 <strpbrk>
 8008832:	6020      	str	r0, [r4, #0]
  if (*saveptr != NULL) {
 8008834:	6823      	ldr	r3, [r4, #0]
 8008836:	b11b      	cbz	r3, 8008840 <parse_arguments+0x40>
    *(*saveptr)++ = '\0';
 8008838:	1c5a      	adds	r2, r3, #1
 800883a:	6022      	str	r2, [r4, #0]
 800883c:	2200      	movs	r2, #0
 800883e:	701a      	strb	r2, [r3, #0]
  return *p != '\0' ? p : NULL;
 8008840:	782b      	ldrb	r3, [r5, #0]
 8008842:	b91b      	cbnz	r3, 800884c <parse_arguments+0x4c>
 8008844:	2000      	movs	r0, #0
 8008846:	bd70      	pop	{r4, r5, r6, pc}
    return NULL;
 8008848:	2000      	movs	r0, #0
 800884a:	bd70      	pop	{r4, r5, r6, pc}
  return *p != '\0' ? p : NULL;
 800884c:	4628      	mov	r0, r5
}
 800884e:	bd70      	pop	{r4, r5, r6, pc}
 8008850:	0800ee6c 	.word	0x0800ee6c
	...

08008860 <_test_fail>:
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 8008860:	2301      	movs	r3, #1
 8008862:	4a04      	ldr	r2, [pc, #16]	; (8008874 <_test_fail+0x14>)
 8008864:	7013      	strb	r3, [r2, #0]
  test_global_fail     = true;
 8008866:	4a04      	ldr	r2, [pc, #16]	; (8008878 <_test_fail+0x18>)
 8008868:	7013      	strb	r3, [r2, #0]
  test_failure_message = msg;
 800886a:	4a04      	ldr	r2, [pc, #16]	; (800887c <_test_fail+0x1c>)
 800886c:	6010      	str	r0, [r2, #0]
  return true;
}
 800886e:	4618      	mov	r0, r3
 8008870:	4770      	bx	lr
 8008872:	bf00      	nop
 8008874:	20003e24 	.word	0x20003e24
 8008878:	20003e10 	.word	0x20003e10
 800887c:	20003e0c 	.word	0x20003e0c

08008880 <print_fat_line.lto_priv.21>:
static void print_fat_line(void) {
 8008880:	b510      	push	{r4, lr}
  for (i = 0; i < 76; i++)
 8008882:	2400      	movs	r4, #0
 8008884:	e006      	b.n	8008894 <print_fat_line.lto_priv.21+0x14>
    streamPut(test_chp, '=');
 8008886:	4b08      	ldr	r3, [pc, #32]	; (80088a8 <print_fat_line.lto_priv.21+0x28>)
 8008888:	6818      	ldr	r0, [r3, #0]
 800888a:	6803      	ldr	r3, [r0, #0]
 800888c:	68db      	ldr	r3, [r3, #12]
 800888e:	213d      	movs	r1, #61	; 0x3d
 8008890:	4798      	blx	r3
  for (i = 0; i < 76; i++)
 8008892:	3401      	adds	r4, #1
 8008894:	2c4b      	cmp	r4, #75	; 0x4b
 8008896:	d9f6      	bls.n	8008886 <print_fat_line.lto_priv.21+0x6>
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 8008898:	4b03      	ldr	r3, [pc, #12]	; (80088a8 <print_fat_line.lto_priv.21+0x28>)
 800889a:	6818      	ldr	r0, [r3, #0]
 800889c:	6803      	ldr	r3, [r0, #0]
 800889e:	685b      	ldr	r3, [r3, #4]
 80088a0:	2202      	movs	r2, #2
 80088a2:	4902      	ldr	r1, [pc, #8]	; (80088ac <print_fat_line.lto_priv.21+0x2c>)
 80088a4:	4798      	blx	r3
 80088a6:	bd10      	pop	{r4, pc}
 80088a8:	20003e08 	.word	0x20003e08
 80088ac:	0800f138 	.word	0x0800f138

080088b0 <print_line.lto_priv.18>:
static void print_line(void) {
 80088b0:	b510      	push	{r4, lr}
  for (i = 0; i < 76; i++)
 80088b2:	2400      	movs	r4, #0
 80088b4:	e006      	b.n	80088c4 <print_line.lto_priv.18+0x14>
    streamPut(test_chp, '-');
 80088b6:	4b08      	ldr	r3, [pc, #32]	; (80088d8 <print_line.lto_priv.18+0x28>)
 80088b8:	6818      	ldr	r0, [r3, #0]
 80088ba:	6803      	ldr	r3, [r0, #0]
 80088bc:	68db      	ldr	r3, [r3, #12]
 80088be:	212d      	movs	r1, #45	; 0x2d
 80088c0:	4798      	blx	r3
  for (i = 0; i < 76; i++)
 80088c2:	3401      	adds	r4, #1
 80088c4:	2c4b      	cmp	r4, #75	; 0x4b
 80088c6:	d9f6      	bls.n	80088b6 <print_line.lto_priv.18+0x6>
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 80088c8:	4b03      	ldr	r3, [pc, #12]	; (80088d8 <print_line.lto_priv.18+0x28>)
 80088ca:	6818      	ldr	r0, [r3, #0]
 80088cc:	6803      	ldr	r3, [r0, #0]
 80088ce:	685b      	ldr	r3, [r3, #4]
 80088d0:	2202      	movs	r2, #2
 80088d2:	4902      	ldr	r1, [pc, #8]	; (80088dc <print_line.lto_priv.18+0x2c>)
 80088d4:	4798      	blx	r3
 80088d6:	bd10      	pop	{r4, pc}
 80088d8:	20003e08 	.word	0x20003e08
 80088dc:	0800f138 	.word	0x0800f138

080088e0 <print_tokens.lto_priv.19>:
static void print_tokens(void) {
 80088e0:	b510      	push	{r4, lr}
  char *cp = test_tokens_buffer;
 80088e2:	4b07      	ldr	r3, [pc, #28]	; (8008900 <print_tokens.lto_priv.19+0x20>)
 80088e4:	e007      	b.n	80088f6 <print_tokens.lto_priv.19+0x16>
    streamPut(test_chp, *cp++);
 80088e6:	4a07      	ldr	r2, [pc, #28]	; (8008904 <print_tokens.lto_priv.19+0x24>)
 80088e8:	6810      	ldr	r0, [r2, #0]
 80088ea:	1c5c      	adds	r4, r3, #1
 80088ec:	6802      	ldr	r2, [r0, #0]
 80088ee:	68d2      	ldr	r2, [r2, #12]
 80088f0:	7819      	ldrb	r1, [r3, #0]
 80088f2:	4790      	blx	r2
 80088f4:	4623      	mov	r3, r4
  while (cp < test_tokp)
 80088f6:	4a04      	ldr	r2, [pc, #16]	; (8008908 <print_tokens.lto_priv.19+0x28>)
 80088f8:	6812      	ldr	r2, [r2, #0]
 80088fa:	4293      	cmp	r3, r2
 80088fc:	d3f3      	bcc.n	80088e6 <print_tokens.lto_priv.19+0x6>
}
 80088fe:	bd10      	pop	{r4, pc}
 8008900:	20003e14 	.word	0x20003e14
 8008904:	20003e08 	.word	0x20003e08
 8008908:	20003e28 	.word	0x20003e28
 800890c:	00000000 	.word	0x00000000

08008910 <clear_tokens.lto_priv.22>:
  test_tokp = test_tokens_buffer;
 8008910:	4a01      	ldr	r2, [pc, #4]	; (8008918 <clear_tokens.lto_priv.22+0x8>)
 8008912:	4b02      	ldr	r3, [pc, #8]	; (800891c <clear_tokens.lto_priv.22+0xc>)
 8008914:	601a      	str	r2, [r3, #0]
 8008916:	4770      	bx	lr
 8008918:	20003e14 	.word	0x20003e14
 800891c:	20003e28 	.word	0x20003e28

08008920 <execute_test.lto_priv.20>:
static void execute_test(const testcase_t *tcp) {
 8008920:	b510      	push	{r4, lr}
 8008922:	4604      	mov	r4, r0
  clear_tokens();
 8008924:	f7ff fff4 	bl	8008910 <clear_tokens.lto_priv.22>
  test_local_fail = false;
 8008928:	2200      	movs	r2, #0
 800892a:	4b05      	ldr	r3, [pc, #20]	; (8008940 <execute_test.lto_priv.20+0x20>)
 800892c:	701a      	strb	r2, [r3, #0]
  if (tcp->setup != NULL)
 800892e:	6863      	ldr	r3, [r4, #4]
 8008930:	b103      	cbz	r3, 8008934 <execute_test.lto_priv.20+0x14>
    tcp->setup();
 8008932:	4798      	blx	r3
  tcp->execute();
 8008934:	68e3      	ldr	r3, [r4, #12]
 8008936:	4798      	blx	r3
  if (tcp->teardown != NULL)
 8008938:	68a3      	ldr	r3, [r4, #8]
 800893a:	b103      	cbz	r3, 800893e <execute_test.lto_priv.20+0x1e>
    tcp->teardown();
 800893c:	4798      	blx	r3
 800893e:	bd10      	pop	{r4, pc}
 8008940:	20003e24 	.word	0x20003e24
	...

08008950 <_sbrk_r>:

/***************************************************************************/

__attribute__((used))
caddr_t _sbrk_r(struct _reent *r, int incr)
{
 8008950:	b510      	push	{r4, lr}
 8008952:	4604      	mov	r4, r0
 8008954:	4608      	mov	r0, r1
 *
 * @api
 */
static inline void *chCoreAlloc(size_t size) {

  return chCoreAllocAlignedWithOffset(size, PORT_NATURAL_ALIGN, 0U);
 8008956:	2200      	movs	r2, #0
 8008958:	2104      	movs	r1, #4
 800895a:	f000 fd49 	bl	80093f0 <chCoreAllocAlignedWithOffset>
  void *p;

  chDbgCheck(incr >= 0);

  p = chCoreAlloc((size_t)incr);
  if (p == NULL) {
 800895e:	b920      	cbnz	r0, 800896a <_sbrk_r+0x1a>
    __errno_r(r) = ENOMEM;
 8008960:	230c      	movs	r3, #12
 8008962:	6023      	str	r3, [r4, #0]
    return (caddr_t)-1;
 8008964:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8008968:	bd10      	pop	{r4, pc}
#else
  (void)incr;
  __errno_r(r) = ENOMEM;
  return (caddr_t)-1;
#endif
}
 800896a:	bd10      	pop	{r4, pc}
 800896c:	0000      	movs	r0, r0
	...

08008970 <shellInit>:
  esp->next = (event_listener_t *)esp;
 8008970:	4b01      	ldr	r3, [pc, #4]	; (8008978 <shellInit+0x8>)
 8008972:	601b      	str	r3, [r3, #0]
 8008974:	4770      	bx	lr
 8008976:	bf00      	nop
 8008978:	20003130 	.word	0x20003130
 800897c:	00000000 	.word	0x00000000

08008980 <chprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8008980:	b40e      	push	{r1, r2, r3}
 8008982:	b500      	push	{lr}
 8008984:	b082      	sub	sp, #8
 8008986:	aa03      	add	r2, sp, #12
 8008988:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800898c:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 800898e:	f7ff fd87 	bl	80084a0 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8008992:	b002      	add	sp, #8
 8008994:	f85d eb04 	ldr.w	lr, [sp], #4
 8008998:	b003      	add	sp, #12
 800899a:	4770      	bx	lr
 800899c:	0000      	movs	r0, r0
	...

080089a0 <cmd_test>:
}

static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
 80089a0:	b530      	push	{r4, r5, lr}
 80089a2:	b083      	sub	sp, #12
 80089a4:	4604      	mov	r4, r0
  thread_t *tp;
  tfunc_t tfp;

  (void)argv;
  if (argc != 1) {
 80089a6:	2901      	cmp	r1, #1
 80089a8:	d004      	beq.n	80089b4 <cmd_test+0x14>
    shellUsage(chp, "test rt|oslib");
 80089aa:	4a17      	ldr	r2, [pc, #92]	; (8008a08 <cmd_test+0x68>)
 80089ac:	4917      	ldr	r1, [pc, #92]	; (8008a0c <cmd_test+0x6c>)
 80089ae:	f7ff ffe7 	bl	8008980 <chprintf>
 80089b2:	e026      	b.n	8008a02 <cmd_test+0x62>
    return;
  }
  if (!strcmp(argv[0], "rt")) {
 80089b4:	6815      	ldr	r5, [r2, #0]
 80089b6:	4916      	ldr	r1, [pc, #88]	; (8008a10 <cmd_test+0x70>)
 80089b8:	4628      	mov	r0, r5
 80089ba:	f7f9 f8c5 	bl	8001b48 <strcmp>
 80089be:	b150      	cbz	r0, 80089d6 <cmd_test+0x36>
    tfp = test_rt;
  }
  else if (!strcmp(argv[0], "oslib")) {
 80089c0:	4914      	ldr	r1, [pc, #80]	; (8008a14 <cmd_test+0x74>)
 80089c2:	4628      	mov	r0, r5
 80089c4:	f7f9 f8c0 	bl	8001b48 <strcmp>
 80089c8:	b138      	cbz	r0, 80089da <cmd_test+0x3a>
    tfp = test_oslib;
  }
  else {
    shellUsage(chp, "test rt|oslib");
 80089ca:	4a0f      	ldr	r2, [pc, #60]	; (8008a08 <cmd_test+0x68>)
 80089cc:	490f      	ldr	r1, [pc, #60]	; (8008a0c <cmd_test+0x6c>)
 80089ce:	4620      	mov	r0, r4
 80089d0:	f7ff ffd6 	bl	8008980 <chprintf>
 80089d4:	e015      	b.n	8008a02 <cmd_test+0x62>
    tfp = test_rt;
 80089d6:	4a10      	ldr	r2, [pc, #64]	; (8008a18 <cmd_test+0x78>)
 80089d8:	e000      	b.n	80089dc <cmd_test+0x3c>
    tfp = test_oslib;
 80089da:	4a10      	ldr	r2, [pc, #64]	; (8008a1c <cmd_test+0x7c>)
  return ch.rlist.current;
 80089dc:	4b10      	ldr	r3, [pc, #64]	; (8008a20 <cmd_test+0x80>)
 80089de:	699b      	ldr	r3, [r3, #24]
  return chThdGetSelfX()->prio;
 80089e0:	689b      	ldr	r3, [r3, #8]
    return;
  }
  tp = chThdCreateFromHeap(NULL, SHELL_CMD_TEST_WA_SIZE,
 80089e2:	9401      	str	r4, [sp, #4]
 80089e4:	9200      	str	r2, [sp, #0]
 80089e6:	4a0f      	ldr	r2, [pc, #60]	; (8008a24 <cmd_test+0x84>)
 80089e8:	f44f 7114 	mov.w	r1, #592	; 0x250
 80089ec:	2000      	movs	r0, #0
 80089ee:	f001 fa2f 	bl	8009e50 <chThdCreateFromHeap>
                           "test", chThdGetPriorityX(),
                           tfp, chp);
  if (tp == NULL) {
 80089f2:	b920      	cbnz	r0, 80089fe <cmd_test+0x5e>
    chprintf(chp, "out of memory" SHELL_NEWLINE_STR);
 80089f4:	490c      	ldr	r1, [pc, #48]	; (8008a28 <cmd_test+0x88>)
 80089f6:	4620      	mov	r0, r4
 80089f8:	f7ff ffc2 	bl	8008980 <chprintf>
 80089fc:	e001      	b.n	8008a02 <cmd_test+0x62>
    return;
  }
  chThdWait(tp);
 80089fe:	f003 f80f 	bl	800ba20 <chThdWait>
}
 8008a02:	b003      	add	sp, #12
 8008a04:	bd30      	pop	{r4, r5, pc}
 8008a06:	bf00      	nop
 8008a08:	0800ee70 	.word	0x0800ee70
 8008a0c:	0800ee80 	.word	0x0800ee80
 8008a10:	0800ee8c 	.word	0x0800ee8c
 8008a14:	0800ee78 	.word	0x0800ee78
 8008a18:	080087c1 	.word	0x080087c1
 8008a1c:	080087d1 	.word	0x080087d1
 8008a20:	20003aec 	.word	0x20003aec
 8008a24:	0800f63c 	.word	0x0800f63c
 8008a28:	0800ee90 	.word	0x0800ee90
 8008a2c:	00000000 	.word	0x00000000

08008a30 <cmd_threads>:
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
 8008a30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008a34:	b086      	sub	sp, #24
 8008a36:	4680      	mov	r8, r0
  if (argc > 0) {
 8008a38:	2900      	cmp	r1, #0
 8008a3a:	dd04      	ble.n	8008a46 <cmd_threads+0x16>
    shellUsage(chp, "threads");
 8008a3c:	4a15      	ldr	r2, [pc, #84]	; (8008a94 <cmd_threads+0x64>)
 8008a3e:	4916      	ldr	r1, [pc, #88]	; (8008a98 <cmd_threads+0x68>)
 8008a40:	f7ff ff9e 	bl	8008980 <chprintf>
 8008a44:	e023      	b.n	8008a8e <cmd_threads+0x5e>
  chprintf(chp, "stklimit    stack     addr refs prio     state         name\r\n" SHELL_NEWLINE_STR);
 8008a46:	4915      	ldr	r1, [pc, #84]	; (8008a9c <cmd_threads+0x6c>)
 8008a48:	f7ff ff9a 	bl	8008980 <chprintf>
  tp = chRegFirstThread();
 8008a4c:	f002 fc30 	bl	800b2b0 <chRegFirstThread>
 8008a50:	4604      	mov	r4, r0
    uint32_t stklimit = (uint32_t)tp->wabase;
 8008a52:	69e2      	ldr	r2, [r4, #28]
             stklimit, (uint32_t)tp->ctx.sp, (uint32_t)tp,
 8008a54:	68e3      	ldr	r3, [r4, #12]
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
 8008a56:	4625      	mov	r5, r4
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
 8008a58:	f894 1022 	ldrb.w	r1, [r4, #34]	; 0x22
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
 8008a5c:	3901      	subs	r1, #1
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
 8008a5e:	68a7      	ldr	r7, [r4, #8]
 8008a60:	f894 e020 	ldrb.w	lr, [r4, #32]
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
 8008a64:	480e      	ldr	r0, [pc, #56]	; (8008aa0 <cmd_threads+0x70>)
 8008a66:	f850 602e 	ldr.w	r6, [r0, lr, lsl #2]
             tp->name == NULL ? "" : tp->name);
 8008a6a:	69a0      	ldr	r0, [r4, #24]
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
 8008a6c:	b900      	cbnz	r0, 8008a70 <cmd_threads+0x40>
 8008a6e:	480d      	ldr	r0, [pc, #52]	; (8008aa4 <cmd_threads+0x74>)
 8008a70:	9004      	str	r0, [sp, #16]
 8008a72:	9603      	str	r6, [sp, #12]
 8008a74:	9702      	str	r7, [sp, #8]
 8008a76:	9101      	str	r1, [sp, #4]
 8008a78:	9500      	str	r5, [sp, #0]
 8008a7a:	490b      	ldr	r1, [pc, #44]	; (8008aa8 <cmd_threads+0x78>)
 8008a7c:	4640      	mov	r0, r8
 8008a7e:	f7ff ff7f 	bl	8008980 <chprintf>
    tp = chRegNextThread(tp);
 8008a82:	4620      	mov	r0, r4
 8008a84:	f002 fcc4 	bl	800b410 <chRegNextThread>
  } while (tp != NULL);
 8008a88:	4604      	mov	r4, r0
 8008a8a:	2800      	cmp	r0, #0
 8008a8c:	d1e1      	bne.n	8008a52 <cmd_threads+0x22>
}
 8008a8e:	b006      	add	sp, #24
 8008a90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008a94:	0800f758 	.word	0x0800f758
 8008a98:	0800ee80 	.word	0x0800ee80
 8008a9c:	0800eea0 	.word	0x0800eea0
 8008aa0:	0800ed00 	.word	0x0800ed00
 8008aa4:	0800f184 	.word	0x0800f184
 8008aa8:	0800eee0 	.word	0x0800eee0
 8008aac:	00000000 	.word	0x00000000

08008ab0 <cmd_mem>:
static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
 8008ab0:	b530      	push	{r4, r5, lr}
 8008ab2:	b083      	sub	sp, #12
 8008ab4:	4604      	mov	r4, r0
  if (argc > 0) {
 8008ab6:	2900      	cmp	r1, #0
 8008ab8:	dd04      	ble.n	8008ac4 <cmd_mem+0x14>
    shellUsage(chp, "mem");
 8008aba:	4a11      	ldr	r2, [pc, #68]	; (8008b00 <cmd_mem+0x50>)
 8008abc:	4911      	ldr	r1, [pc, #68]	; (8008b04 <cmd_mem+0x54>)
 8008abe:	f7ff ff5f 	bl	8008980 <chprintf>
 8008ac2:	e01b      	b.n	8008afc <cmd_mem+0x4c>
  n = chHeapStatus(NULL, &total, &largest);
 8008ac4:	466a      	mov	r2, sp
 8008ac6:	a901      	add	r1, sp, #4
 8008ac8:	2000      	movs	r0, #0
 8008aca:	f000 ff51 	bl	8009970 <chHeapStatus>
 8008ace:	4605      	mov	r5, r0
  chprintf(chp, "core free memory : %u bytes" SHELL_NEWLINE_STR, chCoreGetStatusX());
 8008ad0:	f001 f896 	bl	8009c00 <chCoreGetStatusX>
 8008ad4:	4602      	mov	r2, r0
 8008ad6:	490c      	ldr	r1, [pc, #48]	; (8008b08 <cmd_mem+0x58>)
 8008ad8:	4620      	mov	r0, r4
 8008ada:	f7ff ff51 	bl	8008980 <chprintf>
  chprintf(chp, "heap fragments   : %u" SHELL_NEWLINE_STR, n);
 8008ade:	462a      	mov	r2, r5
 8008ae0:	490a      	ldr	r1, [pc, #40]	; (8008b0c <cmd_mem+0x5c>)
 8008ae2:	4620      	mov	r0, r4
 8008ae4:	f7ff ff4c 	bl	8008980 <chprintf>
  chprintf(chp, "heap free total  : %u bytes" SHELL_NEWLINE_STR, total);
 8008ae8:	9a01      	ldr	r2, [sp, #4]
 8008aea:	4909      	ldr	r1, [pc, #36]	; (8008b10 <cmd_mem+0x60>)
 8008aec:	4620      	mov	r0, r4
 8008aee:	f7ff ff47 	bl	8008980 <chprintf>
  chprintf(chp, "heap free largest: %u bytes" SHELL_NEWLINE_STR, largest);
 8008af2:	9a00      	ldr	r2, [sp, #0]
 8008af4:	4907      	ldr	r1, [pc, #28]	; (8008b14 <cmd_mem+0x64>)
 8008af6:	4620      	mov	r0, r4
 8008af8:	f7ff ff42 	bl	8008980 <chprintf>
}
 8008afc:	b003      	add	sp, #12
 8008afe:	bd30      	pop	{r4, r5, pc}
 8008b00:	0800ef08 	.word	0x0800ef08
 8008b04:	0800ee80 	.word	0x0800ee80
 8008b08:	0800ef0c 	.word	0x0800ef0c
 8008b0c:	0800ef2c 	.word	0x0800ef2c
 8008b10:	0800ef44 	.word	0x0800ef44
 8008b14:	0800ef64 	.word	0x0800ef64
	...

08008b20 <cmd_systime>:
static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {
 8008b20:	b508      	push	{r3, lr}
  if (argc > 0) {
 8008b22:	2900      	cmp	r1, #0
 8008b24:	dd04      	ble.n	8008b30 <cmd_systime+0x10>
    shellUsage(chp, "systime");
 8008b26:	4a08      	ldr	r2, [pc, #32]	; (8008b48 <cmd_systime+0x28>)
 8008b28:	4908      	ldr	r1, [pc, #32]	; (8008b4c <cmd_systime+0x2c>)
 8008b2a:	f7ff ff29 	bl	8008980 <chprintf>
 8008b2e:	bd08      	pop	{r3, pc}
 8008b30:	2320      	movs	r3, #32
 8008b32:	f383 8811 	msr	BASEPRI, r3
 8008b36:	4b06      	ldr	r3, [pc, #24]	; (8008b50 <cmd_systime+0x30>)
 8008b38:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8008b3a:	2300      	movs	r3, #0
 8008b3c:	f383 8811 	msr	BASEPRI, r3
  chprintf(chp, "%lu" SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
 8008b40:	4904      	ldr	r1, [pc, #16]	; (8008b54 <cmd_systime+0x34>)
 8008b42:	f7ff ff1d 	bl	8008980 <chprintf>
 8008b46:	bd08      	pop	{r3, pc}
 8008b48:	0800ef84 	.word	0x0800ef84
 8008b4c:	0800ee80 	.word	0x0800ee80
 8008b50:	40000c00 	.word	0x40000c00
 8008b54:	0800ef8c 	.word	0x0800ef8c
	...

08008b60 <cmd_echo>:
static void cmd_echo(BaseSequentialStream *chp, int argc, char *argv[]) {
 8008b60:	b508      	push	{r3, lr}
  if (argc != 1) {
 8008b62:	2901      	cmp	r1, #1
 8008b64:	d004      	beq.n	8008b70 <cmd_echo+0x10>
    shellUsage(chp, "echo \"message\"");
 8008b66:	4a05      	ldr	r2, [pc, #20]	; (8008b7c <cmd_echo+0x1c>)
 8008b68:	4905      	ldr	r1, [pc, #20]	; (8008b80 <cmd_echo+0x20>)
 8008b6a:	f7ff ff09 	bl	8008980 <chprintf>
 8008b6e:	bd08      	pop	{r3, pc}
  chprintf(chp, "%s" SHELL_NEWLINE_STR, argv[0]);
 8008b70:	6812      	ldr	r2, [r2, #0]
 8008b72:	4904      	ldr	r1, [pc, #16]	; (8008b84 <cmd_echo+0x24>)
 8008b74:	f7ff ff04 	bl	8008980 <chprintf>
 8008b78:	bd08      	pop	{r3, pc}
 8008b7a:	bf00      	nop
 8008b7c:	0800ef94 	.word	0x0800ef94
 8008b80:	0800ee80 	.word	0x0800ee80
 8008b84:	0800efa4 	.word	0x0800efa4
	...

08008b90 <cmd_info>:
static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 8008b90:	b510      	push	{r4, lr}
 8008b92:	b082      	sub	sp, #8
 8008b94:	4604      	mov	r4, r0
  if (argc > 0) {
 8008b96:	2900      	cmp	r1, #0
 8008b98:	dd04      	ble.n	8008ba4 <cmd_info+0x14>
    shellUsage(chp, "info");
 8008b9a:	4a18      	ldr	r2, [pc, #96]	; (8008bfc <cmd_info+0x6c>)
 8008b9c:	4918      	ldr	r1, [pc, #96]	; (8008c00 <cmd_info+0x70>)
 8008b9e:	f7ff feef 	bl	8008980 <chprintf>
 8008ba2:	e029      	b.n	8008bf8 <cmd_info+0x68>
  chprintf(chp, "Kernel:       %s" SHELL_NEWLINE_STR, CH_KERNEL_VERSION);
 8008ba4:	4a17      	ldr	r2, [pc, #92]	; (8008c04 <cmd_info+0x74>)
 8008ba6:	4918      	ldr	r1, [pc, #96]	; (8008c08 <cmd_info+0x78>)
 8008ba8:	f7ff feea 	bl	8008980 <chprintf>
  chprintf(chp, "Compiler:     %s" SHELL_NEWLINE_STR, PORT_COMPILER_NAME);
 8008bac:	4a17      	ldr	r2, [pc, #92]	; (8008c0c <cmd_info+0x7c>)
 8008bae:	4918      	ldr	r1, [pc, #96]	; (8008c10 <cmd_info+0x80>)
 8008bb0:	4620      	mov	r0, r4
 8008bb2:	f7ff fee5 	bl	8008980 <chprintf>
  chprintf(chp, "Architecture: %s" SHELL_NEWLINE_STR, PORT_ARCHITECTURE_NAME);
 8008bb6:	4a17      	ldr	r2, [pc, #92]	; (8008c14 <cmd_info+0x84>)
 8008bb8:	4917      	ldr	r1, [pc, #92]	; (8008c18 <cmd_info+0x88>)
 8008bba:	4620      	mov	r0, r4
 8008bbc:	f7ff fee0 	bl	8008980 <chprintf>
  chprintf(chp, "Core Variant: %s" SHELL_NEWLINE_STR, PORT_CORE_VARIANT_NAME);
 8008bc0:	4a16      	ldr	r2, [pc, #88]	; (8008c1c <cmd_info+0x8c>)
 8008bc2:	4917      	ldr	r1, [pc, #92]	; (8008c20 <cmd_info+0x90>)
 8008bc4:	4620      	mov	r0, r4
 8008bc6:	f7ff fedb 	bl	8008980 <chprintf>
  chprintf(chp, "Port Info:    %s" SHELL_NEWLINE_STR, PORT_INFO);
 8008bca:	4a16      	ldr	r2, [pc, #88]	; (8008c24 <cmd_info+0x94>)
 8008bcc:	4916      	ldr	r1, [pc, #88]	; (8008c28 <cmd_info+0x98>)
 8008bce:	4620      	mov	r0, r4
 8008bd0:	f7ff fed6 	bl	8008980 <chprintf>
  chprintf(chp, "Platform:     %s" SHELL_NEWLINE_STR, PLATFORM_NAME);
 8008bd4:	4a15      	ldr	r2, [pc, #84]	; (8008c2c <cmd_info+0x9c>)
 8008bd6:	4916      	ldr	r1, [pc, #88]	; (8008c30 <cmd_info+0xa0>)
 8008bd8:	4620      	mov	r0, r4
 8008bda:	f7ff fed1 	bl	8008980 <chprintf>
  chprintf(chp, "Board:        %s" SHELL_NEWLINE_STR, BOARD_NAME);
 8008bde:	4a15      	ldr	r2, [pc, #84]	; (8008c34 <cmd_info+0xa4>)
 8008be0:	4915      	ldr	r1, [pc, #84]	; (8008c38 <cmd_info+0xa8>)
 8008be2:	4620      	mov	r0, r4
 8008be4:	f7ff fecc 	bl	8008980 <chprintf>
  chprintf(chp, "Build time:   %s%s%s" SHELL_NEWLINE_STR, __DATE__, " - ", __TIME__);
 8008be8:	4b14      	ldr	r3, [pc, #80]	; (8008c3c <cmd_info+0xac>)
 8008bea:	9300      	str	r3, [sp, #0]
 8008bec:	4b14      	ldr	r3, [pc, #80]	; (8008c40 <cmd_info+0xb0>)
 8008bee:	4a15      	ldr	r2, [pc, #84]	; (8008c44 <cmd_info+0xb4>)
 8008bf0:	4915      	ldr	r1, [pc, #84]	; (8008c48 <cmd_info+0xb8>)
 8008bf2:	4620      	mov	r0, r4
 8008bf4:	f7ff fec4 	bl	8008980 <chprintf>
}
 8008bf8:	b002      	add	sp, #8
 8008bfa:	bd10      	pop	{r4, pc}
 8008bfc:	0800efac 	.word	0x0800efac
 8008c00:	0800ee80 	.word	0x0800ee80
 8008c04:	0800efb4 	.word	0x0800efb4
 8008c08:	0800efbc 	.word	0x0800efbc
 8008c0c:	0800efd0 	.word	0x0800efd0
 8008c10:	0800efe4 	.word	0x0800efe4
 8008c14:	0800eff8 	.word	0x0800eff8
 8008c18:	0800f004 	.word	0x0800f004
 8008c1c:	0800f018 	.word	0x0800f018
 8008c20:	0800f024 	.word	0x0800f024
 8008c24:	0800f038 	.word	0x0800f038
 8008c28:	0800f050 	.word	0x0800f050
 8008c2c:	0800f064 	.word	0x0800f064
 8008c30:	0800f090 	.word	0x0800f090
 8008c34:	0800f0a4 	.word	0x0800f0a4
 8008c38:	0800f0d0 	.word	0x0800f0d0
 8008c3c:	0800f10c 	.word	0x0800f10c
 8008c40:	0800f0e4 	.word	0x0800f0e4
 8008c44:	0800f0e8 	.word	0x0800f0e8
 8008c48:	0800f0f4 	.word	0x0800f0f4
 8008c4c:	00000000 	.word	0x00000000

08008c50 <cmd_exit>:
static void cmd_exit(BaseSequentialStream *chp, int argc, char *argv[]) {
 8008c50:	b508      	push	{r3, lr}
  if (argc > 0) {
 8008c52:	2900      	cmp	r1, #0
 8008c54:	dd04      	ble.n	8008c60 <cmd_exit+0x10>
    shellUsage(chp, "exit");
 8008c56:	4a04      	ldr	r2, [pc, #16]	; (8008c68 <cmd_exit+0x18>)
 8008c58:	4904      	ldr	r1, [pc, #16]	; (8008c6c <cmd_exit+0x1c>)
 8008c5a:	f7ff fe91 	bl	8008980 <chprintf>
 8008c5e:	bd08      	pop	{r3, pc}
  shellExit(MSG_OK);
 8008c60:	2000      	movs	r0, #0
 8008c62:	f7ff fdbd 	bl	80087e0 <shellExit>
 8008c66:	bd08      	pop	{r3, pc}
 8008c68:	0800f118 	.word	0x0800f118
 8008c6c:	0800ee80 	.word	0x0800ee80

08008c70 <shellGetLine>:
 * @retval true         the channel was reset or CTRL-D pressed.
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(ShellConfig *scfg, char *line, unsigned size, ShellHistory *shp) {
 8008c70:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008c72:	b083      	sub	sp, #12
 8008c74:	460e      	mov	r6, r1
 8008c76:	4617      	mov	r7, r2
  char *p = line;
  BaseSequentialStream *chp = scfg->sc_channel;
 8008c78:	6804      	ldr	r4, [r0, #0]
  char *p = line;
 8008c7a:	460d      	mov	r5, r1
#endif

  while (true) {
    char c;

    if (streamRead(chp, (uint8_t *)&c, 1) == 0)
 8008c7c:	6823      	ldr	r3, [r4, #0]
 8008c7e:	689b      	ldr	r3, [r3, #8]
 8008c80:	2201      	movs	r2, #1
 8008c82:	f10d 0107 	add.w	r1, sp, #7
 8008c86:	4620      	mov	r0, r4
 8008c88:	4798      	blx	r3
 8008c8a:	2800      	cmp	r0, #0
 8008c8c:	d038      	beq.n	8008d00 <shellGetLine+0x90>
      }
      continue;
    }
#endif
#if (SHELL_CMD_EXIT_ENABLED == TRUE) && !defined(_CHIBIOS_NIL_)
    if (c == 4) {
 8008c8e:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8008c92:	2904      	cmp	r1, #4
 8008c94:	d105      	bne.n	8008ca2 <shellGetLine+0x32>
      chprintf(chp, "^D");
 8008c96:	491c      	ldr	r1, [pc, #112]	; (8008d08 <shellGetLine+0x98>)
 8008c98:	4620      	mov	r0, r4
 8008c9a:	f7ff fe71 	bl	8008980 <chprintf>
      return true;
 8008c9e:	2001      	movs	r0, #1
 8008ca0:	e02f      	b.n	8008d02 <shellGetLine+0x92>
    }
#endif
    if ((c == 8) || (c == 127)) {
 8008ca2:	2908      	cmp	r1, #8
 8008ca4:	d001      	beq.n	8008caa <shellGetLine+0x3a>
 8008ca6:	297f      	cmp	r1, #127	; 0x7f
 8008ca8:	d112      	bne.n	8008cd0 <shellGetLine+0x60>
      if (p != line) {
 8008caa:	42b5      	cmp	r5, r6
 8008cac:	d0e6      	beq.n	8008c7c <shellGetLine+0xc>
        streamPut(chp, 0x08);
 8008cae:	6823      	ldr	r3, [r4, #0]
 8008cb0:	68db      	ldr	r3, [r3, #12]
 8008cb2:	2108      	movs	r1, #8
 8008cb4:	4620      	mov	r0, r4
 8008cb6:	4798      	blx	r3
        streamPut(chp, 0x20);
 8008cb8:	6823      	ldr	r3, [r4, #0]
 8008cba:	68db      	ldr	r3, [r3, #12]
 8008cbc:	2120      	movs	r1, #32
 8008cbe:	4620      	mov	r0, r4
 8008cc0:	4798      	blx	r3
        streamPut(chp, 0x08);
 8008cc2:	6823      	ldr	r3, [r4, #0]
 8008cc4:	68db      	ldr	r3, [r3, #12]
 8008cc6:	2108      	movs	r1, #8
 8008cc8:	4620      	mov	r0, r4
 8008cca:	4798      	blx	r3
        p--;
 8008ccc:	3d01      	subs	r5, #1
 8008cce:	e7d5      	b.n	8008c7c <shellGetLine+0xc>
      }
      continue;
    }
    if (c == '\r') {
 8008cd0:	290d      	cmp	r1, #13
 8008cd2:	d106      	bne.n	8008ce2 <shellGetLine+0x72>
      chprintf(chp, SHELL_NEWLINE_STR);
 8008cd4:	490d      	ldr	r1, [pc, #52]	; (8008d0c <shellGetLine+0x9c>)
 8008cd6:	4620      	mov	r0, r4
 8008cd8:	f7ff fe52 	bl	8008980 <chprintf>
#if SHELL_USE_HISTORY == TRUE
      save_history(shp, line, p - line);
#endif
      *p = 0;
 8008cdc:	2000      	movs	r0, #0
 8008cde:	7028      	strb	r0, [r5, #0]
 8008ce0:	e00f      	b.n	8008d02 <shellGetLine+0x92>
        p = line + len;
      }
      continue;
    }
#endif
    if (c < 0x20)
 8008ce2:	291f      	cmp	r1, #31
 8008ce4:	d9ca      	bls.n	8008c7c <shellGetLine+0xc>
      continue;
    if (p < line + size - 1) {
 8008ce6:	1e7b      	subs	r3, r7, #1
 8008ce8:	4433      	add	r3, r6
 8008cea:	429d      	cmp	r5, r3
 8008cec:	d2c6      	bcs.n	8008c7c <shellGetLine+0xc>
      streamPut(chp, c);
 8008cee:	6823      	ldr	r3, [r4, #0]
 8008cf0:	68db      	ldr	r3, [r3, #12]
 8008cf2:	4620      	mov	r0, r4
 8008cf4:	4798      	blx	r3
      *p++ = (char)c;
 8008cf6:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8008cfa:	702b      	strb	r3, [r5, #0]
 8008cfc:	3501      	adds	r5, #1
 8008cfe:	e7bd      	b.n	8008c7c <shellGetLine+0xc>
      return true;
 8008d00:	2001      	movs	r0, #1
    }
  }
}
 8008d02:	b003      	add	sp, #12
 8008d04:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008d06:	bf00      	nop
 8008d08:	0800f120 	.word	0x0800f120
 8008d0c:	0800f138 	.word	0x0800f138

08008d10 <list_commands>:
static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {
 8008d10:	b538      	push	{r3, r4, r5, lr}
 8008d12:	4605      	mov	r5, r0
 8008d14:	460c      	mov	r4, r1
 8008d16:	e004      	b.n	8008d22 <list_commands+0x12>
    chprintf(chp, "%s ", scp->sc_name);
 8008d18:	4904      	ldr	r1, [pc, #16]	; (8008d2c <list_commands+0x1c>)
 8008d1a:	4628      	mov	r0, r5
 8008d1c:	f7ff fe30 	bl	8008980 <chprintf>
    scp++;
 8008d20:	3408      	adds	r4, #8
  while (scp->sc_name != NULL) {
 8008d22:	6822      	ldr	r2, [r4, #0]
 8008d24:	2a00      	cmp	r2, #0
 8008d26:	d1f7      	bne.n	8008d18 <list_commands+0x8>
}
 8008d28:	bd38      	pop	{r3, r4, r5, pc}
 8008d2a:	bf00      	nop
 8008d2c:	0800f124 	.word	0x0800f124

08008d30 <shellThread>:
THD_FUNCTION(shellThread, p) {
 8008d30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008d34:	b098      	sub	sp, #96	; 0x60
 8008d36:	4607      	mov	r7, r0
  BaseSequentialStream *chp = scfg->sc_channel;
 8008d38:	6806      	ldr	r6, [r0, #0]
  const ShellCommand *scp = scfg->sc_commands;
 8008d3a:	f8d0 8004 	ldr.w	r8, [r0, #4]
  chprintf(chp, SHELL_NEWLINE_STR);
 8008d3e:	4946      	ldr	r1, [pc, #280]	; (8008e58 <shellThread+0x128>)
 8008d40:	4630      	mov	r0, r6
 8008d42:	f7ff fe1d 	bl	8008980 <chprintf>
  chprintf(chp, "ChibiOS/RT Shell" SHELL_NEWLINE_STR);
 8008d46:	4945      	ldr	r1, [pc, #276]	; (8008e5c <shellThread+0x12c>)
 8008d48:	4630      	mov	r0, r6
 8008d4a:	f7ff fe19 	bl	8008980 <chprintf>
 8008d4e:	e076      	b.n	8008e3e <shellThread+0x10e>
    chprintf(chp, SHELL_PROMPT_STR);
 8008d50:	4943      	ldr	r1, [pc, #268]	; (8008e60 <shellThread+0x130>)
 8008d52:	4630      	mov	r0, r6
 8008d54:	f7ff fe14 	bl	8008980 <chprintf>
    if (shellGetLine(scfg, line, sizeof(line), shp)) {
 8008d58:	2300      	movs	r3, #0
 8008d5a:	2240      	movs	r2, #64	; 0x40
 8008d5c:	a907      	add	r1, sp, #28
 8008d5e:	4638      	mov	r0, r7
 8008d60:	f7ff ff86 	bl	8008c70 <shellGetLine>
 8008d64:	b140      	cbz	r0, 8008d78 <shellThread+0x48>
      chprintf(chp, SHELL_NEWLINE_STR);
 8008d66:	493c      	ldr	r1, [pc, #240]	; (8008e58 <shellThread+0x128>)
 8008d68:	4630      	mov	r0, r6
 8008d6a:	f7ff fe09 	bl	8008980 <chprintf>
      chprintf(chp, "logout");
 8008d6e:	493d      	ldr	r1, [pc, #244]	; (8008e64 <shellThread+0x134>)
 8008d70:	4630      	mov	r0, r6
 8008d72:	f7ff fe05 	bl	8008980 <chprintf>
 8008d76:	e069      	b.n	8008e4c <shellThread+0x11c>
    lp = parse_arguments(line, &tokp);
 8008d78:	a917      	add	r1, sp, #92	; 0x5c
 8008d7a:	a807      	add	r0, sp, #28
 8008d7c:	f7ff fd40 	bl	8008800 <parse_arguments>
 8008d80:	4605      	mov	r5, r0
    n = 0;
 8008d82:	2400      	movs	r4, #0
 8008d84:	e00d      	b.n	8008da2 <shellThread+0x72>
      if (n >= SHELL_MAX_ARGUMENTS) {
 8008d86:	2c03      	cmp	r4, #3
 8008d88:	dd05      	ble.n	8008d96 <shellThread+0x66>
        chprintf(chp, "too many arguments" SHELL_NEWLINE_STR);
 8008d8a:	4937      	ldr	r1, [pc, #220]	; (8008e68 <shellThread+0x138>)
 8008d8c:	4630      	mov	r0, r6
 8008d8e:	f7ff fdf7 	bl	8008980 <chprintf>
        cmd = NULL;
 8008d92:	2500      	movs	r5, #0
 8008d94:	e00c      	b.n	8008db0 <shellThread+0x80>
      args[n++] = lp;
 8008d96:	aa18      	add	r2, sp, #96	; 0x60
 8008d98:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 8008d9c:	f842 3c58 	str.w	r3, [r2, #-88]
 8008da0:	3401      	adds	r4, #1
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8008da2:	a917      	add	r1, sp, #92	; 0x5c
 8008da4:	2000      	movs	r0, #0
 8008da6:	f7ff fd2b 	bl	8008800 <parse_arguments>
 8008daa:	4603      	mov	r3, r0
 8008dac:	2800      	cmp	r0, #0
 8008dae:	d1ea      	bne.n	8008d86 <shellThread+0x56>
    args[n] = NULL;
 8008db0:	2200      	movs	r2, #0
 8008db2:	ab18      	add	r3, sp, #96	; 0x60
 8008db4:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8008db8:	f843 2c58 	str.w	r2, [r3, #-88]
    if (cmd != NULL) {
 8008dbc:	2d00      	cmp	r5, #0
 8008dbe:	d03e      	beq.n	8008e3e <shellThread+0x10e>
      if (strcmp(cmd, "help") == 0) {
 8008dc0:	492a      	ldr	r1, [pc, #168]	; (8008e6c <shellThread+0x13c>)
 8008dc2:	4628      	mov	r0, r5
 8008dc4:	f7f8 fec0 	bl	8001b48 <strcmp>
 8008dc8:	b9d8      	cbnz	r0, 8008e02 <shellThread+0xd2>
        if (n > 0) {
 8008dca:	2c00      	cmp	r4, #0
 8008dcc:	dd05      	ble.n	8008dda <shellThread+0xaa>
          shellUsage(chp, "help");
 8008dce:	4a27      	ldr	r2, [pc, #156]	; (8008e6c <shellThread+0x13c>)
 8008dd0:	4927      	ldr	r1, [pc, #156]	; (8008e70 <shellThread+0x140>)
 8008dd2:	4630      	mov	r0, r6
 8008dd4:	f7ff fdd4 	bl	8008980 <chprintf>
 8008dd8:	e031      	b.n	8008e3e <shellThread+0x10e>
        chprintf(chp, "Commands: help ");
 8008dda:	4926      	ldr	r1, [pc, #152]	; (8008e74 <shellThread+0x144>)
 8008ddc:	4630      	mov	r0, r6
 8008dde:	f7ff fdcf 	bl	8008980 <chprintf>
        list_commands(chp, shell_local_commands);
 8008de2:	4925      	ldr	r1, [pc, #148]	; (8008e78 <shellThread+0x148>)
 8008de4:	4630      	mov	r0, r6
 8008de6:	f7ff ff93 	bl	8008d10 <list_commands>
        if (scp != NULL)
 8008dea:	f1b8 0f00 	cmp.w	r8, #0
 8008dee:	d003      	beq.n	8008df8 <shellThread+0xc8>
          list_commands(chp, scp);
 8008df0:	4641      	mov	r1, r8
 8008df2:	4630      	mov	r0, r6
 8008df4:	f7ff ff8c 	bl	8008d10 <list_commands>
        chprintf(chp, SHELL_NEWLINE_STR);
 8008df8:	4917      	ldr	r1, [pc, #92]	; (8008e58 <shellThread+0x128>)
 8008dfa:	4630      	mov	r0, r6
 8008dfc:	f7ff fdc0 	bl	8008980 <chprintf>
 8008e00:	e01d      	b.n	8008e3e <shellThread+0x10e>
      else if (cmdexec(shell_local_commands, chp, cmd, n, args) &&
 8008e02:	ab02      	add	r3, sp, #8
 8008e04:	9300      	str	r3, [sp, #0]
 8008e06:	4623      	mov	r3, r4
 8008e08:	462a      	mov	r2, r5
 8008e0a:	4631      	mov	r1, r6
 8008e0c:	481a      	ldr	r0, [pc, #104]	; (8008e78 <shellThread+0x148>)
 8008e0e:	f7ff fcbf 	bl	8008790 <cmdexec>
 8008e12:	b1a0      	cbz	r0, 8008e3e <shellThread+0x10e>
 8008e14:	f1b8 0f00 	cmp.w	r8, #0
 8008e18:	d008      	beq.n	8008e2c <shellThread+0xfc>
          ((scp == NULL) || cmdexec(scp, chp, cmd, n, args))) {
 8008e1a:	ab02      	add	r3, sp, #8
 8008e1c:	9300      	str	r3, [sp, #0]
 8008e1e:	4623      	mov	r3, r4
 8008e20:	462a      	mov	r2, r5
 8008e22:	4631      	mov	r1, r6
 8008e24:	4640      	mov	r0, r8
 8008e26:	f7ff fcb3 	bl	8008790 <cmdexec>
 8008e2a:	b140      	cbz	r0, 8008e3e <shellThread+0x10e>
        chprintf(chp, "%s", cmd);
 8008e2c:	462a      	mov	r2, r5
 8008e2e:	4913      	ldr	r1, [pc, #76]	; (8008e7c <shellThread+0x14c>)
 8008e30:	4630      	mov	r0, r6
 8008e32:	f7ff fda5 	bl	8008980 <chprintf>
        chprintf(chp, " ?" SHELL_NEWLINE_STR);
 8008e36:	4912      	ldr	r1, [pc, #72]	; (8008e80 <shellThread+0x150>)
 8008e38:	4630      	mov	r0, r6
 8008e3a:	f7ff fda1 	bl	8008980 <chprintf>
  return ch.rlist.current;
 8008e3e:	4b11      	ldr	r3, [pc, #68]	; (8008e84 <shellThread+0x154>)
 8008e40:	699b      	ldr	r3, [r3, #24]
  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8008e42:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
  while (!chThdShouldTerminateX()) {
 8008e46:	f013 0f04 	tst.w	r3, #4
 8008e4a:	d081      	beq.n	8008d50 <shellThread+0x20>
  shellExit(MSG_OK);
 8008e4c:	2000      	movs	r0, #0
 8008e4e:	f7ff fcc7 	bl	80087e0 <shellExit>
}
 8008e52:	b018      	add	sp, #96	; 0x60
 8008e54:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008e58:	0800f138 	.word	0x0800f138
 8008e5c:	0800f128 	.word	0x0800f128
 8008e60:	0800f13c 	.word	0x0800f13c
 8008e64:	0800f144 	.word	0x0800f144
 8008e68:	0800f14c 	.word	0x0800f14c
 8008e6c:	0800f164 	.word	0x0800f164
 8008e70:	0800ee80 	.word	0x0800ee80
 8008e74:	0800f16c 	.word	0x0800f16c
 8008e78:	0800eb10 	.word	0x0800eb10
 8008e7c:	0800f17c 	.word	0x0800f17c
 8008e80:	0800f180 	.word	0x0800f180
 8008e84:	20003aec 	.word	0x20003aec
	...

08008e90 <_port_irq_epilogue>:
 8008e90:	2320      	movs	r3, #32
 8008e92:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8008e96:	4b12      	ldr	r3, [pc, #72]	; (8008ee0 <_port_irq_epilogue+0x50>)
 8008e98:	685b      	ldr	r3, [r3, #4]
 8008e9a:	f413 6f00 	tst.w	r3, #2048	; 0x800
 8008e9e:	d01b      	beq.n	8008ed8 <_port_irq_epilogue+0x48>
void _port_irq_epilogue(void) {
 8008ea0:	b510      	push	{r4, lr}
  /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
  return __builtin_arm_get_fpscr();
#else
  uint32_t result;

  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 8008ea2:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8008ea6:	f3ef 8409 	mrs	r4, PSP
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8008eaa:	f1a4 0368 	sub.w	r3, r4, #104	; 0x68

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8008eae:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8008eb2:	f844 2c4c 	str.w	r2, [r4, #-76]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8008eb6:	4a0b      	ldr	r2, [pc, #44]	; (8008ee4 <_port_irq_epilogue+0x54>)
 8008eb8:	68d2      	ldr	r2, [r2, #12]
 8008eba:	f844 2c08 	str.w	r2, [r4, #-8]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8008ebe:	f383 8809 	msr	PSP, r3
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8008ec2:	f002 fb1d 	bl	800b500 <chSchIsPreemptionRequired>
 8008ec6:	b118      	cbz	r0, 8008ed0 <_port_irq_epilogue+0x40>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8008ec8:	4b07      	ldr	r3, [pc, #28]	; (8008ee8 <_port_irq_epilogue+0x58>)
 8008eca:	f844 3c50 	str.w	r3, [r4, #-80]
 8008ece:	bd10      	pop	{r4, pc}
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8008ed0:	4b06      	ldr	r3, [pc, #24]	; (8008eec <_port_irq_epilogue+0x5c>)
 8008ed2:	f844 3c50 	str.w	r3, [r4, #-80]
 8008ed6:	bd10      	pop	{r4, pc}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8008ed8:	2300      	movs	r3, #0
 8008eda:	f383 8811 	msr	BASEPRI, r3
 8008ede:	4770      	bx	lr
 8008ee0:	e000ed00 	.word	0xe000ed00
 8008ee4:	e000ef30 	.word	0xe000ef30
 8008ee8:	08000351 	.word	0x08000351
 8008eec:	08000354 	.word	0x08000354

08008ef0 <SVC_Handler>:
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 8008ef0:	4a06      	ldr	r2, [pc, #24]	; (8008f0c <SVC_Handler+0x1c>)
 8008ef2:	6853      	ldr	r3, [r2, #4]
 8008ef4:	f023 0301 	bic.w	r3, r3, #1
 8008ef8:	6053      	str	r3, [r2, #4]
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8008efa:	f3ef 8309 	mrs	r3, PSP
  ctxp++;
 8008efe:	3368      	adds	r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8008f00:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8008f04:	2300      	movs	r3, #0
 8008f06:	f383 8811 	msr	BASEPRI, r3
 8008f0a:	4770      	bx	lr
 8008f0c:	e000ef30 	.word	0xe000ef30

08008f10 <chFactoryReleasePipe>:
 *
 * @param[in] dpp       dynamic pipe object reference
 *
 * @api
 */
void chFactoryReleasePipe(dyn_pipe_t *dpp) {
 8008f10:	b538      	push	{r3, r4, r5, lr}
 8008f12:	4605      	mov	r5, r0

  F_LOCK();
 8008f14:	4c06      	ldr	r4, [pc, #24]	; (8008f30 <chFactoryReleasePipe+0x20>)
 8008f16:	4620      	mov	r0, r4
 8008f18:	f002 fd1a 	bl	800b950 <chMtxLock>

  dyn_release_object_heap(&dpp->element, &ch_factory.pipe_list);
 8008f1c:	f104 0144 	add.w	r1, r4, #68	; 0x44
 8008f20:	4628      	mov	r0, r5
 8008f22:	f000 fd95 	bl	8009a50 <dyn_release_object_heap.lto_priv.136>

  F_UNLOCK();
 8008f26:	4620      	mov	r0, r4
 8008f28:	f002 fb52 	bl	800b5d0 <chMtxUnlock>
 8008f2c:	bd38      	pop	{r3, r4, r5, pc}
 8008f2e:	bf00      	nop
 8008f30:	20003134 	.word	0x20003134
	...

08008f40 <chFactoryFindPipe>:
dyn_pipe_t *chFactoryFindPipe(const char *name) {
 8008f40:	b538      	push	{r3, r4, r5, lr}
 8008f42:	4605      	mov	r5, r0
  F_LOCK();
 8008f44:	4c07      	ldr	r4, [pc, #28]	; (8008f64 <chFactoryFindPipe+0x24>)
 8008f46:	4620      	mov	r0, r4
 8008f48:	f002 fd02 	bl	800b950 <chMtxLock>
  dpp = (dyn_pipe_t *)dyn_find_object(name, &ch_factory.pipe_list);
 8008f4c:	f104 0144 	add.w	r1, r4, #68	; 0x44
 8008f50:	4628      	mov	r0, r5
 8008f52:	f000 fb95 	bl	8009680 <dyn_find_object.lto_priv.137>
 8008f56:	4605      	mov	r5, r0
  F_UNLOCK();
 8008f58:	4620      	mov	r0, r4
 8008f5a:	f002 fb39 	bl	800b5d0 <chMtxUnlock>
}
 8008f5e:	4628      	mov	r0, r5
 8008f60:	bd38      	pop	{r3, r4, r5, pc}
 8008f62:	bf00      	nop
 8008f64:	20003134 	.word	0x20003134
	...

08008f70 <chFactoryCreatePipe>:
dyn_pipe_t *chFactoryCreatePipe(const char *name, size_t size) {
 8008f70:	b570      	push	{r4, r5, r6, lr}
 8008f72:	4606      	mov	r6, r0
 8008f74:	460d      	mov	r5, r1
  F_LOCK();
 8008f76:	4c0c      	ldr	r4, [pc, #48]	; (8008fa8 <chFactoryCreatePipe+0x38>)
 8008f78:	4620      	mov	r0, r4
 8008f7a:	f002 fce9 	bl	800b950 <chMtxLock>
  dpp = (dyn_pipe_t *)dyn_create_object_heap(name,
 8008f7e:	f105 0260 	add.w	r2, r5, #96	; 0x60
 8008f82:	f104 0144 	add.w	r1, r4, #68	; 0x44
 8008f86:	4630      	mov	r0, r6
 8008f88:	f000 fdf2 	bl	8009b70 <dyn_create_object_heap.lto_priv.138>
  if (dpp != NULL) {
 8008f8c:	4604      	mov	r4, r0
 8008f8e:	b128      	cbz	r0, 8008f9c <chFactoryCreatePipe+0x2c>
    chPipeObjectInit(&dpp->pipe, dpp->buffer, size);
 8008f90:	462a      	mov	r2, r5
 8008f92:	f100 0160 	add.w	r1, r0, #96	; 0x60
 8008f96:	3010      	adds	r0, #16
 8008f98:	f000 fc1a 	bl	80097d0 <chPipeObjectInit>
  F_UNLOCK();
 8008f9c:	4802      	ldr	r0, [pc, #8]	; (8008fa8 <chFactoryCreatePipe+0x38>)
 8008f9e:	f002 fb17 	bl	800b5d0 <chMtxUnlock>
}
 8008fa2:	4620      	mov	r0, r4
 8008fa4:	bd70      	pop	{r4, r5, r6, pc}
 8008fa6:	bf00      	nop
 8008fa8:	20003134 	.word	0x20003134
 8008fac:	00000000 	.word	0x00000000

08008fb0 <chFactoryReleaseObjectsFIFO>:
void chFactoryReleaseObjectsFIFO(dyn_objects_fifo_t *dofp) {
 8008fb0:	b538      	push	{r3, r4, r5, lr}
 8008fb2:	4605      	mov	r5, r0
  F_LOCK();
 8008fb4:	4c06      	ldr	r4, [pc, #24]	; (8008fd0 <chFactoryReleaseObjectsFIFO+0x20>)
 8008fb6:	4620      	mov	r0, r4
 8008fb8:	f002 fcca 	bl	800b950 <chMtxLock>
  dyn_release_object_heap(&dofp->element, &ch_factory.fifo_list);
 8008fbc:	f104 0140 	add.w	r1, r4, #64	; 0x40
 8008fc0:	4628      	mov	r0, r5
 8008fc2:	f000 fd45 	bl	8009a50 <dyn_release_object_heap.lto_priv.136>
  F_UNLOCK();
 8008fc6:	4620      	mov	r0, r4
 8008fc8:	f002 fb02 	bl	800b5d0 <chMtxUnlock>
 8008fcc:	bd38      	pop	{r3, r4, r5, pc}
 8008fce:	bf00      	nop
 8008fd0:	20003134 	.word	0x20003134
	...

08008fe0 <chFactoryFindObjectsFIFO>:
dyn_objects_fifo_t *chFactoryFindObjectsFIFO(const char *name) {
 8008fe0:	b538      	push	{r3, r4, r5, lr}
 8008fe2:	4605      	mov	r5, r0
  F_LOCK();
 8008fe4:	4c07      	ldr	r4, [pc, #28]	; (8009004 <chFactoryFindObjectsFIFO+0x24>)
 8008fe6:	4620      	mov	r0, r4
 8008fe8:	f002 fcb2 	bl	800b950 <chMtxLock>
  dofp = (dyn_objects_fifo_t *)dyn_find_object(name, &ch_factory.fifo_list);
 8008fec:	f104 0140 	add.w	r1, r4, #64	; 0x40
 8008ff0:	4628      	mov	r0, r5
 8008ff2:	f000 fb45 	bl	8009680 <dyn_find_object.lto_priv.137>
 8008ff6:	4605      	mov	r5, r0
  F_UNLOCK();
 8008ff8:	4620      	mov	r0, r4
 8008ffa:	f002 fae9 	bl	800b5d0 <chMtxUnlock>
}
 8008ffe:	4628      	mov	r0, r5
 8009000:	bd38      	pop	{r3, r4, r5, pc}
 8009002:	bf00      	nop
 8009004:	20003134 	.word	0x20003134
	...

08009010 <chFactoryCreateObjectsFIFO>:
                                               unsigned objalign) {
 8009010:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8009014:	4606      	mov	r6, r0
 8009016:	4688      	mov	r8, r1
 8009018:	4614      	mov	r4, r2
 800901a:	4699      	mov	r9, r3
  F_LOCK();
 800901c:	4d17      	ldr	r5, [pc, #92]	; (800907c <chFactoryCreateObjectsFIFO+0x6c>)
 800901e:	4628      	mov	r0, r5
 8009020:	f002 fc96 	bl	800b950 <chMtxLock>
                                                      sizeof (dyn_objects_fifo_t) +
 8009024:	f104 0215 	add.w	r2, r4, #21
                                                      (objn * objsize));
 8009028:	fb08 f304 	mul.w	r3, r8, r4
  dofp = (dyn_objects_fifo_t *)dyn_create_object_heap(name,
 800902c:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8009030:	f105 0140 	add.w	r1, r5, #64	; 0x40
 8009034:	4630      	mov	r0, r6
 8009036:	f000 fd9b 	bl	8009b70 <dyn_create_object_heap.lto_priv.138>
  if (dofp != NULL) {
 800903a:	4605      	mov	r5, r0
 800903c:	b1c0      	cbz	r0, 8009070 <chFactoryCreateObjectsFIFO+0x60>
    chFifoObjectInitAligned(&dofp->fifo, objsize, objn, objalign,
 800903e:	f100 0710 	add.w	r7, r0, #16
                            (void *)&dofp->msgbuf[objn], dofp->msgbuf);
 8009042:	f104 0614 	add.w	r6, r4, #20
 8009046:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 800904a:	3604      	adds	r6, #4
 800904c:	f100 0a54 	add.w	sl, r0, #84	; 0x54
                                           size_t objn, unsigned objalign,
                                           void *objbuf, msg_t *msgbuf) {

  chDbgCheck((objsize >= objalign) && ((objsize % objalign) == 0U));

  chGuardedPoolObjectInitAligned(&ofp->free, objsize, objalign);
 8009050:	464a      	mov	r2, r9
 8009052:	4641      	mov	r1, r8
 8009054:	4638      	mov	r0, r7
 8009056:	f000 fc7b 	bl	8009950 <chGuardedPoolObjectInitAligned>
  chGuardedPoolLoadArray(&ofp->free, objbuf, objn);
 800905a:	4622      	mov	r2, r4
 800905c:	4631      	mov	r1, r6
 800905e:	4638      	mov	r0, r7
 8009060:	f000 fbf6 	bl	8009850 <chGuardedPoolLoadArray>
  chMBObjectInit(&ofp->mbx, msgbuf, objn);
 8009064:	4622      	mov	r2, r4
 8009066:	4651      	mov	r1, sl
 8009068:	f105 002c 	add.w	r0, r5, #44	; 0x2c
 800906c:	f000 fea8 	bl	8009dc0 <chMBObjectInit>
  F_UNLOCK();
 8009070:	4802      	ldr	r0, [pc, #8]	; (800907c <chFactoryCreateObjectsFIFO+0x6c>)
 8009072:	f002 faad 	bl	800b5d0 <chMtxUnlock>
}
 8009076:	4628      	mov	r0, r5
 8009078:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800907c:	20003134 	.word	0x20003134

08009080 <chFactoryReleaseMailbox>:
void chFactoryReleaseMailbox(dyn_mailbox_t *dmp) {
 8009080:	b538      	push	{r3, r4, r5, lr}
 8009082:	4605      	mov	r5, r0
  F_LOCK();
 8009084:	4c06      	ldr	r4, [pc, #24]	; (80090a0 <chFactoryReleaseMailbox+0x20>)
 8009086:	4620      	mov	r0, r4
 8009088:	f002 fc62 	bl	800b950 <chMtxLock>
  dyn_release_object_heap(&dmp->element, &ch_factory.mbx_list);
 800908c:	f104 013c 	add.w	r1, r4, #60	; 0x3c
 8009090:	4628      	mov	r0, r5
 8009092:	f000 fcdd 	bl	8009a50 <dyn_release_object_heap.lto_priv.136>
  F_UNLOCK();
 8009096:	4620      	mov	r0, r4
 8009098:	f002 fa9a 	bl	800b5d0 <chMtxUnlock>
 800909c:	bd38      	pop	{r3, r4, r5, pc}
 800909e:	bf00      	nop
 80090a0:	20003134 	.word	0x20003134
	...

080090b0 <chFactoryFindMailbox>:
dyn_mailbox_t *chFactoryFindMailbox(const char *name) {
 80090b0:	b538      	push	{r3, r4, r5, lr}
 80090b2:	4605      	mov	r5, r0
  F_LOCK();
 80090b4:	4c07      	ldr	r4, [pc, #28]	; (80090d4 <chFactoryFindMailbox+0x24>)
 80090b6:	4620      	mov	r0, r4
 80090b8:	f002 fc4a 	bl	800b950 <chMtxLock>
  dmp = (dyn_mailbox_t *)dyn_find_object(name, &ch_factory.mbx_list);
 80090bc:	f104 013c 	add.w	r1, r4, #60	; 0x3c
 80090c0:	4628      	mov	r0, r5
 80090c2:	f000 fadd 	bl	8009680 <dyn_find_object.lto_priv.137>
 80090c6:	4605      	mov	r5, r0
  F_UNLOCK();
 80090c8:	4620      	mov	r0, r4
 80090ca:	f002 fa81 	bl	800b5d0 <chMtxUnlock>
}
 80090ce:	4628      	mov	r0, r5
 80090d0:	bd38      	pop	{r3, r4, r5, pc}
 80090d2:	bf00      	nop
 80090d4:	20003134 	.word	0x20003134
	...

080090e0 <chFactoryCreateMailbox>:
dyn_mailbox_t *chFactoryCreateMailbox(const char *name, size_t n) {
 80090e0:	b570      	push	{r4, r5, r6, lr}
 80090e2:	4606      	mov	r6, r0
 80090e4:	460d      	mov	r5, r1
  F_LOCK();
 80090e6:	4c0c      	ldr	r4, [pc, #48]	; (8009118 <chFactoryCreateMailbox+0x38>)
 80090e8:	4620      	mov	r0, r4
 80090ea:	f002 fc31 	bl	800b950 <chMtxLock>
  dmp = (dyn_mailbox_t *)dyn_create_object_heap(name,
 80090ee:	f105 020e 	add.w	r2, r5, #14
 80090f2:	0092      	lsls	r2, r2, #2
 80090f4:	f104 013c 	add.w	r1, r4, #60	; 0x3c
 80090f8:	4630      	mov	r0, r6
 80090fa:	f000 fd39 	bl	8009b70 <dyn_create_object_heap.lto_priv.138>
  if (dmp != NULL) {
 80090fe:	4604      	mov	r4, r0
 8009100:	b128      	cbz	r0, 800910e <chFactoryCreateMailbox+0x2e>
    chMBObjectInit(&dmp->mbx, dmp->msgbuf, n);
 8009102:	462a      	mov	r2, r5
 8009104:	f100 0138 	add.w	r1, r0, #56	; 0x38
 8009108:	3010      	adds	r0, #16
 800910a:	f000 fe59 	bl	8009dc0 <chMBObjectInit>
  F_UNLOCK();
 800910e:	4802      	ldr	r0, [pc, #8]	; (8009118 <chFactoryCreateMailbox+0x38>)
 8009110:	f002 fa5e 	bl	800b5d0 <chMtxUnlock>
}
 8009114:	4620      	mov	r0, r4
 8009116:	bd70      	pop	{r4, r5, r6, pc}
 8009118:	20003134 	.word	0x20003134
 800911c:	00000000 	.word	0x00000000

08009120 <chFactoryReleaseSemaphore>:
void chFactoryReleaseSemaphore(dyn_semaphore_t *dsp) {
 8009120:	b538      	push	{r3, r4, r5, lr}
 8009122:	4605      	mov	r5, r0
  F_LOCK();
 8009124:	4c07      	ldr	r4, [pc, #28]	; (8009144 <chFactoryReleaseSemaphore+0x24>)
 8009126:	4620      	mov	r0, r4
 8009128:	f002 fc12 	bl	800b950 <chMtxLock>
  dyn_release_object_pool(&dsp->element,
 800912c:	f104 022c 	add.w	r2, r4, #44	; 0x2c
 8009130:	f104 0128 	add.w	r1, r4, #40	; 0x28
 8009134:	4628      	mov	r0, r5
 8009136:	f000 fbab 	bl	8009890 <dyn_release_object_pool.lto_priv.139>
  F_UNLOCK();
 800913a:	4620      	mov	r0, r4
 800913c:	f002 fa48 	bl	800b5d0 <chMtxUnlock>
 8009140:	bd38      	pop	{r3, r4, r5, pc}
 8009142:	bf00      	nop
 8009144:	20003134 	.word	0x20003134
	...

08009150 <chFactoryFindSemaphore>:
dyn_semaphore_t *chFactoryFindSemaphore(const char *name) {
 8009150:	b538      	push	{r3, r4, r5, lr}
 8009152:	4605      	mov	r5, r0
  F_LOCK();
 8009154:	4c07      	ldr	r4, [pc, #28]	; (8009174 <chFactoryFindSemaphore+0x24>)
 8009156:	4620      	mov	r0, r4
 8009158:	f002 fbfa 	bl	800b950 <chMtxLock>
  dsp = (dyn_semaphore_t *)dyn_find_object(name, &ch_factory.sem_list);
 800915c:	f104 0128 	add.w	r1, r4, #40	; 0x28
 8009160:	4628      	mov	r0, r5
 8009162:	f000 fa8d 	bl	8009680 <dyn_find_object.lto_priv.137>
 8009166:	4605      	mov	r5, r0
  F_UNLOCK();
 8009168:	4620      	mov	r0, r4
 800916a:	f002 fa31 	bl	800b5d0 <chMtxUnlock>
}
 800916e:	4628      	mov	r0, r5
 8009170:	bd38      	pop	{r3, r4, r5, pc}
 8009172:	bf00      	nop
 8009174:	20003134 	.word	0x20003134
	...

08009180 <chFactoryCreateSemaphore>:
dyn_semaphore_t *chFactoryCreateSemaphore(const char *name, cnt_t n) {
 8009180:	b570      	push	{r4, r5, r6, lr}
 8009182:	4605      	mov	r5, r0
 8009184:	460e      	mov	r6, r1
  F_LOCK();
 8009186:	4c0b      	ldr	r4, [pc, #44]	; (80091b4 <chFactoryCreateSemaphore+0x34>)
 8009188:	4620      	mov	r0, r4
 800918a:	f002 fbe1 	bl	800b950 <chMtxLock>
  dsp = (dyn_semaphore_t *)dyn_create_object_pool(name,
 800918e:	f104 022c 	add.w	r2, r4, #44	; 0x2c
 8009192:	f104 0128 	add.w	r1, r4, #40	; 0x28
 8009196:	4628      	mov	r0, r5
 8009198:	f000 fb9a 	bl	80098d0 <dyn_create_object_pool.lto_priv.140>
  if (dsp != NULL) {
 800919c:	4604      	mov	r4, r0
 800919e:	b118      	cbz	r0, 80091a8 <chFactoryCreateSemaphore+0x28>
    chSemObjectInit(&dsp->sem, n);
 80091a0:	4631      	mov	r1, r6
 80091a2:	3010      	adds	r0, #16
 80091a4:	f002 f87c 	bl	800b2a0 <chSemObjectInit>
  F_UNLOCK();
 80091a8:	4802      	ldr	r0, [pc, #8]	; (80091b4 <chFactoryCreateSemaphore+0x34>)
 80091aa:	f002 fa11 	bl	800b5d0 <chMtxUnlock>
}
 80091ae:	4620      	mov	r0, r4
 80091b0:	bd70      	pop	{r4, r5, r6, pc}
 80091b2:	bf00      	nop
 80091b4:	20003134 	.word	0x20003134
	...

080091c0 <chFactoryReleaseBuffer>:
void chFactoryReleaseBuffer(dyn_buffer_t *dbp) {
 80091c0:	b538      	push	{r3, r4, r5, lr}
 80091c2:	4605      	mov	r5, r0
  F_LOCK();
 80091c4:	4c06      	ldr	r4, [pc, #24]	; (80091e0 <chFactoryReleaseBuffer+0x20>)
 80091c6:	4620      	mov	r0, r4
 80091c8:	f002 fbc2 	bl	800b950 <chMtxLock>
  dyn_release_object_heap(&dbp->element, &ch_factory.buf_list);
 80091cc:	f104 0124 	add.w	r1, r4, #36	; 0x24
 80091d0:	4628      	mov	r0, r5
 80091d2:	f000 fc3d 	bl	8009a50 <dyn_release_object_heap.lto_priv.136>
  F_UNLOCK();
 80091d6:	4620      	mov	r0, r4
 80091d8:	f002 f9fa 	bl	800b5d0 <chMtxUnlock>
 80091dc:	bd38      	pop	{r3, r4, r5, pc}
 80091de:	bf00      	nop
 80091e0:	20003134 	.word	0x20003134
	...

080091f0 <chFactoryFindBuffer>:
dyn_buffer_t *chFactoryFindBuffer(const char *name) {
 80091f0:	b538      	push	{r3, r4, r5, lr}
 80091f2:	4605      	mov	r5, r0
  F_LOCK();
 80091f4:	4c07      	ldr	r4, [pc, #28]	; (8009214 <chFactoryFindBuffer+0x24>)
 80091f6:	4620      	mov	r0, r4
 80091f8:	f002 fbaa 	bl	800b950 <chMtxLock>
  dbp = (dyn_buffer_t *)dyn_find_object(name, &ch_factory.buf_list);
 80091fc:	f104 0124 	add.w	r1, r4, #36	; 0x24
 8009200:	4628      	mov	r0, r5
 8009202:	f000 fa3d 	bl	8009680 <dyn_find_object.lto_priv.137>
 8009206:	4605      	mov	r5, r0
  F_UNLOCK();
 8009208:	4620      	mov	r0, r4
 800920a:	f002 f9e1 	bl	800b5d0 <chMtxUnlock>
}
 800920e:	4628      	mov	r0, r5
 8009210:	bd38      	pop	{r3, r4, r5, pc}
 8009212:	bf00      	nop
 8009214:	20003134 	.word	0x20003134
	...

08009220 <chFactoryCreateBuffer>:
dyn_buffer_t *chFactoryCreateBuffer(const char *name, size_t size) {
 8009220:	b570      	push	{r4, r5, r6, lr}
 8009222:	4606      	mov	r6, r0
 8009224:	460d      	mov	r5, r1
  F_LOCK();
 8009226:	4c0b      	ldr	r4, [pc, #44]	; (8009254 <chFactoryCreateBuffer+0x34>)
 8009228:	4620      	mov	r0, r4
 800922a:	f002 fb91 	bl	800b950 <chMtxLock>
  dbp = (dyn_buffer_t *)dyn_create_object_heap(name,
 800922e:	462a      	mov	r2, r5
 8009230:	f104 0124 	add.w	r1, r4, #36	; 0x24
 8009234:	4630      	mov	r0, r6
 8009236:	f000 fc9b 	bl	8009b70 <dyn_create_object_heap.lto_priv.138>
  if (dbp != NULL) {
 800923a:	4604      	mov	r4, r0
 800923c:	b120      	cbz	r0, 8009248 <chFactoryCreateBuffer+0x28>
    memset((void *)dbp->buffer, 0, size);
 800923e:	462a      	mov	r2, r5
 8009240:	2100      	movs	r1, #0
 8009242:	3010      	adds	r0, #16
 8009244:	f7f8 fb5e 	bl	8001904 <memset>
  F_UNLOCK();
 8009248:	4802      	ldr	r0, [pc, #8]	; (8009254 <chFactoryCreateBuffer+0x34>)
 800924a:	f002 f9c1 	bl	800b5d0 <chMtxUnlock>
}
 800924e:	4620      	mov	r0, r4
 8009250:	bd70      	pop	{r4, r5, r6, pc}
 8009252:	bf00      	nop
 8009254:	20003134 	.word	0x20003134
	...

08009260 <chFactoryReleaseObject>:
void chFactoryReleaseObject(registered_object_t *rop){
 8009260:	b538      	push	{r3, r4, r5, lr}
 8009262:	4605      	mov	r5, r0
  F_LOCK();
 8009264:	4c07      	ldr	r4, [pc, #28]	; (8009284 <chFactoryReleaseObject+0x24>)
 8009266:	4620      	mov	r0, r4
 8009268:	f002 fb72 	bl	800b950 <chMtxLock>
  dyn_release_object_pool(&rop->element,
 800926c:	f104 0214 	add.w	r2, r4, #20
 8009270:	f104 0110 	add.w	r1, r4, #16
 8009274:	4628      	mov	r0, r5
 8009276:	f000 fb0b 	bl	8009890 <dyn_release_object_pool.lto_priv.139>
  F_UNLOCK();
 800927a:	4620      	mov	r0, r4
 800927c:	f002 f9a8 	bl	800b5d0 <chMtxUnlock>
 8009280:	bd38      	pop	{r3, r4, r5, pc}
 8009282:	bf00      	nop
 8009284:	20003134 	.word	0x20003134
	...

08009290 <chFactoryFindObject>:
registered_object_t *chFactoryFindObject(const char *name) {
 8009290:	b538      	push	{r3, r4, r5, lr}
 8009292:	4605      	mov	r5, r0
  F_LOCK();
 8009294:	4c07      	ldr	r4, [pc, #28]	; (80092b4 <chFactoryFindObject+0x24>)
 8009296:	4620      	mov	r0, r4
 8009298:	f002 fb5a 	bl	800b950 <chMtxLock>
  rop = (registered_object_t *)dyn_find_object(name, &ch_factory.obj_list);
 800929c:	f104 0110 	add.w	r1, r4, #16
 80092a0:	4628      	mov	r0, r5
 80092a2:	f000 f9ed 	bl	8009680 <dyn_find_object.lto_priv.137>
 80092a6:	4605      	mov	r5, r0
  F_UNLOCK();
 80092a8:	4620      	mov	r0, r4
 80092aa:	f002 f991 	bl	800b5d0 <chMtxUnlock>
}
 80092ae:	4628      	mov	r0, r5
 80092b0:	bd38      	pop	{r3, r4, r5, pc}
 80092b2:	bf00      	nop
 80092b4:	20003134 	.word	0x20003134
	...

080092c0 <chFactoryRegisterObject>:
                                             void *objp) {
 80092c0:	b570      	push	{r4, r5, r6, lr}
 80092c2:	4605      	mov	r5, r0
 80092c4:	460e      	mov	r6, r1
  F_LOCK();
 80092c6:	4c09      	ldr	r4, [pc, #36]	; (80092ec <chFactoryRegisterObject+0x2c>)
 80092c8:	4620      	mov	r0, r4
 80092ca:	f002 fb41 	bl	800b950 <chMtxLock>
  rop = (registered_object_t *)dyn_create_object_pool(name,
 80092ce:	f104 0214 	add.w	r2, r4, #20
 80092d2:	f104 0110 	add.w	r1, r4, #16
 80092d6:	4628      	mov	r0, r5
 80092d8:	f000 fafa 	bl	80098d0 <dyn_create_object_pool.lto_priv.140>
  if (rop != NULL) {
 80092dc:	4604      	mov	r4, r0
 80092de:	b100      	cbz	r0, 80092e2 <chFactoryRegisterObject+0x22>
    rop->objp = objp;
 80092e0:	6106      	str	r6, [r0, #16]
  F_UNLOCK();
 80092e2:	4802      	ldr	r0, [pc, #8]	; (80092ec <chFactoryRegisterObject+0x2c>)
 80092e4:	f002 f974 	bl	800b5d0 <chMtxUnlock>
}
 80092e8:	4620      	mov	r0, r4
 80092ea:	bd70      	pop	{r4, r5, r6, pc}
 80092ec:	20003134 	.word	0x20003134

080092f0 <_factory_init>:
void _factory_init(void) {
 80092f0:	b538      	push	{r3, r4, r5, lr}
  chMtxObjectInit(&ch_factory.mtx);
 80092f2:	4c12      	ldr	r4, [pc, #72]	; (800933c <_factory_init+0x4c>)
 80092f4:	4620      	mov	r0, r4
 80092f6:	f001 ffa3 	bl	800b240 <chMtxObjectInit>
  dlp->next = (dyn_element_t *)dlp;
 80092fa:	f104 0310 	add.w	r3, r4, #16
 80092fe:	6123      	str	r3, [r4, #16]
 8009300:	4d0f      	ldr	r5, [pc, #60]	; (8009340 <_factory_init+0x50>)
 8009302:	462b      	mov	r3, r5
 8009304:	2204      	movs	r2, #4
 8009306:	2114      	movs	r1, #20
 8009308:	1860      	adds	r0, r4, r1
 800930a:	f000 fb11 	bl	8009930 <chPoolObjectInitAligned>
 800930e:	f104 0324 	add.w	r3, r4, #36	; 0x24
 8009312:	6263      	str	r3, [r4, #36]	; 0x24
 8009314:	f104 0328 	add.w	r3, r4, #40	; 0x28
 8009318:	62a3      	str	r3, [r4, #40]	; 0x28
 800931a:	462b      	mov	r3, r5
 800931c:	2204      	movs	r2, #4
 800931e:	211c      	movs	r1, #28
 8009320:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 8009324:	f000 fb04 	bl	8009930 <chPoolObjectInitAligned>
 8009328:	f104 033c 	add.w	r3, r4, #60	; 0x3c
 800932c:	63e3      	str	r3, [r4, #60]	; 0x3c
 800932e:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8009332:	6423      	str	r3, [r4, #64]	; 0x40
 8009334:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8009338:	6463      	str	r3, [r4, #68]	; 0x44
 800933a:	bd38      	pop	{r3, r4, r5, pc}
 800933c:	20003134 	.word	0x20003134
 8009340:	080093e1 	.word	0x080093e1
	...

08009350 <dyn_list_unlink>:
  dyn_element_t *prev = (dyn_element_t *)dlp;
 8009350:	460a      	mov	r2, r1
 8009352:	e005      	b.n	8009360 <dyn_list_unlink+0x10>
    if (prev->next == element) {
 8009354:	4283      	cmp	r3, r0
 8009356:	d102      	bne.n	800935e <dyn_list_unlink+0xe>
      prev->next = element->next;
 8009358:	6803      	ldr	r3, [r0, #0]
 800935a:	6013      	str	r3, [r2, #0]
 800935c:	4770      	bx	lr
    prev = prev->next;
 800935e:	461a      	mov	r2, r3
  while (prev->next != (dyn_element_t *)dlp) {
 8009360:	6813      	ldr	r3, [r2, #0]
 8009362:	4299      	cmp	r1, r3
 8009364:	d1f6      	bne.n	8009354 <dyn_list_unlink+0x4>
  return NULL;
 8009366:	2000      	movs	r0, #0
}
 8009368:	4770      	bx	lr
 800936a:	bf00      	nop
 800936c:	0000      	movs	r0, r0
	...

08009370 <chPoolFreeI>:
  chDbgCheckClassI();
  chDbgCheck((mp != NULL) &&
             (objp != NULL) &&
             MEM_IS_ALIGNED(objp, mp->align));

  php->next = mp->next;
 8009370:	6803      	ldr	r3, [r0, #0]
 8009372:	600b      	str	r3, [r1, #0]
  mp->next = php;
 8009374:	6001      	str	r1, [r0, #0]
 8009376:	4770      	bx	lr
	...

08009380 <chPoolAllocI>:
void *chPoolAllocI(memory_pool_t *mp) {
 8009380:	b508      	push	{r3, lr}
 8009382:	4603      	mov	r3, r0
  objp = mp->next;
 8009384:	6800      	ldr	r0, [r0, #0]
  if (objp != NULL) {
 8009386:	b110      	cbz	r0, 800938e <chPoolAllocI+0xe>
    mp->next = mp->next->next;
 8009388:	6802      	ldr	r2, [r0, #0]
 800938a:	601a      	str	r2, [r3, #0]
 800938c:	bd08      	pop	{r3, pc}
  else if (mp->provider != NULL) {
 800938e:	68da      	ldr	r2, [r3, #12]
 8009390:	b112      	cbz	r2, 8009398 <chPoolAllocI+0x18>
    objp = mp->provider(mp->object_size, mp->align);
 8009392:	6899      	ldr	r1, [r3, #8]
 8009394:	6858      	ldr	r0, [r3, #4]
 8009396:	4790      	blx	r2
}
 8009398:	bd08      	pop	{r3, pc}
 800939a:	bf00      	nop
 800939c:	0000      	movs	r0, r0
	...

080093a0 <chCoreAllocAlignedWithOffsetI>:
 *
 * @iclass
 */
void *chCoreAllocAlignedWithOffsetI(size_t size,
                                    unsigned align,
                                    size_t offset) {
 80093a0:	b430      	push	{r4, r5}
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 80093a2:	4408      	add	r0, r1
 80093a4:	1e43      	subs	r3, r0, #1
 80093a6:	4248      	negs	r0, r1
 80093a8:	4003      	ands	r3, r0
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 80093aa:	4c09      	ldr	r4, [pc, #36]	; (80093d0 <chCoreAllocAlignedWithOffsetI+0x30>)
 80093ac:	6825      	ldr	r5, [r4, #0]
 80093ae:	442a      	add	r2, r5
 80093b0:	4411      	add	r1, r2
 80093b2:	3901      	subs	r1, #1
 80093b4:	4008      	ands	r0, r1
  next = p + size;
 80093b6:	4403      	add	r3, r0

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 80093b8:	6862      	ldr	r2, [r4, #4]
 80093ba:	4293      	cmp	r3, r2
 80093bc:	d803      	bhi.n	80093c6 <chCoreAllocAlignedWithOffsetI+0x26>
 80093be:	429d      	cmp	r5, r3
 80093c0:	d803      	bhi.n	80093ca <chCoreAllocAlignedWithOffsetI+0x2a>
    return NULL;
  }

  ch_memcore.nextmem = next;
 80093c2:	6023      	str	r3, [r4, #0]
 80093c4:	e002      	b.n	80093cc <chCoreAllocAlignedWithOffsetI+0x2c>
    return NULL;
 80093c6:	2000      	movs	r0, #0
 80093c8:	e000      	b.n	80093cc <chCoreAllocAlignedWithOffsetI+0x2c>
 80093ca:	2000      	movs	r0, #0

  return p;
}
 80093cc:	bc30      	pop	{r4, r5}
 80093ce:	4770      	bx	lr
 80093d0:	2000318c 	.word	0x2000318c
	...

080093e0 <chCoreAllocAlignedI.lto_priv.28>:
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 80093e0:	b508      	push	{r3, lr}
  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 80093e2:	2200      	movs	r2, #0
 80093e4:	f7ff ffdc 	bl	80093a0 <chCoreAllocAlignedWithOffsetI>
}
 80093e8:	bd08      	pop	{r3, pc}
 80093ea:	bf00      	nop
 80093ec:	0000      	movs	r0, r0
	...

080093f0 <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
 80093f0:	b508      	push	{r3, lr}
 80093f2:	2320      	movs	r3, #32
 80093f4:	f383 8811 	msr	BASEPRI, r3
  void *p;

  chSysLock();
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
 80093f8:	f7ff ffd2 	bl	80093a0 <chCoreAllocAlignedWithOffsetI>
 80093fc:	2300      	movs	r3, #0
 80093fe:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return p;
}
 8009402:	bd08      	pop	{r3, pc}
	...

08009410 <dyn_list_find>:
static dyn_element_t *dyn_list_find(const char *name, dyn_list_t *dlp) {
 8009410:	b570      	push	{r4, r5, r6, lr}
 8009412:	4606      	mov	r6, r0
 8009414:	460d      	mov	r5, r1
  dyn_element_t *p = dlp->next;
 8009416:	680c      	ldr	r4, [r1, #0]
 8009418:	e006      	b.n	8009428 <dyn_list_find+0x18>
    if (strncmp(p->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH) == 0) {
 800941a:	2208      	movs	r2, #8
 800941c:	4631      	mov	r1, r6
 800941e:	18a0      	adds	r0, r4, r2
 8009420:	f7f8 fecc 	bl	80021bc <strncmp>
 8009424:	b120      	cbz	r0, 8009430 <dyn_list_find+0x20>
    p = p->next;
 8009426:	6824      	ldr	r4, [r4, #0]
  while (p != (dyn_element_t *)dlp) {
 8009428:	42ac      	cmp	r4, r5
 800942a:	d1f6      	bne.n	800941a <dyn_list_find+0xa>
  return NULL;
 800942c:	2000      	movs	r0, #0
 800942e:	bd70      	pop	{r4, r5, r6, pc}
      return p;
 8009430:	4620      	mov	r0, r4
}
 8009432:	bd70      	pop	{r4, r5, r6, pc}
	...

08009440 <pipe_read>:
 *                      value 0 is reserved
 * @return              The number of bytes effectively transferred.
 *
 * @notapi
 */
static size_t pipe_read(pipe_t *pp, uint8_t *bp, size_t n) {
 8009440:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8009444:	4604      	mov	r4, r0
 8009446:	4688      	mov	r8, r1
 8009448:	4615      	mov	r5, r2
  size_t s1, s2;

  PC_LOCK(pp);
 800944a:	f100 0720 	add.w	r7, r0, #32
 800944e:	4638      	mov	r0, r7
 8009450:	f002 fa7e 	bl	800b950 <chMtxLock>
 *
 * @api
 */
static inline size_t chPipeGetUsedCount(const pipe_t *pp) {

  return pp->cnt;
 8009454:	6923      	ldr	r3, [r4, #16]

  /* Number of bytes that can be read in a single atomic operation.*/
  if (n > chPipeGetUsedCount(pp)) {
 8009456:	429d      	cmp	r5, r3
 8009458:	d900      	bls.n	800945c <pipe_read+0x1c>
    n = chPipeGetUsedCount(pp);
 800945a:	461d      	mov	r5, r3
  }
  pp->cnt -= n;
 800945c:	1b5b      	subs	r3, r3, r5
 800945e:	6123      	str	r3, [r4, #16]

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(pp->top - pp->rdptr);
 8009460:	6866      	ldr	r6, [r4, #4]
 8009462:	68e1      	ldr	r1, [r4, #12]
 8009464:	1a76      	subs	r6, r6, r1
  /*lint -restore*/

  if (n < s1) {
 8009466:	42b5      	cmp	r5, r6
 8009468:	d207      	bcs.n	800947a <pipe_read+0x3a>
    memcpy((void *)bp, (void *)pp->rdptr, n);
 800946a:	462a      	mov	r2, r5
 800946c:	4640      	mov	r0, r8
 800946e:	f7f8 f9af 	bl	80017d0 <memcpy>
    pp->rdptr += n;
 8009472:	68e3      	ldr	r3, [r4, #12]
 8009474:	442b      	add	r3, r5
 8009476:	60e3      	str	r3, [r4, #12]
 8009478:	e017      	b.n	80094aa <pipe_read+0x6a>
  }
  else if (n > s1) {
 800947a:	42b5      	cmp	r5, r6
 800947c:	d90f      	bls.n	800949e <pipe_read+0x5e>
    memcpy((void *)bp, (void *)pp->rdptr, s1);
 800947e:	4632      	mov	r2, r6
 8009480:	4640      	mov	r0, r8
 8009482:	f7f8 f9a5 	bl	80017d0 <memcpy>
    bp += s1;
    s2 = n - s1;
 8009486:	ebc6 0905 	rsb	r9, r6, r5
    memcpy((void *)bp, (void *)pp->buffer, s2);
 800948a:	464a      	mov	r2, r9
 800948c:	6821      	ldr	r1, [r4, #0]
 800948e:	eb08 0006 	add.w	r0, r8, r6
 8009492:	f7f8 f99d 	bl	80017d0 <memcpy>
    pp->rdptr = pp->buffer + s2;
 8009496:	6823      	ldr	r3, [r4, #0]
 8009498:	444b      	add	r3, r9
 800949a:	60e3      	str	r3, [r4, #12]
 800949c:	e005      	b.n	80094aa <pipe_read+0x6a>
  }
  else { /* n == s1 */
    memcpy((void *)bp, (void *)pp->rdptr, n);
 800949e:	462a      	mov	r2, r5
 80094a0:	4640      	mov	r0, r8
 80094a2:	f7f8 f995 	bl	80017d0 <memcpy>
    pp->rdptr = pp->buffer;
 80094a6:	6823      	ldr	r3, [r4, #0]
 80094a8:	60e3      	str	r3, [r4, #12]
  }

  PC_UNLOCK(pp);
 80094aa:	4638      	mov	r0, r7
 80094ac:	f002 f890 	bl	800b5d0 <chMtxUnlock>

  return n;
}
 80094b0:	4628      	mov	r0, r5
 80094b2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80094b6:	bf00      	nop
	...

080094c0 <pipe_write>:
static size_t pipe_write(pipe_t *pp, const uint8_t *bp, size_t n) {
 80094c0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80094c4:	4605      	mov	r5, r0
 80094c6:	4688      	mov	r8, r1
 80094c8:	4691      	mov	r9, r2
  PC_LOCK(pp);
 80094ca:	f100 0720 	add.w	r7, r0, #32
 80094ce:	4638      	mov	r0, r7
 80094d0:	f002 fa3e 	bl	800b950 <chMtxLock>
  return (size_t)(pp->top - pp->buffer);
 80094d4:	686e      	ldr	r6, [r5, #4]
 80094d6:	682c      	ldr	r4, [r5, #0]
 80094d8:	1b34      	subs	r4, r6, r4
  return pp->cnt;
 80094da:	692b      	ldr	r3, [r5, #16]
 *
 * @api
 */
static inline size_t chPipeGetFreeCount(const pipe_t *pp) {

  return chPipeGetSize(pp) - chPipeGetUsedCount(pp);
 80094dc:	1ae4      	subs	r4, r4, r3
  if (n > chPipeGetFreeCount(pp)) {
 80094de:	45a1      	cmp	r9, r4
 80094e0:	d800      	bhi.n	80094e4 <pipe_write+0x24>
 80094e2:	464c      	mov	r4, r9
  pp->cnt += n;
 80094e4:	4423      	add	r3, r4
 80094e6:	612b      	str	r3, [r5, #16]
  s1 = (size_t)(pp->top - pp->wrptr);
 80094e8:	68a8      	ldr	r0, [r5, #8]
 80094ea:	1a36      	subs	r6, r6, r0
  if (n < s1) {
 80094ec:	42b4      	cmp	r4, r6
 80094ee:	d207      	bcs.n	8009500 <pipe_write+0x40>
    memcpy((void *)pp->wrptr, (const void *)bp, n);
 80094f0:	4622      	mov	r2, r4
 80094f2:	4641      	mov	r1, r8
 80094f4:	f7f8 f96c 	bl	80017d0 <memcpy>
    pp->wrptr += n;
 80094f8:	68ab      	ldr	r3, [r5, #8]
 80094fa:	4423      	add	r3, r4
 80094fc:	60ab      	str	r3, [r5, #8]
 80094fe:	e017      	b.n	8009530 <pipe_write+0x70>
  else if (n > s1) {
 8009500:	42b4      	cmp	r4, r6
 8009502:	d90f      	bls.n	8009524 <pipe_write+0x64>
    memcpy((void *)pp->wrptr, (const void *)bp, s1);
 8009504:	4632      	mov	r2, r6
 8009506:	4641      	mov	r1, r8
 8009508:	f7f8 f962 	bl	80017d0 <memcpy>
    s2 = n - s1;
 800950c:	ebc6 0904 	rsb	r9, r6, r4
    memcpy((void *)pp->buffer, (const void *)bp, s2);
 8009510:	464a      	mov	r2, r9
 8009512:	eb08 0106 	add.w	r1, r8, r6
 8009516:	6828      	ldr	r0, [r5, #0]
 8009518:	f7f8 f95a 	bl	80017d0 <memcpy>
    pp->wrptr = pp->buffer + s2;
 800951c:	682b      	ldr	r3, [r5, #0]
 800951e:	444b      	add	r3, r9
 8009520:	60ab      	str	r3, [r5, #8]
 8009522:	e005      	b.n	8009530 <pipe_write+0x70>
    memcpy((void *)pp->wrptr, (const void *)bp, n);
 8009524:	4622      	mov	r2, r4
 8009526:	4641      	mov	r1, r8
 8009528:	f7f8 f952 	bl	80017d0 <memcpy>
    pp->wrptr = pp->buffer;
 800952c:	682b      	ldr	r3, [r5, #0]
 800952e:	60ab      	str	r3, [r5, #8]
  PC_UNLOCK(pp);
 8009530:	4638      	mov	r0, r7
 8009532:	f002 f84d 	bl	800b5d0 <chMtxUnlock>
}
 8009536:	4620      	mov	r0, r4
 8009538:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800953c:	0000      	movs	r0, r0
	...

08009540 <chGuardedPoolAllocTimeoutS>:
 * @retval NULL         if the operation timed out.
 *
 * @sclass
 */
void *chGuardedPoolAllocTimeoutS(guarded_memory_pool_t *gmp,
                                 sysinterval_t timeout) {
 8009540:	b510      	push	{r4, lr}
 8009542:	4604      	mov	r4, r0
  msg_t msg;

  msg = chSemWaitTimeoutS(&gmp->sem, timeout);
 8009544:	f002 fb14 	bl	800bb70 <chSemWaitTimeoutS>
  if (msg != MSG_OK) {
 8009548:	b920      	cbnz	r0, 8009554 <chGuardedPoolAllocTimeoutS+0x14>
    return NULL;
  }

  return chPoolAllocI(&gmp->pool);
 800954a:	f104 000c 	add.w	r0, r4, #12
 800954e:	f7ff ff17 	bl	8009380 <chPoolAllocI>
 8009552:	bd10      	pop	{r4, pc}
    return NULL;
 8009554:	2000      	movs	r0, #0
}
 8009556:	bd10      	pop	{r4, pc}
	...

08009560 <chMBFetchTimeoutS>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchTimeoutS(mailbox_t *mbp, msg_t *msgp, sysinterval_t timeout) {
 8009560:	b570      	push	{r4, r5, r6, lr}
 8009562:	4604      	mov	r4, r0
 8009564:	460e      	mov	r6, r1
 8009566:	4615      	mov	r5, r2
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
 8009568:	7d23      	ldrb	r3, [r4, #20]
 800956a:	bb03      	cbnz	r3, 80095ae <chMBFetchTimeoutS+0x4e>
 800956c:	6923      	ldr	r3, [r4, #16]
      return MSG_RESET;
    }

    /* Is there a message in queue? if so then fetch.*/
    if (chMBGetUsedCountI(mbp) > (size_t)0) {
 800956e:	b1b3      	cbz	r3, 800959e <chMBFetchTimeoutS+0x3e>
      *msgp = *mbp->rdptr++;
 8009570:	68e3      	ldr	r3, [r4, #12]
 8009572:	1d1a      	adds	r2, r3, #4
 8009574:	60e2      	str	r2, [r4, #12]
 8009576:	681b      	ldr	r3, [r3, #0]
 8009578:	6033      	str	r3, [r6, #0]
      if (mbp->rdptr >= mbp->top) {
 800957a:	68e2      	ldr	r2, [r4, #12]
 800957c:	6863      	ldr	r3, [r4, #4]
 800957e:	429a      	cmp	r2, r3
 8009580:	d301      	bcc.n	8009586 <chMBFetchTimeoutS+0x26>
        mbp->rdptr = mbp->buffer;
 8009582:	6823      	ldr	r3, [r4, #0]
 8009584:	60e3      	str	r3, [r4, #12]
      }
      mbp->cnt--;
 8009586:	6923      	ldr	r3, [r4, #16]
 8009588:	3b01      	subs	r3, #1
 800958a:	6123      	str	r3, [r4, #16]

      /* If there is a writer waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->qw, MSG_OK);
 800958c:	2100      	movs	r1, #0
 800958e:	f104 0018 	add.w	r0, r4, #24
 8009592:	f001 fec5 	bl	800b320 <chThdDequeueNextI>
      chSchRescheduleS();
 8009596:	f001 ffc3 	bl	800b520 <chSchRescheduleS>

      return MSG_OK;
 800959a:	2000      	movs	r0, #0
 800959c:	bd70      	pop	{r4, r5, r6, pc}
    }

    /* No message in the queue, waiting for a message to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 800959e:	4629      	mov	r1, r5
 80095a0:	f104 0020 	add.w	r0, r4, #32
 80095a4:	f002 fb14 	bl	800bbd0 <chThdEnqueueTimeoutS>
  } while (rdymsg == MSG_OK);
 80095a8:	2800      	cmp	r0, #0
 80095aa:	d0dd      	beq.n	8009568 <chMBFetchTimeoutS+0x8>
 80095ac:	bd70      	pop	{r4, r5, r6, pc}
      return MSG_RESET;
 80095ae:	f06f 0001 	mvn.w	r0, #1

  return rdymsg;
}
 80095b2:	bd70      	pop	{r4, r5, r6, pc}
	...

080095c0 <chMBPostAheadTimeoutS>:
msg_t chMBPostAheadTimeoutS(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
 80095c0:	b570      	push	{r4, r5, r6, lr}
 80095c2:	4604      	mov	r4, r0
 80095c4:	460d      	mov	r5, r1
 80095c6:	4616      	mov	r6, r2
    if (mbp->reset) {
 80095c8:	7d23      	ldrb	r3, [r4, #20]
 80095ca:	bb1b      	cbnz	r3, 8009614 <chMBPostAheadTimeoutS+0x54>
  return (size_t)(mbp->top - mbp->buffer);
 80095cc:	6863      	ldr	r3, [r4, #4]
 80095ce:	6822      	ldr	r2, [r4, #0]
 80095d0:	1a98      	subs	r0, r3, r2
  return mbp->cnt;
 80095d2:	6921      	ldr	r1, [r4, #16]
    if (chMBGetFreeCountI(mbp) > (size_t)0) {
 80095d4:	ebb1 0fa0 	cmp.w	r1, r0, asr #2
 80095d8:	d014      	beq.n	8009604 <chMBPostAheadTimeoutS+0x44>
      if (--mbp->rdptr < mbp->buffer) {
 80095da:	68e1      	ldr	r1, [r4, #12]
 80095dc:	3904      	subs	r1, #4
 80095de:	60e1      	str	r1, [r4, #12]
 80095e0:	4291      	cmp	r1, r2
 80095e2:	d201      	bcs.n	80095e8 <chMBPostAheadTimeoutS+0x28>
        mbp->rdptr = mbp->top - 1;
 80095e4:	3b04      	subs	r3, #4
 80095e6:	60e3      	str	r3, [r4, #12]
      *mbp->rdptr = msg;
 80095e8:	68e3      	ldr	r3, [r4, #12]
 80095ea:	601d      	str	r5, [r3, #0]
      mbp->cnt++;
 80095ec:	6923      	ldr	r3, [r4, #16]
 80095ee:	3301      	adds	r3, #1
 80095f0:	6123      	str	r3, [r4, #16]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 80095f2:	2100      	movs	r1, #0
 80095f4:	f104 0020 	add.w	r0, r4, #32
 80095f8:	f001 fe92 	bl	800b320 <chThdDequeueNextI>
      chSchRescheduleS();
 80095fc:	f001 ff90 	bl	800b520 <chSchRescheduleS>
      return MSG_OK;
 8009600:	2000      	movs	r0, #0
 8009602:	bd70      	pop	{r4, r5, r6, pc}
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 8009604:	4631      	mov	r1, r6
 8009606:	f104 0018 	add.w	r0, r4, #24
 800960a:	f002 fae1 	bl	800bbd0 <chThdEnqueueTimeoutS>
  } while (rdymsg == MSG_OK);
 800960e:	2800      	cmp	r0, #0
 8009610:	d0da      	beq.n	80095c8 <chMBPostAheadTimeoutS+0x8>
 8009612:	bd70      	pop	{r4, r5, r6, pc}
      return MSG_RESET;
 8009614:	f06f 0001 	mvn.w	r0, #1
}
 8009618:	bd70      	pop	{r4, r5, r6, pc}
 800961a:	bf00      	nop
 800961c:	0000      	movs	r0, r0
	...

08009620 <chMBPostTimeoutS>:
msg_t chMBPostTimeoutS(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
 8009620:	b570      	push	{r4, r5, r6, lr}
 8009622:	4604      	mov	r4, r0
 8009624:	460e      	mov	r6, r1
 8009626:	4615      	mov	r5, r2
    if (mbp->reset) {
 8009628:	7d23      	ldrb	r3, [r4, #20]
 800962a:	bb23      	cbnz	r3, 8009676 <chMBPostTimeoutS+0x56>
  return (size_t)(mbp->top - mbp->buffer);
 800962c:	6863      	ldr	r3, [r4, #4]
 800962e:	6822      	ldr	r2, [r4, #0]
 8009630:	1a9b      	subs	r3, r3, r2
  return mbp->cnt;
 8009632:	6922      	ldr	r2, [r4, #16]
    if (chMBGetFreeCountI(mbp) > (size_t)0) {
 8009634:	ebb2 0fa3 	cmp.w	r2, r3, asr #2
 8009638:	d015      	beq.n	8009666 <chMBPostTimeoutS+0x46>
      *mbp->wrptr++ = msg;
 800963a:	68a3      	ldr	r3, [r4, #8]
 800963c:	1d1a      	adds	r2, r3, #4
 800963e:	60a2      	str	r2, [r4, #8]
 8009640:	601e      	str	r6, [r3, #0]
      if (mbp->wrptr >= mbp->top) {
 8009642:	68a2      	ldr	r2, [r4, #8]
 8009644:	6863      	ldr	r3, [r4, #4]
 8009646:	429a      	cmp	r2, r3
 8009648:	d301      	bcc.n	800964e <chMBPostTimeoutS+0x2e>
        mbp->wrptr = mbp->buffer;
 800964a:	6823      	ldr	r3, [r4, #0]
 800964c:	60a3      	str	r3, [r4, #8]
      mbp->cnt++;
 800964e:	6923      	ldr	r3, [r4, #16]
 8009650:	3301      	adds	r3, #1
 8009652:	6123      	str	r3, [r4, #16]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 8009654:	2100      	movs	r1, #0
 8009656:	f104 0020 	add.w	r0, r4, #32
 800965a:	f001 fe61 	bl	800b320 <chThdDequeueNextI>
      chSchRescheduleS();
 800965e:	f001 ff5f 	bl	800b520 <chSchRescheduleS>
      return MSG_OK;
 8009662:	2000      	movs	r0, #0
 8009664:	bd70      	pop	{r4, r5, r6, pc}
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 8009666:	4629      	mov	r1, r5
 8009668:	f104 0018 	add.w	r0, r4, #24
 800966c:	f002 fab0 	bl	800bbd0 <chThdEnqueueTimeoutS>
  } while (rdymsg == MSG_OK);
 8009670:	2800      	cmp	r0, #0
 8009672:	d0d9      	beq.n	8009628 <chMBPostTimeoutS+0x8>
 8009674:	bd70      	pop	{r4, r5, r6, pc}
      return MSG_RESET;
 8009676:	f06f 0001 	mvn.w	r0, #1
}
 800967a:	bd70      	pop	{r4, r5, r6, pc}
 800967c:	0000      	movs	r0, r0
	...

08009680 <dyn_find_object.lto_priv.137>:
static dyn_element_t *dyn_find_object(const char *name, dyn_list_t *dlp) {
 8009680:	b508      	push	{r3, lr}
  dep = dyn_list_find(name, dlp);
 8009682:	f7ff fec5 	bl	8009410 <dyn_list_find>
  if (dep != NULL) {
 8009686:	4603      	mov	r3, r0
 8009688:	b110      	cbz	r0, 8009690 <dyn_find_object.lto_priv.137+0x10>
    dep->refs++;
 800968a:	6842      	ldr	r2, [r0, #4]
 800968c:	3201      	adds	r2, #1
 800968e:	6042      	str	r2, [r0, #4]
}
 8009690:	4618      	mov	r0, r3
 8009692:	bd08      	pop	{r3, pc}
	...

080096a0 <chPipeReadTimeout>:
 *                      pipe went in reset state.
 *
 * @api
 */
size_t chPipeReadTimeout(pipe_t *pp, uint8_t *bp,
                         size_t n, sysinterval_t timeout) {
 80096a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80096a4:	461f      	mov	r7, r3
  size_t max = n;

  chDbgCheck(n > 0U);

  /* If the pipe is in reset state then returns immediately.*/
  if (pp->reset) {
 80096a6:	7d03      	ldrb	r3, [r0, #20]
 80096a8:	bb63      	cbnz	r3, 8009704 <chPipeReadTimeout+0x64>
 80096aa:	4605      	mov	r5, r0
 80096ac:	460e      	mov	r6, r1
 80096ae:	4690      	mov	r8, r2
    return (size_t)0;
  }

  PR_LOCK(pp);
 80096b0:	f100 0940 	add.w	r9, r0, #64	; 0x40
 80096b4:	4648      	mov	r0, r9
 80096b6:	f002 f94b 	bl	800b950 <chMtxLock>
 80096ba:	4644      	mov	r4, r8
 80096bc:	e019      	b.n	80096f2 <chPipeReadTimeout+0x52>

  while (n > 0U) {
    size_t done;

    done = pipe_read(pp, bp, n);
 80096be:	4622      	mov	r2, r4
 80096c0:	4631      	mov	r1, r6
 80096c2:	4628      	mov	r0, r5
 80096c4:	f7ff febc 	bl	8009440 <pipe_read>
    if (done == (size_t)0) {
 80096c8:	b960      	cbnz	r0, 80096e4 <chPipeReadTimeout+0x44>
 80096ca:	2320      	movs	r3, #32
 80096cc:	f383 8811 	msr	BASEPRI, r3
      msg_t msg;

      chSysLock();
      msg = chThdSuspendTimeoutS(&pp->rtr, timeout);
 80096d0:	4639      	mov	r1, r7
 80096d2:	f105 001c 	add.w	r0, r5, #28
 80096d6:	f002 fa93 	bl	800bc00 <chThdSuspendTimeoutS>
 80096da:	2300      	movs	r3, #0
 80096dc:	f383 8811 	msr	BASEPRI, r3
      chSysUnlock();

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 80096e0:	b138      	cbz	r0, 80096f2 <chPipeReadTimeout+0x52>
 80096e2:	e008      	b.n	80096f6 <chPipeReadTimeout+0x56>
        break;
      }
    }
    else {
      n  -= done;
 80096e4:	1a24      	subs	r4, r4, r0
      bp += done;
 80096e6:	4406      	add	r6, r0

      /* Resuming the writer, if present.*/
      chThdResume(&pp->wtr, MSG_OK);
 80096e8:	2100      	movs	r1, #0
 80096ea:	f105 0018 	add.w	r0, r5, #24
 80096ee:	f002 f82f 	bl	800b750 <chThdResume>
  while (n > 0U) {
 80096f2:	2c00      	cmp	r4, #0
 80096f4:	d1e3      	bne.n	80096be <chPipeReadTimeout+0x1e>
    }
  }

  PR_UNLOCK(pp);
 80096f6:	4648      	mov	r0, r9
 80096f8:	f001 ff6a 	bl	800b5d0 <chMtxUnlock>

  return max - n;
 80096fc:	ebc4 0008 	rsb	r0, r4, r8
 8009700:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return (size_t)0;
 8009704:	2000      	movs	r0, #0
}
 8009706:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800970a:	bf00      	nop
 800970c:	0000      	movs	r0, r0
	...

08009710 <chPipeWriteTimeout>:
                          size_t n, sysinterval_t timeout) {
 8009710:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8009714:	461f      	mov	r7, r3
  if (pp->reset) {
 8009716:	7d03      	ldrb	r3, [r0, #20]
 8009718:	bb63      	cbnz	r3, 8009774 <chPipeWriteTimeout+0x64>
 800971a:	4605      	mov	r5, r0
 800971c:	460e      	mov	r6, r1
 800971e:	4690      	mov	r8, r2
  PW_LOCK(pp);
 8009720:	f100 0930 	add.w	r9, r0, #48	; 0x30
 8009724:	4648      	mov	r0, r9
 8009726:	f002 f913 	bl	800b950 <chMtxLock>
 800972a:	4644      	mov	r4, r8
 800972c:	e019      	b.n	8009762 <chPipeWriteTimeout+0x52>
    done = pipe_write(pp, bp, n);
 800972e:	4622      	mov	r2, r4
 8009730:	4631      	mov	r1, r6
 8009732:	4628      	mov	r0, r5
 8009734:	f7ff fec4 	bl	80094c0 <pipe_write>
    if (done == (size_t)0) {
 8009738:	b960      	cbnz	r0, 8009754 <chPipeWriteTimeout+0x44>
 800973a:	2320      	movs	r3, #32
 800973c:	f383 8811 	msr	BASEPRI, r3
      msg = chThdSuspendTimeoutS(&pp->wtr, timeout);
 8009740:	4639      	mov	r1, r7
 8009742:	f105 0018 	add.w	r0, r5, #24
 8009746:	f002 fa5b 	bl	800bc00 <chThdSuspendTimeoutS>
 800974a:	2300      	movs	r3, #0
 800974c:	f383 8811 	msr	BASEPRI, r3
      if (msg != MSG_OK) {
 8009750:	b138      	cbz	r0, 8009762 <chPipeWriteTimeout+0x52>
 8009752:	e008      	b.n	8009766 <chPipeWriteTimeout+0x56>
      n  -= done;
 8009754:	1a24      	subs	r4, r4, r0
      bp += done;
 8009756:	4406      	add	r6, r0
      chThdResume(&pp->rtr, MSG_OK);
 8009758:	2100      	movs	r1, #0
 800975a:	f105 001c 	add.w	r0, r5, #28
 800975e:	f001 fff7 	bl	800b750 <chThdResume>
  while (n > 0U) {
 8009762:	2c00      	cmp	r4, #0
 8009764:	d1e3      	bne.n	800972e <chPipeWriteTimeout+0x1e>
  PW_UNLOCK(pp);
 8009766:	4648      	mov	r0, r9
 8009768:	f001 ff32 	bl	800b5d0 <chMtxUnlock>
  return max - n;
 800976c:	ebc4 0008 	rsb	r0, r4, r8
 8009770:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return (size_t)0;
 8009774:	2000      	movs	r0, #0
}
 8009776:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800977a:	bf00      	nop
 800977c:	0000      	movs	r0, r0
	...

08009780 <chPipeReset>:
void chPipeReset(pipe_t *pp) {
 8009780:	b570      	push	{r4, r5, r6, lr}
 8009782:	4604      	mov	r4, r0
  PC_LOCK(pp);
 8009784:	f100 0520 	add.w	r5, r0, #32
 8009788:	4628      	mov	r0, r5
 800978a:	f002 f8e1 	bl	800b950 <chMtxLock>
  pp->wrptr = pp->buffer;
 800978e:	6823      	ldr	r3, [r4, #0]
 8009790:	60a3      	str	r3, [r4, #8]
  pp->rdptr = pp->buffer;
 8009792:	60e3      	str	r3, [r4, #12]
  pp->cnt   = (size_t)0;
 8009794:	2600      	movs	r6, #0
 8009796:	6126      	str	r6, [r4, #16]
  pp->reset = true;
 8009798:	2301      	movs	r3, #1
 800979a:	7523      	strb	r3, [r4, #20]
 800979c:	2320      	movs	r3, #32
 800979e:	f383 8811 	msr	BASEPRI, r3
  chThdResumeI(&pp->wtr, MSG_RESET);
 80097a2:	f06f 0101 	mvn.w	r1, #1
 80097a6:	f104 0018 	add.w	r0, r4, #24
 80097aa:	f001 fdc9 	bl	800b340 <chThdResumeI>
  chThdResumeI(&pp->rtr, MSG_RESET);
 80097ae:	f06f 0101 	mvn.w	r1, #1
 80097b2:	f104 001c 	add.w	r0, r4, #28
 80097b6:	f001 fdc3 	bl	800b340 <chThdResumeI>
  chSchRescheduleS();
 80097ba:	f001 feb1 	bl	800b520 <chSchRescheduleS>
 80097be:	f386 8811 	msr	BASEPRI, r6
  PC_UNLOCK(pp);
 80097c2:	4628      	mov	r0, r5
 80097c4:	f001 ff04 	bl	800b5d0 <chMtxUnlock>
 80097c8:	bd70      	pop	{r4, r5, r6, pc}
 80097ca:	bf00      	nop
 80097cc:	0000      	movs	r0, r0
	...

080097d0 <chPipeObjectInit>:
void chPipeObjectInit(pipe_t *pp, uint8_t *buf, size_t n) {
 80097d0:	b510      	push	{r4, lr}
 80097d2:	4604      	mov	r4, r0
  pp->buffer = buf;
 80097d4:	6001      	str	r1, [r0, #0]
  pp->rdptr  = buf;
 80097d6:	60c1      	str	r1, [r0, #12]
  pp->wrptr  = buf;
 80097d8:	6081      	str	r1, [r0, #8]
  pp->top    = &buf[n];
 80097da:	440a      	add	r2, r1
 80097dc:	6042      	str	r2, [r0, #4]
  pp->cnt    = (size_t)0;
 80097de:	2300      	movs	r3, #0
 80097e0:	6103      	str	r3, [r0, #16]
  pp->reset  = false;
 80097e2:	7503      	strb	r3, [r0, #20]
  pp->wtr    = NULL;
 80097e4:	6183      	str	r3, [r0, #24]
  pp->rtr    = NULL;
 80097e6:	61c3      	str	r3, [r0, #28]
  PC_INIT(pp);
 80097e8:	3020      	adds	r0, #32
 80097ea:	f001 fd29 	bl	800b240 <chMtxObjectInit>
  PW_INIT(pp);
 80097ee:	f104 0030 	add.w	r0, r4, #48	; 0x30
 80097f2:	f001 fd25 	bl	800b240 <chMtxObjectInit>
  PR_INIT(pp);
 80097f6:	f104 0040 	add.w	r0, r4, #64	; 0x40
 80097fa:	f001 fd21 	bl	800b240 <chMtxObjectInit>
 80097fe:	bd10      	pop	{r4, pc}

08009800 <chGuardedPoolFree>:
 * @param[in] gmp       pointer to a @p guarded_memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chGuardedPoolFree(guarded_memory_pool_t *gmp, void *objp) {
 8009800:	b510      	push	{r4, lr}
 8009802:	4604      	mov	r4, r0
 8009804:	2320      	movs	r3, #32
 8009806:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {

  chPoolFreeI(&gmp->pool, objp);
 800980a:	300c      	adds	r0, #12
 800980c:	f7ff fdb0 	bl	8009370 <chPoolFreeI>
  chSemSignalI(&gmp->sem);
 8009810:	4620      	mov	r0, r4
 8009812:	f001 fd35 	bl	800b280 <chSemSignalI>

  chSysLock();
  chGuardedPoolFreeI(gmp, objp);
  chSchRescheduleS();
 8009816:	f001 fe83 	bl	800b520 <chSchRescheduleS>
 800981a:	2300      	movs	r3, #0
 800981c:	f383 8811 	msr	BASEPRI, r3
 8009820:	bd10      	pop	{r4, pc}
 8009822:	bf00      	nop
	...

08009830 <chGuardedPoolAllocTimeout>:
                                sysinterval_t timeout) {
 8009830:	b508      	push	{r3, lr}
 8009832:	2320      	movs	r3, #32
 8009834:	f383 8811 	msr	BASEPRI, r3
  p = chGuardedPoolAllocTimeoutS(gmp, timeout);
 8009838:	f7ff fe82 	bl	8009540 <chGuardedPoolAllocTimeoutS>
 800983c:	2300      	movs	r3, #0
 800983e:	f383 8811 	msr	BASEPRI, r3
}
 8009842:	bd08      	pop	{r3, pc}
	...

08009850 <chGuardedPoolLoadArray>:
void chGuardedPoolLoadArray(guarded_memory_pool_t *gmp, void *p, size_t n) {
 8009850:	b570      	push	{r4, r5, r6, lr}
 8009852:	4606      	mov	r6, r0
 8009854:	460d      	mov	r5, r1
 8009856:	4614      	mov	r4, r2
 8009858:	e006      	b.n	8009868 <chGuardedPoolLoadArray+0x18>
 *
 * @api
 */
static inline void chGuardedPoolAdd(guarded_memory_pool_t *gmp, void *objp) {

  chGuardedPoolFree(gmp, objp);
 800985a:	4629      	mov	r1, r5
 800985c:	4630      	mov	r0, r6
 800985e:	f7ff ffcf 	bl	8009800 <chGuardedPoolFree>
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
 8009862:	6933      	ldr	r3, [r6, #16]
 8009864:	441d      	add	r5, r3
    n--;
 8009866:	3c01      	subs	r4, #1
  while (n != 0U) {
 8009868:	2c00      	cmp	r4, #0
 800986a:	d1f6      	bne.n	800985a <chGuardedPoolLoadArray+0xa>
}
 800986c:	bd70      	pop	{r4, r5, r6, pc}
 800986e:	bf00      	nop

08009870 <chPoolFree>:
void chPoolFree(memory_pool_t *mp, void *objp) {
 8009870:	b508      	push	{r3, lr}
 8009872:	2320      	movs	r3, #32
 8009874:	f383 8811 	msr	BASEPRI, r3
  chPoolFreeI(mp, objp);
 8009878:	f7ff fd7a 	bl	8009370 <chPoolFreeI>
 800987c:	2300      	movs	r3, #0
 800987e:	f383 8811 	msr	BASEPRI, r3
 8009882:	bd08      	pop	{r3, pc}
	...

08009890 <dyn_release_object_pool.lto_priv.139>:
  dep->refs--;
 8009890:	6843      	ldr	r3, [r0, #4]
 8009892:	3b01      	subs	r3, #1
 8009894:	6043      	str	r3, [r0, #4]
  if (dep->refs == (ucnt_t)0) {
 8009896:	b943      	cbnz	r3, 80098aa <dyn_release_object_pool.lto_priv.139+0x1a>
                                    memory_pool_t *mp) {
 8009898:	b510      	push	{r4, lr}
 800989a:	4614      	mov	r4, r2
    dep = dyn_list_unlink(dep, dlp);
 800989c:	f7ff fd58 	bl	8009350 <dyn_list_unlink>
    chPoolFree(mp, (void *)dep);
 80098a0:	4601      	mov	r1, r0
 80098a2:	4620      	mov	r0, r4
 80098a4:	f7ff ffe4 	bl	8009870 <chPoolFree>
 80098a8:	bd10      	pop	{r4, pc}
 80098aa:	4770      	bx	lr
 80098ac:	0000      	movs	r0, r0
	...

080098b0 <chPoolAlloc>:
void *chPoolAlloc(memory_pool_t *mp) {
 80098b0:	b508      	push	{r3, lr}
 80098b2:	2320      	movs	r3, #32
 80098b4:	f383 8811 	msr	BASEPRI, r3
  objp = chPoolAllocI(mp);
 80098b8:	f7ff fd62 	bl	8009380 <chPoolAllocI>
 80098bc:	2300      	movs	r3, #0
 80098be:	f383 8811 	msr	BASEPRI, r3
}
 80098c2:	bd08      	pop	{r3, pc}
	...

080098d0 <dyn_create_object_pool.lto_priv.140>:
                                             memory_pool_t *mp) {
 80098d0:	b570      	push	{r4, r5, r6, lr}
 80098d2:	4606      	mov	r6, r0
 80098d4:	460d      	mov	r5, r1
 80098d6:	4614      	mov	r4, r2
  dep = dyn_list_find(name, dlp);
 80098d8:	f7ff fd9a 	bl	8009410 <dyn_list_find>
  if (dep != NULL) {
 80098dc:	b980      	cbnz	r0, 8009900 <dyn_create_object_pool.lto_priv.140+0x30>
  dep = (dyn_element_t *)chPoolAlloc(mp);
 80098de:	4620      	mov	r0, r4
 80098e0:	f7ff ffe6 	bl	80098b0 <chPoolAlloc>
  if (dep == NULL) {
 80098e4:	4604      	mov	r4, r0
 80098e6:	b168      	cbz	r0, 8009904 <dyn_create_object_pool.lto_priv.140+0x34>
  strncpy(dep->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH);
 80098e8:	2208      	movs	r2, #8
 80098ea:	4631      	mov	r1, r6
 80098ec:	4410      	add	r0, r2
 80098ee:	f7f8 fcb5 	bl	800225c <strncpy>
  dep->refs = (ucnt_t)1;
 80098f2:	2301      	movs	r3, #1
 80098f4:	6063      	str	r3, [r4, #4]
  dep->next = dlp->next;
 80098f6:	682b      	ldr	r3, [r5, #0]
 80098f8:	6023      	str	r3, [r4, #0]
  dlp->next = (dyn_element_t *)dep;
 80098fa:	602c      	str	r4, [r5, #0]
  return dep;
 80098fc:	4620      	mov	r0, r4
 80098fe:	bd70      	pop	{r4, r5, r6, pc}
    return NULL;
 8009900:	2000      	movs	r0, #0
 8009902:	bd70      	pop	{r4, r5, r6, pc}
    return NULL;
 8009904:	2000      	movs	r0, #0
}
 8009906:	bd70      	pop	{r4, r5, r6, pc}
	...

08009910 <chPoolLoadArray>:
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {
 8009910:	b570      	push	{r4, r5, r6, lr}
 8009912:	4606      	mov	r6, r0
 8009914:	460d      	mov	r5, r1
 8009916:	4614      	mov	r4, r2
 8009918:	e006      	b.n	8009928 <chPoolLoadArray+0x18>
  chPoolFree(mp, objp);
 800991a:	4629      	mov	r1, r5
 800991c:	4630      	mov	r0, r6
 800991e:	f7ff ffa7 	bl	8009870 <chPoolFree>
    p = (void *)(((uint8_t *)p) + mp->object_size);
 8009922:	6873      	ldr	r3, [r6, #4]
 8009924:	441d      	add	r5, r3
    n--;
 8009926:	3c01      	subs	r4, #1
  while (n != 0U) {
 8009928:	2c00      	cmp	r4, #0
 800992a:	d1f6      	bne.n	800991a <chPoolLoadArray+0xa>
}
 800992c:	bd70      	pop	{r4, r5, r6, pc}
 800992e:	bf00      	nop

08009930 <chPoolObjectInitAligned>:
                             unsigned align, memgetfunc_t provider) {
 8009930:	b410      	push	{r4}
  mp->next = NULL;
 8009932:	2400      	movs	r4, #0
 8009934:	6004      	str	r4, [r0, #0]
  mp->object_size = size;
 8009936:	6041      	str	r1, [r0, #4]
  mp->align = align;
 8009938:	6082      	str	r2, [r0, #8]
  mp->provider = provider;
 800993a:	60c3      	str	r3, [r0, #12]
}
 800993c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009940:	4770      	bx	lr
 8009942:	bf00      	nop
	...

08009950 <chGuardedPoolObjectInitAligned>:
                                    unsigned align) {
 8009950:	b510      	push	{r4, lr}
 8009952:	4604      	mov	r4, r0
  chPoolObjectInitAligned(&gmp->pool, size, align, NULL);
 8009954:	2300      	movs	r3, #0
 8009956:	300c      	adds	r0, #12
 8009958:	f7ff ffea 	bl	8009930 <chPoolObjectInitAligned>
  chSemObjectInit(&gmp->sem, (cnt_t)0);
 800995c:	2100      	movs	r1, #0
 800995e:	4620      	mov	r0, r4
 8009960:	f001 fc9e 	bl	800b2a0 <chSemObjectInit>
 8009964:	bd10      	pop	{r4, pc}
 8009966:	bf00      	nop
	...

08009970 <chHeapStatus>:
 *                      free free block found space or @p NULL
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
 8009970:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009972:	460f      	mov	r7, r1
 8009974:	4616      	mov	r6, r2
  heap_header_t *qp;
  size_t n, tpages, lpages;

  if (heapp == NULL) {
 8009976:	4604      	mov	r4, r0
 8009978:	b900      	cbnz	r0, 800997c <chHeapStatus+0xc>
    heapp = &default_heap;
 800997a:	4c0f      	ldr	r4, [pc, #60]	; (80099b8 <chHeapStatus+0x48>)
  }

  H_LOCK(heapp);
 800997c:	f104 050c 	add.w	r5, r4, #12
 8009980:	4628      	mov	r0, r5
 8009982:	f001 ffe5 	bl	800b950 <chMtxLock>
  tpages = 0U;
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
 8009986:	1d20      	adds	r0, r4, #4
  lpages = 0U;
 8009988:	2100      	movs	r1, #0
  tpages = 0U;
 800998a:	460a      	mov	r2, r1
  n = 0U;
 800998c:	460c      	mov	r4, r1
 800998e:	e005      	b.n	800999c <chHeapStatus+0x2c>
  while (H_NEXT(qp) != NULL) {
    size_t pages = H_PAGES(H_NEXT(qp));
 8009990:	6843      	ldr	r3, [r0, #4]

    /* Updating counters.*/
    n++;
 8009992:	3401      	adds	r4, #1
    tpages += pages;
 8009994:	441a      	add	r2, r3
    if (pages > lpages) {
 8009996:	4299      	cmp	r1, r3
 8009998:	d200      	bcs.n	800999c <chHeapStatus+0x2c>
      lpages = pages;
 800999a:	4619      	mov	r1, r3
  while (H_NEXT(qp) != NULL) {
 800999c:	6800      	ldr	r0, [r0, #0]
 800999e:	2800      	cmp	r0, #0
 80099a0:	d1f6      	bne.n	8009990 <chHeapStatus+0x20>

    qp = H_NEXT(qp);
  }

  /* Writing out fragmented free memory.*/
  if (totalp != NULL) {
 80099a2:	b10f      	cbz	r7, 80099a8 <chHeapStatus+0x38>
    *totalp = tpages * CH_HEAP_ALIGNMENT;
 80099a4:	00d2      	lsls	r2, r2, #3
 80099a6:	603a      	str	r2, [r7, #0]
  }

  /* Writing out unfragmented free memory.*/
  if (largestp != NULL) {
 80099a8:	b10e      	cbz	r6, 80099ae <chHeapStatus+0x3e>
    *largestp = lpages * CH_HEAP_ALIGNMENT;
 80099aa:	00c9      	lsls	r1, r1, #3
 80099ac:	6031      	str	r1, [r6, #0]
  }
  H_UNLOCK(heapp);
 80099ae:	4628      	mov	r0, r5
 80099b0:	f001 fe0e 	bl	800b5d0 <chMtxUnlock>

  return n;
}
 80099b4:	4620      	mov	r0, r4
 80099b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80099b8:	20003194 	.word	0x20003194
 80099bc:	00000000 	.word	0x00000000

080099c0 <chHeapFree>:
void chHeapFree(void *p) {
 80099c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80099c2:	4606      	mov	r6, r0
  hp = (heap_header_t *)p - 1U;
 80099c4:	f1a0 0408 	sub.w	r4, r0, #8
  heapp = H_HEAP(hp);
 80099c8:	f850 7c08 	ldr.w	r7, [r0, #-8]
  qp = &heapp->header;
 80099cc:	1d3d      	adds	r5, r7, #4
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 80099ce:	f850 3c04 	ldr.w	r3, [r0, #-4]
 80099d2:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 80099d4:	08db      	lsrs	r3, r3, #3
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 80099d6:	f840 3c04 	str.w	r3, [r0, #-4]
  H_LOCK(heapp);
 80099da:	370c      	adds	r7, #12
 80099dc:	4638      	mov	r0, r7
 80099de:	f001 ffb7 	bl	800b950 <chMtxLock>
  qp = &heapp->header;
 80099e2:	462b      	mov	r3, r5
    if (((qp == &heapp->header) || (hp > qp)) &&
 80099e4:	42ab      	cmp	r3, r5
 80099e6:	d001      	beq.n	80099ec <chHeapFree+0x2c>
 80099e8:	42a3      	cmp	r3, r4
 80099ea:	d226      	bcs.n	8009a3a <chHeapFree+0x7a>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 80099ec:	681a      	ldr	r2, [r3, #0]
    if (((qp == &heapp->header) || (hp > qp)) &&
 80099ee:	b10a      	cbz	r2, 80099f4 <chHeapFree+0x34>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 80099f0:	4294      	cmp	r4, r2
 80099f2:	d222      	bcs.n	8009a3a <chHeapFree+0x7a>
      H_NEXT(hp) = H_NEXT(qp);
 80099f4:	f846 2c08 	str.w	r2, [r6, #-8]
      H_NEXT(qp) = hp;
 80099f8:	601c      	str	r4, [r3, #0]
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 80099fa:	f856 0c04 	ldr.w	r0, [r6, #-4]
 80099fe:	1c42      	adds	r2, r0, #1
 8009a00:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 8009a04:	f856 1c08 	ldr.w	r1, [r6, #-8]
 8009a08:	428a      	cmp	r2, r1
 8009a0a:	d107      	bne.n	8009a1c <chHeapFree+0x5c>
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8009a0c:	684a      	ldr	r2, [r1, #4]
 8009a0e:	4402      	add	r2, r0
 8009a10:	3201      	adds	r2, #1
 8009a12:	f846 2c04 	str.w	r2, [r6, #-4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8009a16:	680a      	ldr	r2, [r1, #0]
 8009a18:	f846 2c08 	str.w	r2, [r6, #-8]
      if ((H_LIMIT(qp) == hp)) {
 8009a1c:	6859      	ldr	r1, [r3, #4]
 8009a1e:	1c4a      	adds	r2, r1, #1
 8009a20:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8009a24:	4294      	cmp	r4, r2
 8009a26:	d10a      	bne.n	8009a3e <chHeapFree+0x7e>
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8009a28:	f856 2c04 	ldr.w	r2, [r6, #-4]
 8009a2c:	440a      	add	r2, r1
 8009a2e:	3201      	adds	r2, #1
 8009a30:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 8009a32:	f856 2c08 	ldr.w	r2, [r6, #-8]
 8009a36:	601a      	str	r2, [r3, #0]
 8009a38:	e001      	b.n	8009a3e <chHeapFree+0x7e>
    qp = H_NEXT(qp);
 8009a3a:	681b      	ldr	r3, [r3, #0]
 8009a3c:	e7d2      	b.n	80099e4 <chHeapFree+0x24>
  H_UNLOCK(heapp);
 8009a3e:	4638      	mov	r0, r7
 8009a40:	f001 fdc6 	bl	800b5d0 <chMtxUnlock>
 8009a44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009a46:	bf00      	nop
	...

08009a50 <dyn_release_object_heap.lto_priv.136>:
                                    dyn_list_t *dlp) {
 8009a50:	b508      	push	{r3, lr}
  dep->refs--;
 8009a52:	6843      	ldr	r3, [r0, #4]
 8009a54:	3b01      	subs	r3, #1
 8009a56:	6043      	str	r3, [r0, #4]
  if (dep->refs == (ucnt_t)0) {
 8009a58:	b91b      	cbnz	r3, 8009a62 <dyn_release_object_heap.lto_priv.136+0x12>
    dep = dyn_list_unlink(dep, dlp);
 8009a5a:	f7ff fc79 	bl	8009350 <dyn_list_unlink>
    chHeapFree((void *)dep);
 8009a5e:	f7ff ffaf 	bl	80099c0 <chHeapFree>
 8009a62:	bd08      	pop	{r3, pc}
	...

08009a70 <chHeapAllocAligned>:
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
 8009a70:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009a74:	4688      	mov	r8, r1
 8009a76:	4614      	mov	r4, r2
  if (heapp == NULL) {
 8009a78:	4606      	mov	r6, r0
 8009a7a:	b900      	cbnz	r0, 8009a7e <chHeapAllocAligned+0xe>
    heapp = &default_heap;
 8009a7c:	4e3a      	ldr	r6, [pc, #232]	; (8009b68 <chHeapAllocAligned+0xf8>)
  if (align < CH_HEAP_ALIGNMENT) {
 8009a7e:	2c07      	cmp	r4, #7
 8009a80:	d800      	bhi.n	8009a84 <chHeapAllocAligned+0x14>
    align = CH_HEAP_ALIGNMENT;
 8009a82:	2408      	movs	r4, #8
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8009a84:	f108 0507 	add.w	r5, r8, #7
 8009a88:	08ed      	lsrs	r5, r5, #3
  H_LOCK(heapp);
 8009a8a:	f106 070c 	add.w	r7, r6, #12
 8009a8e:	4638      	mov	r0, r7
 8009a90:	f001 ff5e 	bl	800b950 <chMtxLock>
  qp = &heapp->header;
 8009a94:	f106 0e04 	add.w	lr, r6, #4
 8009a98:	e04a      	b.n	8009b30 <chHeapAllocAligned+0xc0>
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8009a9a:	f101 0c08 	add.w	ip, r1, #8
 8009a9e:	eb0c 0304 	add.w	r3, ip, r4
 8009aa2:	3b01      	subs	r3, #1
 8009aa4:	4262      	negs	r2, r4
 8009aa6:	4013      	ands	r3, r2
 8009aa8:	3b08      	subs	r3, #8
 8009aaa:	4699      	mov	r9, r3
    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8009aac:	6848      	ldr	r0, [r1, #4]
 8009aae:	1c42      	adds	r2, r0, #1
 8009ab0:	00d2      	lsls	r2, r2, #3
 8009ab2:	eb01 0a02 	add.w	sl, r1, r2
 8009ab6:	4553      	cmp	r3, sl
 8009ab8:	d239      	bcs.n	8009b2e <chHeapAllocAligned+0xbe>
 8009aba:	1acb      	subs	r3, r1, r3
 8009abc:	3a08      	subs	r2, #8
 8009abe:	4413      	add	r3, r2
 8009ac0:	10db      	asrs	r3, r3, #3
 8009ac2:	429d      	cmp	r5, r3
 8009ac4:	d833      	bhi.n	8009b2e <chHeapAllocAligned+0xbe>
      if (ahp > hp) {
 8009ac6:	4549      	cmp	r1, r9
 8009ac8:	d210      	bcs.n	8009aec <chHeapAllocAligned+0x7c>
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 8009aca:	ebcc 0209 	rsb	r2, ip, r9
 8009ace:	10d2      	asrs	r2, r2, #3
 8009ad0:	604a      	str	r2, [r1, #4]
        if (bpages > pages) {
 8009ad2:	429d      	cmp	r5, r3
 8009ad4:	d223      	bcs.n	8009b1e <chHeapAllocAligned+0xae>
          fp = H_BLOCK(ahp) + pages;
 8009ad6:	1c68      	adds	r0, r5, #1
 8009ad8:	eb09 02c0 	add.w	r2, r9, r0, lsl #3
          H_PAGES(fp) = (bpages - pages) - 1U;
 8009adc:	1b5b      	subs	r3, r3, r5
 8009ade:	3b01      	subs	r3, #1
 8009ae0:	6053      	str	r3, [r2, #4]
          H_NEXT(fp) = H_NEXT(hp);
 8009ae2:	680b      	ldr	r3, [r1, #0]
 8009ae4:	f849 3030 	str.w	r3, [r9, r0, lsl #3]
          H_NEXT(hp) = fp;
 8009ae8:	600a      	str	r2, [r1, #0]
 8009aea:	e018      	b.n	8009b1e <chHeapAllocAligned+0xae>
        if (H_PAGES(hp) == pages) {
 8009aec:	4285      	cmp	r5, r0
 8009aee:	d104      	bne.n	8009afa <chHeapAllocAligned+0x8a>
          H_NEXT(qp) = H_NEXT(hp);
 8009af0:	680b      	ldr	r3, [r1, #0]
 8009af2:	f8ce 3000 	str.w	r3, [lr]
    hp = H_NEXT(qp);
 8009af6:	4689      	mov	r9, r1
 8009af8:	e011      	b.n	8009b1e <chHeapAllocAligned+0xae>
          fp = H_BLOCK(hp) + pages;
 8009afa:	3501      	adds	r5, #1
 8009afc:	eb01 02c5 	add.w	r2, r1, r5, lsl #3
          H_NEXT(fp) = H_NEXT(hp);
 8009b00:	680b      	ldr	r3, [r1, #0]
 8009b02:	f841 3035 	str.w	r3, [r1, r5, lsl #3]
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 8009b06:	684b      	ldr	r3, [r1, #4]
 8009b08:	3301      	adds	r3, #1
 8009b0a:	00db      	lsls	r3, r3, #3
 8009b0c:	3b08      	subs	r3, #8
 8009b0e:	ebc2 0b01 	rsb	fp, r2, r1
 8009b12:	445b      	add	r3, fp
 8009b14:	10db      	asrs	r3, r3, #3
 8009b16:	6053      	str	r3, [r2, #4]
          H_NEXT(qp) = fp;
 8009b18:	f8ce 2000 	str.w	r2, [lr]
    hp = H_NEXT(qp);
 8009b1c:	4689      	mov	r9, r1
      H_SIZE(hp) = size;
 8009b1e:	f8c9 8004 	str.w	r8, [r9, #4]
      H_HEAP(hp) = heapp;
 8009b22:	f849 6b08 	str.w	r6, [r9], #8
      H_UNLOCK(heapp);
 8009b26:	4638      	mov	r0, r7
 8009b28:	f001 fd52 	bl	800b5d0 <chMtxUnlock>
 8009b2c:	e019      	b.n	8009b62 <chHeapAllocAligned+0xf2>
 8009b2e:	468e      	mov	lr, r1
  while (H_NEXT(qp) != NULL) {
 8009b30:	f8de 1000 	ldr.w	r1, [lr]
 8009b34:	2900      	cmp	r1, #0
 8009b36:	d1b0      	bne.n	8009a9a <chHeapAllocAligned+0x2a>
  H_UNLOCK(heapp);
 8009b38:	4638      	mov	r0, r7
 8009b3a:	f001 fd49 	bl	800b5d0 <chMtxUnlock>
  if (heapp->provider != NULL) {
 8009b3e:	6833      	ldr	r3, [r6, #0]
 8009b40:	b153      	cbz	r3, 8009b58 <chHeapAllocAligned+0xe8>
    ahp = heapp->provider(pages * CH_HEAP_ALIGNMENT,
 8009b42:	2208      	movs	r2, #8
 8009b44:	4621      	mov	r1, r4
 8009b46:	00e8      	lsls	r0, r5, #3
 8009b48:	4798      	blx	r3
    if (ahp != NULL) {
 8009b4a:	4681      	mov	r9, r0
 8009b4c:	b138      	cbz	r0, 8009b5e <chHeapAllocAligned+0xee>
      H_HEAP(hp) = heapp;
 8009b4e:	f840 6c08 	str.w	r6, [r0, #-8]
      H_SIZE(hp) = size;
 8009b52:	f840 8c04 	str.w	r8, [r0, #-4]
 8009b56:	e004      	b.n	8009b62 <chHeapAllocAligned+0xf2>
  return NULL;
 8009b58:	f04f 0900 	mov.w	r9, #0
 8009b5c:	e001      	b.n	8009b62 <chHeapAllocAligned+0xf2>
 8009b5e:	f04f 0900 	mov.w	r9, #0
}
 8009b62:	4648      	mov	r0, r9
 8009b64:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009b68:	20003194 	.word	0x20003194
 8009b6c:	00000000 	.word	0x00000000

08009b70 <dyn_create_object_heap.lto_priv.138>:
                                             size_t size) {
 8009b70:	b570      	push	{r4, r5, r6, lr}
 8009b72:	4606      	mov	r6, r0
 8009b74:	460d      	mov	r5, r1
 8009b76:	4614      	mov	r4, r2
  dep = dyn_list_find(name, dlp);
 8009b78:	f7ff fc4a 	bl	8009410 <dyn_list_find>
  if (dep != NULL) {
 8009b7c:	b988      	cbnz	r0, 8009ba2 <dyn_create_object_heap.lto_priv.138+0x32>
 *
 * @api
 */
static inline void *chHeapAlloc(memory_heap_t *heapp, size_t size) {

  return chHeapAllocAligned(heapp, size, CH_HEAP_ALIGNMENT);
 8009b7e:	2208      	movs	r2, #8
 8009b80:	4621      	mov	r1, r4
 8009b82:	f7ff ff75 	bl	8009a70 <chHeapAllocAligned>
  if (dep == NULL) {
 8009b86:	4604      	mov	r4, r0
 8009b88:	b168      	cbz	r0, 8009ba6 <dyn_create_object_heap.lto_priv.138+0x36>
  strncpy(dep->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH);
 8009b8a:	2208      	movs	r2, #8
 8009b8c:	4631      	mov	r1, r6
 8009b8e:	4410      	add	r0, r2
 8009b90:	f7f8 fb64 	bl	800225c <strncpy>
  dep->refs = (ucnt_t)1;
 8009b94:	2301      	movs	r3, #1
 8009b96:	6063      	str	r3, [r4, #4]
  dep->next = dlp->next;
 8009b98:	682b      	ldr	r3, [r5, #0]
 8009b9a:	6023      	str	r3, [r4, #0]
  dlp->next = dep;
 8009b9c:	602c      	str	r4, [r5, #0]
  return dep;
 8009b9e:	4620      	mov	r0, r4
 8009ba0:	bd70      	pop	{r4, r5, r6, pc}
    return NULL;
 8009ba2:	2000      	movs	r0, #0
 8009ba4:	bd70      	pop	{r4, r5, r6, pc}
    return NULL;
 8009ba6:	2000      	movs	r0, #0
}
 8009ba8:	bd70      	pop	{r4, r5, r6, pc}
 8009baa:	bf00      	nop
 8009bac:	0000      	movs	r0, r0
	...

08009bb0 <chHeapObjectInit>:
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
 8009bb0:	b508      	push	{r3, lr}
  heap_header_t *hp = (heap_header_t *)MEM_ALIGN_NEXT(buf, CH_HEAP_ALIGNMENT);
 8009bb2:	1dcb      	adds	r3, r1, #7
 8009bb4:	f023 0307 	bic.w	r3, r3, #7
  size -= (size_t)((uint8_t *)hp - (uint8_t *)buf);
 8009bb8:	1a59      	subs	r1, r3, r1
 8009bba:	1a51      	subs	r1, r2, r1
  heapp->provider = NULL;
 8009bbc:	2200      	movs	r2, #0
 8009bbe:	6002      	str	r2, [r0, #0]
  H_NEXT(&heapp->header) = hp;
 8009bc0:	6043      	str	r3, [r0, #4]
  H_PAGES(&heapp->header) = 0;
 8009bc2:	6082      	str	r2, [r0, #8]
  H_NEXT(hp) = NULL;
 8009bc4:	601a      	str	r2, [r3, #0]
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 8009bc6:	3908      	subs	r1, #8
 8009bc8:	08c9      	lsrs	r1, r1, #3
 8009bca:	6059      	str	r1, [r3, #4]
  chMtxObjectInit(&heapp->mtx);
 8009bcc:	300c      	adds	r0, #12
 8009bce:	f001 fb37 	bl	800b240 <chMtxObjectInit>
 8009bd2:	bd08      	pop	{r3, pc}
	...

08009be0 <_heap_init>:
void _heap_init(void) {
 8009be0:	b508      	push	{r3, lr}
  default_heap.provider = chCoreAllocAlignedWithOffset;
 8009be2:	4805      	ldr	r0, [pc, #20]	; (8009bf8 <_heap_init+0x18>)
 8009be4:	4b05      	ldr	r3, [pc, #20]	; (8009bfc <_heap_init+0x1c>)
 8009be6:	6003      	str	r3, [r0, #0]
  H_NEXT(&default_heap.header) = NULL;
 8009be8:	2300      	movs	r3, #0
 8009bea:	6043      	str	r3, [r0, #4]
  H_PAGES(&default_heap.header) = 0;
 8009bec:	6083      	str	r3, [r0, #8]
  chMtxObjectInit(&default_heap.mtx);
 8009bee:	300c      	adds	r0, #12
 8009bf0:	f001 fb26 	bl	800b240 <chMtxObjectInit>
 8009bf4:	bd08      	pop	{r3, pc}
 8009bf6:	bf00      	nop
 8009bf8:	20003194 	.word	0x20003194
 8009bfc:	080093f1 	.word	0x080093f1

08009c00 <chCoreGetStatusX>:
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(ch_memcore.endmem - ch_memcore.nextmem);
 8009c00:	4b02      	ldr	r3, [pc, #8]	; (8009c0c <chCoreGetStatusX+0xc>)
 8009c02:	6858      	ldr	r0, [r3, #4]
 8009c04:	681b      	ldr	r3, [r3, #0]
  /*lint -restore*/
}
 8009c06:	1ac0      	subs	r0, r0, r3
 8009c08:	4770      	bx	lr
 8009c0a:	bf00      	nop
 8009c0c:	2000318c 	.word	0x2000318c

08009c10 <_core_init>:
  ch_memcore.nextmem = __heap_base__;
 8009c10:	4b02      	ldr	r3, [pc, #8]	; (8009c1c <_core_init+0xc>)
 8009c12:	4a03      	ldr	r2, [pc, #12]	; (8009c20 <_core_init+0x10>)
 8009c14:	601a      	str	r2, [r3, #0]
  ch_memcore.endmem  = __heap_end__;
 8009c16:	4a03      	ldr	r2, [pc, #12]	; (8009c24 <_core_init+0x14>)
 8009c18:	605a      	str	r2, [r3, #4]
 8009c1a:	4770      	bx	lr
 8009c1c:	2000318c 	.word	0x2000318c
 8009c20:	20003e50 	.word	0x20003e50
 8009c24:	20020000 	.word	0x20020000
	...

08009c30 <chMBFetchI>:
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 8009c30:	b508      	push	{r3, lr}

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 8009c32:	7d03      	ldrb	r3, [r0, #20]
 8009c34:	b9ab      	cbnz	r3, 8009c62 <chMBFetchI+0x32>
 8009c36:	6903      	ldr	r3, [r0, #16]
    return MSG_RESET;
  }

  /* Is there a message in queue? if so then fetch.*/
  if (chMBGetUsedCountI(mbp) > (size_t)0) {
 8009c38:	b1b3      	cbz	r3, 8009c68 <chMBFetchI+0x38>
    *msgp = *mbp->rdptr++;
 8009c3a:	68c3      	ldr	r3, [r0, #12]
 8009c3c:	1d1a      	adds	r2, r3, #4
 8009c3e:	60c2      	str	r2, [r0, #12]
 8009c40:	681b      	ldr	r3, [r3, #0]
 8009c42:	600b      	str	r3, [r1, #0]
    if (mbp->rdptr >= mbp->top) {
 8009c44:	68c2      	ldr	r2, [r0, #12]
 8009c46:	6843      	ldr	r3, [r0, #4]
 8009c48:	429a      	cmp	r2, r3
 8009c4a:	d301      	bcc.n	8009c50 <chMBFetchI+0x20>
      mbp->rdptr = mbp->buffer;
 8009c4c:	6803      	ldr	r3, [r0, #0]
 8009c4e:	60c3      	str	r3, [r0, #12]
    }
    mbp->cnt--;
 8009c50:	6903      	ldr	r3, [r0, #16]
 8009c52:	3b01      	subs	r3, #1
 8009c54:	6103      	str	r3, [r0, #16]

    /* If there is a writer waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qw, MSG_OK);
 8009c56:	2100      	movs	r1, #0
 8009c58:	3018      	adds	r0, #24
 8009c5a:	f001 fb61 	bl	800b320 <chThdDequeueNextI>

    return MSG_OK;
 8009c5e:	2000      	movs	r0, #0
 8009c60:	bd08      	pop	{r3, pc}
    return MSG_RESET;
 8009c62:	f06f 0001 	mvn.w	r0, #1
 8009c66:	bd08      	pop	{r3, pc}
  }

  /* No message, immediate timeout.*/
  return MSG_TIMEOUT;
 8009c68:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8009c6c:	bd08      	pop	{r3, pc}
 8009c6e:	bf00      	nop

08009c70 <chMBFetchTimeout>:
msg_t chMBFetchTimeout(mailbox_t *mbp, msg_t *msgp, sysinterval_t timeout) {
 8009c70:	b508      	push	{r3, lr}
 8009c72:	2320      	movs	r3, #32
 8009c74:	f383 8811 	msr	BASEPRI, r3
  rdymsg = chMBFetchTimeoutS(mbp, msgp, timeout);
 8009c78:	f7ff fc72 	bl	8009560 <chMBFetchTimeoutS>
 8009c7c:	2300      	movs	r3, #0
 8009c7e:	f383 8811 	msr	BASEPRI, r3
}
 8009c82:	bd08      	pop	{r3, pc}
	...

08009c90 <chMBPostAheadI>:
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 8009c90:	b538      	push	{r3, r4, r5, lr}
  if (mbp->reset) {
 8009c92:	7d03      	ldrb	r3, [r0, #20]
 8009c94:	b9c3      	cbnz	r3, 8009cc8 <chMBPostAheadI+0x38>
  return (size_t)(mbp->top - mbp->buffer);
 8009c96:	6842      	ldr	r2, [r0, #4]
 8009c98:	6804      	ldr	r4, [r0, #0]
 8009c9a:	1b15      	subs	r5, r2, r4
  return mbp->cnt;
 8009c9c:	6903      	ldr	r3, [r0, #16]
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
 8009c9e:	ebb3 0fa5 	cmp.w	r3, r5, asr #2
 8009ca2:	d014      	beq.n	8009cce <chMBPostAheadI+0x3e>
    if (--mbp->rdptr < mbp->buffer) {
 8009ca4:	68c3      	ldr	r3, [r0, #12]
 8009ca6:	3b04      	subs	r3, #4
 8009ca8:	60c3      	str	r3, [r0, #12]
 8009caa:	42a3      	cmp	r3, r4
 8009cac:	d201      	bcs.n	8009cb2 <chMBPostAheadI+0x22>
      mbp->rdptr = mbp->top - 1;
 8009cae:	3a04      	subs	r2, #4
 8009cb0:	60c2      	str	r2, [r0, #12]
    *mbp->rdptr = msg;
 8009cb2:	68c3      	ldr	r3, [r0, #12]
 8009cb4:	6019      	str	r1, [r3, #0]
    mbp->cnt++;
 8009cb6:	6903      	ldr	r3, [r0, #16]
 8009cb8:	3301      	adds	r3, #1
 8009cba:	6103      	str	r3, [r0, #16]
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8009cbc:	2100      	movs	r1, #0
 8009cbe:	3020      	adds	r0, #32
 8009cc0:	f001 fb2e 	bl	800b320 <chThdDequeueNextI>
    return MSG_OK;
 8009cc4:	2000      	movs	r0, #0
 8009cc6:	bd38      	pop	{r3, r4, r5, pc}
    return MSG_RESET;
 8009cc8:	f06f 0001 	mvn.w	r0, #1
 8009ccc:	bd38      	pop	{r3, r4, r5, pc}
  return MSG_TIMEOUT;
 8009cce:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8009cd2:	bd38      	pop	{r3, r4, r5, pc}
	...

08009ce0 <chMBPostAheadTimeout>:
msg_t chMBPostAheadTimeout(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
 8009ce0:	b508      	push	{r3, lr}
 8009ce2:	2320      	movs	r3, #32
 8009ce4:	f383 8811 	msr	BASEPRI, r3
  rdymsg = chMBPostAheadTimeoutS(mbp, msg, timeout);
 8009ce8:	f7ff fc6a 	bl	80095c0 <chMBPostAheadTimeoutS>
 8009cec:	2300      	movs	r3, #0
 8009cee:	f383 8811 	msr	BASEPRI, r3
}
 8009cf2:	bd08      	pop	{r3, pc}
	...

08009d00 <chMBPostI>:
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 8009d00:	b508      	push	{r3, lr}
  if (mbp->reset) {
 8009d02:	7d03      	ldrb	r3, [r0, #20]
 8009d04:	b9cb      	cbnz	r3, 8009d3a <chMBPostI+0x3a>
  return (size_t)(mbp->top - mbp->buffer);
 8009d06:	6843      	ldr	r3, [r0, #4]
 8009d08:	6802      	ldr	r2, [r0, #0]
 8009d0a:	1a9b      	subs	r3, r3, r2
  return mbp->cnt;
 8009d0c:	6902      	ldr	r2, [r0, #16]
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
 8009d0e:	ebb2 0fa3 	cmp.w	r2, r3, asr #2
 8009d12:	d015      	beq.n	8009d40 <chMBPostI+0x40>
    *mbp->wrptr++ = msg;
 8009d14:	6883      	ldr	r3, [r0, #8]
 8009d16:	1d1a      	adds	r2, r3, #4
 8009d18:	6082      	str	r2, [r0, #8]
 8009d1a:	6019      	str	r1, [r3, #0]
    if (mbp->wrptr >= mbp->top) {
 8009d1c:	6882      	ldr	r2, [r0, #8]
 8009d1e:	6843      	ldr	r3, [r0, #4]
 8009d20:	429a      	cmp	r2, r3
 8009d22:	d301      	bcc.n	8009d28 <chMBPostI+0x28>
      mbp->wrptr = mbp->buffer;
 8009d24:	6803      	ldr	r3, [r0, #0]
 8009d26:	6083      	str	r3, [r0, #8]
    mbp->cnt++;
 8009d28:	6903      	ldr	r3, [r0, #16]
 8009d2a:	3301      	adds	r3, #1
 8009d2c:	6103      	str	r3, [r0, #16]
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8009d2e:	2100      	movs	r1, #0
 8009d30:	3020      	adds	r0, #32
 8009d32:	f001 faf5 	bl	800b320 <chThdDequeueNextI>
    return MSG_OK;
 8009d36:	2000      	movs	r0, #0
 8009d38:	bd08      	pop	{r3, pc}
    return MSG_RESET;
 8009d3a:	f06f 0001 	mvn.w	r0, #1
 8009d3e:	bd08      	pop	{r3, pc}
  return MSG_TIMEOUT;
 8009d40:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8009d44:	bd08      	pop	{r3, pc}
 8009d46:	bf00      	nop
	...

08009d50 <chMBPostTimeout>:
msg_t chMBPostTimeout(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
 8009d50:	b508      	push	{r3, lr}
 8009d52:	2320      	movs	r3, #32
 8009d54:	f383 8811 	msr	BASEPRI, r3
  rdymsg = chMBPostTimeoutS(mbp, msg, timeout);
 8009d58:	f7ff fc62 	bl	8009620 <chMBPostTimeoutS>
 8009d5c:	2300      	movs	r3, #0
 8009d5e:	f383 8811 	msr	BASEPRI, r3
}
 8009d62:	bd08      	pop	{r3, pc}
	...

08009d70 <chMBResetI>:
void chMBResetI(mailbox_t *mbp) {
 8009d70:	b510      	push	{r4, lr}
 8009d72:	4604      	mov	r4, r0
  mbp->wrptr = mbp->buffer;
 8009d74:	6803      	ldr	r3, [r0, #0]
 8009d76:	6083      	str	r3, [r0, #8]
  mbp->rdptr = mbp->buffer;
 8009d78:	60c3      	str	r3, [r0, #12]
  mbp->cnt   = (size_t)0;
 8009d7a:	2300      	movs	r3, #0
 8009d7c:	6103      	str	r3, [r0, #16]
  mbp->reset = true;
 8009d7e:	2301      	movs	r3, #1
 8009d80:	7503      	strb	r3, [r0, #20]
  chThdDequeueAllI(&mbp->qw, MSG_RESET);
 8009d82:	f06f 0101 	mvn.w	r1, #1
 8009d86:	3018      	adds	r0, #24
 8009d88:	f001 faba 	bl	800b300 <chThdDequeueAllI>
  chThdDequeueAllI(&mbp->qr, MSG_RESET);
 8009d8c:	f06f 0101 	mvn.w	r1, #1
 8009d90:	f104 0020 	add.w	r0, r4, #32
 8009d94:	f001 fab4 	bl	800b300 <chThdDequeueAllI>
 8009d98:	bd10      	pop	{r4, pc}
 8009d9a:	bf00      	nop
 8009d9c:	0000      	movs	r0, r0
	...

08009da0 <chMBReset>:
void chMBReset(mailbox_t *mbp) {
 8009da0:	b508      	push	{r3, lr}
 8009da2:	2320      	movs	r3, #32
 8009da4:	f383 8811 	msr	BASEPRI, r3
  chMBResetI(mbp);
 8009da8:	f7ff ffe2 	bl	8009d70 <chMBResetI>
  chSchRescheduleS();
 8009dac:	f001 fbb8 	bl	800b520 <chSchRescheduleS>
 8009db0:	2300      	movs	r3, #0
 8009db2:	f383 8811 	msr	BASEPRI, r3
 8009db6:	bd08      	pop	{r3, pc}
	...

08009dc0 <chMBObjectInit>:
  mbp->buffer = buf;
 8009dc0:	6001      	str	r1, [r0, #0]
  mbp->rdptr  = buf;
 8009dc2:	60c1      	str	r1, [r0, #12]
  mbp->wrptr  = buf;
 8009dc4:	6081      	str	r1, [r0, #8]
  mbp->top    = &buf[n];
 8009dc6:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 8009dca:	6042      	str	r2, [r0, #4]
  mbp->cnt    = (size_t)0;
 8009dcc:	2300      	movs	r3, #0
 8009dce:	6103      	str	r3, [r0, #16]
  mbp->reset  = false;
 8009dd0:	7503      	strb	r3, [r0, #20]
  chThdQueueObjectInit(&mbp->qw);
 8009dd2:	f100 0318 	add.w	r3, r0, #24
  tqp->next = (thread_t *)tqp;
 8009dd6:	6183      	str	r3, [r0, #24]
  tqp->prev = (thread_t *)tqp;
 8009dd8:	61c3      	str	r3, [r0, #28]
  chThdQueueObjectInit(&mbp->qr);
 8009dda:	f100 0320 	add.w	r3, r0, #32
  tqp->next = (thread_t *)tqp;
 8009dde:	6203      	str	r3, [r0, #32]
  tqp->prev = (thread_t *)tqp;
 8009de0:	6243      	str	r3, [r0, #36]	; 0x24
 8009de2:	4770      	bx	lr
	...

08009df0 <chThdCreateFromMemoryPool>:
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
                                    tprio_t prio, tfunc_t pf, void *arg) {
 8009df0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009df2:	b087      	sub	sp, #28
 8009df4:	4605      	mov	r5, r0
 8009df6:	460f      	mov	r7, r1
 8009df8:	4616      	mov	r6, r2
 8009dfa:	461c      	mov	r4, r3
  thread_t *tp;
  void *wsp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 8009dfc:	f7ff fd58 	bl	80098b0 <chPoolAlloc>
  if (wsp == NULL) {
 8009e00:	b1e0      	cbz	r0, 8009e3c <chThdCreateFromMemoryPool+0x4c>
 8009e02:	4603      	mov	r3, r0
    return NULL;
  }

  thread_descriptor_t td = {
 8009e04:	9700      	str	r7, [sp, #0]
 8009e06:	9001      	str	r0, [sp, #4]
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
 8009e08:	6868      	ldr	r0, [r5, #4]
 8009e0a:	4418      	add	r0, r3
  thread_descriptor_t td = {
 8009e0c:	9002      	str	r0, [sp, #8]
 8009e0e:	9603      	str	r6, [sp, #12]
 8009e10:	9404      	str	r4, [sp, #16]
 8009e12:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8009e14:	9305      	str	r3, [sp, #20]
 8009e16:	2320      	movs	r3, #32
 8009e18:	f383 8811 	msr	BASEPRI, r3
                  (uint8_t *)wsp + mp->object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 8009e1c:	4668      	mov	r0, sp
 8009e1e:	f001 fb37 	bl	800b490 <chThdCreateSuspendedI>
 8009e22:	4604      	mov	r4, r0
  tp->flags = CH_FLAG_MODE_MPOOL;
 8009e24:	2302      	movs	r3, #2
 8009e26:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
  tp->mpool = mp;
 8009e2a:	6405      	str	r5, [r0, #64]	; 0x40
  chSchWakeupS(tp, MSG_OK);
 8009e2c:	2100      	movs	r1, #0
 8009e2e:	f001 fc2f 	bl	800b690 <chSchWakeupS>
 8009e32:	2300      	movs	r3, #0
 8009e34:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
 8009e38:	4620      	mov	r0, r4
 8009e3a:	e000      	b.n	8009e3e <chThdCreateFromMemoryPool+0x4e>
    return NULL;
 8009e3c:	2000      	movs	r0, #0
}
 8009e3e:	b007      	add	sp, #28
 8009e40:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009e42:	bf00      	nop
	...

08009e50 <chThdCreateFromHeap>:
                              tfunc_t pf, void *arg) {
 8009e50:	b570      	push	{r4, r5, r6, lr}
 8009e52:	b086      	sub	sp, #24
 8009e54:	460c      	mov	r4, r1
 8009e56:	4616      	mov	r6, r2
 8009e58:	461d      	mov	r5, r3
  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
 8009e5a:	2208      	movs	r2, #8
 8009e5c:	f7ff fe08 	bl	8009a70 <chHeapAllocAligned>
  if (wsp == NULL) {
 8009e60:	b1d0      	cbz	r0, 8009e98 <chThdCreateFromHeap+0x48>
  thread_descriptor_t td = {
 8009e62:	9600      	str	r6, [sp, #0]
 8009e64:	9001      	str	r0, [sp, #4]
    (stkalign_t *)((uint8_t *)wsp + size),
 8009e66:	4404      	add	r4, r0
  thread_descriptor_t td = {
 8009e68:	9402      	str	r4, [sp, #8]
 8009e6a:	9503      	str	r5, [sp, #12]
 8009e6c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8009e6e:	9304      	str	r3, [sp, #16]
 8009e70:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8009e72:	9305      	str	r3, [sp, #20]
 8009e74:	2320      	movs	r3, #32
 8009e76:	f383 8811 	msr	BASEPRI, r3
  tp = chThdCreateSuspendedI(&td);
 8009e7a:	4668      	mov	r0, sp
 8009e7c:	f001 fb08 	bl	800b490 <chThdCreateSuspendedI>
 8009e80:	4604      	mov	r4, r0
  tp->flags = CH_FLAG_MODE_HEAP;
 8009e82:	2301      	movs	r3, #1
 8009e84:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
  chSchWakeupS(tp, MSG_OK);
 8009e88:	2100      	movs	r1, #0
 8009e8a:	f001 fc01 	bl	800b690 <chSchWakeupS>
 8009e8e:	2300      	movs	r3, #0
 8009e90:	f383 8811 	msr	BASEPRI, r3
  return tp;
 8009e94:	4620      	mov	r0, r4
 8009e96:	e000      	b.n	8009e9a <chThdCreateFromHeap+0x4a>
    return NULL;
 8009e98:	2000      	movs	r0, #0
}
 8009e9a:	b006      	add	sp, #24
 8009e9c:	bd70      	pop	{r4, r5, r6, pc}
 8009e9e:	bf00      	nop

08009ea0 <chMsgRelease>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @api
 */
void chMsgRelease(thread_t *tp, msg_t msg) {
 8009ea0:	b508      	push	{r3, lr}
 8009ea2:	2320      	movs	r3, #32
 8009ea4:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
 8009ea8:	f001 fbf2 	bl	800b690 <chSchWakeupS>
 8009eac:	2300      	movs	r3, #0
 8009eae:	f383 8811 	msr	BASEPRI, r3
 8009eb2:	bd08      	pop	{r3, pc}
	...

08009ec0 <chMsgWait>:
thread_t *chMsgWait(void) {
 8009ec0:	b508      	push	{r3, lr}
 8009ec2:	2320      	movs	r3, #32
 8009ec4:	f383 8811 	msr	BASEPRI, r3
  return (bool)(tp->msgqueue.next != (thread_t *)&tp->msgqueue);
 8009ec8:	4b0b      	ldr	r3, [pc, #44]	; (8009ef8 <chMsgWait+0x38>)
 8009eca:	699b      	ldr	r3, [r3, #24]
 8009ecc:	f853 2f2c 	ldr.w	r2, [r3, #44]!
  if (!chMsgIsPendingI(currp)) {
 8009ed0:	429a      	cmp	r2, r3
 8009ed2:	d102      	bne.n	8009eda <chMsgWait+0x1a>
    chSchGoSleepS(CH_STATE_WTMSG);
 8009ed4:	200e      	movs	r0, #14
 8009ed6:	f001 fc83 	bl	800b7e0 <chSchGoSleepS>
  tp = queue_fifo_remove(&currp->msgqueue);
 8009eda:	4b07      	ldr	r3, [pc, #28]	; (8009ef8 <chMsgWait+0x38>)
 8009edc:	699b      	ldr	r3, [r3, #24]
 8009ede:	f103 012c 	add.w	r1, r3, #44	; 0x2c
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8009ee2:	6ad8      	ldr	r0, [r3, #44]	; 0x2c

  tqp->next             = tp->queue.next;
 8009ee4:	6802      	ldr	r2, [r0, #0]
 8009ee6:	62da      	str	r2, [r3, #44]	; 0x2c
  tqp->next->queue.prev = (thread_t *)tqp;
 8009ee8:	6051      	str	r1, [r2, #4]
  tp->state = CH_STATE_SNDMSG;
 8009eea:	230d      	movs	r3, #13
 8009eec:	f880 3020 	strb.w	r3, [r0, #32]
 8009ef0:	2300      	movs	r3, #0
 8009ef2:	f383 8811 	msr	BASEPRI, r3
}
 8009ef6:	bd08      	pop	{r3, pc}
 8009ef8:	20003aec 	.word	0x20003aec
 8009efc:	00000000 	.word	0x00000000

08009f00 <chMsgSend>:
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 8009f00:	b510      	push	{r4, lr}
  thread_t *ctp = currp;
 8009f02:	4b0d      	ldr	r3, [pc, #52]	; (8009f38 <chMsgSend+0x38>)
 8009f04:	699c      	ldr	r4, [r3, #24]
 8009f06:	2320      	movs	r3, #32
 8009f08:	f383 8811 	msr	BASEPRI, r3
  ctp->u.sentmsg = msg;
 8009f0c:	6261      	str	r1, [r4, #36]	; 0x24
  msg_insert(ctp, &tp->msgqueue);
 8009f0e:	f100 032c 	add.w	r3, r0, #44	; 0x2c
  tp->queue.next             = (thread_t *)tqp;
 8009f12:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = tqp->prev;
 8009f14:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8009f16:	6063      	str	r3, [r4, #4]
  tp->queue.prev->queue.next = tp;
 8009f18:	601c      	str	r4, [r3, #0]
  tqp->prev                  = tp;
 8009f1a:	6304      	str	r4, [r0, #48]	; 0x30
  if (tp->state == CH_STATE_WTMSG) {
 8009f1c:	f890 3020 	ldrb.w	r3, [r0, #32]
 8009f20:	2b0e      	cmp	r3, #14
 8009f22:	d101      	bne.n	8009f28 <chMsgSend+0x28>
    (void) chSchReadyI(tp);
 8009f24:	f7fc fcac 	bl	8006880 <chSchReadyI>
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 8009f28:	200c      	movs	r0, #12
 8009f2a:	f001 fc59 	bl	800b7e0 <chSchGoSleepS>
  msg = ctp->u.rdymsg;
 8009f2e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8009f30:	2300      	movs	r3, #0
 8009f32:	f383 8811 	msr	BASEPRI, r3
}
 8009f36:	bd10      	pop	{r4, pc}
 8009f38:	20003aec 	.word	0x20003aec
 8009f3c:	00000000 	.word	0x00000000

08009f40 <chEvtWaitAllTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, sysinterval_t timeout) {
 8009f40:	b538      	push	{r3, r4, r5, lr}
 8009f42:	4604      	mov	r4, r0
  thread_t *ctp = currp;
 8009f44:	4b10      	ldr	r3, [pc, #64]	; (8009f88 <chEvtWaitAllTimeout+0x48>)
 8009f46:	699d      	ldr	r5, [r3, #24]
 8009f48:	2320      	movs	r3, #32
 8009f4a:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if ((ctp->epending & events) != events) {
 8009f4e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8009f50:	ea30 0303 	bics.w	r3, r0, r3
 8009f54:	d00e      	beq.n	8009f74 <chEvtWaitAllTimeout+0x34>
    if (TIME_IMMEDIATE == timeout) {
 8009f56:	b919      	cbnz	r1, 8009f60 <chEvtWaitAllTimeout+0x20>
 8009f58:	2000      	movs	r0, #0
 8009f5a:	f380 8811 	msr	BASEPRI, r0
 8009f5e:	bd38      	pop	{r3, r4, r5, pc}
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
 8009f60:	6268      	str	r0, [r5, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, timeout) < MSG_OK) {
 8009f62:	200b      	movs	r0, #11
 8009f64:	f001 fdac 	bl	800bac0 <chSchGoSleepTimeoutS>
 8009f68:	2800      	cmp	r0, #0
 8009f6a:	da03      	bge.n	8009f74 <chEvtWaitAllTimeout+0x34>
 8009f6c:	2000      	movs	r0, #0
 8009f6e:	f380 8811 	msr	BASEPRI, r0
 8009f72:	bd38      	pop	{r3, r4, r5, pc}
      chSysUnlock();
      return (eventmask_t)0;
    }
  }
  ctp->epending &= ~events;
 8009f74:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8009f76:	ea23 0304 	bic.w	r3, r3, r4
 8009f7a:	636b      	str	r3, [r5, #52]	; 0x34
 8009f7c:	2300      	movs	r3, #0
 8009f7e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return events;
 8009f82:	4620      	mov	r0, r4
}
 8009f84:	bd38      	pop	{r3, r4, r5, pc}
 8009f86:	bf00      	nop
 8009f88:	20003aec 	.word	0x20003aec
 8009f8c:	00000000 	.word	0x00000000

08009f90 <chEvtWaitAnyTimeout>:
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, sysinterval_t timeout) {
 8009f90:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8009f92:	4b12      	ldr	r3, [pc, #72]	; (8009fdc <chEvtWaitAnyTimeout+0x4c>)
 8009f94:	699d      	ldr	r5, [r3, #24]
 8009f96:	2320      	movs	r3, #32
 8009f98:	f383 8811 	msr	BASEPRI, r3
  m = ctp->epending & events;
 8009f9c:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8009f9e:	4003      	ands	r3, r0
 8009fa0:	d113      	bne.n	8009fca <chEvtWaitAnyTimeout+0x3a>
    if (TIME_IMMEDIATE == timeout) {
 8009fa2:	b921      	cbnz	r1, 8009fae <chEvtWaitAnyTimeout+0x1e>
 8009fa4:	2300      	movs	r3, #0
 8009fa6:	f383 8811 	msr	BASEPRI, r3
      return (eventmask_t)0;
 8009faa:	4618      	mov	r0, r3
 8009fac:	bd38      	pop	{r3, r4, r5, pc}
 8009fae:	4604      	mov	r4, r0
    ctp->u.ewmask = events;
 8009fb0:	6268      	str	r0, [r5, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
 8009fb2:	200a      	movs	r0, #10
 8009fb4:	f001 fd84 	bl	800bac0 <chSchGoSleepTimeoutS>
 8009fb8:	2800      	cmp	r0, #0
 8009fba:	da04      	bge.n	8009fc6 <chEvtWaitAnyTimeout+0x36>
 8009fbc:	2300      	movs	r3, #0
 8009fbe:	f383 8811 	msr	BASEPRI, r3
      return (eventmask_t)0;
 8009fc2:	4618      	mov	r0, r3
 8009fc4:	bd38      	pop	{r3, r4, r5, pc}
    m = ctp->epending & events;
 8009fc6:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8009fc8:	4023      	ands	r3, r4
  ctp->epending &= ~m;
 8009fca:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8009fcc:	ea22 0203 	bic.w	r2, r2, r3
 8009fd0:	636a      	str	r2, [r5, #52]	; 0x34
 8009fd2:	2200      	movs	r2, #0
 8009fd4:	f382 8811 	msr	BASEPRI, r2
  return m;
 8009fd8:	4618      	mov	r0, r3
}
 8009fda:	bd38      	pop	{r3, r4, r5, pc}
 8009fdc:	20003aec 	.word	0x20003aec

08009fe0 <chEvtWaitOneTimeout>:
eventmask_t chEvtWaitOneTimeout(eventmask_t events, sysinterval_t timeout) {
 8009fe0:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8009fe2:	4b13      	ldr	r3, [pc, #76]	; (800a030 <chEvtWaitOneTimeout+0x50>)
 8009fe4:	699d      	ldr	r5, [r3, #24]
 8009fe6:	2320      	movs	r3, #32
 8009fe8:	f383 8811 	msr	BASEPRI, r3
  m = ctp->epending & events;
 8009fec:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8009fee:	ea13 0200 	ands.w	r2, r3, r0
 8009ff2:	d112      	bne.n	800a01a <chEvtWaitOneTimeout+0x3a>
    if (TIME_IMMEDIATE == timeout) {
 8009ff4:	b919      	cbnz	r1, 8009ffe <chEvtWaitOneTimeout+0x1e>
 8009ff6:	2000      	movs	r0, #0
 8009ff8:	f380 8811 	msr	BASEPRI, r0
 8009ffc:	bd38      	pop	{r3, r4, r5, pc}
 8009ffe:	4604      	mov	r4, r0
    ctp->u.ewmask = events;
 800a000:	6268      	str	r0, [r5, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
 800a002:	200a      	movs	r0, #10
 800a004:	f001 fd5c 	bl	800bac0 <chSchGoSleepTimeoutS>
 800a008:	2800      	cmp	r0, #0
 800a00a:	da03      	bge.n	800a014 <chEvtWaitOneTimeout+0x34>
 800a00c:	2000      	movs	r0, #0
 800a00e:	f380 8811 	msr	BASEPRI, r0
 800a012:	bd38      	pop	{r3, r4, r5, pc}
    m = ctp->epending & events;
 800a014:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 800a016:	ea04 0203 	and.w	r2, r4, r3
  m ^= m & (m - (eventmask_t)1);
 800a01a:	4253      	negs	r3, r2
 800a01c:	ea02 0003 	and.w	r0, r2, r3
  ctp->epending &= ~m;
 800a020:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 800a022:	ea23 0300 	bic.w	r3, r3, r0
 800a026:	636b      	str	r3, [r5, #52]	; 0x34
 800a028:	2300      	movs	r3, #0
 800a02a:	f383 8811 	msr	BASEPRI, r3
}
 800a02e:	bd38      	pop	{r3, r4, r5, pc}
 800a030:	20003aec 	.word	0x20003aec
	...

0800a040 <chEvtWaitAll>:
eventmask_t chEvtWaitAll(eventmask_t events) {
 800a040:	b538      	push	{r3, r4, r5, lr}
 800a042:	4604      	mov	r4, r0
  thread_t *ctp = currp;
 800a044:	4b0a      	ldr	r3, [pc, #40]	; (800a070 <chEvtWaitAll+0x30>)
 800a046:	699d      	ldr	r5, [r3, #24]
 800a048:	2320      	movs	r3, #32
 800a04a:	f383 8811 	msr	BASEPRI, r3
  if ((ctp->epending & events) != events) {
 800a04e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 800a050:	ea30 0303 	bics.w	r3, r0, r3
 800a054:	d003      	beq.n	800a05e <chEvtWaitAll+0x1e>
    ctp->u.ewmask = events;
 800a056:	6268      	str	r0, [r5, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTANDEVT);
 800a058:	200b      	movs	r0, #11
 800a05a:	f001 fbc1 	bl	800b7e0 <chSchGoSleepS>
  ctp->epending &= ~events;
 800a05e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 800a060:	ea23 0304 	bic.w	r3, r3, r4
 800a064:	636b      	str	r3, [r5, #52]	; 0x34
 800a066:	2300      	movs	r3, #0
 800a068:	f383 8811 	msr	BASEPRI, r3
}
 800a06c:	4620      	mov	r0, r4
 800a06e:	bd38      	pop	{r3, r4, r5, pc}
 800a070:	20003aec 	.word	0x20003aec
	...

0800a080 <chEvtWaitAny>:
eventmask_t chEvtWaitAny(eventmask_t events) {
 800a080:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 800a082:	4b0c      	ldr	r3, [pc, #48]	; (800a0b4 <chEvtWaitAny+0x34>)
 800a084:	699c      	ldr	r4, [r3, #24]
 800a086:	2320      	movs	r3, #32
 800a088:	f383 8811 	msr	BASEPRI, r3
  m = ctp->epending & events;
 800a08c:	6b63      	ldr	r3, [r4, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800a08e:	4003      	ands	r3, r0
 800a090:	d106      	bne.n	800a0a0 <chEvtWaitAny+0x20>
 800a092:	4605      	mov	r5, r0
    ctp->u.ewmask = events;
 800a094:	6260      	str	r0, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 800a096:	200a      	movs	r0, #10
 800a098:	f001 fba2 	bl	800b7e0 <chSchGoSleepS>
    m = ctp->epending & events;
 800a09c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800a09e:	402b      	ands	r3, r5
  ctp->epending &= ~m;
 800a0a0:	6b62      	ldr	r2, [r4, #52]	; 0x34
 800a0a2:	ea22 0203 	bic.w	r2, r2, r3
 800a0a6:	6362      	str	r2, [r4, #52]	; 0x34
 800a0a8:	2200      	movs	r2, #0
 800a0aa:	f382 8811 	msr	BASEPRI, r2
}
 800a0ae:	4618      	mov	r0, r3
 800a0b0:	bd38      	pop	{r3, r4, r5, pc}
 800a0b2:	bf00      	nop
 800a0b4:	20003aec 	.word	0x20003aec
	...

0800a0c0 <chEvtWaitOne>:
eventmask_t chEvtWaitOne(eventmask_t events) {
 800a0c0:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 800a0c2:	4b0c      	ldr	r3, [pc, #48]	; (800a0f4 <chEvtWaitOne+0x34>)
 800a0c4:	699c      	ldr	r4, [r3, #24]
 800a0c6:	2320      	movs	r3, #32
 800a0c8:	f383 8811 	msr	BASEPRI, r3
  m = ctp->epending & events;
 800a0cc:	6b63      	ldr	r3, [r4, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800a0ce:	4003      	ands	r3, r0
 800a0d0:	d106      	bne.n	800a0e0 <chEvtWaitOne+0x20>
 800a0d2:	4605      	mov	r5, r0
    ctp->u.ewmask = events;
 800a0d4:	6260      	str	r0, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 800a0d6:	200a      	movs	r0, #10
 800a0d8:	f001 fb82 	bl	800b7e0 <chSchGoSleepS>
    m = ctp->epending & events;
 800a0dc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800a0de:	402b      	ands	r3, r5
  m ^= m & (m - (eventmask_t)1);
 800a0e0:	4258      	negs	r0, r3
 800a0e2:	4018      	ands	r0, r3
  ctp->epending &= ~m;
 800a0e4:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800a0e6:	ea23 0300 	bic.w	r3, r3, r0
 800a0ea:	6363      	str	r3, [r4, #52]	; 0x34
 800a0ec:	2300      	movs	r3, #0
 800a0ee:	f383 8811 	msr	BASEPRI, r3
}
 800a0f2:	bd38      	pop	{r3, r4, r5, pc}
 800a0f4:	20003aec 	.word	0x20003aec
	...

0800a100 <chEvtDispatch>:
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
 800a100:	b570      	push	{r4, r5, r6, lr}
 800a102:	4606      	mov	r6, r0
 800a104:	460d      	mov	r5, r1
  eid = (eventid_t)0;
 800a106:	2400      	movs	r4, #0
 800a108:	e00d      	b.n	800a126 <chEvtDispatch+0x26>
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 800a10a:	fa25 f304 	lsr.w	r3, r5, r4
 800a10e:	f013 0f01 	tst.w	r3, #1
 800a112:	d007      	beq.n	800a124 <chEvtDispatch+0x24>
      events &= ~EVENT_MASK(eid);
 800a114:	2301      	movs	r3, #1
 800a116:	40a3      	lsls	r3, r4
 800a118:	ea25 0503 	bic.w	r5, r5, r3
      handlers[eid](eid);
 800a11c:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
 800a120:	4620      	mov	r0, r4
 800a122:	4798      	blx	r3
    eid++;
 800a124:	3401      	adds	r4, #1
  while (events != (eventmask_t)0) {
 800a126:	2d00      	cmp	r5, #0
 800a128:	d1ef      	bne.n	800a10a <chEvtDispatch+0xa>
}
 800a12a:	bd70      	pop	{r4, r5, r6, pc}
 800a12c:	0000      	movs	r0, r0
	...

0800a130 <chEvtBroadcastFlags>:
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {
 800a130:	b508      	push	{r3, lr}
 800a132:	2320      	movs	r3, #32
 800a134:	f383 8811 	msr	BASEPRI, r3
  chEvtBroadcastFlagsI(esp, flags);
 800a138:	f000 ffca 	bl	800b0d0 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 800a13c:	f001 f9f0 	bl	800b520 <chSchRescheduleS>
 800a140:	2300      	movs	r3, #0
 800a142:	f383 8811 	msr	BASEPRI, r3
 800a146:	bd08      	pop	{r3, pc}
	...

0800a150 <chEvtSignalI>:
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 800a150:	b508      	push	{r3, lr}
  tp->epending |= events;
 800a152:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800a154:	4319      	orrs	r1, r3
 800a156:	6341      	str	r1, [r0, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
 800a158:	f890 3020 	ldrb.w	r3, [r0, #32]
 800a15c:	2b0a      	cmp	r3, #10
 800a15e:	d102      	bne.n	800a166 <chEvtSignalI+0x16>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 800a160:	6a42      	ldr	r2, [r0, #36]	; 0x24
  if (((tp->state == CH_STATE_WTOREVT) &&
 800a162:	4211      	tst	r1, r2
 800a164:	d104      	bne.n	800a170 <chEvtSignalI+0x20>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 800a166:	2b0b      	cmp	r3, #11
 800a168:	d106      	bne.n	800a178 <chEvtSignalI+0x28>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 800a16a:	6a43      	ldr	r3, [r0, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
 800a16c:	438b      	bics	r3, r1
 800a16e:	d103      	bne.n	800a178 <chEvtSignalI+0x28>
    tp->u.rdymsg = MSG_OK;
 800a170:	2300      	movs	r3, #0
 800a172:	6243      	str	r3, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 800a174:	f7fc fb84 	bl	8006880 <chSchReadyI>
 800a178:	bd08      	pop	{r3, pc}
 800a17a:	bf00      	nop
 800a17c:	0000      	movs	r0, r0
	...

0800a180 <null_provider>:

  (void)size;
  (void)align;

  return NULL;
}
 800a180:	2000      	movs	r0, #0
 800a182:	4770      	bx	lr
	...

0800a190 <oslib_test_004_001_execute.lto_priv.49>:

static void oslib_test_004_001_setup(void) {
  chHeapObjectInit(&test_heap, test_heap_buffer, sizeof(test_heap_buffer));
}

static void oslib_test_004_001_execute(void) {
 800a190:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a192:	b085      	sub	sp, #20
  void *p1, *p2, *p3;
  size_t n, sz;

  /* [4.1.1] Testing initial conditions, the heap must not be
     fragmented and one free block present.*/
  test_set_step(1);
 800a194:	2201      	movs	r2, #1
 800a196:	4b7a      	ldr	r3, [pc, #488]	; (800a380 <oslib_test_004_001_execute.lto_priv.49+0x1f0>)
 800a198:	601a      	str	r2, [r3, #0]
  {
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 800a19a:	2200      	movs	r2, #0
 800a19c:	a902      	add	r1, sp, #8
 800a19e:	4879      	ldr	r0, [pc, #484]	; (800a384 <oslib_test_004_001_execute.lto_priv.49+0x1f4>)
 800a1a0:	f7ff fbe6 	bl	8009970 <chHeapStatus>
 800a1a4:	4978      	ldr	r1, [pc, #480]	; (800a388 <oslib_test_004_001_execute.lto_priv.49+0x1f8>)
 800a1a6:	2801      	cmp	r0, #1
 800a1a8:	bf14      	ite	ne
 800a1aa:	2000      	movne	r0, #0
 800a1ac:	2001      	moveq	r0, #1
 800a1ae:	f002 ffff 	bl	800d1b0 <_test_assert>
 800a1b2:	2800      	cmp	r0, #0
 800a1b4:	f040 8185 	bne.w	800a4c2 <oslib_test_004_001_execute.lto_priv.49+0x332>
  }

  /* [4.1.2] Trying to allocate an block bigger than available space,
     an error is expected.*/
  test_set_step(2);
 800a1b8:	2202      	movs	r2, #2
 800a1ba:	4b71      	ldr	r3, [pc, #452]	; (800a380 <oslib_test_004_001_execute.lto_priv.49+0x1f0>)
 800a1bc:	601a      	str	r2, [r3, #0]
 800a1be:	2208      	movs	r2, #8
 800a1c0:	f44f 7180 	mov.w	r1, #256	; 0x100
 800a1c4:	486f      	ldr	r0, [pc, #444]	; (800a384 <oslib_test_004_001_execute.lto_priv.49+0x1f4>)
 800a1c6:	f7ff fc53 	bl	8009a70 <chHeapAllocAligned>
  {
    p1 = chHeapAlloc(&test_heap, sizeof test_heap_buffer * 2);
    test_assert(p1 == NULL, "allocation not failed");
 800a1ca:	4970      	ldr	r1, [pc, #448]	; (800a38c <oslib_test_004_001_execute.lto_priv.49+0x1fc>)
 800a1cc:	fab0 f080 	clz	r0, r0
 800a1d0:	0940      	lsrs	r0, r0, #5
 800a1d2:	f002 ffed 	bl	800d1b0 <_test_assert>
 800a1d6:	2800      	cmp	r0, #0
 800a1d8:	f040 8173 	bne.w	800a4c2 <oslib_test_004_001_execute.lto_priv.49+0x332>
  }

  /* [4.1.3] Single block allocation using chHeapAlloc() then the block
     is freed using chHeapFree(), must not fail.*/
  test_set_step(3);
 800a1dc:	2203      	movs	r2, #3
 800a1de:	4b68      	ldr	r3, [pc, #416]	; (800a380 <oslib_test_004_001_execute.lto_priv.49+0x1f0>)
 800a1e0:	601a      	str	r2, [r3, #0]
 800a1e2:	2208      	movs	r2, #8
 800a1e4:	2110      	movs	r1, #16
 800a1e6:	4867      	ldr	r0, [pc, #412]	; (800a384 <oslib_test_004_001_execute.lto_priv.49+0x1f4>)
 800a1e8:	f7ff fc42 	bl	8009a70 <chHeapAllocAligned>
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    test_assert(p1 != NULL, "allocation failed");
 800a1ec:	4604      	mov	r4, r0
 800a1ee:	4968      	ldr	r1, [pc, #416]	; (800a390 <oslib_test_004_001_execute.lto_priv.49+0x200>)
 800a1f0:	3000      	adds	r0, #0
 800a1f2:	bf18      	it	ne
 800a1f4:	2001      	movne	r0, #1
 800a1f6:	f002 ffdb 	bl	800d1b0 <_test_assert>
 800a1fa:	2800      	cmp	r0, #0
 800a1fc:	f040 8161 	bne.w	800a4c2 <oslib_test_004_001_execute.lto_priv.49+0x332>
    chHeapFree(p1);
 800a200:	4620      	mov	r0, r4
 800a202:	f7ff fbdd 	bl	80099c0 <chHeapFree>
  }

  /* [4.1.4] Using chHeapStatus() to assess the heap state. There must
     be at least one free block of sufficient size.*/
  test_set_step(4);
 800a206:	2204      	movs	r2, #4
 800a208:	4b5d      	ldr	r3, [pc, #372]	; (800a380 <oslib_test_004_001_execute.lto_priv.49+0x1f0>)
 800a20a:	601a      	str	r2, [r3, #0]
  {
    size_t total_size, largest_size;

    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 800a20c:	446a      	add	r2, sp
 800a20e:	4669      	mov	r1, sp
 800a210:	485c      	ldr	r0, [pc, #368]	; (800a384 <oslib_test_004_001_execute.lto_priv.49+0x1f4>)
 800a212:	f7ff fbad 	bl	8009970 <chHeapStatus>
 800a216:	9003      	str	r0, [sp, #12]
    test_assert(n == 1, "missing free block");
 800a218:	495e      	ldr	r1, [pc, #376]	; (800a394 <oslib_test_004_001_execute.lto_priv.49+0x204>)
 800a21a:	2801      	cmp	r0, #1
 800a21c:	bf14      	ite	ne
 800a21e:	2000      	movne	r0, #0
 800a220:	2001      	moveq	r0, #1
 800a222:	f002 ffc5 	bl	800d1b0 <_test_assert>
 800a226:	2800      	cmp	r0, #0
 800a228:	f040 814b 	bne.w	800a4c2 <oslib_test_004_001_execute.lto_priv.49+0x332>
    test_assert(total_size >= ALLOC_SIZE, "unexpected heap state");
 800a22c:	495a      	ldr	r1, [pc, #360]	; (800a398 <oslib_test_004_001_execute.lto_priv.49+0x208>)
 800a22e:	9800      	ldr	r0, [sp, #0]
 800a230:	280f      	cmp	r0, #15
 800a232:	bf94      	ite	ls
 800a234:	2000      	movls	r0, #0
 800a236:	2001      	movhi	r0, #1
 800a238:	f002 ffba 	bl	800d1b0 <_test_assert>
 800a23c:	2800      	cmp	r0, #0
 800a23e:	f040 8140 	bne.w	800a4c2 <oslib_test_004_001_execute.lto_priv.49+0x332>
    test_assert(total_size == largest_size, "unexpected heap state");
 800a242:	4955      	ldr	r1, [pc, #340]	; (800a398 <oslib_test_004_001_execute.lto_priv.49+0x208>)
 800a244:	9b01      	ldr	r3, [sp, #4]
 800a246:	9800      	ldr	r0, [sp, #0]
 800a248:	4298      	cmp	r0, r3
 800a24a:	bf14      	ite	ne
 800a24c:	2000      	movne	r0, #0
 800a24e:	2001      	moveq	r0, #1
 800a250:	f002 ffae 	bl	800d1b0 <_test_assert>
 800a254:	2800      	cmp	r0, #0
 800a256:	f040 8134 	bne.w	800a4c2 <oslib_test_004_001_execute.lto_priv.49+0x332>
  }

  /* [4.1.5] Allocating then freeing in the same order.*/
  test_set_step(5);
 800a25a:	2205      	movs	r2, #5
 800a25c:	4b48      	ldr	r3, [pc, #288]	; (800a380 <oslib_test_004_001_execute.lto_priv.49+0x1f0>)
 800a25e:	601a      	str	r2, [r3, #0]
 800a260:	4c48      	ldr	r4, [pc, #288]	; (800a384 <oslib_test_004_001_execute.lto_priv.49+0x1f4>)
 800a262:	2208      	movs	r2, #8
 800a264:	2110      	movs	r1, #16
 800a266:	4620      	mov	r0, r4
 800a268:	f7ff fc02 	bl	8009a70 <chHeapAllocAligned>
 800a26c:	4607      	mov	r7, r0
 800a26e:	2208      	movs	r2, #8
 800a270:	2110      	movs	r1, #16
 800a272:	4620      	mov	r0, r4
 800a274:	f7ff fbfc 	bl	8009a70 <chHeapAllocAligned>
 800a278:	4606      	mov	r6, r0
 800a27a:	2208      	movs	r2, #8
 800a27c:	2110      	movs	r1, #16
 800a27e:	4620      	mov	r0, r4
 800a280:	f7ff fbf6 	bl	8009a70 <chHeapAllocAligned>
 800a284:	4605      	mov	r5, r0
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p3 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    chHeapFree(p1);                                 /* Does not merge.*/
 800a286:	4638      	mov	r0, r7
 800a288:	f7ff fb9a 	bl	80099c0 <chHeapFree>
    chHeapFree(p2);                                 /* Merges backward.*/
 800a28c:	4630      	mov	r0, r6
 800a28e:	f7ff fb97 	bl	80099c0 <chHeapFree>
    chHeapFree(p3);                                 /* Merges both sides.*/
 800a292:	4628      	mov	r0, r5
 800a294:	f7ff fb94 	bl	80099c0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 800a298:	2200      	movs	r2, #0
 800a29a:	a903      	add	r1, sp, #12
 800a29c:	4620      	mov	r0, r4
 800a29e:	f7ff fb67 	bl	8009970 <chHeapStatus>
 800a2a2:	4939      	ldr	r1, [pc, #228]	; (800a388 <oslib_test_004_001_execute.lto_priv.49+0x1f8>)
 800a2a4:	2801      	cmp	r0, #1
 800a2a6:	bf14      	ite	ne
 800a2a8:	2000      	movne	r0, #0
 800a2aa:	2001      	moveq	r0, #1
 800a2ac:	f002 ff80 	bl	800d1b0 <_test_assert>
 800a2b0:	2800      	cmp	r0, #0
 800a2b2:	f040 8106 	bne.w	800a4c2 <oslib_test_004_001_execute.lto_priv.49+0x332>
  }

  /* [4.1.6] Allocating then freeing in reverse order.*/
  test_set_step(6);
 800a2b6:	2206      	movs	r2, #6
 800a2b8:	4b31      	ldr	r3, [pc, #196]	; (800a380 <oslib_test_004_001_execute.lto_priv.49+0x1f0>)
 800a2ba:	601a      	str	r2, [r3, #0]
 800a2bc:	2208      	movs	r2, #8
 800a2be:	2110      	movs	r1, #16
 800a2c0:	4620      	mov	r0, r4
 800a2c2:	f7ff fbd5 	bl	8009a70 <chHeapAllocAligned>
 800a2c6:	4605      	mov	r5, r0
 800a2c8:	2208      	movs	r2, #8
 800a2ca:	2110      	movs	r1, #16
 800a2cc:	4620      	mov	r0, r4
 800a2ce:	f7ff fbcf 	bl	8009a70 <chHeapAllocAligned>
 800a2d2:	4606      	mov	r6, r0
 800a2d4:	2208      	movs	r2, #8
 800a2d6:	2110      	movs	r1, #16
 800a2d8:	4620      	mov	r0, r4
 800a2da:	f7ff fbc9 	bl	8009a70 <chHeapAllocAligned>
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p3 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    chHeapFree(p3);                                 /* Merges forward.*/
 800a2de:	f7ff fb6f 	bl	80099c0 <chHeapFree>
    chHeapFree(p2);                                 /* Merges forward.*/
 800a2e2:	4630      	mov	r0, r6
 800a2e4:	f7ff fb6c 	bl	80099c0 <chHeapFree>
    chHeapFree(p1);                                 /* Merges forward.*/
 800a2e8:	4628      	mov	r0, r5
 800a2ea:	f7ff fb69 	bl	80099c0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 800a2ee:	2200      	movs	r2, #0
 800a2f0:	a903      	add	r1, sp, #12
 800a2f2:	4620      	mov	r0, r4
 800a2f4:	f7ff fb3c 	bl	8009970 <chHeapStatus>
 800a2f8:	4923      	ldr	r1, [pc, #140]	; (800a388 <oslib_test_004_001_execute.lto_priv.49+0x1f8>)
 800a2fa:	2801      	cmp	r0, #1
 800a2fc:	bf14      	ite	ne
 800a2fe:	2000      	movne	r0, #0
 800a300:	2001      	moveq	r0, #1
 800a302:	f002 ff55 	bl	800d1b0 <_test_assert>
 800a306:	2800      	cmp	r0, #0
 800a308:	f040 80db 	bne.w	800a4c2 <oslib_test_004_001_execute.lto_priv.49+0x332>
  }

  /* [4.1.7] Small fragments handling. Checking the behavior when
     allocating blocks with size not multiple of alignment unit.*/
  test_set_step(7);
 800a30c:	2207      	movs	r2, #7
 800a30e:	4b1c      	ldr	r3, [pc, #112]	; (800a380 <oslib_test_004_001_execute.lto_priv.49+0x1f0>)
 800a310:	601a      	str	r2, [r3, #0]
 800a312:	2208      	movs	r2, #8
 800a314:	2111      	movs	r1, #17
 800a316:	4620      	mov	r0, r4
 800a318:	f7ff fbaa 	bl	8009a70 <chHeapAllocAligned>
 800a31c:	4605      	mov	r5, r0
 800a31e:	2208      	movs	r2, #8
 800a320:	2110      	movs	r1, #16
 800a322:	4620      	mov	r0, r4
 800a324:	f7ff fba4 	bl	8009a70 <chHeapAllocAligned>
 800a328:	4606      	mov	r6, r0
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE + 1);
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    chHeapFree(p1);
 800a32a:	4628      	mov	r0, r5
 800a32c:	f7ff fb48 	bl	80099c0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 800a330:	2200      	movs	r2, #0
 800a332:	a903      	add	r1, sp, #12
 800a334:	4620      	mov	r0, r4
 800a336:	f7ff fb1b 	bl	8009970 <chHeapStatus>
 800a33a:	4918      	ldr	r1, [pc, #96]	; (800a39c <oslib_test_004_001_execute.lto_priv.49+0x20c>)
 800a33c:	2802      	cmp	r0, #2
 800a33e:	bf14      	ite	ne
 800a340:	2000      	movne	r0, #0
 800a342:	2001      	moveq	r0, #1
 800a344:	f002 ff34 	bl	800d1b0 <_test_assert>
 800a348:	2800      	cmp	r0, #0
 800a34a:	f040 80ba 	bne.w	800a4c2 <oslib_test_004_001_execute.lto_priv.49+0x332>
 800a34e:	2208      	movs	r2, #8
 800a350:	2110      	movs	r1, #16
 800a352:	4620      	mov	r0, r4
 800a354:	f7ff fb8c 	bl	8009a70 <chHeapAllocAligned>
 800a358:	4605      	mov	r5, r0
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    /* Note, the first situation happens when the alignment size is smaller
       than the header size, the second in the other cases.*/
    test_assert((chHeapStatus(&test_heap, &n, NULL) == 1) ||
 800a35a:	2200      	movs	r2, #0
 800a35c:	a903      	add	r1, sp, #12
 800a35e:	4620      	mov	r0, r4
 800a360:	f7ff fb06 	bl	8009970 <chHeapStatus>
 800a364:	2801      	cmp	r0, #1
 800a366:	d008      	beq.n	800a37a <oslib_test_004_001_execute.lto_priv.49+0x1ea>
 800a368:	2200      	movs	r2, #0
 800a36a:	a903      	add	r1, sp, #12
 800a36c:	4620      	mov	r0, r4
 800a36e:	f7ff faff 	bl	8009970 <chHeapStatus>
 800a372:	2802      	cmp	r0, #2
 800a374:	d014      	beq.n	800a3a0 <oslib_test_004_001_execute.lto_priv.49+0x210>
 800a376:	2000      	movs	r0, #0
 800a378:	e013      	b.n	800a3a2 <oslib_test_004_001_execute.lto_priv.49+0x212>
 800a37a:	2001      	movs	r0, #1
 800a37c:	e011      	b.n	800a3a2 <oslib_test_004_001_execute.lto_priv.49+0x212>
 800a37e:	bf00      	nop
 800a380:	20003e04 	.word	0x20003e04
 800a384:	200035b0 	.word	0x200035b0
 800a388:	0800e720 	.word	0x0800e720
 800a38c:	0800ff84 	.word	0x0800ff84
 800a390:	0800ff9c 	.word	0x0800ff9c
 800a394:	0800ffb0 	.word	0x0800ffb0
 800a398:	0800ffc4 	.word	0x0800ffc4
 800a39c:	0800ffdc 	.word	0x0800ffdc
 800a3a0:	2001      	movs	r0, #1
 800a3a2:	4949      	ldr	r1, [pc, #292]	; (800a4c8 <oslib_test_004_001_execute.lto_priv.49+0x338>)
 800a3a4:	f002 ff04 	bl	800d1b0 <_test_assert>
 800a3a8:	2800      	cmp	r0, #0
 800a3aa:	f040 808a 	bne.w	800a4c2 <oslib_test_004_001_execute.lto_priv.49+0x332>
                (chHeapStatus(&test_heap, &n, NULL) == 2), "heap fragmented");
    chHeapFree(p2);
 800a3ae:	4630      	mov	r0, r6
 800a3b0:	f7ff fb06 	bl	80099c0 <chHeapFree>
    chHeapFree(p1);
 800a3b4:	4628      	mov	r0, r5
 800a3b6:	f7ff fb03 	bl	80099c0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 800a3ba:	2200      	movs	r2, #0
 800a3bc:	a903      	add	r1, sp, #12
 800a3be:	4843      	ldr	r0, [pc, #268]	; (800a4cc <oslib_test_004_001_execute.lto_priv.49+0x33c>)
 800a3c0:	f7ff fad6 	bl	8009970 <chHeapStatus>
 800a3c4:	4940      	ldr	r1, [pc, #256]	; (800a4c8 <oslib_test_004_001_execute.lto_priv.49+0x338>)
 800a3c6:	2801      	cmp	r0, #1
 800a3c8:	bf14      	ite	ne
 800a3ca:	2000      	movne	r0, #0
 800a3cc:	2001      	moveq	r0, #1
 800a3ce:	f002 feef 	bl	800d1b0 <_test_assert>
 800a3d2:	2800      	cmp	r0, #0
 800a3d4:	d175      	bne.n	800a4c2 <oslib_test_004_001_execute.lto_priv.49+0x332>
  }

  /* [4.1.8] Skipping a fragment, the first fragment in the list is too
     small so the allocator must pick the second one.*/
  test_set_step(8);
 800a3d6:	2508      	movs	r5, #8
 800a3d8:	4b3d      	ldr	r3, [pc, #244]	; (800a4d0 <oslib_test_004_001_execute.lto_priv.49+0x340>)
 800a3da:	601d      	str	r5, [r3, #0]
 800a3dc:	4c3b      	ldr	r4, [pc, #236]	; (800a4cc <oslib_test_004_001_execute.lto_priv.49+0x33c>)
 800a3de:	462a      	mov	r2, r5
 800a3e0:	2110      	movs	r1, #16
 800a3e2:	4620      	mov	r0, r4
 800a3e4:	f7ff fb44 	bl	8009a70 <chHeapAllocAligned>
 800a3e8:	4606      	mov	r6, r0
 800a3ea:	462a      	mov	r2, r5
 800a3ec:	2110      	movs	r1, #16
 800a3ee:	4620      	mov	r0, r4
 800a3f0:	f7ff fb3e 	bl	8009a70 <chHeapAllocAligned>
 800a3f4:	4605      	mov	r5, r0
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    chHeapFree(p1);
 800a3f6:	4630      	mov	r0, r6
 800a3f8:	f7ff fae2 	bl	80099c0 <chHeapFree>
    test_assert( chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 800a3fc:	2200      	movs	r2, #0
 800a3fe:	a903      	add	r1, sp, #12
 800a400:	4620      	mov	r0, r4
 800a402:	f7ff fab5 	bl	8009970 <chHeapStatus>
 800a406:	4933      	ldr	r1, [pc, #204]	; (800a4d4 <oslib_test_004_001_execute.lto_priv.49+0x344>)
 800a408:	2802      	cmp	r0, #2
 800a40a:	bf14      	ite	ne
 800a40c:	2000      	movne	r0, #0
 800a40e:	2001      	moveq	r0, #1
 800a410:	f002 fece 	bl	800d1b0 <_test_assert>
 800a414:	2800      	cmp	r0, #0
 800a416:	d154      	bne.n	800a4c2 <oslib_test_004_001_execute.lto_priv.49+0x332>
 800a418:	2208      	movs	r2, #8
 800a41a:	2120      	movs	r1, #32
 800a41c:	4620      	mov	r0, r4
 800a41e:	f7ff fb27 	bl	8009a70 <chHeapAllocAligned>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE * 2); /* Skips first fragment.*/
    chHeapFree(p1);
 800a422:	f7ff facd 	bl	80099c0 <chHeapFree>
    chHeapFree(p2);
 800a426:	4628      	mov	r0, r5
 800a428:	f7ff faca 	bl	80099c0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 800a42c:	2200      	movs	r2, #0
 800a42e:	a903      	add	r1, sp, #12
 800a430:	4620      	mov	r0, r4
 800a432:	f7ff fa9d 	bl	8009970 <chHeapStatus>
 800a436:	4924      	ldr	r1, [pc, #144]	; (800a4c8 <oslib_test_004_001_execute.lto_priv.49+0x338>)
 800a438:	2801      	cmp	r0, #1
 800a43a:	bf14      	ite	ne
 800a43c:	2000      	movne	r0, #0
 800a43e:	2001      	moveq	r0, #1
 800a440:	f002 feb6 	bl	800d1b0 <_test_assert>
 800a444:	2800      	cmp	r0, #0
 800a446:	d13c      	bne.n	800a4c2 <oslib_test_004_001_execute.lto_priv.49+0x332>
  }

  /* [4.1.9] Allocating the whole available space.*/
  test_set_step(9);
 800a448:	2209      	movs	r2, #9
 800a44a:	4b21      	ldr	r3, [pc, #132]	; (800a4d0 <oslib_test_004_001_execute.lto_priv.49+0x340>)
 800a44c:	601a      	str	r2, [r3, #0]
  {
    (void)chHeapStatus(&test_heap, &n, NULL);
 800a44e:	2200      	movs	r2, #0
 800a450:	a903      	add	r1, sp, #12
 800a452:	4620      	mov	r0, r4
 800a454:	f7ff fa8c 	bl	8009970 <chHeapStatus>
 800a458:	2208      	movs	r2, #8
 800a45a:	9903      	ldr	r1, [sp, #12]
 800a45c:	4620      	mov	r0, r4
 800a45e:	f7ff fb07 	bl	8009a70 <chHeapAllocAligned>
    p1 = chHeapAlloc(&test_heap, n);
    test_assert(p1 != NULL, "allocation failed");
 800a462:	4604      	mov	r4, r0
 800a464:	491c      	ldr	r1, [pc, #112]	; (800a4d8 <oslib_test_004_001_execute.lto_priv.49+0x348>)
 800a466:	3000      	adds	r0, #0
 800a468:	bf18      	it	ne
 800a46a:	2001      	movne	r0, #1
 800a46c:	f002 fea0 	bl	800d1b0 <_test_assert>
 800a470:	bb38      	cbnz	r0, 800a4c2 <oslib_test_004_001_execute.lto_priv.49+0x332>
    test_assert(chHeapStatus(&test_heap, NULL, NULL) == 0, "not empty");
 800a472:	2200      	movs	r2, #0
 800a474:	4611      	mov	r1, r2
 800a476:	4815      	ldr	r0, [pc, #84]	; (800a4cc <oslib_test_004_001_execute.lto_priv.49+0x33c>)
 800a478:	f7ff fa7a 	bl	8009970 <chHeapStatus>
 800a47c:	4917      	ldr	r1, [pc, #92]	; (800a4dc <oslib_test_004_001_execute.lto_priv.49+0x34c>)
 800a47e:	fab0 f080 	clz	r0, r0
 800a482:	0940      	lsrs	r0, r0, #5
 800a484:	f002 fe94 	bl	800d1b0 <_test_assert>
 800a488:	b9d8      	cbnz	r0, 800a4c2 <oslib_test_004_001_execute.lto_priv.49+0x332>
    chHeapFree(p1);
 800a48a:	4620      	mov	r0, r4
 800a48c:	f7ff fa98 	bl	80099c0 <chHeapFree>
  }

  /* [4.1.10] Testing final conditions. The heap geometry must be the
     same than the one registered at beginning.*/
  test_set_step(10);
 800a490:	220a      	movs	r2, #10
 800a492:	4b0f      	ldr	r3, [pc, #60]	; (800a4d0 <oslib_test_004_001_execute.lto_priv.49+0x340>)
 800a494:	601a      	str	r2, [r3, #0]
  {
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 800a496:	2200      	movs	r2, #0
 800a498:	a903      	add	r1, sp, #12
 800a49a:	480c      	ldr	r0, [pc, #48]	; (800a4cc <oslib_test_004_001_execute.lto_priv.49+0x33c>)
 800a49c:	f7ff fa68 	bl	8009970 <chHeapStatus>
 800a4a0:	4909      	ldr	r1, [pc, #36]	; (800a4c8 <oslib_test_004_001_execute.lto_priv.49+0x338>)
 800a4a2:	2801      	cmp	r0, #1
 800a4a4:	bf14      	ite	ne
 800a4a6:	2000      	movne	r0, #0
 800a4a8:	2001      	moveq	r0, #1
 800a4aa:	f002 fe81 	bl	800d1b0 <_test_assert>
 800a4ae:	b940      	cbnz	r0, 800a4c2 <oslib_test_004_001_execute.lto_priv.49+0x332>
    test_assert(n == sz, "size changed");
 800a4b0:	490b      	ldr	r1, [pc, #44]	; (800a4e0 <oslib_test_004_001_execute.lto_priv.49+0x350>)
 800a4b2:	9b02      	ldr	r3, [sp, #8]
 800a4b4:	9803      	ldr	r0, [sp, #12]
 800a4b6:	4298      	cmp	r0, r3
 800a4b8:	bf14      	ite	ne
 800a4ba:	2000      	movne	r0, #0
 800a4bc:	2001      	moveq	r0, #1
 800a4be:	f002 fe77 	bl	800d1b0 <_test_assert>
  }
}
 800a4c2:	b005      	add	sp, #20
 800a4c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a4c6:	bf00      	nop
 800a4c8:	0800e720 	.word	0x0800e720
 800a4cc:	200035b0 	.word	0x200035b0
 800a4d0:	20003e04 	.word	0x20003e04
 800a4d4:	0800ffdc 	.word	0x0800ffdc
 800a4d8:	0800ff9c 	.word	0x0800ff9c
 800a4dc:	0800e4a0 	.word	0x0800e4a0
 800a4e0:	0800ffec 	.word	0x0800ffec
	...

0800a4f0 <oslib_test_004_001_setup.lto_priv.48>:
static void oslib_test_004_001_setup(void) {
 800a4f0:	b508      	push	{r3, lr}
  chHeapObjectInit(&test_heap, test_heap_buffer, sizeof(test_heap_buffer));
 800a4f2:	2280      	movs	r2, #128	; 0x80
 800a4f4:	4902      	ldr	r1, [pc, #8]	; (800a500 <oslib_test_004_001_setup.lto_priv.48+0x10>)
 800a4f6:	4803      	ldr	r0, [pc, #12]	; (800a504 <oslib_test_004_001_setup.lto_priv.48+0x14>)
 800a4f8:	f7ff fb5a 	bl	8009bb0 <chHeapObjectInit>
 800a4fc:	bd08      	pop	{r3, pc}
 800a4fe:	bf00      	nop
 800a500:	200031e0 	.word	0x200031e0
 800a504:	200035b0 	.word	0x200035b0
	...

0800a510 <oslib_test_003_003_execute.lto_priv.47>:

static void oslib_test_003_003_setup(void) {
  chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));
}

static void oslib_test_003_003_execute(void) {
 800a510:	b508      	push	{r3, lr}

  /* [3.3.1] Trying to allocate with 100mS timeout, must fail because
     the pool is empty.*/
  test_set_step(1);
 800a512:	2201      	movs	r2, #1
 800a514:	4b06      	ldr	r3, [pc, #24]	; (800a530 <oslib_test_003_003_execute.lto_priv.47+0x20>)
 800a516:	601a      	str	r2, [r3, #0]
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_MS2I(100)) == NULL, "list not empty");
 800a518:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800a51c:	4805      	ldr	r0, [pc, #20]	; (800a534 <oslib_test_003_003_execute.lto_priv.47+0x24>)
 800a51e:	f7ff f987 	bl	8009830 <chGuardedPoolAllocTimeout>
 800a522:	4905      	ldr	r1, [pc, #20]	; (800a538 <oslib_test_003_003_execute.lto_priv.47+0x28>)
 800a524:	fab0 f080 	clz	r0, r0
 800a528:	0940      	lsrs	r0, r0, #5
 800a52a:	f002 fe41 	bl	800d1b0 <_test_assert>
 800a52e:	bd08      	pop	{r3, pc}
 800a530:	20003e04 	.word	0x20003e04
 800a534:	20002478 	.word	0x20002478
 800a538:	0800fffc 	.word	0x0800fffc
 800a53c:	00000000 	.word	0x00000000

0800a540 <oslib_test_003_003_setup.lto_priv.46>:
static void oslib_test_003_003_setup(void) {
 800a540:	b508      	push	{r3, lr}
  chGuardedPoolObjectInitAligned(gmp, size, PORT_NATURAL_ALIGN);
 800a542:	2204      	movs	r2, #4
 800a544:	4611      	mov	r1, r2
 800a546:	4802      	ldr	r0, [pc, #8]	; (800a550 <oslib_test_003_003_setup.lto_priv.46+0x10>)
 800a548:	f7ff fa02 	bl	8009950 <chGuardedPoolObjectInitAligned>
 800a54c:	bd08      	pop	{r3, pc}
 800a54e:	bf00      	nop
 800a550:	20002478 	.word	0x20002478
	...

0800a560 <oslib_test_003_002_setup.lto_priv.44>:
static void oslib_test_003_002_setup(void) {
 800a560:	b508      	push	{r3, lr}
 800a562:	2204      	movs	r2, #4
 800a564:	4611      	mov	r1, r2
 800a566:	4802      	ldr	r0, [pc, #8]	; (800a570 <oslib_test_003_002_setup.lto_priv.44+0x10>)
 800a568:	f7ff f9f2 	bl	8009950 <chGuardedPoolObjectInitAligned>
 800a56c:	bd08      	pop	{r3, pc}
 800a56e:	bf00      	nop
 800a570:	20002478 	.word	0x20002478
	...

0800a580 <oslib_test_003_002_execute.lto_priv.45>:
static void oslib_test_003_002_execute(void) {
 800a580:	b510      	push	{r4, lr}
  test_set_step(1);
 800a582:	4c2c      	ldr	r4, [pc, #176]	; (800a634 <oslib_test_003_002_execute.lto_priv.45+0xb4>)
 800a584:	2301      	movs	r3, #1
 800a586:	6023      	str	r3, [r4, #0]
    chGuardedPoolLoadArray(&gmp1, objects, MEMORY_POOL_SIZE);
 800a588:	2204      	movs	r2, #4
 800a58a:	492b      	ldr	r1, [pc, #172]	; (800a638 <oslib_test_003_002_execute.lto_priv.45+0xb8>)
 800a58c:	482b      	ldr	r0, [pc, #172]	; (800a63c <oslib_test_003_002_execute.lto_priv.45+0xbc>)
 800a58e:	f7ff f95f 	bl	8009850 <chGuardedPoolLoadArray>
  test_set_step(2);
 800a592:	2302      	movs	r3, #2
 800a594:	6023      	str	r3, [r4, #0]
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800a596:	2400      	movs	r4, #0
 800a598:	e00c      	b.n	800a5b4 <oslib_test_003_002_execute.lto_priv.45+0x34>
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 800a59a:	2100      	movs	r1, #0
 800a59c:	4827      	ldr	r0, [pc, #156]	; (800a63c <oslib_test_003_002_execute.lto_priv.45+0xbc>)
 800a59e:	f7ff f947 	bl	8009830 <chGuardedPoolAllocTimeout>
 800a5a2:	4927      	ldr	r1, [pc, #156]	; (800a640 <oslib_test_003_002_execute.lto_priv.45+0xc0>)
 800a5a4:	3000      	adds	r0, #0
 800a5a6:	bf18      	it	ne
 800a5a8:	2001      	movne	r0, #1
 800a5aa:	f002 fe01 	bl	800d1b0 <_test_assert>
 800a5ae:	2800      	cmp	r0, #0
 800a5b0:	d13e      	bne.n	800a630 <oslib_test_003_002_execute.lto_priv.45+0xb0>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800a5b2:	3401      	adds	r4, #1
 800a5b4:	2c03      	cmp	r4, #3
 800a5b6:	d9f0      	bls.n	800a59a <oslib_test_003_002_execute.lto_priv.45+0x1a>
  test_set_step(3);
 800a5b8:	2203      	movs	r2, #3
 800a5ba:	4b1e      	ldr	r3, [pc, #120]	; (800a634 <oslib_test_003_002_execute.lto_priv.45+0xb4>)
 800a5bc:	601a      	str	r2, [r3, #0]
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 800a5be:	2100      	movs	r1, #0
 800a5c0:	481e      	ldr	r0, [pc, #120]	; (800a63c <oslib_test_003_002_execute.lto_priv.45+0xbc>)
 800a5c2:	f7ff f935 	bl	8009830 <chGuardedPoolAllocTimeout>
 800a5c6:	491f      	ldr	r1, [pc, #124]	; (800a644 <oslib_test_003_002_execute.lto_priv.45+0xc4>)
 800a5c8:	fab0 f080 	clz	r0, r0
 800a5cc:	0940      	lsrs	r0, r0, #5
 800a5ce:	f002 fdef 	bl	800d1b0 <_test_assert>
 800a5d2:	bb68      	cbnz	r0, 800a630 <oslib_test_003_002_execute.lto_priv.45+0xb0>
  test_set_step(4);
 800a5d4:	2204      	movs	r2, #4
 800a5d6:	4b17      	ldr	r3, [pc, #92]	; (800a634 <oslib_test_003_002_execute.lto_priv.45+0xb4>)
 800a5d8:	601a      	str	r2, [r3, #0]
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800a5da:	2400      	movs	r4, #0
 800a5dc:	e006      	b.n	800a5ec <oslib_test_003_002_execute.lto_priv.45+0x6c>
      chGuardedPoolFree(&gmp1, &objects[i]);
 800a5de:	4916      	ldr	r1, [pc, #88]	; (800a638 <oslib_test_003_002_execute.lto_priv.45+0xb8>)
 800a5e0:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 800a5e4:	4815      	ldr	r0, [pc, #84]	; (800a63c <oslib_test_003_002_execute.lto_priv.45+0xbc>)
 800a5e6:	f7ff f90b 	bl	8009800 <chGuardedPoolFree>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800a5ea:	3401      	adds	r4, #1
 800a5ec:	2c03      	cmp	r4, #3
 800a5ee:	d9f6      	bls.n	800a5de <oslib_test_003_002_execute.lto_priv.45+0x5e>
  test_set_step(5);
 800a5f0:	2205      	movs	r2, #5
 800a5f2:	4b10      	ldr	r3, [pc, #64]	; (800a634 <oslib_test_003_002_execute.lto_priv.45+0xb4>)
 800a5f4:	601a      	str	r2, [r3, #0]
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800a5f6:	2400      	movs	r4, #0
 800a5f8:	e00b      	b.n	800a612 <oslib_test_003_002_execute.lto_priv.45+0x92>
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 800a5fa:	2100      	movs	r1, #0
 800a5fc:	480f      	ldr	r0, [pc, #60]	; (800a63c <oslib_test_003_002_execute.lto_priv.45+0xbc>)
 800a5fe:	f7ff f917 	bl	8009830 <chGuardedPoolAllocTimeout>
 800a602:	490f      	ldr	r1, [pc, #60]	; (800a640 <oslib_test_003_002_execute.lto_priv.45+0xc0>)
 800a604:	3000      	adds	r0, #0
 800a606:	bf18      	it	ne
 800a608:	2001      	movne	r0, #1
 800a60a:	f002 fdd1 	bl	800d1b0 <_test_assert>
 800a60e:	b978      	cbnz	r0, 800a630 <oslib_test_003_002_execute.lto_priv.45+0xb0>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800a610:	3401      	adds	r4, #1
 800a612:	2c03      	cmp	r4, #3
 800a614:	d9f1      	bls.n	800a5fa <oslib_test_003_002_execute.lto_priv.45+0x7a>
  test_set_step(6);
 800a616:	2206      	movs	r2, #6
 800a618:	4b06      	ldr	r3, [pc, #24]	; (800a634 <oslib_test_003_002_execute.lto_priv.45+0xb4>)
 800a61a:	601a      	str	r2, [r3, #0]
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 800a61c:	2100      	movs	r1, #0
 800a61e:	4807      	ldr	r0, [pc, #28]	; (800a63c <oslib_test_003_002_execute.lto_priv.45+0xbc>)
 800a620:	f7ff f906 	bl	8009830 <chGuardedPoolAllocTimeout>
 800a624:	4907      	ldr	r1, [pc, #28]	; (800a644 <oslib_test_003_002_execute.lto_priv.45+0xc4>)
 800a626:	fab0 f080 	clz	r0, r0
 800a62a:	0940      	lsrs	r0, r0, #5
 800a62c:	f002 fdc0 	bl	800d1b0 <_test_assert>
 800a630:	bd10      	pop	{r4, pc}
 800a632:	bf00      	nop
 800a634:	20003e04 	.word	0x20003e04
 800a638:	200031b0 	.word	0x200031b0
 800a63c:	20002478 	.word	0x20002478
 800a640:	0801000c 	.word	0x0801000c
 800a644:	0800fffc 	.word	0x0800fffc
	...

0800a650 <oslib_test_003_001_setup.lto_priv.42>:
static void oslib_test_003_001_setup(void) {
 800a650:	b508      	push	{r3, lr}
  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 800a652:	2300      	movs	r3, #0
 800a654:	2204      	movs	r2, #4
 800a656:	4611      	mov	r1, r2
 800a658:	4801      	ldr	r0, [pc, #4]	; (800a660 <oslib_test_003_001_setup.lto_priv.42+0x10>)
 800a65a:	f7ff f969 	bl	8009930 <chPoolObjectInitAligned>
 800a65e:	bd08      	pop	{r3, pc}
 800a660:	2000250c 	.word	0x2000250c
	...

0800a670 <oslib_test_003_001_execute.lto_priv.43>:
static void oslib_test_003_001_execute(void) {
 800a670:	b510      	push	{r4, lr}
  test_set_step(1);
 800a672:	4c34      	ldr	r4, [pc, #208]	; (800a744 <oslib_test_003_001_execute.lto_priv.43+0xd4>)
 800a674:	2301      	movs	r3, #1
 800a676:	6023      	str	r3, [r4, #0]
    chPoolLoadArray(&mp1, objects, MEMORY_POOL_SIZE);
 800a678:	2204      	movs	r2, #4
 800a67a:	4933      	ldr	r1, [pc, #204]	; (800a748 <oslib_test_003_001_execute.lto_priv.43+0xd8>)
 800a67c:	4833      	ldr	r0, [pc, #204]	; (800a74c <oslib_test_003_001_execute.lto_priv.43+0xdc>)
 800a67e:	f7ff f947 	bl	8009910 <chPoolLoadArray>
  test_set_step(2);
 800a682:	2302      	movs	r3, #2
 800a684:	6023      	str	r3, [r4, #0]
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800a686:	2400      	movs	r4, #0
 800a688:	e00b      	b.n	800a6a2 <oslib_test_003_001_execute.lto_priv.43+0x32>
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 800a68a:	4830      	ldr	r0, [pc, #192]	; (800a74c <oslib_test_003_001_execute.lto_priv.43+0xdc>)
 800a68c:	f7ff f910 	bl	80098b0 <chPoolAlloc>
 800a690:	492f      	ldr	r1, [pc, #188]	; (800a750 <oslib_test_003_001_execute.lto_priv.43+0xe0>)
 800a692:	3000      	adds	r0, #0
 800a694:	bf18      	it	ne
 800a696:	2001      	movne	r0, #1
 800a698:	f002 fd8a 	bl	800d1b0 <_test_assert>
 800a69c:	2800      	cmp	r0, #0
 800a69e:	d150      	bne.n	800a742 <oslib_test_003_001_execute.lto_priv.43+0xd2>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800a6a0:	3401      	adds	r4, #1
 800a6a2:	2c03      	cmp	r4, #3
 800a6a4:	d9f1      	bls.n	800a68a <oslib_test_003_001_execute.lto_priv.43+0x1a>
  test_set_step(3);
 800a6a6:	2203      	movs	r2, #3
 800a6a8:	4b26      	ldr	r3, [pc, #152]	; (800a744 <oslib_test_003_001_execute.lto_priv.43+0xd4>)
 800a6aa:	601a      	str	r2, [r3, #0]
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 800a6ac:	4827      	ldr	r0, [pc, #156]	; (800a74c <oslib_test_003_001_execute.lto_priv.43+0xdc>)
 800a6ae:	f7ff f8ff 	bl	80098b0 <chPoolAlloc>
 800a6b2:	4928      	ldr	r1, [pc, #160]	; (800a754 <oslib_test_003_001_execute.lto_priv.43+0xe4>)
 800a6b4:	fab0 f080 	clz	r0, r0
 800a6b8:	0940      	lsrs	r0, r0, #5
 800a6ba:	f002 fd79 	bl	800d1b0 <_test_assert>
 800a6be:	2800      	cmp	r0, #0
 800a6c0:	d13f      	bne.n	800a742 <oslib_test_003_001_execute.lto_priv.43+0xd2>
  test_set_step(4);
 800a6c2:	2204      	movs	r2, #4
 800a6c4:	4b1f      	ldr	r3, [pc, #124]	; (800a744 <oslib_test_003_001_execute.lto_priv.43+0xd4>)
 800a6c6:	601a      	str	r2, [r3, #0]
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800a6c8:	2400      	movs	r4, #0
 800a6ca:	e006      	b.n	800a6da <oslib_test_003_001_execute.lto_priv.43+0x6a>
      chPoolFree(&mp1, &objects[i]);
 800a6cc:	491e      	ldr	r1, [pc, #120]	; (800a748 <oslib_test_003_001_execute.lto_priv.43+0xd8>)
 800a6ce:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 800a6d2:	481e      	ldr	r0, [pc, #120]	; (800a74c <oslib_test_003_001_execute.lto_priv.43+0xdc>)
 800a6d4:	f7ff f8cc 	bl	8009870 <chPoolFree>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800a6d8:	3401      	adds	r4, #1
 800a6da:	2c03      	cmp	r4, #3
 800a6dc:	d9f6      	bls.n	800a6cc <oslib_test_003_001_execute.lto_priv.43+0x5c>
  test_set_step(5);
 800a6de:	2205      	movs	r2, #5
 800a6e0:	4b18      	ldr	r3, [pc, #96]	; (800a744 <oslib_test_003_001_execute.lto_priv.43+0xd4>)
 800a6e2:	601a      	str	r2, [r3, #0]
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800a6e4:	2400      	movs	r4, #0
 800a6e6:	e00a      	b.n	800a6fe <oslib_test_003_001_execute.lto_priv.43+0x8e>
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 800a6e8:	4818      	ldr	r0, [pc, #96]	; (800a74c <oslib_test_003_001_execute.lto_priv.43+0xdc>)
 800a6ea:	f7ff f8e1 	bl	80098b0 <chPoolAlloc>
 800a6ee:	4918      	ldr	r1, [pc, #96]	; (800a750 <oslib_test_003_001_execute.lto_priv.43+0xe0>)
 800a6f0:	3000      	adds	r0, #0
 800a6f2:	bf18      	it	ne
 800a6f4:	2001      	movne	r0, #1
 800a6f6:	f002 fd5b 	bl	800d1b0 <_test_assert>
 800a6fa:	bb10      	cbnz	r0, 800a742 <oslib_test_003_001_execute.lto_priv.43+0xd2>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800a6fc:	3401      	adds	r4, #1
 800a6fe:	2c03      	cmp	r4, #3
 800a700:	d9f2      	bls.n	800a6e8 <oslib_test_003_001_execute.lto_priv.43+0x78>
  test_set_step(6);
 800a702:	2206      	movs	r2, #6
 800a704:	4b0f      	ldr	r3, [pc, #60]	; (800a744 <oslib_test_003_001_execute.lto_priv.43+0xd4>)
 800a706:	601a      	str	r2, [r3, #0]
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 800a708:	4810      	ldr	r0, [pc, #64]	; (800a74c <oslib_test_003_001_execute.lto_priv.43+0xdc>)
 800a70a:	f7ff f8d1 	bl	80098b0 <chPoolAlloc>
 800a70e:	4911      	ldr	r1, [pc, #68]	; (800a754 <oslib_test_003_001_execute.lto_priv.43+0xe4>)
 800a710:	fab0 f080 	clz	r0, r0
 800a714:	0940      	lsrs	r0, r0, #5
 800a716:	f002 fd4b 	bl	800d1b0 <_test_assert>
 800a71a:	b990      	cbnz	r0, 800a742 <oslib_test_003_001_execute.lto_priv.43+0xd2>
  test_set_step(7);
 800a71c:	2207      	movs	r2, #7
 800a71e:	4b09      	ldr	r3, [pc, #36]	; (800a744 <oslib_test_003_001_execute.lto_priv.43+0xd4>)
 800a720:	601a      	str	r2, [r3, #0]
 800a722:	4c0a      	ldr	r4, [pc, #40]	; (800a74c <oslib_test_003_001_execute.lto_priv.43+0xdc>)
 800a724:	4b0c      	ldr	r3, [pc, #48]	; (800a758 <oslib_test_003_001_execute.lto_priv.43+0xe8>)
 800a726:	2204      	movs	r2, #4
 800a728:	4611      	mov	r1, r2
 800a72a:	4620      	mov	r0, r4
 800a72c:	f7ff f900 	bl	8009930 <chPoolObjectInitAligned>
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
 800a730:	4620      	mov	r0, r4
 800a732:	f7ff f8bd 	bl	80098b0 <chPoolAlloc>
 800a736:	4909      	ldr	r1, [pc, #36]	; (800a75c <oslib_test_003_001_execute.lto_priv.43+0xec>)
 800a738:	fab0 f080 	clz	r0, r0
 800a73c:	0940      	lsrs	r0, r0, #5
 800a73e:	f002 fd37 	bl	800d1b0 <_test_assert>
 800a742:	bd10      	pop	{r4, pc}
 800a744:	20003e04 	.word	0x20003e04
 800a748:	200031b0 	.word	0x200031b0
 800a74c:	2000250c 	.word	0x2000250c
 800a750:	0801000c 	.word	0x0801000c
 800a754:	0800fffc 	.word	0x0800fffc
 800a758:	0800a181 	.word	0x0800a181
 800a75c:	08010018 	.word	0x08010018

0800a760 <oslib_test_002_002_execute.lto_priv.41>:

static void oslib_test_002_002_setup(void) {
  chPipeObjectInit(&pipe1, buffer, PIPE_SIZE / 2);
}

static void oslib_test_002_002_execute(void) {
 800a760:	b500      	push	{lr}
 800a762:	b085      	sub	sp, #20

  /* [2.2.1] Reading while pipe is empty.*/
  test_set_step(1);
 800a764:	2201      	movs	r2, #1
 800a766:	4b28      	ldr	r3, [pc, #160]	; (800a808 <oslib_test_002_002_execute.lto_priv.41+0xa8>)
 800a768:	601a      	str	r2, [r3, #0]
  {
    size_t n;
    uint8_t buf[PIPE_SIZE];

    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 800a76a:	2300      	movs	r3, #0
 800a76c:	2210      	movs	r2, #16
 800a76e:	4669      	mov	r1, sp
 800a770:	4826      	ldr	r0, [pc, #152]	; (800a80c <oslib_test_002_002_execute.lto_priv.41+0xac>)
 800a772:	f7fe ff95 	bl	80096a0 <chPipeReadTimeout>
    test_assert(n == 0, "wrong size");
 800a776:	4926      	ldr	r1, [pc, #152]	; (800a810 <oslib_test_002_002_execute.lto_priv.41+0xb0>)
 800a778:	fab0 f080 	clz	r0, r0
 800a77c:	0940      	lsrs	r0, r0, #5
 800a77e:	f002 fd17 	bl	800d1b0 <_test_assert>
 800a782:	2800      	cmp	r0, #0
 800a784:	d13c      	bne.n	800a800 <oslib_test_002_002_execute.lto_priv.41+0xa0>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 800a786:	4b21      	ldr	r3, [pc, #132]	; (800a80c <oslib_test_002_002_execute.lto_priv.41+0xac>)
 800a788:	681a      	ldr	r2, [r3, #0]
 800a78a:	68db      	ldr	r3, [r3, #12]
 800a78c:	4293      	cmp	r3, r2
 800a78e:	d107      	bne.n	800a7a0 <oslib_test_002_002_execute.lto_priv.41+0x40>
 800a790:	4b1e      	ldr	r3, [pc, #120]	; (800a80c <oslib_test_002_002_execute.lto_priv.41+0xac>)
 800a792:	689b      	ldr	r3, [r3, #8]
 800a794:	429a      	cmp	r2, r3
 800a796:	d105      	bne.n	800a7a4 <oslib_test_002_002_execute.lto_priv.41+0x44>
 800a798:	4b1c      	ldr	r3, [pc, #112]	; (800a80c <oslib_test_002_002_execute.lto_priv.41+0xac>)
 800a79a:	691b      	ldr	r3, [r3, #16]
 800a79c:	b123      	cbz	r3, 800a7a8 <oslib_test_002_002_execute.lto_priv.41+0x48>
 800a79e:	e004      	b.n	800a7aa <oslib_test_002_002_execute.lto_priv.41+0x4a>
 800a7a0:	2000      	movs	r0, #0
 800a7a2:	e002      	b.n	800a7aa <oslib_test_002_002_execute.lto_priv.41+0x4a>
 800a7a4:	2000      	movs	r0, #0
 800a7a6:	e000      	b.n	800a7aa <oslib_test_002_002_execute.lto_priv.41+0x4a>
 800a7a8:	2001      	movs	r0, #1
 800a7aa:	491a      	ldr	r1, [pc, #104]	; (800a814 <oslib_test_002_002_execute.lto_priv.41+0xb4>)
 800a7ac:	f002 fd00 	bl	800d1b0 <_test_assert>
 800a7b0:	bb30      	cbnz	r0, 800a800 <oslib_test_002_002_execute.lto_priv.41+0xa0>
                (pipe1.cnt == 0),
                "invalid pipe state");
  }

  /* [2.2.2] Writing a string larger than pipe buffer.*/
  test_set_step(2);
 800a7b2:	2202      	movs	r2, #2
 800a7b4:	4b14      	ldr	r3, [pc, #80]	; (800a808 <oslib_test_002_002_execute.lto_priv.41+0xa8>)
 800a7b6:	601a      	str	r2, [r3, #0]
  {
    size_t n;

    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 800a7b8:	2300      	movs	r3, #0
 800a7ba:	2210      	movs	r2, #16
 800a7bc:	4916      	ldr	r1, [pc, #88]	; (800a818 <oslib_test_002_002_execute.lto_priv.41+0xb8>)
 800a7be:	4813      	ldr	r0, [pc, #76]	; (800a80c <oslib_test_002_002_execute.lto_priv.41+0xac>)
 800a7c0:	f7fe ffa6 	bl	8009710 <chPipeWriteTimeout>
    test_assert(n == PIPE_SIZE / 2, "wrong size");
 800a7c4:	4912      	ldr	r1, [pc, #72]	; (800a810 <oslib_test_002_002_execute.lto_priv.41+0xb0>)
 800a7c6:	2808      	cmp	r0, #8
 800a7c8:	bf14      	ite	ne
 800a7ca:	2000      	movne	r0, #0
 800a7cc:	2001      	moveq	r0, #1
 800a7ce:	f002 fcef 	bl	800d1b0 <_test_assert>
 800a7d2:	b9a8      	cbnz	r0, 800a800 <oslib_test_002_002_execute.lto_priv.41+0xa0>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 800a7d4:	4b0d      	ldr	r3, [pc, #52]	; (800a80c <oslib_test_002_002_execute.lto_priv.41+0xac>)
 800a7d6:	689a      	ldr	r2, [r3, #8]
 800a7d8:	68db      	ldr	r3, [r3, #12]
 800a7da:	4293      	cmp	r3, r2
 800a7dc:	d108      	bne.n	800a7f0 <oslib_test_002_002_execute.lto_priv.41+0x90>
 800a7de:	4b0b      	ldr	r3, [pc, #44]	; (800a80c <oslib_test_002_002_execute.lto_priv.41+0xac>)
 800a7e0:	681b      	ldr	r3, [r3, #0]
 800a7e2:	429a      	cmp	r2, r3
 800a7e4:	d106      	bne.n	800a7f4 <oslib_test_002_002_execute.lto_priv.41+0x94>
 800a7e6:	4b09      	ldr	r3, [pc, #36]	; (800a80c <oslib_test_002_002_execute.lto_priv.41+0xac>)
 800a7e8:	691b      	ldr	r3, [r3, #16]
 800a7ea:	2b08      	cmp	r3, #8
 800a7ec:	d004      	beq.n	800a7f8 <oslib_test_002_002_execute.lto_priv.41+0x98>
 800a7ee:	e004      	b.n	800a7fa <oslib_test_002_002_execute.lto_priv.41+0x9a>
 800a7f0:	2000      	movs	r0, #0
 800a7f2:	e002      	b.n	800a7fa <oslib_test_002_002_execute.lto_priv.41+0x9a>
 800a7f4:	2000      	movs	r0, #0
 800a7f6:	e000      	b.n	800a7fa <oslib_test_002_002_execute.lto_priv.41+0x9a>
 800a7f8:	2001      	movs	r0, #1
 800a7fa:	4906      	ldr	r1, [pc, #24]	; (800a814 <oslib_test_002_002_execute.lto_priv.41+0xb4>)
 800a7fc:	f002 fcd8 	bl	800d1b0 <_test_assert>
                (pipe1.wrptr == pipe1.buffer) &&
                (pipe1.cnt == PIPE_SIZE / 2),
                "invalid pipe state");
  }
}
 800a800:	b005      	add	sp, #20
 800a802:	f85d fb04 	ldr.w	pc, [sp], #4
 800a806:	bf00      	nop
 800a808:	20003e04 	.word	0x20003e04
 800a80c:	200024bc 	.word	0x200024bc
 800a810:	0800e494 	.word	0x0800e494
 800a814:	08010034 	.word	0x08010034
 800a818:	0800ff70 	.word	0x0800ff70
 800a81c:	00000000 	.word	0x00000000

0800a820 <oslib_test_002_002_setup.lto_priv.40>:
static void oslib_test_002_002_setup(void) {
 800a820:	b508      	push	{r3, lr}
  chPipeObjectInit(&pipe1, buffer, PIPE_SIZE / 2);
 800a822:	2208      	movs	r2, #8
 800a824:	4902      	ldr	r1, [pc, #8]	; (800a830 <oslib_test_002_002_setup.lto_priv.40+0x10>)
 800a826:	4803      	ldr	r0, [pc, #12]	; (800a834 <oslib_test_002_002_setup.lto_priv.40+0x14>)
 800a828:	f7fe ffd2 	bl	80097d0 <chPipeObjectInit>
 800a82c:	bd08      	pop	{r3, pc}
 800a82e:	bf00      	nop
 800a830:	200031d0 	.word	0x200031d0
 800a834:	200024bc 	.word	0x200024bc
	...

0800a840 <oslib_test_002_001_setup.lto_priv.38>:
static void oslib_test_002_001_setup(void) {
 800a840:	b508      	push	{r3, lr}
  chPipeObjectInit(&pipe1, buffer, PIPE_SIZE);
 800a842:	2210      	movs	r2, #16
 800a844:	4902      	ldr	r1, [pc, #8]	; (800a850 <oslib_test_002_001_setup.lto_priv.38+0x10>)
 800a846:	4803      	ldr	r0, [pc, #12]	; (800a854 <oslib_test_002_001_setup.lto_priv.38+0x14>)
 800a848:	f7fe ffc2 	bl	80097d0 <chPipeObjectInit>
 800a84c:	bd08      	pop	{r3, pc}
 800a84e:	bf00      	nop
 800a850:	200031d0 	.word	0x200031d0
 800a854:	200024bc 	.word	0x200024bc
	...

0800a860 <oslib_test_002_001_execute.lto_priv.39>:
static void oslib_test_002_001_execute(void) {
 800a860:	b510      	push	{r4, lr}
 800a862:	b084      	sub	sp, #16
  test_set_step(1);
 800a864:	2201      	movs	r2, #1
 800a866:	4ba1      	ldr	r3, [pc, #644]	; (800aaec <oslib_test_002_001_execute.lto_priv.39+0x28c>)
 800a868:	601a      	str	r2, [r3, #0]
    chPipeReset(&pipe1);
 800a86a:	4ca1      	ldr	r4, [pc, #644]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800a86c:	4620      	mov	r0, r4
 800a86e:	f7fe ff87 	bl	8009780 <chPipeReset>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 800a872:	6823      	ldr	r3, [r4, #0]
 800a874:	68e2      	ldr	r2, [r4, #12]
 800a876:	429a      	cmp	r2, r3
 800a878:	d106      	bne.n	800a888 <oslib_test_002_001_execute.lto_priv.39+0x28>
 800a87a:	68a2      	ldr	r2, [r4, #8]
 800a87c:	4293      	cmp	r3, r2
 800a87e:	d105      	bne.n	800a88c <oslib_test_002_001_execute.lto_priv.39+0x2c>
 800a880:	6923      	ldr	r3, [r4, #16]
 800a882:	b12b      	cbz	r3, 800a890 <oslib_test_002_001_execute.lto_priv.39+0x30>
 800a884:	2000      	movs	r0, #0
 800a886:	e004      	b.n	800a892 <oslib_test_002_001_execute.lto_priv.39+0x32>
 800a888:	2000      	movs	r0, #0
 800a88a:	e002      	b.n	800a892 <oslib_test_002_001_execute.lto_priv.39+0x32>
 800a88c:	2000      	movs	r0, #0
 800a88e:	e000      	b.n	800a892 <oslib_test_002_001_execute.lto_priv.39+0x32>
 800a890:	2001      	movs	r0, #1
 800a892:	4998      	ldr	r1, [pc, #608]	; (800aaf4 <oslib_test_002_001_execute.lto_priv.39+0x294>)
 800a894:	f002 fc8c 	bl	800d1b0 <_test_assert>
 800a898:	2800      	cmp	r0, #0
 800a89a:	f040 826d 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
  test_set_step(2);
 800a89e:	2202      	movs	r2, #2
 800a8a0:	4b92      	ldr	r3, [pc, #584]	; (800aaec <oslib_test_002_001_execute.lto_priv.39+0x28c>)
 800a8a2:	601a      	str	r2, [r3, #0]
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 800a8a4:	2300      	movs	r3, #0
 800a8a6:	2210      	movs	r2, #16
 800a8a8:	4993      	ldr	r1, [pc, #588]	; (800aaf8 <oslib_test_002_001_execute.lto_priv.39+0x298>)
 800a8aa:	4891      	ldr	r0, [pc, #580]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800a8ac:	f7fe ff30 	bl	8009710 <chPipeWriteTimeout>
    test_assert(n == 0, "not reset");
 800a8b0:	4992      	ldr	r1, [pc, #584]	; (800aafc <oslib_test_002_001_execute.lto_priv.39+0x29c>)
 800a8b2:	fab0 f080 	clz	r0, r0
 800a8b6:	0940      	lsrs	r0, r0, #5
 800a8b8:	f002 fc7a 	bl	800d1b0 <_test_assert>
 800a8bc:	2800      	cmp	r0, #0
 800a8be:	f040 825b 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 800a8c2:	4b8b      	ldr	r3, [pc, #556]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800a8c4:	681a      	ldr	r2, [r3, #0]
 800a8c6:	68db      	ldr	r3, [r3, #12]
 800a8c8:	4293      	cmp	r3, r2
 800a8ca:	d107      	bne.n	800a8dc <oslib_test_002_001_execute.lto_priv.39+0x7c>
 800a8cc:	4b88      	ldr	r3, [pc, #544]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800a8ce:	689b      	ldr	r3, [r3, #8]
 800a8d0:	429a      	cmp	r2, r3
 800a8d2:	d105      	bne.n	800a8e0 <oslib_test_002_001_execute.lto_priv.39+0x80>
 800a8d4:	4b86      	ldr	r3, [pc, #536]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800a8d6:	691b      	ldr	r3, [r3, #16]
 800a8d8:	b123      	cbz	r3, 800a8e4 <oslib_test_002_001_execute.lto_priv.39+0x84>
 800a8da:	e004      	b.n	800a8e6 <oslib_test_002_001_execute.lto_priv.39+0x86>
 800a8dc:	2000      	movs	r0, #0
 800a8de:	e002      	b.n	800a8e6 <oslib_test_002_001_execute.lto_priv.39+0x86>
 800a8e0:	2000      	movs	r0, #0
 800a8e2:	e000      	b.n	800a8e6 <oslib_test_002_001_execute.lto_priv.39+0x86>
 800a8e4:	2001      	movs	r0, #1
 800a8e6:	4983      	ldr	r1, [pc, #524]	; (800aaf4 <oslib_test_002_001_execute.lto_priv.39+0x294>)
 800a8e8:	f002 fc62 	bl	800d1b0 <_test_assert>
 800a8ec:	2800      	cmp	r0, #0
 800a8ee:	f040 8243 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
  test_set_step(3);
 800a8f2:	2203      	movs	r2, #3
 800a8f4:	4b7d      	ldr	r3, [pc, #500]	; (800aaec <oslib_test_002_001_execute.lto_priv.39+0x28c>)
 800a8f6:	601a      	str	r2, [r3, #0]
    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 800a8f8:	2300      	movs	r3, #0
 800a8fa:	2210      	movs	r2, #16
 800a8fc:	4669      	mov	r1, sp
 800a8fe:	487c      	ldr	r0, [pc, #496]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800a900:	f7fe fece 	bl	80096a0 <chPipeReadTimeout>
    test_assert(n == 0, "not reset");
 800a904:	497d      	ldr	r1, [pc, #500]	; (800aafc <oslib_test_002_001_execute.lto_priv.39+0x29c>)
 800a906:	fab0 f080 	clz	r0, r0
 800a90a:	0940      	lsrs	r0, r0, #5
 800a90c:	f002 fc50 	bl	800d1b0 <_test_assert>
 800a910:	2800      	cmp	r0, #0
 800a912:	f040 8231 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 800a916:	4b76      	ldr	r3, [pc, #472]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800a918:	681a      	ldr	r2, [r3, #0]
 800a91a:	68db      	ldr	r3, [r3, #12]
 800a91c:	4293      	cmp	r3, r2
 800a91e:	d107      	bne.n	800a930 <oslib_test_002_001_execute.lto_priv.39+0xd0>
 800a920:	4b73      	ldr	r3, [pc, #460]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800a922:	689b      	ldr	r3, [r3, #8]
 800a924:	429a      	cmp	r2, r3
 800a926:	d105      	bne.n	800a934 <oslib_test_002_001_execute.lto_priv.39+0xd4>
 800a928:	4b71      	ldr	r3, [pc, #452]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800a92a:	691b      	ldr	r3, [r3, #16]
 800a92c:	b123      	cbz	r3, 800a938 <oslib_test_002_001_execute.lto_priv.39+0xd8>
 800a92e:	e004      	b.n	800a93a <oslib_test_002_001_execute.lto_priv.39+0xda>
 800a930:	2000      	movs	r0, #0
 800a932:	e002      	b.n	800a93a <oslib_test_002_001_execute.lto_priv.39+0xda>
 800a934:	2000      	movs	r0, #0
 800a936:	e000      	b.n	800a93a <oslib_test_002_001_execute.lto_priv.39+0xda>
 800a938:	2001      	movs	r0, #1
 800a93a:	496e      	ldr	r1, [pc, #440]	; (800aaf4 <oslib_test_002_001_execute.lto_priv.39+0x294>)
 800a93c:	f002 fc38 	bl	800d1b0 <_test_assert>
 800a940:	2800      	cmp	r0, #0
 800a942:	f040 8219 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
  test_set_step(4);
 800a946:	2204      	movs	r2, #4
 800a948:	4b68      	ldr	r3, [pc, #416]	; (800aaec <oslib_test_002_001_execute.lto_priv.39+0x28c>)
 800a94a:	601a      	str	r2, [r3, #0]
 *
 * @api
 */
static inline void chPipeResume(pipe_t *pp) {

  pp->reset = false;
 800a94c:	4b68      	ldr	r3, [pc, #416]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800a94e:	2200      	movs	r2, #0
 800a950:	751a      	strb	r2, [r3, #20]
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 800a952:	681a      	ldr	r2, [r3, #0]
 800a954:	68db      	ldr	r3, [r3, #12]
 800a956:	4293      	cmp	r3, r2
 800a958:	d10b      	bne.n	800a972 <oslib_test_002_001_execute.lto_priv.39+0x112>
 800a95a:	4b65      	ldr	r3, [pc, #404]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800a95c:	689b      	ldr	r3, [r3, #8]
 800a95e:	429a      	cmp	r2, r3
 800a960:	d104      	bne.n	800a96c <oslib_test_002_001_execute.lto_priv.39+0x10c>
 800a962:	4b63      	ldr	r3, [pc, #396]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800a964:	691b      	ldr	r3, [r3, #16]
 800a966:	b11b      	cbz	r3, 800a970 <oslib_test_002_001_execute.lto_priv.39+0x110>
 800a968:	2000      	movs	r0, #0
 800a96a:	e002      	b.n	800a972 <oslib_test_002_001_execute.lto_priv.39+0x112>
 800a96c:	2000      	movs	r0, #0
 800a96e:	e000      	b.n	800a972 <oslib_test_002_001_execute.lto_priv.39+0x112>
 800a970:	2001      	movs	r0, #1
 800a972:	4960      	ldr	r1, [pc, #384]	; (800aaf4 <oslib_test_002_001_execute.lto_priv.39+0x294>)
 800a974:	f002 fc1c 	bl	800d1b0 <_test_assert>
 800a978:	2800      	cmp	r0, #0
 800a97a:	f040 81fd 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
  test_set_step(5);
 800a97e:	2205      	movs	r2, #5
 800a980:	4b5a      	ldr	r3, [pc, #360]	; (800aaec <oslib_test_002_001_execute.lto_priv.39+0x28c>)
 800a982:	601a      	str	r2, [r3, #0]
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 800a984:	2300      	movs	r3, #0
 800a986:	2210      	movs	r2, #16
 800a988:	495b      	ldr	r1, [pc, #364]	; (800aaf8 <oslib_test_002_001_execute.lto_priv.39+0x298>)
 800a98a:	4859      	ldr	r0, [pc, #356]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800a98c:	f7fe fec0 	bl	8009710 <chPipeWriteTimeout>
    test_assert(n == PIPE_SIZE, "wrong size");
 800a990:	495b      	ldr	r1, [pc, #364]	; (800ab00 <oslib_test_002_001_execute.lto_priv.39+0x2a0>)
 800a992:	2810      	cmp	r0, #16
 800a994:	bf14      	ite	ne
 800a996:	2000      	movne	r0, #0
 800a998:	2001      	moveq	r0, #1
 800a99a:	f002 fc09 	bl	800d1b0 <_test_assert>
 800a99e:	2800      	cmp	r0, #0
 800a9a0:	f040 81ea 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 800a9a4:	4b52      	ldr	r3, [pc, #328]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800a9a6:	681a      	ldr	r2, [r3, #0]
 800a9a8:	68db      	ldr	r3, [r3, #12]
 800a9aa:	4293      	cmp	r3, r2
 800a9ac:	d108      	bne.n	800a9c0 <oslib_test_002_001_execute.lto_priv.39+0x160>
 800a9ae:	4b50      	ldr	r3, [pc, #320]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800a9b0:	689b      	ldr	r3, [r3, #8]
 800a9b2:	429a      	cmp	r2, r3
 800a9b4:	d106      	bne.n	800a9c4 <oslib_test_002_001_execute.lto_priv.39+0x164>
 800a9b6:	4b4e      	ldr	r3, [pc, #312]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800a9b8:	691b      	ldr	r3, [r3, #16]
 800a9ba:	2b10      	cmp	r3, #16
 800a9bc:	d004      	beq.n	800a9c8 <oslib_test_002_001_execute.lto_priv.39+0x168>
 800a9be:	e004      	b.n	800a9ca <oslib_test_002_001_execute.lto_priv.39+0x16a>
 800a9c0:	2000      	movs	r0, #0
 800a9c2:	e002      	b.n	800a9ca <oslib_test_002_001_execute.lto_priv.39+0x16a>
 800a9c4:	2000      	movs	r0, #0
 800a9c6:	e000      	b.n	800a9ca <oslib_test_002_001_execute.lto_priv.39+0x16a>
 800a9c8:	2001      	movs	r0, #1
 800a9ca:	494a      	ldr	r1, [pc, #296]	; (800aaf4 <oslib_test_002_001_execute.lto_priv.39+0x294>)
 800a9cc:	f002 fbf0 	bl	800d1b0 <_test_assert>
 800a9d0:	2800      	cmp	r0, #0
 800a9d2:	f040 81d1 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
  test_set_step(6);
 800a9d6:	2206      	movs	r2, #6
 800a9d8:	4b44      	ldr	r3, [pc, #272]	; (800aaec <oslib_test_002_001_execute.lto_priv.39+0x28c>)
 800a9da:	601a      	str	r2, [r3, #0]
    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 800a9dc:	2300      	movs	r3, #0
 800a9de:	2210      	movs	r2, #16
 800a9e0:	4669      	mov	r1, sp
 800a9e2:	4843      	ldr	r0, [pc, #268]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800a9e4:	f7fe fe5c 	bl	80096a0 <chPipeReadTimeout>
    test_assert(n == PIPE_SIZE, "wrong size");
 800a9e8:	4945      	ldr	r1, [pc, #276]	; (800ab00 <oslib_test_002_001_execute.lto_priv.39+0x2a0>)
 800a9ea:	2810      	cmp	r0, #16
 800a9ec:	bf14      	ite	ne
 800a9ee:	2000      	movne	r0, #0
 800a9f0:	2001      	moveq	r0, #1
 800a9f2:	f002 fbdd 	bl	800d1b0 <_test_assert>
 800a9f6:	2800      	cmp	r0, #0
 800a9f8:	f040 81be 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 800a9fc:	4a3c      	ldr	r2, [pc, #240]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800a9fe:	6813      	ldr	r3, [r2, #0]
 800aa00:	68d2      	ldr	r2, [r2, #12]
 800aa02:	429a      	cmp	r2, r3
 800aa04:	d107      	bne.n	800aa16 <oslib_test_002_001_execute.lto_priv.39+0x1b6>
 800aa06:	4a3a      	ldr	r2, [pc, #232]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800aa08:	6892      	ldr	r2, [r2, #8]
 800aa0a:	4293      	cmp	r3, r2
 800aa0c:	d105      	bne.n	800aa1a <oslib_test_002_001_execute.lto_priv.39+0x1ba>
 800aa0e:	4b38      	ldr	r3, [pc, #224]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800aa10:	691b      	ldr	r3, [r3, #16]
 800aa12:	b123      	cbz	r3, 800aa1e <oslib_test_002_001_execute.lto_priv.39+0x1be>
 800aa14:	e004      	b.n	800aa20 <oslib_test_002_001_execute.lto_priv.39+0x1c0>
 800aa16:	2000      	movs	r0, #0
 800aa18:	e002      	b.n	800aa20 <oslib_test_002_001_execute.lto_priv.39+0x1c0>
 800aa1a:	2000      	movs	r0, #0
 800aa1c:	e000      	b.n	800aa20 <oslib_test_002_001_execute.lto_priv.39+0x1c0>
 800aa1e:	2001      	movs	r0, #1
 800aa20:	4934      	ldr	r1, [pc, #208]	; (800aaf4 <oslib_test_002_001_execute.lto_priv.39+0x294>)
 800aa22:	f002 fbc5 	bl	800d1b0 <_test_assert>
 800aa26:	2800      	cmp	r0, #0
 800aa28:	f040 81a6 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
    test_assert(memcmp(pipe_pattern, buf, PIPE_SIZE) == 0, "content mismatch");
 800aa2c:	2210      	movs	r2, #16
 800aa2e:	4669      	mov	r1, sp
 800aa30:	4831      	ldr	r0, [pc, #196]	; (800aaf8 <oslib_test_002_001_execute.lto_priv.39+0x298>)
 800aa32:	f7f7 fb29 	bl	8002088 <memcmp>
 800aa36:	4933      	ldr	r1, [pc, #204]	; (800ab04 <oslib_test_002_001_execute.lto_priv.39+0x2a4>)
 800aa38:	fab0 f080 	clz	r0, r0
 800aa3c:	0940      	lsrs	r0, r0, #5
 800aa3e:	f002 fbb7 	bl	800d1b0 <_test_assert>
 800aa42:	2800      	cmp	r0, #0
 800aa44:	f040 8198 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
  test_set_step(7);
 800aa48:	2207      	movs	r2, #7
 800aa4a:	4b28      	ldr	r3, [pc, #160]	; (800aaec <oslib_test_002_001_execute.lto_priv.39+0x28c>)
 800aa4c:	601a      	str	r2, [r3, #0]
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, 4, TIME_IMMEDIATE);
 800aa4e:	2300      	movs	r3, #0
 800aa50:	2204      	movs	r2, #4
 800aa52:	4929      	ldr	r1, [pc, #164]	; (800aaf8 <oslib_test_002_001_execute.lto_priv.39+0x298>)
 800aa54:	4826      	ldr	r0, [pc, #152]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800aa56:	f7fe fe5b 	bl	8009710 <chPipeWriteTimeout>
    test_assert(n == 4, "wrong size");
 800aa5a:	4929      	ldr	r1, [pc, #164]	; (800ab00 <oslib_test_002_001_execute.lto_priv.39+0x2a0>)
 800aa5c:	2804      	cmp	r0, #4
 800aa5e:	bf14      	ite	ne
 800aa60:	2000      	movne	r0, #0
 800aa62:	2001      	moveq	r0, #1
 800aa64:	f002 fba4 	bl	800d1b0 <_test_assert>
 800aa68:	2800      	cmp	r0, #0
 800aa6a:	f040 8185 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
    test_assert((pipe1.rdptr != pipe1.wrptr) &&
 800aa6e:	4a20      	ldr	r2, [pc, #128]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800aa70:	68d3      	ldr	r3, [r2, #12]
 800aa72:	6892      	ldr	r2, [r2, #8]
 800aa74:	4293      	cmp	r3, r2
 800aa76:	d008      	beq.n	800aa8a <oslib_test_002_001_execute.lto_priv.39+0x22a>
 800aa78:	4a1d      	ldr	r2, [pc, #116]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800aa7a:	6812      	ldr	r2, [r2, #0]
 800aa7c:	4293      	cmp	r3, r2
 800aa7e:	d106      	bne.n	800aa8e <oslib_test_002_001_execute.lto_priv.39+0x22e>
 800aa80:	4b1b      	ldr	r3, [pc, #108]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800aa82:	691b      	ldr	r3, [r3, #16]
 800aa84:	2b04      	cmp	r3, #4
 800aa86:	d004      	beq.n	800aa92 <oslib_test_002_001_execute.lto_priv.39+0x232>
 800aa88:	e004      	b.n	800aa94 <oslib_test_002_001_execute.lto_priv.39+0x234>
 800aa8a:	2000      	movs	r0, #0
 800aa8c:	e002      	b.n	800aa94 <oslib_test_002_001_execute.lto_priv.39+0x234>
 800aa8e:	2000      	movs	r0, #0
 800aa90:	e000      	b.n	800aa94 <oslib_test_002_001_execute.lto_priv.39+0x234>
 800aa92:	2001      	movs	r0, #1
 800aa94:	4917      	ldr	r1, [pc, #92]	; (800aaf4 <oslib_test_002_001_execute.lto_priv.39+0x294>)
 800aa96:	f002 fb8b 	bl	800d1b0 <_test_assert>
 800aa9a:	2800      	cmp	r0, #0
 800aa9c:	f040 816c 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
  test_set_step(8);
 800aaa0:	2208      	movs	r2, #8
 800aaa2:	4b12      	ldr	r3, [pc, #72]	; (800aaec <oslib_test_002_001_execute.lto_priv.39+0x28c>)
 800aaa4:	601a      	str	r2, [r3, #0]
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE - 4, TIME_IMMEDIATE);
 800aaa6:	2300      	movs	r3, #0
 800aaa8:	220c      	movs	r2, #12
 800aaaa:	4913      	ldr	r1, [pc, #76]	; (800aaf8 <oslib_test_002_001_execute.lto_priv.39+0x298>)
 800aaac:	4810      	ldr	r0, [pc, #64]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800aaae:	f7fe fe2f 	bl	8009710 <chPipeWriteTimeout>
    test_assert(n == PIPE_SIZE - 4, "wrong size");
 800aab2:	4913      	ldr	r1, [pc, #76]	; (800ab00 <oslib_test_002_001_execute.lto_priv.39+0x2a0>)
 800aab4:	280c      	cmp	r0, #12
 800aab6:	bf14      	ite	ne
 800aab8:	2000      	movne	r0, #0
 800aaba:	2001      	moveq	r0, #1
 800aabc:	f002 fb78 	bl	800d1b0 <_test_assert>
 800aac0:	2800      	cmp	r0, #0
 800aac2:	f040 8159 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 800aac6:	4a0a      	ldr	r2, [pc, #40]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800aac8:	6813      	ldr	r3, [r2, #0]
 800aaca:	68d2      	ldr	r2, [r2, #12]
 800aacc:	429a      	cmp	r2, r3
 800aace:	d108      	bne.n	800aae2 <oslib_test_002_001_execute.lto_priv.39+0x282>
 800aad0:	4a07      	ldr	r2, [pc, #28]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800aad2:	6892      	ldr	r2, [r2, #8]
 800aad4:	4293      	cmp	r3, r2
 800aad6:	d106      	bne.n	800aae6 <oslib_test_002_001_execute.lto_priv.39+0x286>
 800aad8:	4b05      	ldr	r3, [pc, #20]	; (800aaf0 <oslib_test_002_001_execute.lto_priv.39+0x290>)
 800aada:	691b      	ldr	r3, [r3, #16]
 800aadc:	2b10      	cmp	r3, #16
 800aade:	d013      	beq.n	800ab08 <oslib_test_002_001_execute.lto_priv.39+0x2a8>
 800aae0:	e013      	b.n	800ab0a <oslib_test_002_001_execute.lto_priv.39+0x2aa>
 800aae2:	2000      	movs	r0, #0
 800aae4:	e011      	b.n	800ab0a <oslib_test_002_001_execute.lto_priv.39+0x2aa>
 800aae6:	2000      	movs	r0, #0
 800aae8:	e00f      	b.n	800ab0a <oslib_test_002_001_execute.lto_priv.39+0x2aa>
 800aaea:	bf00      	nop
 800aaec:	20003e04 	.word	0x20003e04
 800aaf0:	200024bc 	.word	0x200024bc
 800aaf4:	08010034 	.word	0x08010034
 800aaf8:	0800ff70 	.word	0x0800ff70
 800aafc:	08010048 	.word	0x08010048
 800ab00:	0800e494 	.word	0x0800e494
 800ab04:	08010054 	.word	0x08010054
 800ab08:	2001      	movs	r0, #1
 800ab0a:	499c      	ldr	r1, [pc, #624]	; (800ad7c <oslib_test_002_001_execute.lto_priv.39+0x51c>)
 800ab0c:	f002 fb50 	bl	800d1b0 <_test_assert>
 800ab10:	2800      	cmp	r0, #0
 800ab12:	f040 8131 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
  test_set_step(9);
 800ab16:	2209      	movs	r2, #9
 800ab18:	4b99      	ldr	r3, [pc, #612]	; (800ad80 <oslib_test_002_001_execute.lto_priv.39+0x520>)
 800ab1a:	601a      	str	r2, [r3, #0]
    n = chPipeReadTimeout(&pipe1, buf, 4, TIME_IMMEDIATE);
 800ab1c:	2300      	movs	r3, #0
 800ab1e:	2204      	movs	r2, #4
 800ab20:	4669      	mov	r1, sp
 800ab22:	4898      	ldr	r0, [pc, #608]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800ab24:	f7fe fdbc 	bl	80096a0 <chPipeReadTimeout>
    test_assert(n == 4, "wrong size");
 800ab28:	4997      	ldr	r1, [pc, #604]	; (800ad88 <oslib_test_002_001_execute.lto_priv.39+0x528>)
 800ab2a:	2804      	cmp	r0, #4
 800ab2c:	bf14      	ite	ne
 800ab2e:	2000      	movne	r0, #0
 800ab30:	2001      	moveq	r0, #1
 800ab32:	f002 fb3d 	bl	800d1b0 <_test_assert>
 800ab36:	2800      	cmp	r0, #0
 800ab38:	f040 811e 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
    test_assert((pipe1.rdptr != pipe1.buffer) &&
 800ab3c:	4a91      	ldr	r2, [pc, #580]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800ab3e:	6813      	ldr	r3, [r2, #0]
 800ab40:	68d2      	ldr	r2, [r2, #12]
 800ab42:	429a      	cmp	r2, r3
 800ab44:	d008      	beq.n	800ab58 <oslib_test_002_001_execute.lto_priv.39+0x2f8>
 800ab46:	4a8f      	ldr	r2, [pc, #572]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800ab48:	6892      	ldr	r2, [r2, #8]
 800ab4a:	4293      	cmp	r3, r2
 800ab4c:	d106      	bne.n	800ab5c <oslib_test_002_001_execute.lto_priv.39+0x2fc>
 800ab4e:	4b8d      	ldr	r3, [pc, #564]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800ab50:	691b      	ldr	r3, [r3, #16]
 800ab52:	2b0c      	cmp	r3, #12
 800ab54:	d004      	beq.n	800ab60 <oslib_test_002_001_execute.lto_priv.39+0x300>
 800ab56:	e004      	b.n	800ab62 <oslib_test_002_001_execute.lto_priv.39+0x302>
 800ab58:	2000      	movs	r0, #0
 800ab5a:	e002      	b.n	800ab62 <oslib_test_002_001_execute.lto_priv.39+0x302>
 800ab5c:	2000      	movs	r0, #0
 800ab5e:	e000      	b.n	800ab62 <oslib_test_002_001_execute.lto_priv.39+0x302>
 800ab60:	2001      	movs	r0, #1
 800ab62:	4986      	ldr	r1, [pc, #536]	; (800ad7c <oslib_test_002_001_execute.lto_priv.39+0x51c>)
 800ab64:	f002 fb24 	bl	800d1b0 <_test_assert>
 800ab68:	2800      	cmp	r0, #0
 800ab6a:	f040 8105 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
    test_assert(memcmp(pipe_pattern, buf, 4) == 0, "content mismatch");
 800ab6e:	2204      	movs	r2, #4
 800ab70:	4669      	mov	r1, sp
 800ab72:	4886      	ldr	r0, [pc, #536]	; (800ad8c <oslib_test_002_001_execute.lto_priv.39+0x52c>)
 800ab74:	f7f7 fa88 	bl	8002088 <memcmp>
 800ab78:	4985      	ldr	r1, [pc, #532]	; (800ad90 <oslib_test_002_001_execute.lto_priv.39+0x530>)
 800ab7a:	fab0 f080 	clz	r0, r0
 800ab7e:	0940      	lsrs	r0, r0, #5
 800ab80:	f002 fb16 	bl	800d1b0 <_test_assert>
 800ab84:	2800      	cmp	r0, #0
 800ab86:	f040 80f7 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
  test_set_step(10);
 800ab8a:	220a      	movs	r2, #10
 800ab8c:	4b7c      	ldr	r3, [pc, #496]	; (800ad80 <oslib_test_002_001_execute.lto_priv.39+0x520>)
 800ab8e:	601a      	str	r2, [r3, #0]
    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE - 4, TIME_IMMEDIATE);
 800ab90:	2300      	movs	r3, #0
 800ab92:	220c      	movs	r2, #12
 800ab94:	4669      	mov	r1, sp
 800ab96:	487b      	ldr	r0, [pc, #492]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800ab98:	f7fe fd82 	bl	80096a0 <chPipeReadTimeout>
    test_assert(n == PIPE_SIZE - 4, "wrong size");
 800ab9c:	497a      	ldr	r1, [pc, #488]	; (800ad88 <oslib_test_002_001_execute.lto_priv.39+0x528>)
 800ab9e:	280c      	cmp	r0, #12
 800aba0:	bf14      	ite	ne
 800aba2:	2000      	movne	r0, #0
 800aba4:	2001      	moveq	r0, #1
 800aba6:	f002 fb03 	bl	800d1b0 <_test_assert>
 800abaa:	2800      	cmp	r0, #0
 800abac:	f040 80e4 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 800abb0:	4a74      	ldr	r2, [pc, #464]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800abb2:	6813      	ldr	r3, [r2, #0]
 800abb4:	68d2      	ldr	r2, [r2, #12]
 800abb6:	429a      	cmp	r2, r3
 800abb8:	d107      	bne.n	800abca <oslib_test_002_001_execute.lto_priv.39+0x36a>
 800abba:	4a72      	ldr	r2, [pc, #456]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800abbc:	6892      	ldr	r2, [r2, #8]
 800abbe:	4293      	cmp	r3, r2
 800abc0:	d105      	bne.n	800abce <oslib_test_002_001_execute.lto_priv.39+0x36e>
 800abc2:	4b70      	ldr	r3, [pc, #448]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800abc4:	691b      	ldr	r3, [r3, #16]
 800abc6:	b123      	cbz	r3, 800abd2 <oslib_test_002_001_execute.lto_priv.39+0x372>
 800abc8:	e004      	b.n	800abd4 <oslib_test_002_001_execute.lto_priv.39+0x374>
 800abca:	2000      	movs	r0, #0
 800abcc:	e002      	b.n	800abd4 <oslib_test_002_001_execute.lto_priv.39+0x374>
 800abce:	2000      	movs	r0, #0
 800abd0:	e000      	b.n	800abd4 <oslib_test_002_001_execute.lto_priv.39+0x374>
 800abd2:	2001      	movs	r0, #1
 800abd4:	4969      	ldr	r1, [pc, #420]	; (800ad7c <oslib_test_002_001_execute.lto_priv.39+0x51c>)
 800abd6:	f002 faeb 	bl	800d1b0 <_test_assert>
 800abda:	2800      	cmp	r0, #0
 800abdc:	f040 80cc 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
    test_assert(memcmp(pipe_pattern, buf, PIPE_SIZE - 4) == 0, "content mismatch");
 800abe0:	220c      	movs	r2, #12
 800abe2:	4669      	mov	r1, sp
 800abe4:	4869      	ldr	r0, [pc, #420]	; (800ad8c <oslib_test_002_001_execute.lto_priv.39+0x52c>)
 800abe6:	f7f7 fa4f 	bl	8002088 <memcmp>
 800abea:	4969      	ldr	r1, [pc, #420]	; (800ad90 <oslib_test_002_001_execute.lto_priv.39+0x530>)
 800abec:	fab0 f080 	clz	r0, r0
 800abf0:	0940      	lsrs	r0, r0, #5
 800abf2:	f002 fadd 	bl	800d1b0 <_test_assert>
 800abf6:	2800      	cmp	r0, #0
 800abf8:	f040 80be 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
  test_set_step(11);
 800abfc:	220b      	movs	r2, #11
 800abfe:	4b60      	ldr	r3, [pc, #384]	; (800ad80 <oslib_test_002_001_execute.lto_priv.39+0x520>)
 800ac00:	601a      	str	r2, [r3, #0]
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, 5, TIME_IMMEDIATE);
 800ac02:	2300      	movs	r3, #0
 800ac04:	2205      	movs	r2, #5
 800ac06:	4961      	ldr	r1, [pc, #388]	; (800ad8c <oslib_test_002_001_execute.lto_priv.39+0x52c>)
 800ac08:	485e      	ldr	r0, [pc, #376]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800ac0a:	f7fe fd81 	bl	8009710 <chPipeWriteTimeout>
    test_assert(n == 5, "wrong size");
 800ac0e:	495e      	ldr	r1, [pc, #376]	; (800ad88 <oslib_test_002_001_execute.lto_priv.39+0x528>)
 800ac10:	2805      	cmp	r0, #5
 800ac12:	bf14      	ite	ne
 800ac14:	2000      	movne	r0, #0
 800ac16:	2001      	moveq	r0, #1
 800ac18:	f002 faca 	bl	800d1b0 <_test_assert>
 800ac1c:	2800      	cmp	r0, #0
 800ac1e:	f040 80ab 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
    test_assert((pipe1.rdptr != pipe1.wrptr) &&
 800ac22:	4a58      	ldr	r2, [pc, #352]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800ac24:	68d3      	ldr	r3, [r2, #12]
 800ac26:	6892      	ldr	r2, [r2, #8]
 800ac28:	4293      	cmp	r3, r2
 800ac2a:	d008      	beq.n	800ac3e <oslib_test_002_001_execute.lto_priv.39+0x3de>
 800ac2c:	4a55      	ldr	r2, [pc, #340]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800ac2e:	6812      	ldr	r2, [r2, #0]
 800ac30:	4293      	cmp	r3, r2
 800ac32:	d106      	bne.n	800ac42 <oslib_test_002_001_execute.lto_priv.39+0x3e2>
 800ac34:	4b53      	ldr	r3, [pc, #332]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800ac36:	691b      	ldr	r3, [r3, #16]
 800ac38:	2b05      	cmp	r3, #5
 800ac3a:	d004      	beq.n	800ac46 <oslib_test_002_001_execute.lto_priv.39+0x3e6>
 800ac3c:	e004      	b.n	800ac48 <oslib_test_002_001_execute.lto_priv.39+0x3e8>
 800ac3e:	2000      	movs	r0, #0
 800ac40:	e002      	b.n	800ac48 <oslib_test_002_001_execute.lto_priv.39+0x3e8>
 800ac42:	2000      	movs	r0, #0
 800ac44:	e000      	b.n	800ac48 <oslib_test_002_001_execute.lto_priv.39+0x3e8>
 800ac46:	2001      	movs	r0, #1
 800ac48:	494c      	ldr	r1, [pc, #304]	; (800ad7c <oslib_test_002_001_execute.lto_priv.39+0x51c>)
 800ac4a:	f002 fab1 	bl	800d1b0 <_test_assert>
 800ac4e:	2800      	cmp	r0, #0
 800ac50:	f040 8092 	bne.w	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
  test_set_step(12);
 800ac54:	220c      	movs	r2, #12
 800ac56:	4b4a      	ldr	r3, [pc, #296]	; (800ad80 <oslib_test_002_001_execute.lto_priv.39+0x520>)
 800ac58:	601a      	str	r2, [r3, #0]
    n = chPipeReadTimeout(&pipe1, buf, 5, TIME_IMMEDIATE);
 800ac5a:	2300      	movs	r3, #0
 800ac5c:	2205      	movs	r2, #5
 800ac5e:	4669      	mov	r1, sp
 800ac60:	4848      	ldr	r0, [pc, #288]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800ac62:	f7fe fd1d 	bl	80096a0 <chPipeReadTimeout>
    test_assert(n == 5, "wrong size");
 800ac66:	4948      	ldr	r1, [pc, #288]	; (800ad88 <oslib_test_002_001_execute.lto_priv.39+0x528>)
 800ac68:	2805      	cmp	r0, #5
 800ac6a:	bf14      	ite	ne
 800ac6c:	2000      	movne	r0, #0
 800ac6e:	2001      	moveq	r0, #1
 800ac70:	f002 fa9e 	bl	800d1b0 <_test_assert>
 800ac74:	2800      	cmp	r0, #0
 800ac76:	d17f      	bne.n	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 800ac78:	4a42      	ldr	r2, [pc, #264]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800ac7a:	6893      	ldr	r3, [r2, #8]
 800ac7c:	68d2      	ldr	r2, [r2, #12]
 800ac7e:	429a      	cmp	r2, r3
 800ac80:	d107      	bne.n	800ac92 <oslib_test_002_001_execute.lto_priv.39+0x432>
 800ac82:	4a40      	ldr	r2, [pc, #256]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800ac84:	6812      	ldr	r2, [r2, #0]
 800ac86:	4293      	cmp	r3, r2
 800ac88:	d005      	beq.n	800ac96 <oslib_test_002_001_execute.lto_priv.39+0x436>
 800ac8a:	4b3e      	ldr	r3, [pc, #248]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800ac8c:	691b      	ldr	r3, [r3, #16]
 800ac8e:	b123      	cbz	r3, 800ac9a <oslib_test_002_001_execute.lto_priv.39+0x43a>
 800ac90:	e004      	b.n	800ac9c <oslib_test_002_001_execute.lto_priv.39+0x43c>
 800ac92:	2000      	movs	r0, #0
 800ac94:	e002      	b.n	800ac9c <oslib_test_002_001_execute.lto_priv.39+0x43c>
 800ac96:	2000      	movs	r0, #0
 800ac98:	e000      	b.n	800ac9c <oslib_test_002_001_execute.lto_priv.39+0x43c>
 800ac9a:	2001      	movs	r0, #1
 800ac9c:	4937      	ldr	r1, [pc, #220]	; (800ad7c <oslib_test_002_001_execute.lto_priv.39+0x51c>)
 800ac9e:	f002 fa87 	bl	800d1b0 <_test_assert>
 800aca2:	2800      	cmp	r0, #0
 800aca4:	d168      	bne.n	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
    test_assert(memcmp(pipe_pattern, buf, 5) == 0, "content mismatch");
 800aca6:	2205      	movs	r2, #5
 800aca8:	4669      	mov	r1, sp
 800acaa:	4838      	ldr	r0, [pc, #224]	; (800ad8c <oslib_test_002_001_execute.lto_priv.39+0x52c>)
 800acac:	f7f7 f9ec 	bl	8002088 <memcmp>
 800acb0:	4937      	ldr	r1, [pc, #220]	; (800ad90 <oslib_test_002_001_execute.lto_priv.39+0x530>)
 800acb2:	fab0 f080 	clz	r0, r0
 800acb6:	0940      	lsrs	r0, r0, #5
 800acb8:	f002 fa7a 	bl	800d1b0 <_test_assert>
 800acbc:	2800      	cmp	r0, #0
 800acbe:	d15b      	bne.n	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
  test_set_step(13);
 800acc0:	220d      	movs	r2, #13
 800acc2:	4b2f      	ldr	r3, [pc, #188]	; (800ad80 <oslib_test_002_001_execute.lto_priv.39+0x520>)
 800acc4:	601a      	str	r2, [r3, #0]
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 800acc6:	2300      	movs	r3, #0
 800acc8:	2210      	movs	r2, #16
 800acca:	4930      	ldr	r1, [pc, #192]	; (800ad8c <oslib_test_002_001_execute.lto_priv.39+0x52c>)
 800accc:	482d      	ldr	r0, [pc, #180]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800acce:	f7fe fd1f 	bl	8009710 <chPipeWriteTimeout>
    test_assert(n == PIPE_SIZE, "wrong size");
 800acd2:	492d      	ldr	r1, [pc, #180]	; (800ad88 <oslib_test_002_001_execute.lto_priv.39+0x528>)
 800acd4:	2810      	cmp	r0, #16
 800acd6:	bf14      	ite	ne
 800acd8:	2000      	movne	r0, #0
 800acda:	2001      	moveq	r0, #1
 800acdc:	f002 fa68 	bl	800d1b0 <_test_assert>
 800ace0:	2800      	cmp	r0, #0
 800ace2:	d149      	bne.n	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 800ace4:	4a27      	ldr	r2, [pc, #156]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800ace6:	6893      	ldr	r3, [r2, #8]
 800ace8:	68d2      	ldr	r2, [r2, #12]
 800acea:	429a      	cmp	r2, r3
 800acec:	d108      	bne.n	800ad00 <oslib_test_002_001_execute.lto_priv.39+0x4a0>
 800acee:	4a25      	ldr	r2, [pc, #148]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800acf0:	6812      	ldr	r2, [r2, #0]
 800acf2:	4293      	cmp	r3, r2
 800acf4:	d006      	beq.n	800ad04 <oslib_test_002_001_execute.lto_priv.39+0x4a4>
 800acf6:	4b23      	ldr	r3, [pc, #140]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800acf8:	691b      	ldr	r3, [r3, #16]
 800acfa:	2b10      	cmp	r3, #16
 800acfc:	d004      	beq.n	800ad08 <oslib_test_002_001_execute.lto_priv.39+0x4a8>
 800acfe:	e004      	b.n	800ad0a <oslib_test_002_001_execute.lto_priv.39+0x4aa>
 800ad00:	2000      	movs	r0, #0
 800ad02:	e002      	b.n	800ad0a <oslib_test_002_001_execute.lto_priv.39+0x4aa>
 800ad04:	2000      	movs	r0, #0
 800ad06:	e000      	b.n	800ad0a <oslib_test_002_001_execute.lto_priv.39+0x4aa>
 800ad08:	2001      	movs	r0, #1
 800ad0a:	491c      	ldr	r1, [pc, #112]	; (800ad7c <oslib_test_002_001_execute.lto_priv.39+0x51c>)
 800ad0c:	f002 fa50 	bl	800d1b0 <_test_assert>
 800ad10:	2800      	cmp	r0, #0
 800ad12:	d131      	bne.n	800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
  test_set_step(14);
 800ad14:	220e      	movs	r2, #14
 800ad16:	4b1a      	ldr	r3, [pc, #104]	; (800ad80 <oslib_test_002_001_execute.lto_priv.39+0x520>)
 800ad18:	601a      	str	r2, [r3, #0]
    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 800ad1a:	2300      	movs	r3, #0
 800ad1c:	2210      	movs	r2, #16
 800ad1e:	4669      	mov	r1, sp
 800ad20:	4818      	ldr	r0, [pc, #96]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800ad22:	f7fe fcbd 	bl	80096a0 <chPipeReadTimeout>
    test_assert(n == PIPE_SIZE, "wrong size");
 800ad26:	4918      	ldr	r1, [pc, #96]	; (800ad88 <oslib_test_002_001_execute.lto_priv.39+0x528>)
 800ad28:	2810      	cmp	r0, #16
 800ad2a:	bf14      	ite	ne
 800ad2c:	2000      	movne	r0, #0
 800ad2e:	2001      	moveq	r0, #1
 800ad30:	f002 fa3e 	bl	800d1b0 <_test_assert>
 800ad34:	bb00      	cbnz	r0, 800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 800ad36:	4a13      	ldr	r2, [pc, #76]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800ad38:	6893      	ldr	r3, [r2, #8]
 800ad3a:	68d2      	ldr	r2, [r2, #12]
 800ad3c:	429a      	cmp	r2, r3
 800ad3e:	d107      	bne.n	800ad50 <oslib_test_002_001_execute.lto_priv.39+0x4f0>
 800ad40:	4a10      	ldr	r2, [pc, #64]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800ad42:	6812      	ldr	r2, [r2, #0]
 800ad44:	4293      	cmp	r3, r2
 800ad46:	d005      	beq.n	800ad54 <oslib_test_002_001_execute.lto_priv.39+0x4f4>
 800ad48:	4b0e      	ldr	r3, [pc, #56]	; (800ad84 <oslib_test_002_001_execute.lto_priv.39+0x524>)
 800ad4a:	691b      	ldr	r3, [r3, #16]
 800ad4c:	b123      	cbz	r3, 800ad58 <oslib_test_002_001_execute.lto_priv.39+0x4f8>
 800ad4e:	e004      	b.n	800ad5a <oslib_test_002_001_execute.lto_priv.39+0x4fa>
 800ad50:	2000      	movs	r0, #0
 800ad52:	e002      	b.n	800ad5a <oslib_test_002_001_execute.lto_priv.39+0x4fa>
 800ad54:	2000      	movs	r0, #0
 800ad56:	e000      	b.n	800ad5a <oslib_test_002_001_execute.lto_priv.39+0x4fa>
 800ad58:	2001      	movs	r0, #1
 800ad5a:	4908      	ldr	r1, [pc, #32]	; (800ad7c <oslib_test_002_001_execute.lto_priv.39+0x51c>)
 800ad5c:	f002 fa28 	bl	800d1b0 <_test_assert>
 800ad60:	b950      	cbnz	r0, 800ad78 <oslib_test_002_001_execute.lto_priv.39+0x518>
    test_assert(memcmp(pipe_pattern, buf, PIPE_SIZE) == 0, "content mismatch");
 800ad62:	2210      	movs	r2, #16
 800ad64:	4669      	mov	r1, sp
 800ad66:	4809      	ldr	r0, [pc, #36]	; (800ad8c <oslib_test_002_001_execute.lto_priv.39+0x52c>)
 800ad68:	f7f7 f98e 	bl	8002088 <memcmp>
 800ad6c:	4908      	ldr	r1, [pc, #32]	; (800ad90 <oslib_test_002_001_execute.lto_priv.39+0x530>)
 800ad6e:	fab0 f080 	clz	r0, r0
 800ad72:	0940      	lsrs	r0, r0, #5
 800ad74:	f002 fa1c 	bl	800d1b0 <_test_assert>
}
 800ad78:	b004      	add	sp, #16
 800ad7a:	bd10      	pop	{r4, pc}
 800ad7c:	08010034 	.word	0x08010034
 800ad80:	20003e04 	.word	0x20003e04
 800ad84:	200024bc 	.word	0x200024bc
 800ad88:	0800e494 	.word	0x0800e494
 800ad8c:	0800ff70 	.word	0x0800ff70
 800ad90:	08010054 	.word	0x08010054
	...

0800ada0 <oslib_test_001_003_teardown.lto_priv.36>:

static void oslib_test_001_003_setup(void) {
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}

static void oslib_test_001_003_teardown(void) {
 800ada0:	b508      	push	{r3, lr}
  chMBReset(&mb1);
 800ada2:	4802      	ldr	r0, [pc, #8]	; (800adac <oslib_test_001_003_teardown.lto_priv.36+0xc>)
 800ada4:	f7fe fffc 	bl	8009da0 <chMBReset>
 800ada8:	bd08      	pop	{r3, pc}
 800adaa:	bf00      	nop
 800adac:	20002494 	.word	0x20002494

0800adb0 <oslib_test_001_003_execute.lto_priv.37>:
}

static void oslib_test_001_003_execute(void) {
 800adb0:	b530      	push	{r4, r5, lr}
 800adb2:	b083      	sub	sp, #12
  msg_t msg1, msg2;
  unsigned i;

  /* [1.3.1] Filling the mailbox.*/
  test_set_step(1);
 800adb4:	2201      	movs	r2, #1
 800adb6:	4b46      	ldr	r3, [pc, #280]	; (800aed0 <oslib_test_001_003_execute.lto_priv.37+0x120>)
 800adb8:	601a      	str	r2, [r3, #0]
  {
    for (i = 0; i < MB_SIZE; i++) {
 800adba:	2400      	movs	r4, #0
 800adbc:	e00f      	b.n	800adde <oslib_test_001_003_execute.lto_priv.37+0x2e>
      msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 800adbe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800adc2:	f104 0142 	add.w	r1, r4, #66	; 0x42
 800adc6:	4843      	ldr	r0, [pc, #268]	; (800aed4 <oslib_test_001_003_execute.lto_priv.37+0x124>)
 800adc8:	f7fe ffc2 	bl	8009d50 <chMBPostTimeout>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800adcc:	4942      	ldr	r1, [pc, #264]	; (800aed8 <oslib_test_001_003_execute.lto_priv.37+0x128>)
 800adce:	fab0 f080 	clz	r0, r0
 800add2:	0940      	lsrs	r0, r0, #5
 800add4:	f002 f9ec 	bl	800d1b0 <_test_assert>
 800add8:	2800      	cmp	r0, #0
 800adda:	d176      	bne.n	800aeca <oslib_test_001_003_execute.lto_priv.37+0x11a>
    for (i = 0; i < MB_SIZE; i++) {
 800addc:	3401      	adds	r4, #1
 800adde:	2c03      	cmp	r4, #3
 800ade0:	d9ed      	bls.n	800adbe <oslib_test_001_003_execute.lto_priv.37+0xe>
    }
  }

  /* [1.3.2] Testing chMBPostTimeout(), chMBPostI(),
     chMBPostAheadTimeout() and chMBPostAheadI() timeout.*/
  test_set_step(2);
 800ade2:	2202      	movs	r2, #2
 800ade4:	4b3a      	ldr	r3, [pc, #232]	; (800aed0 <oslib_test_001_003_execute.lto_priv.37+0x120>)
 800ade6:	601a      	str	r2, [r3, #0]
  {
    msg1 = chMBPostTimeout(&mb1, 'X', 1);
 800ade8:	2201      	movs	r2, #1
 800adea:	2158      	movs	r1, #88	; 0x58
 800adec:	4839      	ldr	r0, [pc, #228]	; (800aed4 <oslib_test_001_003_execute.lto_priv.37+0x124>)
 800adee:	f7fe ffaf 	bl	8009d50 <chMBPostTimeout>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800adf2:	4939      	ldr	r1, [pc, #228]	; (800aed8 <oslib_test_001_003_execute.lto_priv.37+0x128>)
 800adf4:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800adf8:	bf14      	ite	ne
 800adfa:	2000      	movne	r0, #0
 800adfc:	2001      	moveq	r0, #1
 800adfe:	f002 f9d7 	bl	800d1b0 <_test_assert>
 800ae02:	2800      	cmp	r0, #0
 800ae04:	d161      	bne.n	800aeca <oslib_test_001_003_execute.lto_priv.37+0x11a>
 800ae06:	2320      	movs	r3, #32
 800ae08:	f383 8811 	msr	BASEPRI, r3
    chSysLock();
    msg1 = chMBPostI(&mb1, 'X');
 800ae0c:	2158      	movs	r1, #88	; 0x58
 800ae0e:	4831      	ldr	r0, [pc, #196]	; (800aed4 <oslib_test_001_003_execute.lto_priv.37+0x124>)
 800ae10:	f7fe ff76 	bl	8009d00 <chMBPostI>
 800ae14:	2300      	movs	r3, #0
 800ae16:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800ae1a:	492f      	ldr	r1, [pc, #188]	; (800aed8 <oslib_test_001_003_execute.lto_priv.37+0x128>)
 800ae1c:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800ae20:	bf14      	ite	ne
 800ae22:	2000      	movne	r0, #0
 800ae24:	2001      	moveq	r0, #1
 800ae26:	f002 f9c3 	bl	800d1b0 <_test_assert>
 800ae2a:	2800      	cmp	r0, #0
 800ae2c:	d14d      	bne.n	800aeca <oslib_test_001_003_execute.lto_priv.37+0x11a>
    msg1 = chMBPostAheadTimeout(&mb1, 'X', 1);
 800ae2e:	2201      	movs	r2, #1
 800ae30:	2158      	movs	r1, #88	; 0x58
 800ae32:	4828      	ldr	r0, [pc, #160]	; (800aed4 <oslib_test_001_003_execute.lto_priv.37+0x124>)
 800ae34:	f7fe ff54 	bl	8009ce0 <chMBPostAheadTimeout>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800ae38:	4927      	ldr	r1, [pc, #156]	; (800aed8 <oslib_test_001_003_execute.lto_priv.37+0x128>)
 800ae3a:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800ae3e:	bf14      	ite	ne
 800ae40:	2000      	movne	r0, #0
 800ae42:	2001      	moveq	r0, #1
 800ae44:	f002 f9b4 	bl	800d1b0 <_test_assert>
 800ae48:	2800      	cmp	r0, #0
 800ae4a:	d13e      	bne.n	800aeca <oslib_test_001_003_execute.lto_priv.37+0x11a>
 800ae4c:	2320      	movs	r3, #32
 800ae4e:	f383 8811 	msr	BASEPRI, r3
    chSysLock();
    msg1 = chMBPostAheadI(&mb1, 'X');
 800ae52:	2158      	movs	r1, #88	; 0x58
 800ae54:	481f      	ldr	r0, [pc, #124]	; (800aed4 <oslib_test_001_003_execute.lto_priv.37+0x124>)
 800ae56:	f7fe ff1b 	bl	8009c90 <chMBPostAheadI>
 800ae5a:	2300      	movs	r3, #0
 800ae5c:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800ae60:	491d      	ldr	r1, [pc, #116]	; (800aed8 <oslib_test_001_003_execute.lto_priv.37+0x128>)
 800ae62:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800ae66:	bf14      	ite	ne
 800ae68:	2000      	movne	r0, #0
 800ae6a:	2001      	moveq	r0, #1
 800ae6c:	f002 f9a0 	bl	800d1b0 <_test_assert>
 800ae70:	bb58      	cbnz	r0, 800aeca <oslib_test_001_003_execute.lto_priv.37+0x11a>
  }

  /* [1.3.3] Resetting the mailbox. The mailbox is then returned in
     active state.*/
  test_set_step(3);
 800ae72:	4d17      	ldr	r5, [pc, #92]	; (800aed0 <oslib_test_001_003_execute.lto_priv.37+0x120>)
 800ae74:	2303      	movs	r3, #3
 800ae76:	602b      	str	r3, [r5, #0]
  {
    chMBReset(&mb1);
 800ae78:	4c16      	ldr	r4, [pc, #88]	; (800aed4 <oslib_test_001_003_execute.lto_priv.37+0x124>)
 800ae7a:	4620      	mov	r0, r4
 800ae7c:	f7fe ff90 	bl	8009da0 <chMBReset>
  mbp->reset = false;
 800ae80:	2300      	movs	r3, #0
 800ae82:	7523      	strb	r3, [r4, #20]
    chMBResumeX(&mb1);
  }

  /* [1.3.4] Testing chMBFetchTimeout() and chMBFetchI() timeout.*/
  test_set_step(4);
 800ae84:	2304      	movs	r3, #4
 800ae86:	602b      	str	r3, [r5, #0]
  {
    msg1 = chMBFetchTimeout(&mb1, &msg2, 1);
 800ae88:	2201      	movs	r2, #1
 800ae8a:	eb0d 0103 	add.w	r1, sp, r3
 800ae8e:	4620      	mov	r0, r4
 800ae90:	f7fe feee 	bl	8009c70 <chMBFetchTimeout>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800ae94:	4910      	ldr	r1, [pc, #64]	; (800aed8 <oslib_test_001_003_execute.lto_priv.37+0x128>)
 800ae96:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800ae9a:	bf14      	ite	ne
 800ae9c:	2000      	movne	r0, #0
 800ae9e:	2001      	moveq	r0, #1
 800aea0:	f002 f986 	bl	800d1b0 <_test_assert>
 800aea4:	b988      	cbnz	r0, 800aeca <oslib_test_001_003_execute.lto_priv.37+0x11a>
 800aea6:	2320      	movs	r3, #32
 800aea8:	f383 8811 	msr	BASEPRI, r3
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
 800aeac:	a901      	add	r1, sp, #4
 800aeae:	4620      	mov	r0, r4
 800aeb0:	f7fe febe 	bl	8009c30 <chMBFetchI>
 800aeb4:	2300      	movs	r3, #0
 800aeb6:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800aeba:	4907      	ldr	r1, [pc, #28]	; (800aed8 <oslib_test_001_003_execute.lto_priv.37+0x128>)
 800aebc:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800aec0:	bf14      	ite	ne
 800aec2:	2000      	movne	r0, #0
 800aec4:	2001      	moveq	r0, #1
 800aec6:	f002 f973 	bl	800d1b0 <_test_assert>
  }
}
 800aeca:	b003      	add	sp, #12
 800aecc:	bd30      	pop	{r4, r5, pc}
 800aece:	bf00      	nop
 800aed0:	20003e04 	.word	0x20003e04
 800aed4:	20002494 	.word	0x20002494
 800aed8:	0800e500 	.word	0x0800e500
 800aedc:	00000000 	.word	0x00000000

0800aee0 <oslib_test_001_003_setup.lto_priv.35>:
static void oslib_test_001_003_setup(void) {
 800aee0:	b508      	push	{r3, lr}
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
 800aee2:	2204      	movs	r2, #4
 800aee4:	4902      	ldr	r1, [pc, #8]	; (800aef0 <oslib_test_001_003_setup.lto_priv.35+0x10>)
 800aee6:	4803      	ldr	r0, [pc, #12]	; (800aef4 <oslib_test_001_003_setup.lto_priv.35+0x14>)
 800aee8:	f7fe ff6a 	bl	8009dc0 <chMBObjectInit>
 800aeec:	bd08      	pop	{r3, pc}
 800aeee:	bf00      	nop
 800aef0:	200031c0 	.word	0x200031c0
 800aef4:	20002494 	.word	0x20002494
	...

0800af00 <chEvtGetAndClearEventsI>:
  m = currp->epending & events;
 800af00:	4b03      	ldr	r3, [pc, #12]	; (800af10 <chEvtGetAndClearEventsI+0x10>)
 800af02:	699a      	ldr	r2, [r3, #24]
 800af04:	6b53      	ldr	r3, [r2, #52]	; 0x34
  currp->epending &= ~events;
 800af06:	ea23 0100 	bic.w	r1, r3, r0
 800af0a:	6351      	str	r1, [r2, #52]	; 0x34
}
 800af0c:	4018      	ands	r0, r3
 800af0e:	4770      	bx	lr
 800af10:	20003aec 	.word	0x20003aec
	...

0800af20 <chMtxTryLockS>:
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->owner != NULL) {
 800af20:	6883      	ldr	r3, [r0, #8]
 800af22:	b94b      	cbnz	r3, 800af38 <chMtxTryLockS+0x18>

  chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

  mp->cnt++;
#endif
  mp->owner = currp;
 800af24:	4b05      	ldr	r3, [pc, #20]	; (800af3c <chMtxTryLockS+0x1c>)
 800af26:	699a      	ldr	r2, [r3, #24]
 800af28:	6082      	str	r2, [r0, #8]
  mp->next = currp->mtxlist;
 800af2a:	699a      	ldr	r2, [r3, #24]
 800af2c:	6b92      	ldr	r2, [r2, #56]	; 0x38
 800af2e:	60c2      	str	r2, [r0, #12]
  currp->mtxlist = mp;
 800af30:	699b      	ldr	r3, [r3, #24]
 800af32:	6398      	str	r0, [r3, #56]	; 0x38
  return true;
 800af34:	2001      	movs	r0, #1
 800af36:	4770      	bx	lr
    return false;
 800af38:	2000      	movs	r0, #0
}
 800af3a:	4770      	bx	lr
 800af3c:	20003aec 	.word	0x20003aec

0800af40 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 800af40:	b430      	push	{r4, r5}
  return DWT->CYCCNT;
 800af42:	4b0e      	ldr	r3, [pc, #56]	; (800af7c <chTMStopMeasurementX+0x3c>)
 800af44:	685a      	ldr	r2, [r3, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 800af46:	4b0e      	ldr	r3, [pc, #56]	; (800af80 <chTMStopMeasurementX+0x40>)
 800af48:	6f5c      	ldr	r4, [r3, #116]	; 0x74
  tmp->n++;
 800af4a:	68c1      	ldr	r1, [r0, #12]
 800af4c:	3101      	adds	r1, #1
 800af4e:	60c1      	str	r1, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
 800af50:	6883      	ldr	r3, [r0, #8]
 800af52:	1ad3      	subs	r3, r2, r3
 800af54:	1b1b      	subs	r3, r3, r4
 800af56:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 800af58:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
 800af5c:	18e4      	adds	r4, r4, r3
 800af5e:	f145 0500 	adc.w	r5, r5, #0
 800af62:	e9c0 4504 	strd	r4, r5, [r0, #16]
  if (tmp->last > tmp->worst) {
 800af66:	6842      	ldr	r2, [r0, #4]
 800af68:	4293      	cmp	r3, r2
 800af6a:	d900      	bls.n	800af6e <chTMStopMeasurementX+0x2e>
    tmp->worst = tmp->last;
 800af6c:	6043      	str	r3, [r0, #4]
  if (tmp->last < tmp->best) {
 800af6e:	6802      	ldr	r2, [r0, #0]
 800af70:	4293      	cmp	r3, r2
 800af72:	d200      	bcs.n	800af76 <chTMStopMeasurementX+0x36>
    tmp->best = tmp->last;
 800af74:	6003      	str	r3, [r0, #0]
}
 800af76:	bc30      	pop	{r4, r5}
 800af78:	4770      	bx	lr
 800af7a:	bf00      	nop
 800af7c:	e0001000 	.word	0xe0001000
 800af80:	20003aec 	.word	0x20003aec
	...

0800af90 <chTMStartMeasurementX>:
 800af90:	4b01      	ldr	r3, [pc, #4]	; (800af98 <chTMStartMeasurementX+0x8>)
 800af92:	685b      	ldr	r3, [r3, #4]
  tmp->last = chSysGetRealtimeCounterX();
 800af94:	6083      	str	r3, [r0, #8]
 800af96:	4770      	bx	lr
 800af98:	e0001000 	.word	0xe0001000
 800af9c:	00000000 	.word	0x00000000

0800afa0 <chTMObjectInit>:
  tmp->best       = (rtcnt_t)-1;
 800afa0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800afa4:	6003      	str	r3, [r0, #0]
  tmp->worst      = (rtcnt_t)0;
 800afa6:	2300      	movs	r3, #0
 800afa8:	6043      	str	r3, [r0, #4]
  tmp->last       = (rtcnt_t)0;
 800afaa:	6083      	str	r3, [r0, #8]
  tmp->n          = (ucnt_t)0;
 800afac:	60c3      	str	r3, [r0, #12]
  tmp->cumulative = (rttime_t)0;
 800afae:	2200      	movs	r2, #0
 800afb0:	2300      	movs	r3, #0
 800afb2:	e9c0 2304 	strd	r2, r3, [r0, #16]
 800afb6:	4770      	bx	lr
	...

0800afc0 <chCondBroadcastI>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondBroadcastI(condition_variable_t *cp) {
 800afc0:	b510      	push	{r4, lr}
 800afc2:	4604      	mov	r4, r0
 800afc4:	e007      	b.n	800afd6 <chCondBroadcastI+0x16>
  tqp->next             = tp->queue.next;
 800afc6:	6803      	ldr	r3, [r0, #0]
 800afc8:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800afca:	605c      	str	r4, [r3, #4]

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->queue)) {
    chSchReadyI(queue_fifo_remove(&cp->queue))->u.rdymsg = MSG_RESET;
 800afcc:	f7fb fc58 	bl	8006880 <chSchReadyI>
 800afd0:	f06f 0301 	mvn.w	r3, #1
 800afd4:	6243      	str	r3, [r0, #36]	; 0x24
  return (bool)(tqp->next != (const thread_t *)tqp);
 800afd6:	6820      	ldr	r0, [r4, #0]
  while (queue_notempty(&cp->queue)) {
 800afd8:	4284      	cmp	r4, r0
 800afda:	d1f4      	bne.n	800afc6 <chCondBroadcastI+0x6>
  }
}
 800afdc:	bd10      	pop	{r4, pc}
 800afde:	bf00      	nop

0800afe0 <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
 800afe0:	b538      	push	{r3, r4, r5, lr}
 800afe2:	4605      	mov	r5, r0
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
 800afe4:	6884      	ldr	r4, [r0, #8]
  sp->cnt = n;
 800afe6:	6081      	str	r1, [r0, #8]
 800afe8:	e008      	b.n	800affc <chSemResetI+0x1c>

  return tp;
}

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->prev;
 800afea:	6868      	ldr	r0, [r5, #4]

  tqp->prev             = tp->queue.prev;
 800afec:	6843      	ldr	r3, [r0, #4]
 800afee:	606b      	str	r3, [r5, #4]
  tqp->prev->queue.next = (thread_t *)tqp;
 800aff0:	601d      	str	r5, [r3, #0]
  while (++cnt <= (cnt_t)0) {
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
 800aff2:	f7fb fc45 	bl	8006880 <chSchReadyI>
 800aff6:	f06f 0301 	mvn.w	r3, #1
 800affa:	6243      	str	r3, [r0, #36]	; 0x24
  while (++cnt <= (cnt_t)0) {
 800affc:	3401      	adds	r4, #1
 800affe:	2c00      	cmp	r4, #0
 800b000:	ddf3      	ble.n	800afea <chSemResetI+0xa>
  }
}
 800b002:	bd38      	pop	{r3, r4, r5, pc}
	...

0800b010 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 800b010:	b508      	push	{r3, lr}
 800b012:	2320      	movs	r3, #32
 800b014:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 800b018:	f890 3020 	ldrb.w	r3, [r0, #32]
 800b01c:	2b07      	cmp	r3, #7
 800b01e:	d817      	bhi.n	800b050 <wakeup+0x40>
 800b020:	e8df f003 	tbb	[pc, r3]
 800b024:	08161604 	.word	0x08161604
 800b028:	10160c10 	.word	0x10160c10
 800b02c:	2300      	movs	r3, #0
 800b02e:	f383 8811 	msr	BASEPRI, r3
 800b032:	bd08      	pop	{r3, pc}
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 800b034:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800b036:	2200      	movs	r2, #0
 800b038:	601a      	str	r2, [r3, #0]
 800b03a:	e009      	b.n	800b050 <wakeup+0x40>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 800b03c:	6a42      	ldr	r2, [r0, #36]	; 0x24
  sp->cnt++;
 800b03e:	6893      	ldr	r3, [r2, #8]
 800b040:	3301      	adds	r3, #1
 800b042:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800b044:	6843      	ldr	r3, [r0, #4]
 800b046:	6802      	ldr	r2, [r0, #0]
 800b048:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800b04a:	6803      	ldr	r3, [r0, #0]
 800b04c:	6842      	ldr	r2, [r0, #4]
 800b04e:	605a      	str	r2, [r3, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 800b050:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800b054:	6243      	str	r3, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 800b056:	f7fb fc13 	bl	8006880 <chSchReadyI>
 800b05a:	2300      	movs	r3, #0
 800b05c:	f383 8811 	msr	BASEPRI, r3
 800b060:	bd08      	pop	{r3, pc}
 800b062:	bf00      	nop
	...

0800b070 <chSchDoRescheduleBehind>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleBehind(void) {
 800b070:	b510      	push	{r4, lr}
  thread_t *otp = currp;
 800b072:	4c08      	ldr	r4, [pc, #32]	; (800b094 <chSchDoRescheduleBehind+0x24>)
 800b074:	69a0      	ldr	r0, [r4, #24]
  thread_t *tp = tqp->next;
 800b076:	6823      	ldr	r3, [r4, #0]
  tqp->next             = tp->queue.next;
 800b078:	681a      	ldr	r2, [r3, #0]
 800b07a:	6022      	str	r2, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800b07c:	6054      	str	r4, [r2, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800b07e:	61a3      	str	r3, [r4, #24]
  currp->state = CH_STATE_CURRENT;
 800b080:	2201      	movs	r2, #1
 800b082:	f883 2020 	strb.w	r2, [r3, #32]
  /* It went behind peers so it gets a new time quantum.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Placing in ready list behind peers.*/
  otp = chSchReadyI(otp);
 800b086:	f7fb fbfb 	bl	8006880 <chSchReadyI>

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800b08a:	4601      	mov	r1, r0
 800b08c:	69a0      	ldr	r0, [r4, #24]
 800b08e:	f7f5 f94b 	bl	8000328 <_port_switch>
 800b092:	bd10      	pop	{r4, pc}
 800b094:	20003aec 	.word	0x20003aec
	...

0800b0a0 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 800b0a0:	b510      	push	{r4, lr}
  thread_t *otp = currp;
 800b0a2:	4c08      	ldr	r4, [pc, #32]	; (800b0c4 <chSchDoRescheduleAhead+0x24>)
 800b0a4:	69a0      	ldr	r0, [r4, #24]
  thread_t *tp = tqp->next;
 800b0a6:	6823      	ldr	r3, [r4, #0]
  tqp->next             = tp->queue.next;
 800b0a8:	681a      	ldr	r2, [r3, #0]
 800b0aa:	6022      	str	r2, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800b0ac:	6054      	str	r4, [r2, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800b0ae:	61a3      	str	r3, [r4, #24]
  currp->state = CH_STATE_CURRENT;
 800b0b0:	2201      	movs	r2, #1
 800b0b2:	f883 2020 	strb.w	r2, [r3, #32]
  if (otp->prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);
 800b0b6:	f7fb fbcb 	bl	8006850 <chSchReadyAheadI>

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800b0ba:	4601      	mov	r1, r0
 800b0bc:	69a0      	ldr	r0, [r4, #24]
 800b0be:	f7f5 f933 	bl	8000328 <_port_switch>
 800b0c2:	bd10      	pop	{r4, pc}
 800b0c4:	20003aec 	.word	0x20003aec
	...

0800b0d0 <chEvtBroadcastFlagsI>:
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 800b0d0:	b570      	push	{r4, r5, r6, lr}
 800b0d2:	4606      	mov	r6, r0
 800b0d4:	460d      	mov	r5, r1
  elp = esp->next;
 800b0d6:	6804      	ldr	r4, [r0, #0]
 800b0d8:	e00b      	b.n	800b0f2 <chEvtBroadcastFlagsI+0x22>
    elp->flags |= flags;
 800b0da:	68e3      	ldr	r3, [r4, #12]
 800b0dc:	432b      	orrs	r3, r5
 800b0de:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
 800b0e0:	b115      	cbz	r5, 800b0e8 <chEvtBroadcastFlagsI+0x18>
        ((flags & elp->wflags) != (eventflags_t)0)) {
 800b0e2:	6923      	ldr	r3, [r4, #16]
    if ((flags == (eventflags_t)0) ||
 800b0e4:	421d      	tst	r5, r3
 800b0e6:	d003      	beq.n	800b0f0 <chEvtBroadcastFlagsI+0x20>
      chEvtSignalI(elp->listener, elp->events);
 800b0e8:	68a1      	ldr	r1, [r4, #8]
 800b0ea:	6860      	ldr	r0, [r4, #4]
 800b0ec:	f7ff f830 	bl	800a150 <chEvtSignalI>
    elp = elp->next;
 800b0f0:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 800b0f2:	42b4      	cmp	r4, r6
 800b0f4:	d1f1      	bne.n	800b0da <chEvtBroadcastFlagsI+0xa>
}
 800b0f6:	bd70      	pop	{r4, r5, r6, pc}
	...

0800b100 <chEvtAddEvents>:
 800b100:	2320      	movs	r3, #32
 800b102:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline eventmask_t chEvtAddEventsI(eventmask_t events) {

  return currp->epending |= events;
 800b106:	4b04      	ldr	r3, [pc, #16]	; (800b118 <chEvtAddEvents+0x18>)
 800b108:	699a      	ldr	r2, [r3, #24]
 800b10a:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800b10c:	4318      	orrs	r0, r3
 800b10e:	6350      	str	r0, [r2, #52]	; 0x34
 800b110:	2300      	movs	r3, #0
 800b112:	f383 8811 	msr	BASEPRI, r3
}
 800b116:	4770      	bx	lr
 800b118:	20003aec 	.word	0x20003aec
 800b11c:	00000000 	.word	0x00000000

0800b120 <chEvtGetAndClearEvents>:
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
 800b120:	b508      	push	{r3, lr}
 800b122:	2320      	movs	r3, #32
 800b124:	f383 8811 	msr	BASEPRI, r3
  m = chEvtGetAndClearEventsI(events);
 800b128:	f7ff feea 	bl	800af00 <chEvtGetAndClearEventsI>
 800b12c:	2300      	movs	r3, #0
 800b12e:	f383 8811 	msr	BASEPRI, r3
}
 800b132:	bd08      	pop	{r3, pc}
	...

0800b140 <chEvtUnregister>:
 800b140:	2320      	movs	r3, #32
 800b142:	f383 8811 	msr	BASEPRI, r3
  p = (event_listener_t *)esp;
 800b146:	4602      	mov	r2, r0
 800b148:	e005      	b.n	800b156 <chEvtUnregister+0x16>
    if (p->next == elp) {
 800b14a:	428b      	cmp	r3, r1
 800b14c:	d102      	bne.n	800b154 <chEvtUnregister+0x14>
      p->next = elp->next;
 800b14e:	680b      	ldr	r3, [r1, #0]
 800b150:	6013      	str	r3, [r2, #0]
 800b152:	e003      	b.n	800b15c <chEvtUnregister+0x1c>
    p = p->next;
 800b154:	461a      	mov	r2, r3
  while (p->next != (event_listener_t *)esp) {
 800b156:	6813      	ldr	r3, [r2, #0]
 800b158:	4298      	cmp	r0, r3
 800b15a:	d1f6      	bne.n	800b14a <chEvtUnregister+0xa>
 800b15c:	2300      	movs	r3, #0
 800b15e:	f383 8811 	msr	BASEPRI, r3
 800b162:	4770      	bx	lr
	...

0800b170 <chEvtRegisterMaskWithFlags>:
                                eventflags_t wflags) {
 800b170:	b410      	push	{r4}
 800b172:	2420      	movs	r4, #32
 800b174:	f384 8811 	msr	BASEPRI, r4
  elp->next     = esp->next;
 800b178:	6804      	ldr	r4, [r0, #0]
 800b17a:	600c      	str	r4, [r1, #0]
  esp->next     = elp;
 800b17c:	6001      	str	r1, [r0, #0]
  elp->listener = currp;
 800b17e:	4806      	ldr	r0, [pc, #24]	; (800b198 <chEvtRegisterMaskWithFlags+0x28>)
 800b180:	6980      	ldr	r0, [r0, #24]
 800b182:	6048      	str	r0, [r1, #4]
  elp->events   = events;
 800b184:	608a      	str	r2, [r1, #8]
  elp->flags    = (eventflags_t)0;
 800b186:	2200      	movs	r2, #0
 800b188:	60ca      	str	r2, [r1, #12]
  elp->wflags   = wflags;
 800b18a:	610b      	str	r3, [r1, #16]
 800b18c:	f382 8811 	msr	BASEPRI, r2
}
 800b190:	f85d 4b04 	ldr.w	r4, [sp], #4
 800b194:	4770      	bx	lr
 800b196:	bf00      	nop
 800b198:	20003aec 	.word	0x20003aec
 800b19c:	00000000 	.word	0x00000000

0800b1a0 <chCondSignalI>:
  return (bool)(tqp->next != (const thread_t *)tqp);
 800b1a0:	6802      	ldr	r2, [r0, #0]
  if (queue_notempty(&cp->queue)) {
 800b1a2:	4290      	cmp	r0, r2
 800b1a4:	d009      	beq.n	800b1ba <chCondSignalI+0x1a>
void chCondSignalI(condition_variable_t *cp) {
 800b1a6:	b508      	push	{r3, lr}
  tqp->next             = tp->queue.next;
 800b1a8:	6811      	ldr	r1, [r2, #0]
 800b1aa:	6001      	str	r1, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800b1ac:	6048      	str	r0, [r1, #4]
    tp->u.rdymsg = MSG_OK;
 800b1ae:	2300      	movs	r3, #0
 800b1b0:	6253      	str	r3, [r2, #36]	; 0x24
    (void) chSchReadyI(tp);
 800b1b2:	4610      	mov	r0, r2
 800b1b4:	f7fb fb64 	bl	8006880 <chSchReadyI>
 800b1b8:	bd08      	pop	{r3, pc}
 800b1ba:	4770      	bx	lr
 800b1bc:	0000      	movs	r0, r0
	...

0800b1c0 <chCondObjectInit>:
  tqp->next = (thread_t *)tqp;
 800b1c0:	6000      	str	r0, [r0, #0]
  tqp->prev = (thread_t *)tqp;
 800b1c2:	6040      	str	r0, [r0, #4]
 800b1c4:	4770      	bx	lr
 800b1c6:	bf00      	nop
	...

0800b1d0 <chMtxUnlockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 800b1d0:	b510      	push	{r4, lr}
  thread_t *ctp = currp;
 800b1d2:	4b11      	ldr	r3, [pc, #68]	; (800b218 <chMtxUnlockS+0x48>)
 800b1d4:	699c      	ldr	r4, [r3, #24]
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 800b1d6:	68c3      	ldr	r3, [r0, #12]
 800b1d8:	63a3      	str	r3, [r4, #56]	; 0x38
  return (bool)(tqp->next != (const thread_t *)tqp);
 800b1da:	6802      	ldr	r2, [r0, #0]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800b1dc:	4282      	cmp	r2, r0
 800b1de:	d018      	beq.n	800b212 <chMtxUnlockS+0x42>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 800b1e0:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 800b1e2:	e007      	b.n	800b1f4 <chMtxUnlockS+0x24>
 800b1e4:	681a      	ldr	r2, [r3, #0]
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800b1e6:	4293      	cmp	r3, r2
 800b1e8:	d003      	beq.n	800b1f2 <chMtxUnlockS+0x22>
            (lmp->queue.next->prio > newprio)) {
 800b1ea:	6892      	ldr	r2, [r2, #8]
        if (chMtxQueueNotEmptyS(lmp) &&
 800b1ec:	4291      	cmp	r1, r2
 800b1ee:	d200      	bcs.n	800b1f2 <chMtxUnlockS+0x22>
          newprio = lmp->queue.next->prio;
 800b1f0:	4611      	mov	r1, r2
        }
        lmp = lmp->next;
 800b1f2:	68db      	ldr	r3, [r3, #12]
      while (lmp != NULL) {
 800b1f4:	2b00      	cmp	r3, #0
 800b1f6:	d1f5      	bne.n	800b1e4 <chMtxUnlockS+0x14>
 800b1f8:	4603      	mov	r3, r0
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 800b1fa:	60a1      	str	r1, [r4, #8]
  thread_t *tp = tqp->next;
 800b1fc:	6800      	ldr	r0, [r0, #0]
  tqp->next             = tp->queue.next;
 800b1fe:	6802      	ldr	r2, [r0, #0]
 800b200:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800b202:	6053      	str	r3, [r2, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 800b204:	6098      	str	r0, [r3, #8]
      mp->next = tp->mtxlist;
 800b206:	6b82      	ldr	r2, [r0, #56]	; 0x38
 800b208:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 800b20a:	6383      	str	r3, [r0, #56]	; 0x38
      (void) chSchReadyI(tp);
 800b20c:	f7fb fb38 	bl	8006880 <chSchReadyI>
 800b210:	bd10      	pop	{r4, pc}
    }
    else {
      mp->owner = NULL;
 800b212:	2300      	movs	r3, #0
 800b214:	6083      	str	r3, [r0, #8]
 800b216:	bd10      	pop	{r4, pc}
 800b218:	20003aec 	.word	0x20003aec
 800b21c:	00000000 	.word	0x00000000

0800b220 <chMtxTryLock>:
bool chMtxTryLock(mutex_t *mp) {
 800b220:	b508      	push	{r3, lr}
 800b222:	2320      	movs	r3, #32
 800b224:	f383 8811 	msr	BASEPRI, r3
  b = chMtxTryLockS(mp);
 800b228:	f7ff fe7a 	bl	800af20 <chMtxTryLockS>
 800b22c:	2300      	movs	r3, #0
 800b22e:	f383 8811 	msr	BASEPRI, r3
}
 800b232:	bd08      	pop	{r3, pc}
	...

0800b240 <chMtxObjectInit>:
  tqp->next = (thread_t *)tqp;
 800b240:	6000      	str	r0, [r0, #0]
  tqp->prev = (thread_t *)tqp;
 800b242:	6040      	str	r0, [r0, #4]
  mp->owner = NULL;
 800b244:	2300      	movs	r3, #0
 800b246:	6083      	str	r3, [r0, #8]
 800b248:	4770      	bx	lr
 800b24a:	bf00      	nop
 800b24c:	0000      	movs	r0, r0
	...

0800b250 <chSemAddCounterI>:
 * @param[in] n         value to be added to the semaphore counter. The value
 *                      must be positive.
 *
 * @iclass
 */
void chSemAddCounterI(semaphore_t *sp, cnt_t n) {
 800b250:	b538      	push	{r3, r4, r5, lr}
 800b252:	4605      	mov	r5, r0
 800b254:	460c      	mov	r4, r1
 800b256:	e00d      	b.n	800b274 <chSemAddCounterI+0x24>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
    if (++sp->cnt <= (cnt_t)0) {
 800b258:	68ab      	ldr	r3, [r5, #8]
 800b25a:	3301      	adds	r3, #1
 800b25c:	60ab      	str	r3, [r5, #8]
 800b25e:	2b00      	cmp	r3, #0
 800b260:	dc07      	bgt.n	800b272 <chSemAddCounterI+0x22>
  thread_t *tp = tqp->next;
 800b262:	6828      	ldr	r0, [r5, #0]
  tqp->next             = tp->queue.next;
 800b264:	6803      	ldr	r3, [r0, #0]
 800b266:	602b      	str	r3, [r5, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800b268:	605d      	str	r5, [r3, #4]
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 800b26a:	f7fb fb09 	bl	8006880 <chSchReadyI>
 800b26e:	2300      	movs	r3, #0
 800b270:	6243      	str	r3, [r0, #36]	; 0x24
    }
    n--;
 800b272:	3c01      	subs	r4, #1
  while (n > (cnt_t)0) {
 800b274:	2c00      	cmp	r4, #0
 800b276:	dcef      	bgt.n	800b258 <chSemAddCounterI+0x8>
  }
}
 800b278:	bd38      	pop	{r3, r4, r5, pc}
 800b27a:	bf00      	nop
 800b27c:	0000      	movs	r0, r0
	...

0800b280 <chSemSignalI>:
void chSemSignalI(semaphore_t *sp) {
 800b280:	b508      	push	{r3, lr}
  if (++sp->cnt <= (cnt_t)0) {
 800b282:	6883      	ldr	r3, [r0, #8]
 800b284:	3301      	adds	r3, #1
 800b286:	6083      	str	r3, [r0, #8]
 800b288:	2b00      	cmp	r3, #0
 800b28a:	dc08      	bgt.n	800b29e <chSemSignalI+0x1e>
 800b28c:	4603      	mov	r3, r0
  thread_t *tp = tqp->next;
 800b28e:	6800      	ldr	r0, [r0, #0]
  tqp->next             = tp->queue.next;
 800b290:	6802      	ldr	r2, [r0, #0]
 800b292:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800b294:	6053      	str	r3, [r2, #4]
    tp->u.rdymsg = MSG_OK;
 800b296:	2300      	movs	r3, #0
 800b298:	6243      	str	r3, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 800b29a:	f7fb faf1 	bl	8006880 <chSchReadyI>
 800b29e:	bd08      	pop	{r3, pc}

0800b2a0 <chSemObjectInit>:
  tqp->next = (thread_t *)tqp;
 800b2a0:	6000      	str	r0, [r0, #0]
  tqp->prev = (thread_t *)tqp;
 800b2a2:	6040      	str	r0, [r0, #4]
  sp->cnt = n;
 800b2a4:	6081      	str	r1, [r0, #8]
 800b2a6:	4770      	bx	lr
	...

0800b2b0 <chRegFirstThread>:
 800b2b0:	2320      	movs	r3, #32
 800b2b2:	f383 8811 	msr	BASEPRI, r3
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
 800b2b6:	4b05      	ldr	r3, [pc, #20]	; (800b2cc <chRegFirstThread+0x1c>)
 800b2b8:	6918      	ldr	r0, [r3, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 800b2ba:	f890 3022 	ldrb.w	r3, [r0, #34]	; 0x22
 800b2be:	3301      	adds	r3, #1
 800b2c0:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22
 800b2c4:	2300      	movs	r3, #0
 800b2c6:	f383 8811 	msr	BASEPRI, r3
#endif
  chSysUnlock();

  return tp;
}
 800b2ca:	4770      	bx	lr
 800b2cc:	20003aec 	.word	0x20003aec

0800b2d0 <_tm_init>:
void _tm_init(void) {
 800b2d0:	b510      	push	{r4, lr}
 800b2d2:	b086      	sub	sp, #24
  ch.tm.offset = (rtcnt_t)0;
 800b2d4:	4c07      	ldr	r4, [pc, #28]	; (800b2f4 <_tm_init+0x24>)
 800b2d6:	2300      	movs	r3, #0
 800b2d8:	6763      	str	r3, [r4, #116]	; 0x74
  chTMObjectInit(&tm);
 800b2da:	4668      	mov	r0, sp
 800b2dc:	f7ff fe60 	bl	800afa0 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
 800b2e0:	4668      	mov	r0, sp
 800b2e2:	f7ff fe55 	bl	800af90 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 800b2e6:	4668      	mov	r0, sp
 800b2e8:	f7ff fe2a 	bl	800af40 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 800b2ec:	9b02      	ldr	r3, [sp, #8]
 800b2ee:	6763      	str	r3, [r4, #116]	; 0x74
}
 800b2f0:	b006      	add	sp, #24
 800b2f2:	bd10      	pop	{r4, pc}
 800b2f4:	20003aec 	.word	0x20003aec
	...

0800b300 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 800b300:	b538      	push	{r3, r4, r5, lr}
 800b302:	4604      	mov	r4, r0
 800b304:	460d      	mov	r5, r1
 800b306:	e005      	b.n	800b314 <chThdDequeueAllI+0x14>
  tqp->next             = tp->queue.next;
 800b308:	6803      	ldr	r3, [r0, #0]
 800b30a:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800b30c:	605c      	str	r4, [r3, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 800b30e:	6245      	str	r5, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 800b310:	f7fb fab6 	bl	8006880 <chSchReadyI>
  return (bool)(tqp->next != (const thread_t *)tqp);
 800b314:	6820      	ldr	r0, [r4, #0]

  while (queue_notempty(tqp)) {
 800b316:	4284      	cmp	r4, r0
 800b318:	d1f6      	bne.n	800b308 <chThdDequeueAllI+0x8>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 800b31a:	bd38      	pop	{r3, r4, r5, pc}
 800b31c:	0000      	movs	r0, r0
	...

0800b320 <chThdDequeueNextI>:
 800b320:	6802      	ldr	r2, [r0, #0]
  if (queue_notempty(tqp)) {
 800b322:	4290      	cmp	r0, r2
 800b324:	d009      	beq.n	800b33a <chThdDequeueNextI+0x1a>
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 800b326:	b508      	push	{r3, lr}
 800b328:	4603      	mov	r3, r0
  tqp->next             = tp->queue.next;
 800b32a:	6810      	ldr	r0, [r2, #0]
 800b32c:	6018      	str	r0, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800b32e:	6043      	str	r3, [r0, #4]
  tp->u.rdymsg = msg;
 800b330:	6251      	str	r1, [r2, #36]	; 0x24
  (void) chSchReadyI(tp);
 800b332:	4610      	mov	r0, r2
 800b334:	f7fb faa4 	bl	8006880 <chSchReadyI>
 800b338:	bd08      	pop	{r3, pc}
 800b33a:	4770      	bx	lr
 800b33c:	0000      	movs	r0, r0
	...

0800b340 <chThdResumeI>:
  if (*trp != NULL) {
 800b340:	6802      	ldr	r2, [r0, #0]
 800b342:	b142      	cbz	r2, 800b356 <chThdResumeI+0x16>
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 800b344:	b508      	push	{r3, lr}
 800b346:	4603      	mov	r3, r0
    *trp = NULL;
 800b348:	2000      	movs	r0, #0
 800b34a:	6018      	str	r0, [r3, #0]
    tp->u.rdymsg = msg;
 800b34c:	6251      	str	r1, [r2, #36]	; 0x24
    (void) chSchReadyI(tp);
 800b34e:	4610      	mov	r0, r2
 800b350:	f7fb fa96 	bl	8006880 <chSchReadyI>
 800b354:	bd08      	pop	{r3, pc}
 800b356:	4770      	bx	lr
	...

0800b360 <chThdYield>:
void chThdYield(void) {
 800b360:	b508      	push	{r3, lr}
 800b362:	2320      	movs	r3, #32
 800b364:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.queue) >= currp->prio;
 800b368:	4b06      	ldr	r3, [pc, #24]	; (800b384 <chThdYield+0x24>)
 800b36a:	681a      	ldr	r2, [r3, #0]
 800b36c:	6892      	ldr	r2, [r2, #8]
 800b36e:	699b      	ldr	r3, [r3, #24]
 800b370:	689b      	ldr	r3, [r3, #8]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 800b372:	429a      	cmp	r2, r3
 800b374:	d301      	bcc.n	800b37a <chThdYield+0x1a>
    chSchDoRescheduleBehind();
 800b376:	f7ff fe7b 	bl	800b070 <chSchDoRescheduleBehind>
 800b37a:	2300      	movs	r3, #0
 800b37c:	f383 8811 	msr	BASEPRI, r3
 800b380:	bd08      	pop	{r3, pc}
 800b382:	bf00      	nop
 800b384:	20003aec 	.word	0x20003aec
	...

0800b390 <chThdTerminate>:
 800b390:	2320      	movs	r3, #32
 800b392:	f383 8811 	msr	BASEPRI, r3
  tp->flags |= CH_FLAG_TERMINATE;
 800b396:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 800b39a:	f043 0304 	orr.w	r3, r3, #4
 800b39e:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
 800b3a2:	2300      	movs	r3, #0
 800b3a4:	f383 8811 	msr	BASEPRI, r3
 800b3a8:	4770      	bx	lr
 800b3aa:	bf00      	nop
 800b3ac:	0000      	movs	r0, r0
	...

0800b3b0 <chThdRelease>:
void chThdRelease(thread_t *tp) {
 800b3b0:	b508      	push	{r3, lr}
 800b3b2:	2320      	movs	r3, #32
 800b3b4:	f383 8811 	msr	BASEPRI, r3
  tp->refs--;
 800b3b8:	f890 3022 	ldrb.w	r3, [r0, #34]	; 0x22
 800b3bc:	3b01      	subs	r3, #1
 800b3be:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 800b3c2:	6a03      	ldr	r3, [r0, #32]
 800b3c4:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 800b3c8:	2b0f      	cmp	r3, #15
 800b3ca:	d11a      	bne.n	800b402 <chThdRelease+0x52>
    REG_REMOVE(tp);
 800b3cc:	6943      	ldr	r3, [r0, #20]
 800b3ce:	6902      	ldr	r2, [r0, #16]
 800b3d0:	611a      	str	r2, [r3, #16]
 800b3d2:	6903      	ldr	r3, [r0, #16]
 800b3d4:	6942      	ldr	r2, [r0, #20]
 800b3d6:	615a      	str	r2, [r3, #20]
 800b3d8:	2300      	movs	r3, #0
 800b3da:	f383 8811 	msr	BASEPRI, r3
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 800b3de:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 800b3e2:	f003 0303 	and.w	r3, r3, #3
 800b3e6:	2b01      	cmp	r3, #1
 800b3e8:	d002      	beq.n	800b3f0 <chThdRelease+0x40>
 800b3ea:	2b02      	cmp	r3, #2
 800b3ec:	d004      	beq.n	800b3f8 <chThdRelease+0x48>
 800b3ee:	bd08      	pop	{r3, pc}
      chHeapFree(chThdGetWorkingAreaX(tp));
 800b3f0:	69c0      	ldr	r0, [r0, #28]
 800b3f2:	f7fe fae5 	bl	80099c0 <chHeapFree>
 800b3f6:	bd08      	pop	{r3, pc}
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 800b3f8:	69c1      	ldr	r1, [r0, #28]
 800b3fa:	6c00      	ldr	r0, [r0, #64]	; 0x40
 800b3fc:	f7fe fa38 	bl	8009870 <chPoolFree>
 800b400:	bd08      	pop	{r3, pc}
 800b402:	2300      	movs	r3, #0
 800b404:	f383 8811 	msr	BASEPRI, r3
 800b408:	bd08      	pop	{r3, pc}
 800b40a:	bf00      	nop
 800b40c:	0000      	movs	r0, r0
	...

0800b410 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 800b410:	b510      	push	{r4, lr}
 800b412:	2320      	movs	r3, #32
 800b414:	f383 8811 	msr	BASEPRI, r3
  thread_t *ntp;

  chSysLock();
  ntp = tp->newer;
 800b418:	6904      	ldr	r4, [r0, #16]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 800b41a:	4b08      	ldr	r3, [pc, #32]	; (800b43c <chRegNextThread+0x2c>)
 800b41c:	429c      	cmp	r4, r3
 800b41e:	d005      	beq.n	800b42c <chRegNextThread+0x1c>
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
    ntp->refs++;
 800b420:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 800b424:	3301      	adds	r3, #1
 800b426:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
 800b42a:	e000      	b.n	800b42e <chRegNextThread+0x1e>
    ntp = NULL;
 800b42c:	2400      	movs	r4, #0
 800b42e:	2300      	movs	r3, #0
 800b430:	f383 8811 	msr	BASEPRI, r3
  }
#endif
  chSysUnlock();
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 800b434:	f7ff ffbc 	bl	800b3b0 <chThdRelease>
#endif

  return ntp;
}
 800b438:	4620      	mov	r0, r4
 800b43a:	bd10      	pop	{r4, pc}
 800b43c:	20003aec 	.word	0x20003aec

0800b440 <_thread_init>:
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {
 800b440:	b410      	push	{r4}
  tp->prio      = prio;
 800b442:	6082      	str	r2, [r0, #8]
  tp->state     = CH_STATE_WTSTART;
 800b444:	2402      	movs	r4, #2
 800b446:	f880 4020 	strb.w	r4, [r0, #32]
  tp->flags     = CH_FLAG_MODE_STATIC;
 800b44a:	2400      	movs	r4, #0
 800b44c:	f880 4021 	strb.w	r4, [r0, #33]	; 0x21
  tp->realprio  = prio;
 800b450:	63c2      	str	r2, [r0, #60]	; 0x3c
  tp->mtxlist   = NULL;
 800b452:	6384      	str	r4, [r0, #56]	; 0x38
  tp->epending  = (eventmask_t)0;
 800b454:	6344      	str	r4, [r0, #52]	; 0x34
  tp->refs      = (trefs_t)1;
 800b456:	2201      	movs	r2, #1
 800b458:	f880 2022 	strb.w	r2, [r0, #34]	; 0x22
  tp->name      = name;
 800b45c:	6181      	str	r1, [r0, #24]
  REG_INSERT(tp);
 800b45e:	4a08      	ldr	r2, [pc, #32]	; (800b480 <_thread_init+0x40>)
 800b460:	6102      	str	r2, [r0, #16]
 800b462:	6951      	ldr	r1, [r2, #20]
 800b464:	6141      	str	r1, [r0, #20]
 800b466:	6108      	str	r0, [r1, #16]
 800b468:	6150      	str	r0, [r2, #20]
  list_init(&tp->waiting);
 800b46a:	f100 0228 	add.w	r2, r0, #40	; 0x28
  tlp->next = (thread_t *)tlp;
 800b46e:	6282      	str	r2, [r0, #40]	; 0x28
  queue_init(&tp->msgqueue);
 800b470:	f100 022c 	add.w	r2, r0, #44	; 0x2c
  tqp->next = (thread_t *)tqp;
 800b474:	62c2      	str	r2, [r0, #44]	; 0x2c
  tqp->prev = (thread_t *)tqp;
 800b476:	6302      	str	r2, [r0, #48]	; 0x30
}
 800b478:	f85d 4b04 	ldr.w	r4, [sp], #4
 800b47c:	4770      	bx	lr
 800b47e:	bf00      	nop
 800b480:	20003aec 	.word	0x20003aec
	...

0800b490 <chThdCreateSuspendedI>:
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 800b490:	b508      	push	{r3, lr}
  tp = (thread_t *)((uint8_t *)tdp->wend -
 800b492:	6883      	ldr	r3, [r0, #8]
  tp->wabase = tdp->wbase;
 800b494:	6842      	ldr	r2, [r0, #4]
 800b496:	f843 2c2c 	str.w	r2, [r3, #-44]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800b49a:	f1a3 02ac 	sub.w	r2, r3, #172	; 0xac
 800b49e:	f843 2c3c 	str.w	r2, [r3, #-60]
 800b4a2:	6901      	ldr	r1, [r0, #16]
 800b4a4:	f843 1c6c 	str.w	r1, [r3, #-108]
 800b4a8:	6941      	ldr	r1, [r0, #20]
 800b4aa:	f843 1c68 	str.w	r1, [r3, #-104]
 800b4ae:	4905      	ldr	r1, [pc, #20]	; (800b4c4 <chThdCreateSuspendedI+0x34>)
 800b4b0:	f843 1c4c 	str.w	r1, [r3, #-76]
  return _thread_init(tp, tdp->name, tdp->prio);
 800b4b4:	68c2      	ldr	r2, [r0, #12]
 800b4b6:	6801      	ldr	r1, [r0, #0]
 800b4b8:	f1a3 0048 	sub.w	r0, r3, #72	; 0x48
 800b4bc:	f7ff ffc0 	bl	800b440 <_thread_init>
}
 800b4c0:	bd08      	pop	{r3, pc}
 800b4c2:	bf00      	nop
 800b4c4:	08000341 	.word	0x08000341
	...

0800b4d0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 800b4d0:	b510      	push	{r4, lr}
  thread_t *otp = currp;
 800b4d2:	4c08      	ldr	r4, [pc, #32]	; (800b4f4 <chSchDoReschedule+0x24>)
 800b4d4:	69a0      	ldr	r0, [r4, #24]
  thread_t *tp = tqp->next;
 800b4d6:	6823      	ldr	r3, [r4, #0]
  tqp->next             = tp->queue.next;
 800b4d8:	681a      	ldr	r2, [r3, #0]
 800b4da:	6022      	str	r2, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800b4dc:	6054      	str	r4, [r2, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800b4de:	61a3      	str	r3, [r4, #24]
  currp->state = CH_STATE_CURRENT;
 800b4e0:	2201      	movs	r2, #1
 800b4e2:	f883 2020 	strb.w	r2, [r3, #32]
    otp = chSchReadyAheadI(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
 800b4e6:	f7fb f9b3 	bl	8006850 <chSchReadyAheadI>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800b4ea:	4601      	mov	r1, r0
 800b4ec:	69a0      	ldr	r0, [r4, #24]
 800b4ee:	f7f4 ff1b 	bl	8000328 <_port_switch>
 800b4f2:	bd10      	pop	{r4, pc}
 800b4f4:	20003aec 	.word	0x20003aec
	...

0800b500 <chSchIsPreemptionRequired>:
  tprio_t p1 = firstprio(&ch.rlist.queue);
 800b500:	4b04      	ldr	r3, [pc, #16]	; (800b514 <chSchIsPreemptionRequired+0x14>)
 800b502:	681a      	ldr	r2, [r3, #0]
 800b504:	6890      	ldr	r0, [r2, #8]
  tprio_t p2 = currp->prio;
 800b506:	699b      	ldr	r3, [r3, #24]
 800b508:	689b      	ldr	r3, [r3, #8]
}
 800b50a:	4298      	cmp	r0, r3
 800b50c:	bf94      	ite	ls
 800b50e:	2000      	movls	r0, #0
 800b510:	2001      	movhi	r0, #1
 800b512:	4770      	bx	lr
 800b514:	20003aec 	.word	0x20003aec
	...

0800b520 <chSchRescheduleS>:
void chSchRescheduleS(void) {
 800b520:	b508      	push	{r3, lr}
  return firstprio(&ch.rlist.queue) > currp->prio;
 800b522:	4b05      	ldr	r3, [pc, #20]	; (800b538 <chSchRescheduleS+0x18>)
 800b524:	681a      	ldr	r2, [r3, #0]
 800b526:	6892      	ldr	r2, [r2, #8]
 800b528:	699b      	ldr	r3, [r3, #24]
 800b52a:	689b      	ldr	r3, [r3, #8]
  if (chSchIsRescRequiredI()) {
 800b52c:	429a      	cmp	r2, r3
 800b52e:	d901      	bls.n	800b534 <chSchRescheduleS+0x14>
    chSchDoRescheduleAhead();
 800b530:	f7ff fdb6 	bl	800b0a0 <chSchDoRescheduleAhead>
 800b534:	bd08      	pop	{r3, pc}
 800b536:	bf00      	nop
 800b538:	20003aec 	.word	0x20003aec
 800b53c:	00000000 	.word	0x00000000

0800b540 <chEvtSignal>:
void chEvtSignal(thread_t *tp, eventmask_t events) {
 800b540:	b508      	push	{r3, lr}
 800b542:	2320      	movs	r3, #32
 800b544:	f383 8811 	msr	BASEPRI, r3
  chEvtSignalI(tp, events);
 800b548:	f7fe fe02 	bl	800a150 <chEvtSignalI>
  chSchRescheduleS();
 800b54c:	f7ff ffe8 	bl	800b520 <chSchRescheduleS>
 800b550:	2300      	movs	r3, #0
 800b552:	f383 8811 	msr	BASEPRI, r3
 800b556:	bd08      	pop	{r3, pc}
	...

0800b560 <chCondBroadcast>:
void chCondBroadcast(condition_variable_t *cp) {
 800b560:	b508      	push	{r3, lr}
 800b562:	2320      	movs	r3, #32
 800b564:	f383 8811 	msr	BASEPRI, r3
  chCondBroadcastI(cp);
 800b568:	f7ff fd2a 	bl	800afc0 <chCondBroadcastI>
  chSchRescheduleS();
 800b56c:	f7ff ffd8 	bl	800b520 <chSchRescheduleS>
 800b570:	2300      	movs	r3, #0
 800b572:	f383 8811 	msr	BASEPRI, r3
 800b576:	bd08      	pop	{r3, pc}
	...

0800b580 <chMtxUnlockAll>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
 800b580:	b510      	push	{r4, lr}
  thread_t *ctp = currp;
 800b582:	4b12      	ldr	r3, [pc, #72]	; (800b5cc <chMtxUnlockAll+0x4c>)
 800b584:	699c      	ldr	r4, [r3, #24]
 800b586:	2320      	movs	r3, #32
 800b588:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if (ctp->mtxlist != NULL) {
 800b58c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b58e:	b1c3      	cbz	r3, 800b5c2 <chMtxUnlockAll+0x42>
    do {
      mutex_t *mp = ctp->mtxlist;
 800b590:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      ctp->mtxlist = mp->next;
 800b592:	68da      	ldr	r2, [r3, #12]
 800b594:	63a2      	str	r2, [r4, #56]	; 0x38
  return (bool)(tqp->next != (const thread_t *)tqp);
 800b596:	6818      	ldr	r0, [r3, #0]
      if (chMtxQueueNotEmptyS(mp)) {
 800b598:	4283      	cmp	r3, r0
 800b59a:	d009      	beq.n	800b5b0 <chMtxUnlockAll+0x30>
  tqp->next             = tp->queue.next;
 800b59c:	6802      	ldr	r2, [r0, #0]
 800b59e:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800b5a0:	6053      	str	r3, [r2, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->queue);
        mp->owner = tp;
 800b5a2:	6098      	str	r0, [r3, #8]
        mp->next = tp->mtxlist;
 800b5a4:	6b82      	ldr	r2, [r0, #56]	; 0x38
 800b5a6:	60da      	str	r2, [r3, #12]
        tp->mtxlist = mp;
 800b5a8:	6383      	str	r3, [r0, #56]	; 0x38
        (void) chSchReadyI(tp);
 800b5aa:	f7fb f969 	bl	8006880 <chSchReadyI>
 800b5ae:	e001      	b.n	800b5b4 <chMtxUnlockAll+0x34>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
 800b5b0:	2200      	movs	r2, #0
 800b5b2:	609a      	str	r2, [r3, #8]
      }
    } while (ctp->mtxlist != NULL);
 800b5b4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b5b6:	2b00      	cmp	r3, #0
 800b5b8:	d1ea      	bne.n	800b590 <chMtxUnlockAll+0x10>
    ctp->prio = ctp->realprio;
 800b5ba:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800b5bc:	60a3      	str	r3, [r4, #8]
    chSchRescheduleS();
 800b5be:	f7ff ffaf 	bl	800b520 <chSchRescheduleS>
 800b5c2:	2300      	movs	r3, #0
 800b5c4:	f383 8811 	msr	BASEPRI, r3
 800b5c8:	bd10      	pop	{r4, pc}
 800b5ca:	bf00      	nop
 800b5cc:	20003aec 	.word	0x20003aec

0800b5d0 <chMtxUnlock>:
void chMtxUnlock(mutex_t *mp) {
 800b5d0:	b510      	push	{r4, lr}
  thread_t *ctp = currp;
 800b5d2:	4b15      	ldr	r3, [pc, #84]	; (800b628 <chMtxUnlock+0x58>)
 800b5d4:	699c      	ldr	r4, [r3, #24]
 800b5d6:	2320      	movs	r3, #32
 800b5d8:	f383 8811 	msr	BASEPRI, r3
    ctp->mtxlist = mp->next;
 800b5dc:	68c3      	ldr	r3, [r0, #12]
 800b5de:	63a3      	str	r3, [r4, #56]	; 0x38
  return (bool)(tqp->next != (const thread_t *)tqp);
 800b5e0:	6802      	ldr	r2, [r0, #0]
    if (chMtxQueueNotEmptyS(mp)) {
 800b5e2:	4282      	cmp	r2, r0
 800b5e4:	d01a      	beq.n	800b61c <chMtxUnlock+0x4c>
      tprio_t newprio = ctp->realprio;
 800b5e6:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 800b5e8:	e007      	b.n	800b5fa <chMtxUnlock+0x2a>
 800b5ea:	681a      	ldr	r2, [r3, #0]
        if (chMtxQueueNotEmptyS(lmp) &&
 800b5ec:	4293      	cmp	r3, r2
 800b5ee:	d003      	beq.n	800b5f8 <chMtxUnlock+0x28>
            (lmp->queue.next->prio > newprio)) {
 800b5f0:	6892      	ldr	r2, [r2, #8]
        if (chMtxQueueNotEmptyS(lmp) &&
 800b5f2:	4291      	cmp	r1, r2
 800b5f4:	d200      	bcs.n	800b5f8 <chMtxUnlock+0x28>
          newprio = lmp->queue.next->prio;
 800b5f6:	4611      	mov	r1, r2
        lmp = lmp->next;
 800b5f8:	68db      	ldr	r3, [r3, #12]
      while (lmp != NULL) {
 800b5fa:	2b00      	cmp	r3, #0
 800b5fc:	d1f5      	bne.n	800b5ea <chMtxUnlock+0x1a>
 800b5fe:	4603      	mov	r3, r0
      ctp->prio = newprio;
 800b600:	60a1      	str	r1, [r4, #8]
  thread_t *tp = tqp->next;
 800b602:	6800      	ldr	r0, [r0, #0]
  tqp->next             = tp->queue.next;
 800b604:	6802      	ldr	r2, [r0, #0]
 800b606:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800b608:	6053      	str	r3, [r2, #4]
      mp->owner = tp;
 800b60a:	6098      	str	r0, [r3, #8]
      mp->next = tp->mtxlist;
 800b60c:	6b82      	ldr	r2, [r0, #56]	; 0x38
 800b60e:	60da      	str	r2, [r3, #12]
      tp->mtxlist = mp;
 800b610:	6383      	str	r3, [r0, #56]	; 0x38
      (void) chSchReadyI(tp);
 800b612:	f7fb f935 	bl	8006880 <chSchReadyI>
      chSchRescheduleS();
 800b616:	f7ff ff83 	bl	800b520 <chSchRescheduleS>
 800b61a:	e001      	b.n	800b620 <chMtxUnlock+0x50>
      mp->owner = NULL;
 800b61c:	2300      	movs	r3, #0
 800b61e:	6083      	str	r3, [r0, #8]
 800b620:	2300      	movs	r3, #0
 800b622:	f383 8811 	msr	BASEPRI, r3
 800b626:	bd10      	pop	{r4, pc}
 800b628:	20003aec 	.word	0x20003aec
 800b62c:	00000000 	.word	0x00000000

0800b630 <chSemReset>:
void chSemReset(semaphore_t *sp, cnt_t n) {
 800b630:	b508      	push	{r3, lr}
 800b632:	2320      	movs	r3, #32
 800b634:	f383 8811 	msr	BASEPRI, r3
  chSemResetI(sp, n);
 800b638:	f7ff fcd2 	bl	800afe0 <chSemResetI>
  chSchRescheduleS();
 800b63c:	f7ff ff70 	bl	800b520 <chSchRescheduleS>
 800b640:	2300      	movs	r3, #0
 800b642:	f383 8811 	msr	BASEPRI, r3
 800b646:	bd08      	pop	{r3, pc}
	...

0800b650 <chThdSetPriority>:
tprio_t chThdSetPriority(tprio_t newprio) {
 800b650:	b510      	push	{r4, lr}
 800b652:	2320      	movs	r3, #32
 800b654:	f383 8811 	msr	BASEPRI, r3
  oldprio = currp->realprio;
 800b658:	4b09      	ldr	r3, [pc, #36]	; (800b680 <chThdSetPriority+0x30>)
 800b65a:	699b      	ldr	r3, [r3, #24]
 800b65c:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
  if ((currp->prio == currp->realprio) || (newprio > currp->prio)) {
 800b65e:	689a      	ldr	r2, [r3, #8]
 800b660:	4294      	cmp	r4, r2
 800b662:	d001      	beq.n	800b668 <chThdSetPriority+0x18>
 800b664:	4282      	cmp	r2, r0
 800b666:	d200      	bcs.n	800b66a <chThdSetPriority+0x1a>
    currp->prio = newprio;
 800b668:	6098      	str	r0, [r3, #8]
  currp->realprio = newprio;
 800b66a:	4b05      	ldr	r3, [pc, #20]	; (800b680 <chThdSetPriority+0x30>)
 800b66c:	699b      	ldr	r3, [r3, #24]
 800b66e:	63d8      	str	r0, [r3, #60]	; 0x3c
  chSchRescheduleS();
 800b670:	f7ff ff56 	bl	800b520 <chSchRescheduleS>
 800b674:	2300      	movs	r3, #0
 800b676:	f383 8811 	msr	BASEPRI, r3
}
 800b67a:	4620      	mov	r0, r4
 800b67c:	bd10      	pop	{r4, pc}
 800b67e:	bf00      	nop
 800b680:	20003aec 	.word	0x20003aec
	...

0800b690 <chSchWakeupS>:
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 800b690:	b510      	push	{r4, lr}
 800b692:	4604      	mov	r4, r0
  thread_t *otp = currp;
 800b694:	4b0b      	ldr	r3, [pc, #44]	; (800b6c4 <chSchWakeupS+0x34>)
 800b696:	6998      	ldr	r0, [r3, #24]
  ntp->u.rdymsg = msg;
 800b698:	6261      	str	r1, [r4, #36]	; 0x24
  if (ntp->prio <= otp->prio) {
 800b69a:	68a2      	ldr	r2, [r4, #8]
 800b69c:	6883      	ldr	r3, [r0, #8]
 800b69e:	429a      	cmp	r2, r3
 800b6a0:	d803      	bhi.n	800b6aa <chSchWakeupS+0x1a>
    (void) chSchReadyI(ntp);
 800b6a2:	4620      	mov	r0, r4
 800b6a4:	f7fb f8ec 	bl	8006880 <chSchReadyI>
 800b6a8:	bd10      	pop	{r4, pc}
    otp = chSchReadyI(otp);
 800b6aa:	f7fb f8e9 	bl	8006880 <chSchReadyI>
    currp = ntp;
 800b6ae:	4b05      	ldr	r3, [pc, #20]	; (800b6c4 <chSchWakeupS+0x34>)
 800b6b0:	619c      	str	r4, [r3, #24]
    ntp->state = CH_STATE_CURRENT;
 800b6b2:	2301      	movs	r3, #1
 800b6b4:	f884 3020 	strb.w	r3, [r4, #32]
    chSysSwitch(ntp, otp);
 800b6b8:	4601      	mov	r1, r0
 800b6ba:	4620      	mov	r0, r4
 800b6bc:	f7f4 fe34 	bl	8000328 <_port_switch>
 800b6c0:	bd10      	pop	{r4, pc}
 800b6c2:	bf00      	nop
 800b6c4:	20003aec 	.word	0x20003aec
	...

0800b6d0 <chCondSignal>:
void chCondSignal(condition_variable_t *cp) {
 800b6d0:	b508      	push	{r3, lr}
 800b6d2:	2320      	movs	r3, #32
 800b6d4:	f383 8811 	msr	BASEPRI, r3
  return (bool)(tqp->next != (const thread_t *)tqp);
 800b6d8:	6802      	ldr	r2, [r0, #0]
  if (queue_notempty(&cp->queue)) {
 800b6da:	4290      	cmp	r0, r2
 800b6dc:	d006      	beq.n	800b6ec <chCondSignal+0x1c>
  tqp->next             = tp->queue.next;
 800b6de:	6811      	ldr	r1, [r2, #0]
 800b6e0:	6001      	str	r1, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800b6e2:	6048      	str	r0, [r1, #4]
    chSchWakeupS(queue_fifo_remove(&cp->queue), MSG_OK);
 800b6e4:	2100      	movs	r1, #0
 800b6e6:	4610      	mov	r0, r2
 800b6e8:	f7ff ffd2 	bl	800b690 <chSchWakeupS>
 800b6ec:	2300      	movs	r3, #0
 800b6ee:	f383 8811 	msr	BASEPRI, r3
 800b6f2:	bd08      	pop	{r3, pc}
	...

0800b700 <chSemSignal>:
void chSemSignal(semaphore_t *sp) {
 800b700:	b508      	push	{r3, lr}
 800b702:	2320      	movs	r3, #32
 800b704:	f383 8811 	msr	BASEPRI, r3
  if (++sp->cnt <= (cnt_t)0) {
 800b708:	6883      	ldr	r3, [r0, #8]
 800b70a:	3301      	adds	r3, #1
 800b70c:	6083      	str	r3, [r0, #8]
 800b70e:	2b00      	cmp	r3, #0
 800b710:	dc07      	bgt.n	800b722 <chSemSignal+0x22>
 800b712:	4603      	mov	r3, r0
  thread_t *tp = tqp->next;
 800b714:	6800      	ldr	r0, [r0, #0]
  tqp->next             = tp->queue.next;
 800b716:	6802      	ldr	r2, [r0, #0]
 800b718:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800b71a:	6053      	str	r3, [r2, #4]
    chSchWakeupS(queue_fifo_remove(&sp->queue), MSG_OK);
 800b71c:	2100      	movs	r1, #0
 800b71e:	f7ff ffb7 	bl	800b690 <chSchWakeupS>
 800b722:	2300      	movs	r3, #0
 800b724:	f383 8811 	msr	BASEPRI, r3
 800b728:	bd08      	pop	{r3, pc}
 800b72a:	bf00      	nop
 800b72c:	0000      	movs	r0, r0
	...

0800b730 <chThdResumeS>:
  if (*trp != NULL) {
 800b730:	6802      	ldr	r2, [r0, #0]
 800b732:	b13a      	cbz	r2, 800b744 <chThdResumeS+0x14>
void chThdResumeS(thread_reference_t *trp, msg_t msg) {
 800b734:	b508      	push	{r3, lr}
 800b736:	4603      	mov	r3, r0
    *trp = NULL;
 800b738:	2000      	movs	r0, #0
 800b73a:	6018      	str	r0, [r3, #0]
    chSchWakeupS(tp, msg);
 800b73c:	4610      	mov	r0, r2
 800b73e:	f7ff ffa7 	bl	800b690 <chSchWakeupS>
 800b742:	bd08      	pop	{r3, pc}
 800b744:	4770      	bx	lr
 800b746:	bf00      	nop
	...

0800b750 <chThdResume>:
void chThdResume(thread_reference_t *trp, msg_t msg) {
 800b750:	b508      	push	{r3, lr}
 800b752:	2320      	movs	r3, #32
 800b754:	f383 8811 	msr	BASEPRI, r3
  chThdResumeS(trp, msg);
 800b758:	f7ff ffea 	bl	800b730 <chThdResumeS>
 800b75c:	2300      	movs	r3, #0
 800b75e:	f383 8811 	msr	BASEPRI, r3
 800b762:	bd08      	pop	{r3, pc}
	...

0800b770 <chThdCreateStatic>:
                            tprio_t prio, tfunc_t pf, void *arg) {
 800b770:	b510      	push	{r4, lr}
 800b772:	4604      	mov	r4, r0
 800b774:	2020      	movs	r0, #32
 800b776:	f380 8811 	msr	BASEPRI, r0
  tp = (thread_t *)((uint8_t *)wsp + size -
 800b77a:	3948      	subs	r1, #72	; 0x48
 800b77c:	1860      	adds	r0, r4, r1
  tp->wabase = (stkalign_t *)wsp;
 800b77e:	61c4      	str	r4, [r0, #28]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 800b780:	f1a0 0164 	sub.w	r1, r0, #100	; 0x64
 800b784:	60c1      	str	r1, [r0, #12]
 800b786:	f840 3c24 	str.w	r3, [r0, #-36]
 800b78a:	9b02      	ldr	r3, [sp, #8]
 800b78c:	f840 3c20 	str.w	r3, [r0, #-32]
 800b790:	4b07      	ldr	r3, [pc, #28]	; (800b7b0 <chThdCreateStatic+0x40>)
 800b792:	f840 3c04 	str.w	r3, [r0, #-4]
  tp = _thread_init(tp, "noname", prio);
 800b796:	4907      	ldr	r1, [pc, #28]	; (800b7b4 <chThdCreateStatic+0x44>)
 800b798:	f7ff fe52 	bl	800b440 <_thread_init>
 800b79c:	4604      	mov	r4, r0
  chSchWakeupS(tp, MSG_OK);
 800b79e:	2100      	movs	r1, #0
 800b7a0:	f7ff ff76 	bl	800b690 <chSchWakeupS>
 800b7a4:	2300      	movs	r3, #0
 800b7a6:	f383 8811 	msr	BASEPRI, r3
}
 800b7aa:	4620      	mov	r0, r4
 800b7ac:	bd10      	pop	{r4, pc}
 800b7ae:	bf00      	nop
 800b7b0:	08000341 	.word	0x08000341
 800b7b4:	08010068 	.word	0x08010068
	...

0800b7c0 <chThdCreate>:
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
 800b7c0:	b510      	push	{r4, lr}
 800b7c2:	2320      	movs	r3, #32
 800b7c4:	f383 8811 	msr	BASEPRI, r3
  tp = chThdCreateSuspendedI(tdp);
 800b7c8:	f7ff fe62 	bl	800b490 <chThdCreateSuspendedI>
 800b7cc:	4604      	mov	r4, r0
  chSchWakeupS(tp, MSG_OK);
 800b7ce:	2100      	movs	r1, #0
 800b7d0:	f7ff ff5e 	bl	800b690 <chSchWakeupS>
 800b7d4:	2300      	movs	r3, #0
 800b7d6:	f383 8811 	msr	BASEPRI, r3
}
 800b7da:	4620      	mov	r0, r4
 800b7dc:	bd10      	pop	{r4, pc}
 800b7de:	bf00      	nop

0800b7e0 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
 800b7e0:	b508      	push	{r3, lr}
  thread_t *otp = currp;
 800b7e2:	4b07      	ldr	r3, [pc, #28]	; (800b800 <chSchGoSleepS+0x20>)
 800b7e4:	6999      	ldr	r1, [r3, #24]
  otp->state = newstate;
 800b7e6:	f881 0020 	strb.w	r0, [r1, #32]
  thread_t *tp = tqp->next;
 800b7ea:	6818      	ldr	r0, [r3, #0]
  tqp->next             = tp->queue.next;
 800b7ec:	6802      	ldr	r2, [r0, #0]
 800b7ee:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800b7f0:	6053      	str	r3, [r2, #4]
  currp = queue_fifo_remove(&ch.rlist.queue);
 800b7f2:	6198      	str	r0, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 800b7f4:	2301      	movs	r3, #1
 800b7f6:	f880 3020 	strb.w	r3, [r0, #32]
  chSysSwitch(currp, otp);
 800b7fa:	f7f4 fd95 	bl	8000328 <_port_switch>
 800b7fe:	bd08      	pop	{r3, pc}
 800b800:	20003aec 	.word	0x20003aec
	...

0800b810 <chMtxLockS>:
void chMtxLockS(mutex_t *mp) {
 800b810:	b570      	push	{r4, r5, r6, lr}
 800b812:	4605      	mov	r5, r0
  thread_t *ctp = currp;
 800b814:	4b30      	ldr	r3, [pc, #192]	; (800b8d8 <chMtxLockS+0xc8>)
 800b816:	699c      	ldr	r4, [r3, #24]
  if (mp->owner != NULL) {
 800b818:	6880      	ldr	r0, [r0, #8]
 800b81a:	2800      	cmp	r0, #0
 800b81c:	d13f      	bne.n	800b89e <chMtxLockS+0x8e>
 800b81e:	e055      	b.n	800b8cc <chMtxLockS+0xbc>
        tp->prio = ctp->prio;
 800b820:	6083      	str	r3, [r0, #8]
        switch (tp->state) {
 800b822:	f890 3020 	ldrb.w	r3, [r0, #32]
 800b826:	2b06      	cmp	r3, #6
 800b828:	d004      	beq.n	800b834 <chMtxLockS+0x24>
 800b82a:	2b07      	cmp	r3, #7
 800b82c:	d019      	beq.n	800b862 <chMtxLockS+0x52>
 800b82e:	2b00      	cmp	r3, #0
 800b830:	d139      	bne.n	800b8a6 <chMtxLockS+0x96>
 800b832:	e02b      	b.n	800b88c <chMtxLockS+0x7c>
  tp->queue.prev->queue.next = tp->queue.next;
 800b834:	6843      	ldr	r3, [r0, #4]
 800b836:	6802      	ldr	r2, [r0, #0]
 800b838:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800b83a:	6803      	ldr	r3, [r0, #0]
 800b83c:	6842      	ldr	r2, [r0, #4]
 800b83e:	605a      	str	r2, [r3, #4]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 800b840:	6a46      	ldr	r6, [r0, #36]	; 0x24
  thread_t *cp = (thread_t *)tqp;
 800b842:	4633      	mov	r3, r6
    cp = cp->queue.next;
 800b844:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800b846:	429e      	cmp	r6, r3
 800b848:	d003      	beq.n	800b852 <chMtxLockS+0x42>
 800b84a:	6899      	ldr	r1, [r3, #8]
 800b84c:	6882      	ldr	r2, [r0, #8]
 800b84e:	4291      	cmp	r1, r2
 800b850:	d2f8      	bcs.n	800b844 <chMtxLockS+0x34>
  tp->queue.next             = cp;
 800b852:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 800b854:	685a      	ldr	r2, [r3, #4]
 800b856:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 800b858:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 800b85a:	6058      	str	r0, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 800b85c:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800b85e:	6898      	ldr	r0, [r3, #8]
 800b860:	e01d      	b.n	800b89e <chMtxLockS+0x8e>
  tp->queue.prev->queue.next = tp->queue.next;
 800b862:	6843      	ldr	r3, [r0, #4]
 800b864:	6802      	ldr	r2, [r0, #0]
 800b866:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800b868:	6803      	ldr	r3, [r0, #0]
 800b86a:	6842      	ldr	r2, [r0, #4]
 800b86c:	605a      	str	r2, [r3, #4]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 800b86e:	6a46      	ldr	r6, [r0, #36]	; 0x24
  thread_t *cp = (thread_t *)tqp;
 800b870:	4633      	mov	r3, r6
    cp = cp->queue.next;
 800b872:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800b874:	429e      	cmp	r6, r3
 800b876:	d003      	beq.n	800b880 <chMtxLockS+0x70>
 800b878:	6899      	ldr	r1, [r3, #8]
 800b87a:	6882      	ldr	r2, [r0, #8]
 800b87c:	4291      	cmp	r1, r2
 800b87e:	d2f8      	bcs.n	800b872 <chMtxLockS+0x62>
  tp->queue.next             = cp;
 800b880:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 800b882:	685a      	ldr	r2, [r3, #4]
 800b884:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 800b886:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 800b888:	6058      	str	r0, [r3, #4]
 800b88a:	e00c      	b.n	800b8a6 <chMtxLockS+0x96>
  tp->queue.prev->queue.next = tp->queue.next;
 800b88c:	6843      	ldr	r3, [r0, #4]
 800b88e:	6802      	ldr	r2, [r0, #0]
 800b890:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800b892:	6803      	ldr	r3, [r0, #0]
 800b894:	6842      	ldr	r2, [r0, #4]
 800b896:	605a      	str	r2, [r3, #4]
          (void) chSchReadyI(queue_dequeue(tp));
 800b898:	f7fa fff2 	bl	8006880 <chSchReadyI>
 800b89c:	e003      	b.n	800b8a6 <chMtxLockS+0x96>
      while (tp->prio < ctp->prio) {
 800b89e:	6882      	ldr	r2, [r0, #8]
 800b8a0:	68a3      	ldr	r3, [r4, #8]
 800b8a2:	429a      	cmp	r2, r3
 800b8a4:	d3bc      	bcc.n	800b820 <chMtxLockS+0x10>
      queue_prio_insert(ctp, &mp->queue);
 800b8a6:	4628      	mov	r0, r5
  thread_t *cp = (thread_t *)tqp;
 800b8a8:	462b      	mov	r3, r5
    cp = cp->queue.next;
 800b8aa:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800b8ac:	4298      	cmp	r0, r3
 800b8ae:	d003      	beq.n	800b8b8 <chMtxLockS+0xa8>
 800b8b0:	6899      	ldr	r1, [r3, #8]
 800b8b2:	68a2      	ldr	r2, [r4, #8]
 800b8b4:	4291      	cmp	r1, r2
 800b8b6:	d2f8      	bcs.n	800b8aa <chMtxLockS+0x9a>
  tp->queue.next             = cp;
 800b8b8:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 800b8ba:	685a      	ldr	r2, [r3, #4]
 800b8bc:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
 800b8be:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 800b8c0:	605c      	str	r4, [r3, #4]
      ctp->u.wtmtxp = mp;
 800b8c2:	6265      	str	r5, [r4, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 800b8c4:	2006      	movs	r0, #6
 800b8c6:	f7ff ff8b 	bl	800b7e0 <chSchGoSleepS>
 800b8ca:	bd70      	pop	{r4, r5, r6, pc}
    mp->owner = ctp;
 800b8cc:	60ac      	str	r4, [r5, #8]
    mp->next = ctp->mtxlist;
 800b8ce:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b8d0:	60eb      	str	r3, [r5, #12]
    ctp->mtxlist = mp;
 800b8d2:	63a5      	str	r5, [r4, #56]	; 0x38
 800b8d4:	bd70      	pop	{r4, r5, r6, pc}
 800b8d6:	bf00      	nop
 800b8d8:	20003aec 	.word	0x20003aec
 800b8dc:	00000000 	.word	0x00000000

0800b8e0 <chCondWaitS>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
 800b8e0:	b570      	push	{r4, r5, r6, lr}
 800b8e2:	4604      	mov	r4, r0
  thread_t *ctp = currp;
 800b8e4:	4b0e      	ldr	r3, [pc, #56]	; (800b920 <chCondWaitS+0x40>)
 800b8e6:	699d      	ldr	r5, [r3, #24]
 *
 * @xclass
 */
static inline mutex_t *chMtxGetNextMutexX(void) {

  return chThdGetSelfX()->mtxlist;
 800b8e8:	6bae      	ldr	r6, [r5, #56]	; 0x38
  chDbgCheckClassS();
  chDbgCheck(cp != NULL);
  chDbgAssert(mp != NULL, "not owning a mutex");

  /* Releasing "current" mutex.*/
  chMtxUnlockS(mp);
 800b8ea:	4630      	mov	r0, r6
 800b8ec:	f7ff fc70 	bl	800b1d0 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->u.wtobjp = cp;
 800b8f0:	626c      	str	r4, [r5, #36]	; 0x24
  queue_prio_insert(ctp, &cp->queue);
 800b8f2:	4621      	mov	r1, r4
  thread_t *cp = (thread_t *)tqp;
 800b8f4:	4620      	mov	r0, r4
    cp = cp->queue.next;
 800b8f6:	6800      	ldr	r0, [r0, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800b8f8:	4281      	cmp	r1, r0
 800b8fa:	d003      	beq.n	800b904 <chCondWaitS+0x24>
 800b8fc:	6882      	ldr	r2, [r0, #8]
 800b8fe:	68ab      	ldr	r3, [r5, #8]
 800b900:	429a      	cmp	r2, r3
 800b902:	d2f8      	bcs.n	800b8f6 <chCondWaitS+0x16>
  tp->queue.next             = cp;
 800b904:	6028      	str	r0, [r5, #0]
  tp->queue.prev             = cp->queue.prev;
 800b906:	6843      	ldr	r3, [r0, #4]
 800b908:	606b      	str	r3, [r5, #4]
  tp->queue.prev->queue.next = tp;
 800b90a:	601d      	str	r5, [r3, #0]
  cp->queue.prev             = tp;
 800b90c:	6045      	str	r5, [r0, #4]
  chSchGoSleepS(CH_STATE_WTCOND);
 800b90e:	2007      	movs	r0, #7
 800b910:	f7ff ff66 	bl	800b7e0 <chSchGoSleepS>
  msg = ctp->u.rdymsg;
 800b914:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  chMtxLockS(mp);
 800b916:	4630      	mov	r0, r6
 800b918:	f7ff ff7a 	bl	800b810 <chMtxLockS>

  return msg;
}
 800b91c:	4620      	mov	r0, r4
 800b91e:	bd70      	pop	{r4, r5, r6, pc}
 800b920:	20003aec 	.word	0x20003aec
	...

0800b930 <chCondWait>:
msg_t chCondWait(condition_variable_t *cp) {
 800b930:	b508      	push	{r3, lr}
 800b932:	2320      	movs	r3, #32
 800b934:	f383 8811 	msr	BASEPRI, r3
  msg = chCondWaitS(cp);
 800b938:	f7ff ffd2 	bl	800b8e0 <chCondWaitS>
 800b93c:	2300      	movs	r3, #0
 800b93e:	f383 8811 	msr	BASEPRI, r3
}
 800b942:	bd08      	pop	{r3, pc}
	...

0800b950 <chMtxLock>:
void chMtxLock(mutex_t *mp) {
 800b950:	b508      	push	{r3, lr}
 800b952:	2320      	movs	r3, #32
 800b954:	f383 8811 	msr	BASEPRI, r3
  chMtxLockS(mp);
 800b958:	f7ff ff5a 	bl	800b810 <chMtxLockS>
 800b95c:	2300      	movs	r3, #0
 800b95e:	f383 8811 	msr	BASEPRI, r3
 800b962:	bd08      	pop	{r3, pc}
	...

0800b970 <chSemSignalWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 800b970:	b538      	push	{r3, r4, r5, lr}
 800b972:	460c      	mov	r4, r1
 800b974:	2320      	movs	r3, #32
 800b976:	f383 8811 	msr	BASEPRI, r3
              ((sps->cnt < (cnt_t)0) && queue_notempty(&sps->queue)),
              "inconsistent semaphore");
  chDbgAssert(((spw->cnt >= (cnt_t)0) && queue_isempty(&spw->queue)) ||
              ((spw->cnt < (cnt_t)0) && queue_notempty(&spw->queue)),
              "inconsistent semaphore");
  if (++sps->cnt <= (cnt_t)0) {
 800b97a:	6883      	ldr	r3, [r0, #8]
 800b97c:	3301      	adds	r3, #1
 800b97e:	6083      	str	r3, [r0, #8]
 800b980:	2b00      	cmp	r3, #0
 800b982:	dc08      	bgt.n	800b996 <chSemSignalWait+0x26>
  thread_t *tp = tqp->next;
 800b984:	6803      	ldr	r3, [r0, #0]
  tqp->next             = tp->queue.next;
 800b986:	681a      	ldr	r2, [r3, #0]
 800b988:	6002      	str	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800b98a:	6050      	str	r0, [r2, #4]
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
 800b98c:	4618      	mov	r0, r3
 800b98e:	f7fa ff77 	bl	8006880 <chSchReadyI>
 800b992:	2300      	movs	r3, #0
 800b994:	6243      	str	r3, [r0, #36]	; 0x24
  }
  if (--spw->cnt < (cnt_t)0) {
 800b996:	68a3      	ldr	r3, [r4, #8]
 800b998:	3b01      	subs	r3, #1
 800b99a:	60a3      	str	r3, [r4, #8]
 800b99c:	2b00      	cmp	r3, #0
 800b99e:	da0c      	bge.n	800b9ba <chSemSignalWait+0x4a>
    thread_t *ctp = currp;
 800b9a0:	4b09      	ldr	r3, [pc, #36]	; (800b9c8 <chSemSignalWait+0x58>)
 800b9a2:	699d      	ldr	r5, [r3, #24]
  tp->queue.next             = (thread_t *)tqp;
 800b9a4:	602c      	str	r4, [r5, #0]
  tp->queue.prev             = tqp->prev;
 800b9a6:	6863      	ldr	r3, [r4, #4]
 800b9a8:	606b      	str	r3, [r5, #4]
  tp->queue.prev->queue.next = tp;
 800b9aa:	601d      	str	r5, [r3, #0]
  tqp->prev                  = tp;
 800b9ac:	6065      	str	r5, [r4, #4]
    sem_insert(ctp, &spw->queue);
    ctp->u.wtsemp = spw;
 800b9ae:	626c      	str	r4, [r5, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTSEM);
 800b9b0:	2005      	movs	r0, #5
 800b9b2:	f7ff ff15 	bl	800b7e0 <chSchGoSleepS>
    msg = ctp->u.rdymsg;
 800b9b6:	6a68      	ldr	r0, [r5, #36]	; 0x24
 800b9b8:	e002      	b.n	800b9c0 <chSemSignalWait+0x50>
  }
  else {
    chSchRescheduleS();
 800b9ba:	f7ff fdb1 	bl	800b520 <chSchRescheduleS>
    msg = MSG_OK;
 800b9be:	2000      	movs	r0, #0
 800b9c0:	2300      	movs	r3, #0
 800b9c2:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return msg;
}
 800b9c6:	bd38      	pop	{r3, r4, r5, pc}
 800b9c8:	20003aec 	.word	0x20003aec
 800b9cc:	00000000 	.word	0x00000000

0800b9d0 <chSemWaitS>:
  if (--sp->cnt < (cnt_t)0) {
 800b9d0:	6883      	ldr	r3, [r0, #8]
 800b9d2:	3b01      	subs	r3, #1
 800b9d4:	6083      	str	r3, [r0, #8]
 800b9d6:	2b00      	cmp	r3, #0
 800b9d8:	da0e      	bge.n	800b9f8 <chSemWaitS+0x28>
msg_t chSemWaitS(semaphore_t *sp) {
 800b9da:	b510      	push	{r4, lr}
    currp->u.wtsemp = sp;
 800b9dc:	4c07      	ldr	r4, [pc, #28]	; (800b9fc <chSemWaitS+0x2c>)
 800b9de:	69a3      	ldr	r3, [r4, #24]
 800b9e0:	6258      	str	r0, [r3, #36]	; 0x24
  tp->queue.next             = (thread_t *)tqp;
 800b9e2:	6018      	str	r0, [r3, #0]
  tp->queue.prev             = tqp->prev;
 800b9e4:	6842      	ldr	r2, [r0, #4]
 800b9e6:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800b9e8:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
 800b9ea:	6043      	str	r3, [r0, #4]
    chSchGoSleepS(CH_STATE_WTSEM);
 800b9ec:	2005      	movs	r0, #5
 800b9ee:	f7ff fef7 	bl	800b7e0 <chSchGoSleepS>
    return currp->u.rdymsg;
 800b9f2:	69a3      	ldr	r3, [r4, #24]
 800b9f4:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800b9f6:	bd10      	pop	{r4, pc}
  return MSG_OK;
 800b9f8:	2000      	movs	r0, #0
 800b9fa:	4770      	bx	lr
 800b9fc:	20003aec 	.word	0x20003aec

0800ba00 <chSemWait>:
msg_t chSemWait(semaphore_t *sp) {
 800ba00:	b508      	push	{r3, lr}
 800ba02:	2320      	movs	r3, #32
 800ba04:	f383 8811 	msr	BASEPRI, r3
  msg = chSemWaitS(sp);
 800ba08:	f7ff ffe2 	bl	800b9d0 <chSemWaitS>
 800ba0c:	2300      	movs	r3, #0
 800ba0e:	f383 8811 	msr	BASEPRI, r3
}
 800ba12:	bd08      	pop	{r3, pc}
	...

0800ba20 <chThdWait>:
msg_t chThdWait(thread_t *tp) {
 800ba20:	b538      	push	{r3, r4, r5, lr}
 800ba22:	4604      	mov	r4, r0
 800ba24:	2320      	movs	r3, #32
 800ba26:	f383 8811 	msr	BASEPRI, r3
  if (tp->state != CH_STATE_FINAL) {
 800ba2a:	f890 3020 	ldrb.w	r3, [r0, #32]
 800ba2e:	2b0f      	cmp	r3, #15
 800ba30:	d007      	beq.n	800ba42 <chThdWait+0x22>
    list_insert(currp, &tp->waiting);
 800ba32:	4b08      	ldr	r3, [pc, #32]	; (800ba54 <chThdWait+0x34>)
 800ba34:	699b      	ldr	r3, [r3, #24]
  tp->queue.next = tlp->next;
 800ba36:	6a82      	ldr	r2, [r0, #40]	; 0x28
 800ba38:	601a      	str	r2, [r3, #0]
  tlp->next = tp;
 800ba3a:	6283      	str	r3, [r0, #40]	; 0x28
    chSchGoSleepS(CH_STATE_WTEXIT);
 800ba3c:	2009      	movs	r0, #9
 800ba3e:	f7ff fecf 	bl	800b7e0 <chSchGoSleepS>
  msg = tp->u.exitcode;
 800ba42:	6a65      	ldr	r5, [r4, #36]	; 0x24
 800ba44:	2300      	movs	r3, #0
 800ba46:	f383 8811 	msr	BASEPRI, r3
  chThdRelease(tp);
 800ba4a:	4620      	mov	r0, r4
 800ba4c:	f7ff fcb0 	bl	800b3b0 <chThdRelease>
}
 800ba50:	4628      	mov	r0, r5
 800ba52:	bd38      	pop	{r3, r4, r5, pc}
 800ba54:	20003aec 	.word	0x20003aec
	...

0800ba60 <chThdExitS>:
void chThdExitS(msg_t msg) {
 800ba60:	b510      	push	{r4, lr}
  thread_t *tp = currp;
 800ba62:	4b0f      	ldr	r3, [pc, #60]	; (800baa0 <chThdExitS+0x40>)
 800ba64:	699c      	ldr	r4, [r3, #24]
  tp->u.exitcode = msg;
 800ba66:	6260      	str	r0, [r4, #36]	; 0x24
 800ba68:	e003      	b.n	800ba72 <chThdExitS+0x12>
  tlp->next = tp->queue.next;
 800ba6a:	6803      	ldr	r3, [r0, #0]
 800ba6c:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 800ba6e:	f7fa ff07 	bl	8006880 <chSchReadyI>
  while (list_notempty(&tp->waiting)) {
 800ba72:	f104 0328 	add.w	r3, r4, #40	; 0x28
  return (bool)(tlp->next != (thread_t *)tlp);
 800ba76:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 800ba78:	4283      	cmp	r3, r0
 800ba7a:	d1f6      	bne.n	800ba6a <chThdExitS+0xa>
  if ((tp->refs == (trefs_t)0) &&
 800ba7c:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 800ba80:	b953      	cbnz	r3, 800ba98 <chThdExitS+0x38>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 800ba82:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
  if ((tp->refs == (trefs_t)0) &&
 800ba86:	f013 0f03 	tst.w	r3, #3
 800ba8a:	d105      	bne.n	800ba98 <chThdExitS+0x38>
    REG_REMOVE(tp);
 800ba8c:	6963      	ldr	r3, [r4, #20]
 800ba8e:	6922      	ldr	r2, [r4, #16]
 800ba90:	611a      	str	r2, [r3, #16]
 800ba92:	6923      	ldr	r3, [r4, #16]
 800ba94:	6962      	ldr	r2, [r4, #20]
 800ba96:	615a      	str	r2, [r3, #20]
  chSchGoSleepS(CH_STATE_FINAL);
 800ba98:	200f      	movs	r0, #15
 800ba9a:	f7ff fea1 	bl	800b7e0 <chSchGoSleepS>
 800ba9e:	bd10      	pop	{r4, pc}
 800baa0:	20003aec 	.word	0x20003aec
	...

0800bab0 <chThdExit>:
void chThdExit(msg_t msg) {
 800bab0:	b508      	push	{r3, lr}
 800bab2:	2320      	movs	r3, #32
 800bab4:	f383 8811 	msr	BASEPRI, r3
  chThdExitS(msg);
 800bab8:	f7ff ffd2 	bl	800ba60 <chThdExitS>
 800babc:	bd08      	pop	{r3, pc}
 800babe:	bf00      	nop

0800bac0 <chSchGoSleepTimeoutS>:
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 800bac0:	b510      	push	{r4, lr}
 800bac2:	b086      	sub	sp, #24
 800bac4:	4604      	mov	r4, r0
  if (TIME_INFINITE != timeout) {
 800bac6:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
 800baca:	d00e      	beq.n	800baea <chSchGoSleepTimeoutS+0x2a>
    chVTDoSetI(&vt, timeout, wakeup, currp);
 800bacc:	4b0a      	ldr	r3, [pc, #40]	; (800baf8 <chSchGoSleepTimeoutS+0x38>)
 800bace:	699b      	ldr	r3, [r3, #24]
 800bad0:	4a0a      	ldr	r2, [pc, #40]	; (800bafc <chSchGoSleepTimeoutS+0x3c>)
 800bad2:	a801      	add	r0, sp, #4
 800bad4:	f7fa ff2c 	bl	8006930 <chVTDoSetI>
    chSchGoSleepS(newstate);
 800bad8:	4620      	mov	r0, r4
 800bada:	f7ff fe81 	bl	800b7e0 <chSchGoSleepS>
  return (bool)(vtp->func != NULL);
 800bade:	9b04      	ldr	r3, [sp, #16]
    if (chVTIsArmedI(&vt)) {
 800bae0:	b12b      	cbz	r3, 800baee <chSchGoSleepTimeoutS+0x2e>
      chVTDoResetI(&vt);
 800bae2:	a801      	add	r0, sp, #4
 800bae4:	f7fa fee4 	bl	80068b0 <chVTDoResetI>
 800bae8:	e001      	b.n	800baee <chSchGoSleepTimeoutS+0x2e>
    chSchGoSleepS(newstate);
 800baea:	f7ff fe79 	bl	800b7e0 <chSchGoSleepS>
  return currp->u.rdymsg;
 800baee:	4b02      	ldr	r3, [pc, #8]	; (800baf8 <chSchGoSleepTimeoutS+0x38>)
 800baf0:	699b      	ldr	r3, [r3, #24]
}
 800baf2:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800baf4:	b006      	add	sp, #24
 800baf6:	bd10      	pop	{r4, pc}
 800baf8:	20003aec 	.word	0x20003aec
 800bafc:	0800b011 	.word	0x0800b011

0800bb00 <chCondWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chCondWaitTimeoutS(condition_variable_t *cp, sysinterval_t timeout) {
 800bb00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800bb02:	4604      	mov	r4, r0
 800bb04:	460f      	mov	r7, r1
  return ch.rlist.current;
 800bb06:	4d11      	ldr	r5, [pc, #68]	; (800bb4c <chCondWaitTimeoutS+0x4c>)
 800bb08:	69ab      	ldr	r3, [r5, #24]
 800bb0a:	6b9e      	ldr	r6, [r3, #56]	; 0x38
  chDbgCheckClassS();
  chDbgCheck((cp != NULL) && (timeout != TIME_IMMEDIATE));
  chDbgAssert(mp != NULL, "not owning a mutex");

  /* Releasing "current" mutex.*/
  chMtxUnlockS(mp);
 800bb0c:	4630      	mov	r0, r6
 800bb0e:	f7ff fb5f 	bl	800b1d0 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->u.wtobjp = cp;
 800bb12:	69a9      	ldr	r1, [r5, #24]
 800bb14:	624c      	str	r4, [r1, #36]	; 0x24
  queue_prio_insert(currp, &cp->queue);
 800bb16:	4625      	mov	r5, r4
  thread_t *cp = (thread_t *)tqp;
 800bb18:	4620      	mov	r0, r4
    cp = cp->queue.next;
 800bb1a:	6800      	ldr	r0, [r0, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800bb1c:	4285      	cmp	r5, r0
 800bb1e:	d003      	beq.n	800bb28 <chCondWaitTimeoutS+0x28>
 800bb20:	6882      	ldr	r2, [r0, #8]
 800bb22:	688b      	ldr	r3, [r1, #8]
 800bb24:	429a      	cmp	r2, r3
 800bb26:	d2f8      	bcs.n	800bb1a <chCondWaitTimeoutS+0x1a>
  tp->queue.next             = cp;
 800bb28:	6008      	str	r0, [r1, #0]
  tp->queue.prev             = cp->queue.prev;
 800bb2a:	6843      	ldr	r3, [r0, #4]
 800bb2c:	604b      	str	r3, [r1, #4]
  tp->queue.prev->queue.next = tp;
 800bb2e:	6019      	str	r1, [r3, #0]
  cp->queue.prev             = tp;
 800bb30:	6041      	str	r1, [r0, #4]
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, timeout);
 800bb32:	4639      	mov	r1, r7
 800bb34:	2007      	movs	r0, #7
 800bb36:	f7ff ffc3 	bl	800bac0 <chSchGoSleepTimeoutS>
 800bb3a:	4604      	mov	r4, r0
  if (msg != MSG_TIMEOUT) {
 800bb3c:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800bb40:	d002      	beq.n	800bb48 <chCondWaitTimeoutS+0x48>
    chMtxLockS(mp);
 800bb42:	4630      	mov	r0, r6
 800bb44:	f7ff fe64 	bl	800b810 <chMtxLockS>
  }

  return msg;
}
 800bb48:	4620      	mov	r0, r4
 800bb4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800bb4c:	20003aec 	.word	0x20003aec

0800bb50 <chCondWaitTimeout>:
msg_t chCondWaitTimeout(condition_variable_t *cp, sysinterval_t timeout) {
 800bb50:	b508      	push	{r3, lr}
 800bb52:	2320      	movs	r3, #32
 800bb54:	f383 8811 	msr	BASEPRI, r3
  msg = chCondWaitTimeoutS(cp, timeout);
 800bb58:	f7ff ffd2 	bl	800bb00 <chCondWaitTimeoutS>
 800bb5c:	2300      	movs	r3, #0
 800bb5e:	f383 8811 	msr	BASEPRI, r3
}
 800bb62:	bd08      	pop	{r3, pc}
	...

0800bb70 <chSemWaitTimeoutS>:
msg_t chSemWaitTimeoutS(semaphore_t *sp, sysinterval_t timeout) {
 800bb70:	b508      	push	{r3, lr}
  if (--sp->cnt < (cnt_t)0) {
 800bb72:	6882      	ldr	r2, [r0, #8]
 800bb74:	1e53      	subs	r3, r2, #1
 800bb76:	6083      	str	r3, [r0, #8]
 800bb78:	2b00      	cmp	r3, #0
 800bb7a:	da10      	bge.n	800bb9e <chSemWaitTimeoutS+0x2e>
    if (TIME_IMMEDIATE == timeout) {
 800bb7c:	b919      	cbnz	r1, 800bb86 <chSemWaitTimeoutS+0x16>
      sp->cnt++;
 800bb7e:	6082      	str	r2, [r0, #8]
      return MSG_TIMEOUT;
 800bb80:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800bb84:	bd08      	pop	{r3, pc}
    currp->u.wtsemp = sp;
 800bb86:	4b07      	ldr	r3, [pc, #28]	; (800bba4 <chSemWaitTimeoutS+0x34>)
 800bb88:	699b      	ldr	r3, [r3, #24]
 800bb8a:	6258      	str	r0, [r3, #36]	; 0x24
  tp->queue.next             = (thread_t *)tqp;
 800bb8c:	6018      	str	r0, [r3, #0]
  tp->queue.prev             = tqp->prev;
 800bb8e:	6842      	ldr	r2, [r0, #4]
 800bb90:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800bb92:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
 800bb94:	6043      	str	r3, [r0, #4]
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
 800bb96:	2005      	movs	r0, #5
 800bb98:	f7ff ff92 	bl	800bac0 <chSchGoSleepTimeoutS>
 800bb9c:	bd08      	pop	{r3, pc}
  return MSG_OK;
 800bb9e:	2000      	movs	r0, #0
}
 800bba0:	bd08      	pop	{r3, pc}
 800bba2:	bf00      	nop
 800bba4:	20003aec 	.word	0x20003aec
	...

0800bbb0 <chSemWaitTimeout>:
msg_t chSemWaitTimeout(semaphore_t *sp, sysinterval_t timeout) {
 800bbb0:	b508      	push	{r3, lr}
 800bbb2:	2320      	movs	r3, #32
 800bbb4:	f383 8811 	msr	BASEPRI, r3
  msg = chSemWaitTimeoutS(sp, timeout);
 800bbb8:	f7ff ffda 	bl	800bb70 <chSemWaitTimeoutS>
 800bbbc:	2300      	movs	r3, #0
 800bbbe:	f383 8811 	msr	BASEPRI, r3
}
 800bbc2:	bd08      	pop	{r3, pc}
	...

0800bbd0 <chThdEnqueueTimeoutS>:
  if (TIME_IMMEDIATE == timeout) {
 800bbd0:	b159      	cbz	r1, 800bbea <chThdEnqueueTimeoutS+0x1a>
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 800bbd2:	b508      	push	{r3, lr}
  queue_insert(currp, tqp);
 800bbd4:	4b06      	ldr	r3, [pc, #24]	; (800bbf0 <chThdEnqueueTimeoutS+0x20>)
 800bbd6:	699b      	ldr	r3, [r3, #24]
  tp->queue.next             = (thread_t *)tqp;
 800bbd8:	6018      	str	r0, [r3, #0]
  tp->queue.prev             = tqp->prev;
 800bbda:	6842      	ldr	r2, [r0, #4]
 800bbdc:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800bbde:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
 800bbe0:	6043      	str	r3, [r0, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800bbe2:	2004      	movs	r0, #4
 800bbe4:	f7ff ff6c 	bl	800bac0 <chSchGoSleepTimeoutS>
 800bbe8:	bd08      	pop	{r3, pc}
    return MSG_TIMEOUT;
 800bbea:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800bbee:	4770      	bx	lr
 800bbf0:	20003aec 	.word	0x20003aec
	...

0800bc00 <chThdSuspendTimeoutS>:
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, sysinterval_t timeout) {
 800bc00:	b508      	push	{r3, lr}
 800bc02:	4b06      	ldr	r3, [pc, #24]	; (800bc1c <chThdSuspendTimeoutS+0x1c>)
 800bc04:	699a      	ldr	r2, [r3, #24]
  if (TIME_IMMEDIATE == timeout) {
 800bc06:	b129      	cbz	r1, 800bc14 <chThdSuspendTimeoutS+0x14>
  *trp = tp;
 800bc08:	6002      	str	r2, [r0, #0]
  tp->u.wttrp = trp;
 800bc0a:	6250      	str	r0, [r2, #36]	; 0x24
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800bc0c:	2003      	movs	r0, #3
 800bc0e:	f7ff ff57 	bl	800bac0 <chSchGoSleepTimeoutS>
 800bc12:	bd08      	pop	{r3, pc}
    return MSG_TIMEOUT;
 800bc14:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 800bc18:	bd08      	pop	{r3, pc}
 800bc1a:	bf00      	nop
 800bc1c:	20003aec 	.word	0x20003aec

0800bc20 <chThdSleepUntil>:
void chThdSleepUntil(systime_t time) {
 800bc20:	b508      	push	{r3, lr}
 800bc22:	2320      	movs	r3, #32
 800bc24:	f383 8811 	msr	BASEPRI, r3
 800bc28:	4b05      	ldr	r3, [pc, #20]	; (800bc40 <chThdSleepUntil+0x20>)
 800bc2a:	6a59      	ldr	r1, [r3, #36]	; 0x24
  if (interval > (sysinterval_t)0) {
 800bc2c:	1a41      	subs	r1, r0, r1
 800bc2e:	d002      	beq.n	800bc36 <chThdSleepUntil+0x16>
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 800bc30:	2008      	movs	r0, #8
 800bc32:	f7ff ff45 	bl	800bac0 <chSchGoSleepTimeoutS>
 800bc36:	2300      	movs	r3, #0
 800bc38:	f383 8811 	msr	BASEPRI, r3
 800bc3c:	bd08      	pop	{r3, pc}
 800bc3e:	bf00      	nop
 800bc40:	40000c00 	.word	0x40000c00
	...

0800bc50 <chThdSleep>:
void chThdSleep(sysinterval_t time) {
 800bc50:	b508      	push	{r3, lr}
 800bc52:	4601      	mov	r1, r0
 800bc54:	2320      	movs	r3, #32
 800bc56:	f383 8811 	msr	BASEPRI, r3
 800bc5a:	2008      	movs	r0, #8
 800bc5c:	f7ff ff30 	bl	800bac0 <chSchGoSleepTimeoutS>
 800bc60:	2300      	movs	r3, #0
 800bc62:	f383 8811 	msr	BASEPRI, r3
 800bc66:	bd08      	pop	{r3, pc}
	...

0800bc70 <_ZN9USBStreamC1Ev>:
#include "core_cm4.h"

const uint32_t synchroWord = 0xDEADBEEF;

USBStream *USBStream::s_instance = NULL;
USBStream::USBStream()
 800bc70:	4a03      	ldr	r2, [pc, #12]	; (800bc80 <_ZN9USBStreamC1Ev+0x10>)
 800bc72:	6002      	str	r2, [r0, #0]
{
	m_currentPtr = NULL;
 800bc74:	2200      	movs	r2, #0
 800bc76:	6042      	str	r2, [r0, #4]
	m_timestamp = 0;
 800bc78:	6202      	str	r2, [r0, #32]
	m_bufferSize = 0;
 800bc7a:	6242      	str	r2, [r0, #36]	; 0x24
}
 800bc7c:	4770      	bx	lr
 800bc7e:	bf00      	nop
 800bc80:	08010078 	.word	0x08010078
	...

0800bc90 <_ZN9USBStreamD1Ev>:

	inline void setValue(float a) {m_currentStruct.tempPhaseA = a;}

private:
	USBStream();
	virtual ~USBStream() {};
 800bc90:	4b01      	ldr	r3, [pc, #4]	; (800bc98 <_ZN9USBStreamD1Ev+0x8>)
 800bc92:	6003      	str	r3, [r0, #0]
 800bc94:	4770      	bx	lr
 800bc96:	bf00      	nop
 800bc98:	08010078 	.word	0x08010078
 800bc9c:	00000000 	.word	0x00000000

0800bca0 <_ZN9USBStream14getEmptyBufferEv>:
		obqPostFullBuffer(&SDU1.obqueue, sizeof(UsbStreamSample));
	}
}

void USBStream::getEmptyBuffer()
{
 800bca0:	b510      	push	{r4, lr}
 800bca2:	4604      	mov	r4, r0
	msg_t msg = obqGetEmptyBufferTimeout(&SDU1.obqueue, 0);
 800bca4:	2100      	movs	r1, #0
 800bca6:	4805      	ldr	r0, [pc, #20]	; (800bcbc <_ZN9USBStream14getEmptyBufferEv+0x1c>)
 800bca8:	f7f7 fbaa 	bl	8003400 <obqGetEmptyBufferTimeout>
	if( msg == MSG_OK)
 800bcac:	b918      	cbnz	r0, 800bcb6 <_ZN9USBStream14getEmptyBufferEv+0x16>
	{
		m_currentPtr = (UsbStreamSample*) SDU1.obqueue.ptr;
 800bcae:	4b04      	ldr	r3, [pc, #16]	; (800bcc0 <_ZN9USBStream14getEmptyBufferEv+0x20>)
 800bcb0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800bcb2:	6063      	str	r3, [r4, #4]
 800bcb4:	bd10      	pop	{r4, pc}
		uint32_t available_size = ((uint32_t)SDU1.obqueue.top - (uint32_t)SDU1.obqueue.ptr);
		chDbgAssert (available_size >= (sizeof(UsbStreamSample)+4), "Not enough space in the free buffer. Did you set a correct USB buffer size ?");
	}
	else
	{
		m_currentPtr = NULL;
 800bcb6:	2300      	movs	r3, #0
 800bcb8:	6063      	str	r3, [r4, #4]
 800bcba:	bd10      	pop	{r4, pc}
 800bcbc:	200036a0 	.word	0x200036a0
 800bcc0:	2000365c 	.word	0x2000365c
	...

0800bcd0 <_ZN9USBStream14sendFullBufferEv>:
{
 800bcd0:	b538      	push	{r3, r4, r5, lr}
	if(m_currentPtr != NULL )
 800bcd2:	6845      	ldr	r5, [r0, #4]
 800bcd4:	b16d      	cbz	r5, 800bcf2 <_ZN9USBStream14sendFullBufferEv+0x22>
		*m_currentPtr = m_currentStruct;
 800bcd6:	f100 0408 	add.w	r4, r0, #8
 800bcda:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800bcdc:	6028      	str	r0, [r5, #0]
 800bcde:	6069      	str	r1, [r5, #4]
 800bce0:	60aa      	str	r2, [r5, #8]
 800bce2:	60eb      	str	r3, [r5, #12]
 800bce4:	cc03      	ldmia	r4!, {r0, r1}
 800bce6:	6128      	str	r0, [r5, #16]
 800bce8:	6169      	str	r1, [r5, #20]
		obqPostFullBuffer(&SDU1.obqueue, sizeof(UsbStreamSample));
 800bcea:	2118      	movs	r1, #24
 800bcec:	4801      	ldr	r0, [pc, #4]	; (800bcf4 <_ZN9USBStream14sendFullBufferEv+0x24>)
 800bcee:	f7f7 fb77 	bl	80033e0 <obqPostFullBuffer>
 800bcf2:	bd38      	pop	{r3, r4, r5, pc}
 800bcf4:	200036a0 	.word	0x200036a0
	...

0800bd00 <_ZN9USBStream17SendCurrentStreamEv>:
{
 800bd00:	b510      	push	{r4, lr}
 800bd02:	4604      	mov	r4, r0
	m_currentStruct.synchro = synchroWord;
 800bd04:	4b06      	ldr	r3, [pc, #24]	; (800bd20 <_ZN9USBStream17SendCurrentStreamEv+0x20>)
 800bd06:	6083      	str	r3, [r0, #8]
	m_currentStruct.timestamp = m_timestamp++;
 800bd08:	6a03      	ldr	r3, [r0, #32]
 800bd0a:	1c5a      	adds	r2, r3, #1
 800bd0c:	6202      	str	r2, [r0, #32]
 800bd0e:	60c3      	str	r3, [r0, #12]
	sendFullBuffer();
 800bd10:	f7ff ffde 	bl	800bcd0 <_ZN9USBStream14sendFullBufferEv>
	getEmptyBuffer();
 800bd14:	4620      	mov	r0, r4
 800bd16:	f7ff ffc3 	bl	800bca0 <_ZN9USBStream14getEmptyBufferEv>
}
 800bd1a:	6860      	ldr	r0, [r4, #4]
 800bd1c:	bd10      	pop	{r4, pc}
 800bd1e:	bf00      	nop
 800bd20:	deadbeef 	.word	0xdeadbeef
	...

0800bd30 <_ZL7Thread1Pv>:

/*
 * Green LED blinker thread, times are in milliseconds.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 800bd30:	b508      	push	{r3, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 800bd32:	4b08      	ldr	r3, [pc, #32]	; (800bd54 <_ZL7Thread1Pv+0x24>)
 800bd34:	699b      	ldr	r3, [r3, #24]
 800bd36:	4a08      	ldr	r2, [pc, #32]	; (800bd58 <_ZL7Thread1Pv+0x28>)
 800bd38:	619a      	str	r2, [r3, #24]

  (void)arg;
  chRegSetThreadName("blinker");
  while (true) {
    palClearPad(GPIOA, GPIOA_LED_GREEN);
 800bd3a:	4c08      	ldr	r4, [pc, #32]	; (800bd5c <_ZL7Thread1Pv+0x2c>)
 800bd3c:	2520      	movs	r5, #32
 800bd3e:	8365      	strh	r5, [r4, #26]
    chThdSleepMilliseconds(1000);
 800bd40:	f242 7010 	movw	r0, #10000	; 0x2710
 800bd44:	f7ff ff84 	bl	800bc50 <chThdSleep>
    palSetPad(GPIOA, GPIOA_LED_GREEN);
 800bd48:	8325      	strh	r5, [r4, #24]
    chThdSleepMilliseconds(1000);
 800bd4a:	f242 7010 	movw	r0, #10000	; 0x2710
 800bd4e:	f7ff ff7f 	bl	800bc50 <chThdSleep>
 800bd52:	e7f2      	b.n	800bd3a <_ZL7Thread1Pv+0xa>
 800bd54:	20003aec 	.word	0x20003aec
 800bd58:	08010090 	.word	0x08010090
 800bd5c:	40020000 	.word	0x40020000

0800bd60 <_ZN9USBStream4initEv>:
{
 800bd60:	b538      	push	{r3, r4, r5, lr}
	s_instance = new USBStream();
 800bd62:	2028      	movs	r0, #40	; 0x28
 800bd64:	f001 fafe 	bl	800d364 <_Znwj>
 800bd68:	4604      	mov	r4, r0
 800bd6a:	f7ff ff81 	bl	800bc70 <_ZN9USBStreamC1Ev>
 800bd6e:	4d13      	ldr	r5, [pc, #76]	; (800bdbc <_ZN9USBStream4initEv+0x5c>)
 800bd70:	602c      	str	r4, [r5, #0]
	sduObjectInit(&SDU1);
 800bd72:	4c13      	ldr	r4, [pc, #76]	; (800bdc0 <_ZN9USBStream4initEv+0x60>)
 800bd74:	4620      	mov	r0, r4
 800bd76:	f7f7 fa6b 	bl	8003250 <sduObjectInit>
	sduStart(&SDU1, &serusbcfg);
 800bd7a:	4912      	ldr	r1, [pc, #72]	; (800bdc4 <_ZN9USBStream4initEv+0x64>)
 800bd7c:	4620      	mov	r0, r4
 800bd7e:	f7f7 fa47 	bl	8003210 <sduStart>
	usbDisconnectBus(serusbcfg.usbp);
 800bd82:	4c11      	ldr	r4, [pc, #68]	; (800bdc8 <_ZN9USBStream4initEv+0x68>)
 800bd84:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
 800bd88:	f8d2 3804 	ldr.w	r3, [r2, #2052]	; 0x804
 800bd8c:	f043 0302 	orr.w	r3, r3, #2
 800bd90:	f8c2 3804 	str.w	r3, [r2, #2052]	; 0x804
	chThdSleepMilliseconds(1000);
 800bd94:	f242 7010 	movw	r0, #10000	; 0x2710
 800bd98:	f7ff ff5a 	bl	800bc50 <chThdSleep>
	usbStart(serusbcfg.usbp, &usbcfg);
 800bd9c:	490b      	ldr	r1, [pc, #44]	; (800bdcc <_ZN9USBStream4initEv+0x6c>)
 800bd9e:	4620      	mov	r0, r4
 800bda0:	f7f7 f846 	bl	8002e30 <usbStart>
	usbConnectBus(serusbcfg.usbp);
 800bda4:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
 800bda8:	f8d2 3804 	ldr.w	r3, [r2, #2052]	; 0x804
 800bdac:	f023 0302 	bic.w	r3, r3, #2
 800bdb0:	f8c2 3804 	str.w	r3, [r2, #2052]	; 0x804
	s_instance->getEmptyBuffer();
 800bdb4:	6828      	ldr	r0, [r5, #0]
 800bdb6:	f7ff ff73 	bl	800bca0 <_ZN9USBStream14getEmptyBufferEv>
 800bdba:	bd38      	pop	{r3, r4, r5, pc}
 800bdbc:	20003de8 	.word	0x20003de8
 800bdc0:	2000365c 	.word	0x2000365c
 800bdc4:	0801019c 	.word	0x0801019c
 800bdc8:	200035cc 	.word	0x200035cc
 800bdcc:	08010080 	.word	0x08010080

0800bdd0 <_ZN9USBStreamD0Ev>:
 800bdd0:	b510      	push	{r4, lr}
 800bdd2:	4604      	mov	r4, r0
 800bdd4:	4b02      	ldr	r3, [pc, #8]	; (800bde0 <_ZN9USBStreamD0Ev+0x10>)
 800bdd6:	6003      	str	r3, [r0, #0]
 800bdd8:	f001 fac2 	bl	800d360 <_ZdlPv>
 800bddc:	4620      	mov	r0, r4
 800bdde:	bd10      	pop	{r4, pc}
 800bde0:	08010078 	.word	0x08010078
	...

0800bdf0 <oslib_test_005_006_teardown.lto_priv.61>:
 *   trigger an assertion.
 * - [5.6.6] Retrieving the dynamic pipe by name again, must not exist.
 * .
 */

static void oslib_test_005_006_teardown(void) {
 800bdf0:	b510      	push	{r4, lr}
  dyn_pipe_t *dpp;

  dpp = chFactoryFindPipe("mypipe");
 800bdf2:	4806      	ldr	r0, [pc, #24]	; (800be0c <oslib_test_005_006_teardown.lto_priv.61+0x1c>)
 800bdf4:	f7fd f8a4 	bl	8008f40 <chFactoryFindPipe>
  if (dpp != NULL) {
 800bdf8:	4604      	mov	r4, r0
 800bdfa:	b918      	cbnz	r0, 800be04 <oslib_test_005_006_teardown.lto_priv.61+0x14>
 800bdfc:	bd10      	pop	{r4, pc}
    while (dpp->element.refs > 0U) {
      chFactoryReleasePipe(dpp);
 800bdfe:	4620      	mov	r0, r4
 800be00:	f7fd f886 	bl	8008f10 <chFactoryReleasePipe>
    while (dpp->element.refs > 0U) {
 800be04:	6863      	ldr	r3, [r4, #4]
 800be06:	2b00      	cmp	r3, #0
 800be08:	d1f9      	bne.n	800bdfe <oslib_test_005_006_teardown.lto_priv.61+0xe>
 800be0a:	bd10      	pop	{r4, pc}
 800be0c:	08010098 	.word	0x08010098

0800be10 <oslib_test_005_006_execute.lto_priv.62>:
    }
  }
}

static void oslib_test_005_006_execute(void) {
 800be10:	b538      	push	{r3, r4, r5, lr}
  dyn_pipe_t *dpp;

  /* [5.6.1] Retrieving a dynamic pipe by name, must not exist.*/
  test_set_step(1);
 800be12:	2201      	movs	r2, #1
 800be14:	4b44      	ldr	r3, [pc, #272]	; (800bf28 <oslib_test_005_006_execute.lto_priv.62+0x118>)
 800be16:	601a      	str	r2, [r3, #0]
  {
    dpp = chFactoryFindPipe("mypipe");
 800be18:	4844      	ldr	r0, [pc, #272]	; (800bf2c <oslib_test_005_006_execute.lto_priv.62+0x11c>)
 800be1a:	f7fd f891 	bl	8008f40 <chFactoryFindPipe>
    test_assert(dpp == NULL, "found");
 800be1e:	4944      	ldr	r1, [pc, #272]	; (800bf30 <oslib_test_005_006_execute.lto_priv.62+0x120>)
 800be20:	fab0 f080 	clz	r0, r0
 800be24:	0940      	lsrs	r0, r0, #5
 800be26:	f001 f9c3 	bl	800d1b0 <_test_assert>
 800be2a:	2800      	cmp	r0, #0
 800be2c:	d17b      	bne.n	800bf26 <oslib_test_005_006_execute.lto_priv.62+0x116>
  }

  /* [5.6.2] Creating a dynamic pipe it must not exists, must
     succeed.*/
  test_set_step(2);
 800be2e:	2202      	movs	r2, #2
 800be30:	4b3d      	ldr	r3, [pc, #244]	; (800bf28 <oslib_test_005_006_execute.lto_priv.62+0x118>)
 800be32:	601a      	str	r2, [r3, #0]
  {
    dpp = chFactoryCreatePipe("mypipe", 16U);
 800be34:	2110      	movs	r1, #16
 800be36:	483d      	ldr	r0, [pc, #244]	; (800bf2c <oslib_test_005_006_execute.lto_priv.62+0x11c>)
 800be38:	f7fd f89a 	bl	8008f70 <chFactoryCreatePipe>
    test_assert(dpp != NULL, "cannot create");
 800be3c:	4604      	mov	r4, r0
 800be3e:	493d      	ldr	r1, [pc, #244]	; (800bf34 <oslib_test_005_006_execute.lto_priv.62+0x124>)
 800be40:	3000      	adds	r0, #0
 800be42:	bf18      	it	ne
 800be44:	2001      	movne	r0, #1
 800be46:	f001 f9b3 	bl	800d1b0 <_test_assert>
 800be4a:	2800      	cmp	r0, #0
 800be4c:	d16b      	bne.n	800bf26 <oslib_test_005_006_execute.lto_priv.62+0x116>
  }

  /* [5.6.3] Creating a dynamic pipe with the same name, must fail.*/
  test_set_step(3);
 800be4e:	2203      	movs	r2, #3
 800be50:	4b35      	ldr	r3, [pc, #212]	; (800bf28 <oslib_test_005_006_execute.lto_priv.62+0x118>)
 800be52:	601a      	str	r2, [r3, #0]
  {
    dyn_pipe_t *dpp1;

    dpp1 = chFactoryCreatePipe("mypipe", 16U);
 800be54:	2110      	movs	r1, #16
 800be56:	4835      	ldr	r0, [pc, #212]	; (800bf2c <oslib_test_005_006_execute.lto_priv.62+0x11c>)
 800be58:	f7fd f88a 	bl	8008f70 <chFactoryCreatePipe>
    test_assert(dpp1 == NULL, "can create");
 800be5c:	4936      	ldr	r1, [pc, #216]	; (800bf38 <oslib_test_005_006_execute.lto_priv.62+0x128>)
 800be5e:	fab0 f080 	clz	r0, r0
 800be62:	0940      	lsrs	r0, r0, #5
 800be64:	f001 f9a4 	bl	800d1b0 <_test_assert>
 800be68:	2800      	cmp	r0, #0
 800be6a:	d15c      	bne.n	800bf26 <oslib_test_005_006_execute.lto_priv.62+0x116>
  }

  /* [5.6.4] Retrieving the dynamic pipe by name, must exist, then
     increasing the reference counter, finally releasing both
     references.*/
  test_set_step(4);
 800be6c:	2204      	movs	r2, #4
 800be6e:	4b2e      	ldr	r3, [pc, #184]	; (800bf28 <oslib_test_005_006_execute.lto_priv.62+0x118>)
 800be70:	601a      	str	r2, [r3, #0]
  {
    dyn_pipe_t *dpp1, *dpp2;

    dpp1 = chFactoryFindPipe("mypipe");
 800be72:	482e      	ldr	r0, [pc, #184]	; (800bf2c <oslib_test_005_006_execute.lto_priv.62+0x11c>)
 800be74:	f7fd f864 	bl	8008f40 <chFactoryFindPipe>
    test_assert(dpp1 != NULL, "not found");
 800be78:	4605      	mov	r5, r0
 800be7a:	4930      	ldr	r1, [pc, #192]	; (800bf3c <oslib_test_005_006_execute.lto_priv.62+0x12c>)
 800be7c:	3000      	adds	r0, #0
 800be7e:	bf18      	it	ne
 800be80:	2001      	movne	r0, #1
 800be82:	f001 f995 	bl	800d1b0 <_test_assert>
 800be86:	2800      	cmp	r0, #0
 800be88:	d14d      	bne.n	800bf26 <oslib_test_005_006_execute.lto_priv.62+0x116>
    test_assert(dpp == dpp1, "object reference mismatch");
 800be8a:	492d      	ldr	r1, [pc, #180]	; (800bf40 <oslib_test_005_006_execute.lto_priv.62+0x130>)
 800be8c:	42ac      	cmp	r4, r5
 800be8e:	bf14      	ite	ne
 800be90:	2000      	movne	r0, #0
 800be92:	2001      	moveq	r0, #1
 800be94:	f001 f98c 	bl	800d1b0 <_test_assert>
 800be98:	2800      	cmp	r0, #0
 800be9a:	d144      	bne.n	800bf26 <oslib_test_005_006_execute.lto_priv.62+0x116>
    test_assert(dpp1->element.refs == 2, "object reference mismatch");
 800be9c:	6868      	ldr	r0, [r5, #4]
 800be9e:	4928      	ldr	r1, [pc, #160]	; (800bf40 <oslib_test_005_006_execute.lto_priv.62+0x130>)
 800bea0:	2802      	cmp	r0, #2
 800bea2:	bf14      	ite	ne
 800bea4:	2000      	movne	r0, #0
 800bea6:	2001      	moveq	r0, #1
 800bea8:	f001 f982 	bl	800d1b0 <_test_assert>
 800beac:	2800      	cmp	r0, #0
 800beae:	d13a      	bne.n	800bf26 <oslib_test_005_006_execute.lto_priv.62+0x116>
 *
 * @api
 */
static inline dyn_element_t *chFactoryDuplicateReference(dyn_element_t *dep) {

  dep->refs++;
 800beb0:	686b      	ldr	r3, [r5, #4]
 800beb2:	3301      	adds	r3, #1
 800beb4:	606b      	str	r3, [r5, #4]

    dpp2 = (dyn_pipe_t *)chFactoryDuplicateReference(&dpp1->element);
    test_assert(dpp1 == dpp2, "object reference mismatch");
 800beb6:	4922      	ldr	r1, [pc, #136]	; (800bf40 <oslib_test_005_006_execute.lto_priv.62+0x130>)
 800beb8:	2001      	movs	r0, #1
 800beba:	f001 f979 	bl	800d1b0 <_test_assert>
 800bebe:	2800      	cmp	r0, #0
 800bec0:	d131      	bne.n	800bf26 <oslib_test_005_006_execute.lto_priv.62+0x116>
    test_assert(dpp2->element.refs == 3, "object reference mismatch");
 800bec2:	6868      	ldr	r0, [r5, #4]
 800bec4:	491e      	ldr	r1, [pc, #120]	; (800bf40 <oslib_test_005_006_execute.lto_priv.62+0x130>)
 800bec6:	2803      	cmp	r0, #3
 800bec8:	bf14      	ite	ne
 800beca:	2000      	movne	r0, #0
 800becc:	2001      	moveq	r0, #1
 800bece:	f001 f96f 	bl	800d1b0 <_test_assert>
 800bed2:	bb40      	cbnz	r0, 800bf26 <oslib_test_005_006_execute.lto_priv.62+0x116>

    chFactoryReleasePipe(dpp2);
 800bed4:	4628      	mov	r0, r5
 800bed6:	f7fd f81b 	bl	8008f10 <chFactoryReleasePipe>
    test_assert(dpp1->element.refs == 2, "references mismatch");
 800beda:	6868      	ldr	r0, [r5, #4]
 800bedc:	4919      	ldr	r1, [pc, #100]	; (800bf44 <oslib_test_005_006_execute.lto_priv.62+0x134>)
 800bede:	2802      	cmp	r0, #2
 800bee0:	bf14      	ite	ne
 800bee2:	2000      	movne	r0, #0
 800bee4:	2001      	moveq	r0, #1
 800bee6:	f001 f963 	bl	800d1b0 <_test_assert>
 800beea:	b9e0      	cbnz	r0, 800bf26 <oslib_test_005_006_execute.lto_priv.62+0x116>

    chFactoryReleasePipe(dpp1);
 800beec:	4628      	mov	r0, r5
 800beee:	f7fd f80f 	bl	8008f10 <chFactoryReleasePipe>
    test_assert(dpp->element.refs == 1, "references mismatch");
 800bef2:	6860      	ldr	r0, [r4, #4]
 800bef4:	4913      	ldr	r1, [pc, #76]	; (800bf44 <oslib_test_005_006_execute.lto_priv.62+0x134>)
 800bef6:	2801      	cmp	r0, #1
 800bef8:	bf14      	ite	ne
 800befa:	2000      	movne	r0, #0
 800befc:	2001      	moveq	r0, #1
 800befe:	f001 f957 	bl	800d1b0 <_test_assert>
 800bf02:	b980      	cbnz	r0, 800bf26 <oslib_test_005_006_execute.lto_priv.62+0x116>
  }

  /* [5.6.5] Releasing the first reference to the dynamic pipe must not
     trigger an assertion.*/
  test_set_step(5);
 800bf04:	4d08      	ldr	r5, [pc, #32]	; (800bf28 <oslib_test_005_006_execute.lto_priv.62+0x118>)
 800bf06:	2305      	movs	r3, #5
 800bf08:	602b      	str	r3, [r5, #0]
  {
    chFactoryReleasePipe(dpp);
 800bf0a:	4620      	mov	r0, r4
 800bf0c:	f7fd f800 	bl	8008f10 <chFactoryReleasePipe>
  }

  /* [5.6.6] Retrieving the dynamic pipe by name again, must not
     exist.*/
  test_set_step(6);
 800bf10:	2306      	movs	r3, #6
 800bf12:	602b      	str	r3, [r5, #0]
  {
    dpp = chFactoryFindPipe("mypipe");
 800bf14:	4805      	ldr	r0, [pc, #20]	; (800bf2c <oslib_test_005_006_execute.lto_priv.62+0x11c>)
 800bf16:	f7fd f813 	bl	8008f40 <chFactoryFindPipe>
    test_assert(dpp == NULL, "found");
 800bf1a:	4905      	ldr	r1, [pc, #20]	; (800bf30 <oslib_test_005_006_execute.lto_priv.62+0x120>)
 800bf1c:	fab0 f080 	clz	r0, r0
 800bf20:	0940      	lsrs	r0, r0, #5
 800bf22:	f001 f945 	bl	800d1b0 <_test_assert>
 800bf26:	bd38      	pop	{r3, r4, r5, pc}
 800bf28:	20003e04 	.word	0x20003e04
 800bf2c:	08010098 	.word	0x08010098
 800bf30:	080100c0 	.word	0x080100c0
 800bf34:	080100a0 	.word	0x080100a0
 800bf38:	080100b0 	.word	0x080100b0
 800bf3c:	080100bc 	.word	0x080100bc
 800bf40:	080100c8 	.word	0x080100c8
 800bf44:	080100e4 	.word	0x080100e4
	...

0800bf50 <oslib_test_005_005_teardown.lto_priv.59>:
static void oslib_test_005_005_teardown(void) {
 800bf50:	b510      	push	{r4, lr}
  dofp = chFactoryFindObjectsFIFO("myfifo");
 800bf52:	4806      	ldr	r0, [pc, #24]	; (800bf6c <oslib_test_005_005_teardown.lto_priv.59+0x1c>)
 800bf54:	f7fd f844 	bl	8008fe0 <chFactoryFindObjectsFIFO>
  if (dofp != NULL) {
 800bf58:	4604      	mov	r4, r0
 800bf5a:	b918      	cbnz	r0, 800bf64 <oslib_test_005_005_teardown.lto_priv.59+0x14>
 800bf5c:	bd10      	pop	{r4, pc}
      chFactoryReleaseObjectsFIFO(dofp);
 800bf5e:	4620      	mov	r0, r4
 800bf60:	f7fd f826 	bl	8008fb0 <chFactoryReleaseObjectsFIFO>
    while (dofp->element.refs > 0U) {
 800bf64:	6863      	ldr	r3, [r4, #4]
 800bf66:	2b00      	cmp	r3, #0
 800bf68:	d1f9      	bne.n	800bf5e <oslib_test_005_005_teardown.lto_priv.59+0xe>
 800bf6a:	bd10      	pop	{r4, pc}
 800bf6c:	080100f8 	.word	0x080100f8

0800bf70 <oslib_test_005_005_execute.lto_priv.60>:
static void oslib_test_005_005_execute(void) {
 800bf70:	b538      	push	{r3, r4, r5, lr}
  test_set_step(1);
 800bf72:	2201      	movs	r2, #1
 800bf74:	4b46      	ldr	r3, [pc, #280]	; (800c090 <oslib_test_005_005_execute.lto_priv.60+0x120>)
 800bf76:	601a      	str	r2, [r3, #0]
    dofp = chFactoryFindObjectsFIFO("myfifo");
 800bf78:	4846      	ldr	r0, [pc, #280]	; (800c094 <oslib_test_005_005_execute.lto_priv.60+0x124>)
 800bf7a:	f7fd f831 	bl	8008fe0 <chFactoryFindObjectsFIFO>
    test_assert(dofp == NULL, "found");
 800bf7e:	4946      	ldr	r1, [pc, #280]	; (800c098 <oslib_test_005_005_execute.lto_priv.60+0x128>)
 800bf80:	fab0 f080 	clz	r0, r0
 800bf84:	0940      	lsrs	r0, r0, #5
 800bf86:	f001 f913 	bl	800d1b0 <_test_assert>
 800bf8a:	2800      	cmp	r0, #0
 800bf8c:	d17f      	bne.n	800c08e <oslib_test_005_005_execute.lto_priv.60+0x11e>
  test_set_step(2);
 800bf8e:	2202      	movs	r2, #2
 800bf90:	4b3f      	ldr	r3, [pc, #252]	; (800c090 <oslib_test_005_005_execute.lto_priv.60+0x120>)
 800bf92:	601a      	str	r2, [r3, #0]
    dofp = chFactoryCreateObjectsFIFO("myfifo", 16U, 16U, PORT_NATURAL_ALIGN);
 800bf94:	2304      	movs	r3, #4
 800bf96:	2210      	movs	r2, #16
 800bf98:	4611      	mov	r1, r2
 800bf9a:	483e      	ldr	r0, [pc, #248]	; (800c094 <oslib_test_005_005_execute.lto_priv.60+0x124>)
 800bf9c:	f7fd f838 	bl	8009010 <chFactoryCreateObjectsFIFO>
    test_assert(dofp != NULL, "cannot create");
 800bfa0:	4604      	mov	r4, r0
 800bfa2:	493e      	ldr	r1, [pc, #248]	; (800c09c <oslib_test_005_005_execute.lto_priv.60+0x12c>)
 800bfa4:	3000      	adds	r0, #0
 800bfa6:	bf18      	it	ne
 800bfa8:	2001      	movne	r0, #1
 800bfaa:	f001 f901 	bl	800d1b0 <_test_assert>
 800bfae:	2800      	cmp	r0, #0
 800bfb0:	d16d      	bne.n	800c08e <oslib_test_005_005_execute.lto_priv.60+0x11e>
  test_set_step(3);
 800bfb2:	2203      	movs	r2, #3
 800bfb4:	4b36      	ldr	r3, [pc, #216]	; (800c090 <oslib_test_005_005_execute.lto_priv.60+0x120>)
 800bfb6:	601a      	str	r2, [r3, #0]
    dofp1 = chFactoryCreateObjectsFIFO("myfifo", 16U, 16U, PORT_NATURAL_ALIGN);
 800bfb8:	2304      	movs	r3, #4
 800bfba:	2210      	movs	r2, #16
 800bfbc:	4611      	mov	r1, r2
 800bfbe:	4835      	ldr	r0, [pc, #212]	; (800c094 <oslib_test_005_005_execute.lto_priv.60+0x124>)
 800bfc0:	f7fd f826 	bl	8009010 <chFactoryCreateObjectsFIFO>
    test_assert(dofp1 == NULL, "can create");
 800bfc4:	4936      	ldr	r1, [pc, #216]	; (800c0a0 <oslib_test_005_005_execute.lto_priv.60+0x130>)
 800bfc6:	fab0 f080 	clz	r0, r0
 800bfca:	0940      	lsrs	r0, r0, #5
 800bfcc:	f001 f8f0 	bl	800d1b0 <_test_assert>
 800bfd0:	2800      	cmp	r0, #0
 800bfd2:	d15c      	bne.n	800c08e <oslib_test_005_005_execute.lto_priv.60+0x11e>
  test_set_step(4);
 800bfd4:	2204      	movs	r2, #4
 800bfd6:	4b2e      	ldr	r3, [pc, #184]	; (800c090 <oslib_test_005_005_execute.lto_priv.60+0x120>)
 800bfd8:	601a      	str	r2, [r3, #0]
    dofp1 = chFactoryFindObjectsFIFO("myfifo");
 800bfda:	482e      	ldr	r0, [pc, #184]	; (800c094 <oslib_test_005_005_execute.lto_priv.60+0x124>)
 800bfdc:	f7fd f800 	bl	8008fe0 <chFactoryFindObjectsFIFO>
    test_assert(dofp1 != NULL, "not found");
 800bfe0:	4605      	mov	r5, r0
 800bfe2:	4930      	ldr	r1, [pc, #192]	; (800c0a4 <oslib_test_005_005_execute.lto_priv.60+0x134>)
 800bfe4:	3000      	adds	r0, #0
 800bfe6:	bf18      	it	ne
 800bfe8:	2001      	movne	r0, #1
 800bfea:	f001 f8e1 	bl	800d1b0 <_test_assert>
 800bfee:	2800      	cmp	r0, #0
 800bff0:	d14d      	bne.n	800c08e <oslib_test_005_005_execute.lto_priv.60+0x11e>
    test_assert(dofp == dofp1, "object reference mismatch");
 800bff2:	492d      	ldr	r1, [pc, #180]	; (800c0a8 <oslib_test_005_005_execute.lto_priv.60+0x138>)
 800bff4:	42ac      	cmp	r4, r5
 800bff6:	bf14      	ite	ne
 800bff8:	2000      	movne	r0, #0
 800bffa:	2001      	moveq	r0, #1
 800bffc:	f001 f8d8 	bl	800d1b0 <_test_assert>
 800c000:	2800      	cmp	r0, #0
 800c002:	d144      	bne.n	800c08e <oslib_test_005_005_execute.lto_priv.60+0x11e>
    test_assert(dofp1->element.refs == 2, "object reference mismatch");
 800c004:	6868      	ldr	r0, [r5, #4]
 800c006:	4928      	ldr	r1, [pc, #160]	; (800c0a8 <oslib_test_005_005_execute.lto_priv.60+0x138>)
 800c008:	2802      	cmp	r0, #2
 800c00a:	bf14      	ite	ne
 800c00c:	2000      	movne	r0, #0
 800c00e:	2001      	moveq	r0, #1
 800c010:	f001 f8ce 	bl	800d1b0 <_test_assert>
 800c014:	2800      	cmp	r0, #0
 800c016:	d13a      	bne.n	800c08e <oslib_test_005_005_execute.lto_priv.60+0x11e>
 800c018:	686b      	ldr	r3, [r5, #4]
 800c01a:	3301      	adds	r3, #1
 800c01c:	606b      	str	r3, [r5, #4]
    test_assert(dofp1 == dofp2, "object reference mismatch");
 800c01e:	4922      	ldr	r1, [pc, #136]	; (800c0a8 <oslib_test_005_005_execute.lto_priv.60+0x138>)
 800c020:	2001      	movs	r0, #1
 800c022:	f001 f8c5 	bl	800d1b0 <_test_assert>
 800c026:	2800      	cmp	r0, #0
 800c028:	d131      	bne.n	800c08e <oslib_test_005_005_execute.lto_priv.60+0x11e>
    test_assert(dofp2->element.refs == 3, "object reference mismatch");
 800c02a:	6868      	ldr	r0, [r5, #4]
 800c02c:	491e      	ldr	r1, [pc, #120]	; (800c0a8 <oslib_test_005_005_execute.lto_priv.60+0x138>)
 800c02e:	2803      	cmp	r0, #3
 800c030:	bf14      	ite	ne
 800c032:	2000      	movne	r0, #0
 800c034:	2001      	moveq	r0, #1
 800c036:	f001 f8bb 	bl	800d1b0 <_test_assert>
 800c03a:	bb40      	cbnz	r0, 800c08e <oslib_test_005_005_execute.lto_priv.60+0x11e>
    chFactoryReleaseObjectsFIFO(dofp2);
 800c03c:	4628      	mov	r0, r5
 800c03e:	f7fc ffb7 	bl	8008fb0 <chFactoryReleaseObjectsFIFO>
    test_assert(dofp1->element.refs == 2, "references mismatch");
 800c042:	6868      	ldr	r0, [r5, #4]
 800c044:	4919      	ldr	r1, [pc, #100]	; (800c0ac <oslib_test_005_005_execute.lto_priv.60+0x13c>)
 800c046:	2802      	cmp	r0, #2
 800c048:	bf14      	ite	ne
 800c04a:	2000      	movne	r0, #0
 800c04c:	2001      	moveq	r0, #1
 800c04e:	f001 f8af 	bl	800d1b0 <_test_assert>
 800c052:	b9e0      	cbnz	r0, 800c08e <oslib_test_005_005_execute.lto_priv.60+0x11e>
    chFactoryReleaseObjectsFIFO(dofp1);
 800c054:	4628      	mov	r0, r5
 800c056:	f7fc ffab 	bl	8008fb0 <chFactoryReleaseObjectsFIFO>
    test_assert(dofp->element.refs == 1, "references mismatch");
 800c05a:	6860      	ldr	r0, [r4, #4]
 800c05c:	4913      	ldr	r1, [pc, #76]	; (800c0ac <oslib_test_005_005_execute.lto_priv.60+0x13c>)
 800c05e:	2801      	cmp	r0, #1
 800c060:	bf14      	ite	ne
 800c062:	2000      	movne	r0, #0
 800c064:	2001      	moveq	r0, #1
 800c066:	f001 f8a3 	bl	800d1b0 <_test_assert>
 800c06a:	b980      	cbnz	r0, 800c08e <oslib_test_005_005_execute.lto_priv.60+0x11e>
  test_set_step(5);
 800c06c:	4d08      	ldr	r5, [pc, #32]	; (800c090 <oslib_test_005_005_execute.lto_priv.60+0x120>)
 800c06e:	2305      	movs	r3, #5
 800c070:	602b      	str	r3, [r5, #0]
    chFactoryReleaseObjectsFIFO(dofp);
 800c072:	4620      	mov	r0, r4
 800c074:	f7fc ff9c 	bl	8008fb0 <chFactoryReleaseObjectsFIFO>
  test_set_step(6);
 800c078:	2306      	movs	r3, #6
 800c07a:	602b      	str	r3, [r5, #0]
    dofp = chFactoryFindObjectsFIFO("myfifo");
 800c07c:	4805      	ldr	r0, [pc, #20]	; (800c094 <oslib_test_005_005_execute.lto_priv.60+0x124>)
 800c07e:	f7fc ffaf 	bl	8008fe0 <chFactoryFindObjectsFIFO>
    test_assert(dofp == NULL, "found");
 800c082:	4905      	ldr	r1, [pc, #20]	; (800c098 <oslib_test_005_005_execute.lto_priv.60+0x128>)
 800c084:	fab0 f080 	clz	r0, r0
 800c088:	0940      	lsrs	r0, r0, #5
 800c08a:	f001 f891 	bl	800d1b0 <_test_assert>
 800c08e:	bd38      	pop	{r3, r4, r5, pc}
 800c090:	20003e04 	.word	0x20003e04
 800c094:	080100f8 	.word	0x080100f8
 800c098:	080100c0 	.word	0x080100c0
 800c09c:	080100a0 	.word	0x080100a0
 800c0a0:	080100b0 	.word	0x080100b0
 800c0a4:	080100bc 	.word	0x080100bc
 800c0a8:	080100c8 	.word	0x080100c8
 800c0ac:	080100e4 	.word	0x080100e4

0800c0b0 <oslib_test_005_004_teardown.lto_priv.57>:
static void oslib_test_005_004_teardown(void) {
 800c0b0:	b510      	push	{r4, lr}
  dmp = chFactoryFindMailbox("mymbx");
 800c0b2:	4806      	ldr	r0, [pc, #24]	; (800c0cc <oslib_test_005_004_teardown.lto_priv.57+0x1c>)
 800c0b4:	f7fc fffc 	bl	80090b0 <chFactoryFindMailbox>
  if (dmp != NULL) {
 800c0b8:	4604      	mov	r4, r0
 800c0ba:	b918      	cbnz	r0, 800c0c4 <oslib_test_005_004_teardown.lto_priv.57+0x14>
 800c0bc:	bd10      	pop	{r4, pc}
      chFactoryReleaseMailbox(dmp);
 800c0be:	4620      	mov	r0, r4
 800c0c0:	f7fc ffde 	bl	8009080 <chFactoryReleaseMailbox>
    while (dmp->element.refs > 0U) {
 800c0c4:	6863      	ldr	r3, [r4, #4]
 800c0c6:	2b00      	cmp	r3, #0
 800c0c8:	d1f9      	bne.n	800c0be <oslib_test_005_004_teardown.lto_priv.57+0xe>
 800c0ca:	bd10      	pop	{r4, pc}
 800c0cc:	08010100 	.word	0x08010100

0800c0d0 <oslib_test_005_004_execute.lto_priv.58>:
static void oslib_test_005_004_execute(void) {
 800c0d0:	b538      	push	{r3, r4, r5, lr}
  test_set_step(1);
 800c0d2:	2201      	movs	r2, #1
 800c0d4:	4b44      	ldr	r3, [pc, #272]	; (800c1e8 <oslib_test_005_004_execute.lto_priv.58+0x118>)
 800c0d6:	601a      	str	r2, [r3, #0]
    dmp = chFactoryFindMailbox("mymbx");
 800c0d8:	4844      	ldr	r0, [pc, #272]	; (800c1ec <oslib_test_005_004_execute.lto_priv.58+0x11c>)
 800c0da:	f7fc ffe9 	bl	80090b0 <chFactoryFindMailbox>
    test_assert(dmp == NULL, "found");
 800c0de:	4944      	ldr	r1, [pc, #272]	; (800c1f0 <oslib_test_005_004_execute.lto_priv.58+0x120>)
 800c0e0:	fab0 f080 	clz	r0, r0
 800c0e4:	0940      	lsrs	r0, r0, #5
 800c0e6:	f001 f863 	bl	800d1b0 <_test_assert>
 800c0ea:	2800      	cmp	r0, #0
 800c0ec:	d17b      	bne.n	800c1e6 <oslib_test_005_004_execute.lto_priv.58+0x116>
  test_set_step(2);
 800c0ee:	2202      	movs	r2, #2
 800c0f0:	4b3d      	ldr	r3, [pc, #244]	; (800c1e8 <oslib_test_005_004_execute.lto_priv.58+0x118>)
 800c0f2:	601a      	str	r2, [r3, #0]
    dmp = chFactoryCreateMailbox("mymbx", 16U);
 800c0f4:	2110      	movs	r1, #16
 800c0f6:	483d      	ldr	r0, [pc, #244]	; (800c1ec <oslib_test_005_004_execute.lto_priv.58+0x11c>)
 800c0f8:	f7fc fff2 	bl	80090e0 <chFactoryCreateMailbox>
    test_assert(dmp != NULL, "cannot create");
 800c0fc:	4604      	mov	r4, r0
 800c0fe:	493d      	ldr	r1, [pc, #244]	; (800c1f4 <oslib_test_005_004_execute.lto_priv.58+0x124>)
 800c100:	3000      	adds	r0, #0
 800c102:	bf18      	it	ne
 800c104:	2001      	movne	r0, #1
 800c106:	f001 f853 	bl	800d1b0 <_test_assert>
 800c10a:	2800      	cmp	r0, #0
 800c10c:	d16b      	bne.n	800c1e6 <oslib_test_005_004_execute.lto_priv.58+0x116>
  test_set_step(3);
 800c10e:	2203      	movs	r2, #3
 800c110:	4b35      	ldr	r3, [pc, #212]	; (800c1e8 <oslib_test_005_004_execute.lto_priv.58+0x118>)
 800c112:	601a      	str	r2, [r3, #0]
    dmp1 = chFactoryCreateMailbox("mymbx", 16U);
 800c114:	2110      	movs	r1, #16
 800c116:	4835      	ldr	r0, [pc, #212]	; (800c1ec <oslib_test_005_004_execute.lto_priv.58+0x11c>)
 800c118:	f7fc ffe2 	bl	80090e0 <chFactoryCreateMailbox>
    test_assert(dmp1 == NULL, "can create");
 800c11c:	4936      	ldr	r1, [pc, #216]	; (800c1f8 <oslib_test_005_004_execute.lto_priv.58+0x128>)
 800c11e:	fab0 f080 	clz	r0, r0
 800c122:	0940      	lsrs	r0, r0, #5
 800c124:	f001 f844 	bl	800d1b0 <_test_assert>
 800c128:	2800      	cmp	r0, #0
 800c12a:	d15c      	bne.n	800c1e6 <oslib_test_005_004_execute.lto_priv.58+0x116>
  test_set_step(4);
 800c12c:	2204      	movs	r2, #4
 800c12e:	4b2e      	ldr	r3, [pc, #184]	; (800c1e8 <oslib_test_005_004_execute.lto_priv.58+0x118>)
 800c130:	601a      	str	r2, [r3, #0]
    dmp1 = chFactoryFindMailbox("mymbx");
 800c132:	482e      	ldr	r0, [pc, #184]	; (800c1ec <oslib_test_005_004_execute.lto_priv.58+0x11c>)
 800c134:	f7fc ffbc 	bl	80090b0 <chFactoryFindMailbox>
    test_assert(dmp1 != NULL, "not found");
 800c138:	4605      	mov	r5, r0
 800c13a:	4930      	ldr	r1, [pc, #192]	; (800c1fc <oslib_test_005_004_execute.lto_priv.58+0x12c>)
 800c13c:	3000      	adds	r0, #0
 800c13e:	bf18      	it	ne
 800c140:	2001      	movne	r0, #1
 800c142:	f001 f835 	bl	800d1b0 <_test_assert>
 800c146:	2800      	cmp	r0, #0
 800c148:	d14d      	bne.n	800c1e6 <oslib_test_005_004_execute.lto_priv.58+0x116>
    test_assert(dmp == dmp1, "object reference mismatch");
 800c14a:	492d      	ldr	r1, [pc, #180]	; (800c200 <oslib_test_005_004_execute.lto_priv.58+0x130>)
 800c14c:	42ac      	cmp	r4, r5
 800c14e:	bf14      	ite	ne
 800c150:	2000      	movne	r0, #0
 800c152:	2001      	moveq	r0, #1
 800c154:	f001 f82c 	bl	800d1b0 <_test_assert>
 800c158:	2800      	cmp	r0, #0
 800c15a:	d144      	bne.n	800c1e6 <oslib_test_005_004_execute.lto_priv.58+0x116>
    test_assert(dmp1->element.refs == 2, "object reference mismatch");
 800c15c:	6868      	ldr	r0, [r5, #4]
 800c15e:	4928      	ldr	r1, [pc, #160]	; (800c200 <oslib_test_005_004_execute.lto_priv.58+0x130>)
 800c160:	2802      	cmp	r0, #2
 800c162:	bf14      	ite	ne
 800c164:	2000      	movne	r0, #0
 800c166:	2001      	moveq	r0, #1
 800c168:	f001 f822 	bl	800d1b0 <_test_assert>
 800c16c:	2800      	cmp	r0, #0
 800c16e:	d13a      	bne.n	800c1e6 <oslib_test_005_004_execute.lto_priv.58+0x116>
 800c170:	686b      	ldr	r3, [r5, #4]
 800c172:	3301      	adds	r3, #1
 800c174:	606b      	str	r3, [r5, #4]
    test_assert(dmp1 == dmp2, "object reference mismatch");
 800c176:	4922      	ldr	r1, [pc, #136]	; (800c200 <oslib_test_005_004_execute.lto_priv.58+0x130>)
 800c178:	2001      	movs	r0, #1
 800c17a:	f001 f819 	bl	800d1b0 <_test_assert>
 800c17e:	2800      	cmp	r0, #0
 800c180:	d131      	bne.n	800c1e6 <oslib_test_005_004_execute.lto_priv.58+0x116>
    test_assert(dmp2->element.refs == 3, "object reference mismatch");
 800c182:	6868      	ldr	r0, [r5, #4]
 800c184:	491e      	ldr	r1, [pc, #120]	; (800c200 <oslib_test_005_004_execute.lto_priv.58+0x130>)
 800c186:	2803      	cmp	r0, #3
 800c188:	bf14      	ite	ne
 800c18a:	2000      	movne	r0, #0
 800c18c:	2001      	moveq	r0, #1
 800c18e:	f001 f80f 	bl	800d1b0 <_test_assert>
 800c192:	bb40      	cbnz	r0, 800c1e6 <oslib_test_005_004_execute.lto_priv.58+0x116>
    chFactoryReleaseMailbox(dmp2);
 800c194:	4628      	mov	r0, r5
 800c196:	f7fc ff73 	bl	8009080 <chFactoryReleaseMailbox>
    test_assert(dmp1->element.refs == 2, "references mismatch");
 800c19a:	6868      	ldr	r0, [r5, #4]
 800c19c:	4919      	ldr	r1, [pc, #100]	; (800c204 <oslib_test_005_004_execute.lto_priv.58+0x134>)
 800c19e:	2802      	cmp	r0, #2
 800c1a0:	bf14      	ite	ne
 800c1a2:	2000      	movne	r0, #0
 800c1a4:	2001      	moveq	r0, #1
 800c1a6:	f001 f803 	bl	800d1b0 <_test_assert>
 800c1aa:	b9e0      	cbnz	r0, 800c1e6 <oslib_test_005_004_execute.lto_priv.58+0x116>
    chFactoryReleaseMailbox(dmp1);
 800c1ac:	4628      	mov	r0, r5
 800c1ae:	f7fc ff67 	bl	8009080 <chFactoryReleaseMailbox>
    test_assert(dmp->element.refs == 1, "references mismatch");
 800c1b2:	6860      	ldr	r0, [r4, #4]
 800c1b4:	4913      	ldr	r1, [pc, #76]	; (800c204 <oslib_test_005_004_execute.lto_priv.58+0x134>)
 800c1b6:	2801      	cmp	r0, #1
 800c1b8:	bf14      	ite	ne
 800c1ba:	2000      	movne	r0, #0
 800c1bc:	2001      	moveq	r0, #1
 800c1be:	f000 fff7 	bl	800d1b0 <_test_assert>
 800c1c2:	b980      	cbnz	r0, 800c1e6 <oslib_test_005_004_execute.lto_priv.58+0x116>
  test_set_step(5);
 800c1c4:	4d08      	ldr	r5, [pc, #32]	; (800c1e8 <oslib_test_005_004_execute.lto_priv.58+0x118>)
 800c1c6:	2305      	movs	r3, #5
 800c1c8:	602b      	str	r3, [r5, #0]
    chFactoryReleaseMailbox(dmp);
 800c1ca:	4620      	mov	r0, r4
 800c1cc:	f7fc ff58 	bl	8009080 <chFactoryReleaseMailbox>
  test_set_step(6);
 800c1d0:	2306      	movs	r3, #6
 800c1d2:	602b      	str	r3, [r5, #0]
    dmp = chFactoryFindMailbox("mymbx");
 800c1d4:	4805      	ldr	r0, [pc, #20]	; (800c1ec <oslib_test_005_004_execute.lto_priv.58+0x11c>)
 800c1d6:	f7fc ff6b 	bl	80090b0 <chFactoryFindMailbox>
    test_assert(dmp == NULL, "found");
 800c1da:	4905      	ldr	r1, [pc, #20]	; (800c1f0 <oslib_test_005_004_execute.lto_priv.58+0x120>)
 800c1dc:	fab0 f080 	clz	r0, r0
 800c1e0:	0940      	lsrs	r0, r0, #5
 800c1e2:	f000 ffe5 	bl	800d1b0 <_test_assert>
 800c1e6:	bd38      	pop	{r3, r4, r5, pc}
 800c1e8:	20003e04 	.word	0x20003e04
 800c1ec:	08010100 	.word	0x08010100
 800c1f0:	080100c0 	.word	0x080100c0
 800c1f4:	080100a0 	.word	0x080100a0
 800c1f8:	080100b0 	.word	0x080100b0
 800c1fc:	080100bc 	.word	0x080100bc
 800c200:	080100c8 	.word	0x080100c8
 800c204:	080100e4 	.word	0x080100e4
	...

0800c210 <oslib_test_005_003_teardown.lto_priv.55>:
static void oslib_test_005_003_teardown(void) {
 800c210:	b510      	push	{r4, lr}
  dsp = chFactoryFindSemaphore("mysem");
 800c212:	4806      	ldr	r0, [pc, #24]	; (800c22c <oslib_test_005_003_teardown.lto_priv.55+0x1c>)
 800c214:	f7fc ff9c 	bl	8009150 <chFactoryFindSemaphore>
  if (dsp != NULL) {
 800c218:	4604      	mov	r4, r0
 800c21a:	b918      	cbnz	r0, 800c224 <oslib_test_005_003_teardown.lto_priv.55+0x14>
 800c21c:	bd10      	pop	{r4, pc}
      chFactoryReleaseSemaphore(dsp);
 800c21e:	4620      	mov	r0, r4
 800c220:	f7fc ff7e 	bl	8009120 <chFactoryReleaseSemaphore>
    while (dsp->element.refs > 0U) {
 800c224:	6863      	ldr	r3, [r4, #4]
 800c226:	2b00      	cmp	r3, #0
 800c228:	d1f9      	bne.n	800c21e <oslib_test_005_003_teardown.lto_priv.55+0xe>
 800c22a:	bd10      	pop	{r4, pc}
 800c22c:	08010108 	.word	0x08010108

0800c230 <oslib_test_005_003_execute.lto_priv.56>:
static void oslib_test_005_003_execute(void) {
 800c230:	b538      	push	{r3, r4, r5, lr}
  test_set_step(1);
 800c232:	2201      	movs	r2, #1
 800c234:	4b44      	ldr	r3, [pc, #272]	; (800c348 <oslib_test_005_003_execute.lto_priv.56+0x118>)
 800c236:	601a      	str	r2, [r3, #0]
    dsp = chFactoryFindSemaphore("mysem");
 800c238:	4844      	ldr	r0, [pc, #272]	; (800c34c <oslib_test_005_003_execute.lto_priv.56+0x11c>)
 800c23a:	f7fc ff89 	bl	8009150 <chFactoryFindSemaphore>
    test_assert(dsp == NULL, "found");
 800c23e:	4944      	ldr	r1, [pc, #272]	; (800c350 <oslib_test_005_003_execute.lto_priv.56+0x120>)
 800c240:	fab0 f080 	clz	r0, r0
 800c244:	0940      	lsrs	r0, r0, #5
 800c246:	f000 ffb3 	bl	800d1b0 <_test_assert>
 800c24a:	2800      	cmp	r0, #0
 800c24c:	d17b      	bne.n	800c346 <oslib_test_005_003_execute.lto_priv.56+0x116>
  test_set_step(2);
 800c24e:	2202      	movs	r2, #2
 800c250:	4b3d      	ldr	r3, [pc, #244]	; (800c348 <oslib_test_005_003_execute.lto_priv.56+0x118>)
 800c252:	601a      	str	r2, [r3, #0]
    dsp = chFactoryCreateSemaphore("mysem", 0);
 800c254:	2100      	movs	r1, #0
 800c256:	483d      	ldr	r0, [pc, #244]	; (800c34c <oslib_test_005_003_execute.lto_priv.56+0x11c>)
 800c258:	f7fc ff92 	bl	8009180 <chFactoryCreateSemaphore>
    test_assert(dsp != NULL, "cannot create");
 800c25c:	4604      	mov	r4, r0
 800c25e:	493d      	ldr	r1, [pc, #244]	; (800c354 <oslib_test_005_003_execute.lto_priv.56+0x124>)
 800c260:	3000      	adds	r0, #0
 800c262:	bf18      	it	ne
 800c264:	2001      	movne	r0, #1
 800c266:	f000 ffa3 	bl	800d1b0 <_test_assert>
 800c26a:	2800      	cmp	r0, #0
 800c26c:	d16b      	bne.n	800c346 <oslib_test_005_003_execute.lto_priv.56+0x116>
  test_set_step(3);
 800c26e:	2203      	movs	r2, #3
 800c270:	4b35      	ldr	r3, [pc, #212]	; (800c348 <oslib_test_005_003_execute.lto_priv.56+0x118>)
 800c272:	601a      	str	r2, [r3, #0]
    dsp1 = chFactoryCreateSemaphore("mysem", 0);
 800c274:	2100      	movs	r1, #0
 800c276:	4835      	ldr	r0, [pc, #212]	; (800c34c <oslib_test_005_003_execute.lto_priv.56+0x11c>)
 800c278:	f7fc ff82 	bl	8009180 <chFactoryCreateSemaphore>
    test_assert(dsp1 == NULL, "can create");
 800c27c:	4936      	ldr	r1, [pc, #216]	; (800c358 <oslib_test_005_003_execute.lto_priv.56+0x128>)
 800c27e:	fab0 f080 	clz	r0, r0
 800c282:	0940      	lsrs	r0, r0, #5
 800c284:	f000 ff94 	bl	800d1b0 <_test_assert>
 800c288:	2800      	cmp	r0, #0
 800c28a:	d15c      	bne.n	800c346 <oslib_test_005_003_execute.lto_priv.56+0x116>
  test_set_step(4);
 800c28c:	2204      	movs	r2, #4
 800c28e:	4b2e      	ldr	r3, [pc, #184]	; (800c348 <oslib_test_005_003_execute.lto_priv.56+0x118>)
 800c290:	601a      	str	r2, [r3, #0]
    dsp1 = chFactoryFindSemaphore("mysem");
 800c292:	482e      	ldr	r0, [pc, #184]	; (800c34c <oslib_test_005_003_execute.lto_priv.56+0x11c>)
 800c294:	f7fc ff5c 	bl	8009150 <chFactoryFindSemaphore>
    test_assert(dsp1 != NULL, "not found");
 800c298:	4605      	mov	r5, r0
 800c29a:	4930      	ldr	r1, [pc, #192]	; (800c35c <oslib_test_005_003_execute.lto_priv.56+0x12c>)
 800c29c:	3000      	adds	r0, #0
 800c29e:	bf18      	it	ne
 800c2a0:	2001      	movne	r0, #1
 800c2a2:	f000 ff85 	bl	800d1b0 <_test_assert>
 800c2a6:	2800      	cmp	r0, #0
 800c2a8:	d14d      	bne.n	800c346 <oslib_test_005_003_execute.lto_priv.56+0x116>
    test_assert(dsp == dsp1, "object reference mismatch");
 800c2aa:	492d      	ldr	r1, [pc, #180]	; (800c360 <oslib_test_005_003_execute.lto_priv.56+0x130>)
 800c2ac:	42ac      	cmp	r4, r5
 800c2ae:	bf14      	ite	ne
 800c2b0:	2000      	movne	r0, #0
 800c2b2:	2001      	moveq	r0, #1
 800c2b4:	f000 ff7c 	bl	800d1b0 <_test_assert>
 800c2b8:	2800      	cmp	r0, #0
 800c2ba:	d144      	bne.n	800c346 <oslib_test_005_003_execute.lto_priv.56+0x116>
    test_assert(dsp1->element.refs == 2, "object reference mismatch");
 800c2bc:	6868      	ldr	r0, [r5, #4]
 800c2be:	4928      	ldr	r1, [pc, #160]	; (800c360 <oslib_test_005_003_execute.lto_priv.56+0x130>)
 800c2c0:	2802      	cmp	r0, #2
 800c2c2:	bf14      	ite	ne
 800c2c4:	2000      	movne	r0, #0
 800c2c6:	2001      	moveq	r0, #1
 800c2c8:	f000 ff72 	bl	800d1b0 <_test_assert>
 800c2cc:	2800      	cmp	r0, #0
 800c2ce:	d13a      	bne.n	800c346 <oslib_test_005_003_execute.lto_priv.56+0x116>
 800c2d0:	686b      	ldr	r3, [r5, #4]
 800c2d2:	3301      	adds	r3, #1
 800c2d4:	606b      	str	r3, [r5, #4]
    test_assert(dsp1 == dsp2, "object reference mismatch");
 800c2d6:	4922      	ldr	r1, [pc, #136]	; (800c360 <oslib_test_005_003_execute.lto_priv.56+0x130>)
 800c2d8:	2001      	movs	r0, #1
 800c2da:	f000 ff69 	bl	800d1b0 <_test_assert>
 800c2de:	2800      	cmp	r0, #0
 800c2e0:	d131      	bne.n	800c346 <oslib_test_005_003_execute.lto_priv.56+0x116>
    test_assert(dsp2->element.refs == 3, "object reference mismatch");
 800c2e2:	6868      	ldr	r0, [r5, #4]
 800c2e4:	491e      	ldr	r1, [pc, #120]	; (800c360 <oslib_test_005_003_execute.lto_priv.56+0x130>)
 800c2e6:	2803      	cmp	r0, #3
 800c2e8:	bf14      	ite	ne
 800c2ea:	2000      	movne	r0, #0
 800c2ec:	2001      	moveq	r0, #1
 800c2ee:	f000 ff5f 	bl	800d1b0 <_test_assert>
 800c2f2:	bb40      	cbnz	r0, 800c346 <oslib_test_005_003_execute.lto_priv.56+0x116>
    chFactoryReleaseSemaphore(dsp2);
 800c2f4:	4628      	mov	r0, r5
 800c2f6:	f7fc ff13 	bl	8009120 <chFactoryReleaseSemaphore>
    test_assert(dsp1->element.refs == 2, "references mismatch");
 800c2fa:	6868      	ldr	r0, [r5, #4]
 800c2fc:	4919      	ldr	r1, [pc, #100]	; (800c364 <oslib_test_005_003_execute.lto_priv.56+0x134>)
 800c2fe:	2802      	cmp	r0, #2
 800c300:	bf14      	ite	ne
 800c302:	2000      	movne	r0, #0
 800c304:	2001      	moveq	r0, #1
 800c306:	f000 ff53 	bl	800d1b0 <_test_assert>
 800c30a:	b9e0      	cbnz	r0, 800c346 <oslib_test_005_003_execute.lto_priv.56+0x116>
    chFactoryReleaseSemaphore(dsp1);
 800c30c:	4628      	mov	r0, r5
 800c30e:	f7fc ff07 	bl	8009120 <chFactoryReleaseSemaphore>
    test_assert(dsp->element.refs == 1, "references mismatch");
 800c312:	6860      	ldr	r0, [r4, #4]
 800c314:	4913      	ldr	r1, [pc, #76]	; (800c364 <oslib_test_005_003_execute.lto_priv.56+0x134>)
 800c316:	2801      	cmp	r0, #1
 800c318:	bf14      	ite	ne
 800c31a:	2000      	movne	r0, #0
 800c31c:	2001      	moveq	r0, #1
 800c31e:	f000 ff47 	bl	800d1b0 <_test_assert>
 800c322:	b980      	cbnz	r0, 800c346 <oslib_test_005_003_execute.lto_priv.56+0x116>
  test_set_step(5);
 800c324:	4d08      	ldr	r5, [pc, #32]	; (800c348 <oslib_test_005_003_execute.lto_priv.56+0x118>)
 800c326:	2305      	movs	r3, #5
 800c328:	602b      	str	r3, [r5, #0]
    chFactoryReleaseSemaphore(dsp);
 800c32a:	4620      	mov	r0, r4
 800c32c:	f7fc fef8 	bl	8009120 <chFactoryReleaseSemaphore>
  test_set_step(6);
 800c330:	2306      	movs	r3, #6
 800c332:	602b      	str	r3, [r5, #0]
    dsp = chFactoryFindSemaphore("mysem");
 800c334:	4805      	ldr	r0, [pc, #20]	; (800c34c <oslib_test_005_003_execute.lto_priv.56+0x11c>)
 800c336:	f7fc ff0b 	bl	8009150 <chFactoryFindSemaphore>
    test_assert(dsp == NULL, "found");
 800c33a:	4905      	ldr	r1, [pc, #20]	; (800c350 <oslib_test_005_003_execute.lto_priv.56+0x120>)
 800c33c:	fab0 f080 	clz	r0, r0
 800c340:	0940      	lsrs	r0, r0, #5
 800c342:	f000 ff35 	bl	800d1b0 <_test_assert>
 800c346:	bd38      	pop	{r3, r4, r5, pc}
 800c348:	20003e04 	.word	0x20003e04
 800c34c:	08010108 	.word	0x08010108
 800c350:	080100c0 	.word	0x080100c0
 800c354:	080100a0 	.word	0x080100a0
 800c358:	080100b0 	.word	0x080100b0
 800c35c:	080100bc 	.word	0x080100bc
 800c360:	080100c8 	.word	0x080100c8
 800c364:	080100e4 	.word	0x080100e4
	...

0800c370 <oslib_test_005_002_teardown.lto_priv.53>:
static void oslib_test_005_002_teardown(void) {
 800c370:	b510      	push	{r4, lr}
  dbp = chFactoryFindBuffer("mybuf");
 800c372:	4806      	ldr	r0, [pc, #24]	; (800c38c <oslib_test_005_002_teardown.lto_priv.53+0x1c>)
 800c374:	f7fc ff3c 	bl	80091f0 <chFactoryFindBuffer>
  if (dbp != NULL) {
 800c378:	4604      	mov	r4, r0
 800c37a:	b918      	cbnz	r0, 800c384 <oslib_test_005_002_teardown.lto_priv.53+0x14>
 800c37c:	bd10      	pop	{r4, pc}
      chFactoryReleaseBuffer(dbp);
 800c37e:	4620      	mov	r0, r4
 800c380:	f7fc ff1e 	bl	80091c0 <chFactoryReleaseBuffer>
    while (dbp->element.refs > 0U) {
 800c384:	6863      	ldr	r3, [r4, #4]
 800c386:	2b00      	cmp	r3, #0
 800c388:	d1f9      	bne.n	800c37e <oslib_test_005_002_teardown.lto_priv.53+0xe>
 800c38a:	bd10      	pop	{r4, pc}
 800c38c:	08010110 	.word	0x08010110

0800c390 <oslib_test_005_002_execute.lto_priv.54>:
static void oslib_test_005_002_execute(void) {
 800c390:	b538      	push	{r3, r4, r5, lr}
  test_set_step(1);
 800c392:	2201      	movs	r2, #1
 800c394:	4b44      	ldr	r3, [pc, #272]	; (800c4a8 <oslib_test_005_002_execute.lto_priv.54+0x118>)
 800c396:	601a      	str	r2, [r3, #0]
    dbp = chFactoryFindBuffer("mybuf");
 800c398:	4844      	ldr	r0, [pc, #272]	; (800c4ac <oslib_test_005_002_execute.lto_priv.54+0x11c>)
 800c39a:	f7fc ff29 	bl	80091f0 <chFactoryFindBuffer>
    test_assert(dbp == NULL, "found");
 800c39e:	4944      	ldr	r1, [pc, #272]	; (800c4b0 <oslib_test_005_002_execute.lto_priv.54+0x120>)
 800c3a0:	fab0 f080 	clz	r0, r0
 800c3a4:	0940      	lsrs	r0, r0, #5
 800c3a6:	f000 ff03 	bl	800d1b0 <_test_assert>
 800c3aa:	2800      	cmp	r0, #0
 800c3ac:	d17b      	bne.n	800c4a6 <oslib_test_005_002_execute.lto_priv.54+0x116>
  test_set_step(2);
 800c3ae:	2202      	movs	r2, #2
 800c3b0:	4b3d      	ldr	r3, [pc, #244]	; (800c4a8 <oslib_test_005_002_execute.lto_priv.54+0x118>)
 800c3b2:	601a      	str	r2, [r3, #0]
    dbp = chFactoryCreateBuffer("mybuf", 128U);
 800c3b4:	2180      	movs	r1, #128	; 0x80
 800c3b6:	483d      	ldr	r0, [pc, #244]	; (800c4ac <oslib_test_005_002_execute.lto_priv.54+0x11c>)
 800c3b8:	f7fc ff32 	bl	8009220 <chFactoryCreateBuffer>
    test_assert(dbp != NULL, "cannot create");
 800c3bc:	4604      	mov	r4, r0
 800c3be:	493d      	ldr	r1, [pc, #244]	; (800c4b4 <oslib_test_005_002_execute.lto_priv.54+0x124>)
 800c3c0:	3000      	adds	r0, #0
 800c3c2:	bf18      	it	ne
 800c3c4:	2001      	movne	r0, #1
 800c3c6:	f000 fef3 	bl	800d1b0 <_test_assert>
 800c3ca:	2800      	cmp	r0, #0
 800c3cc:	d16b      	bne.n	800c4a6 <oslib_test_005_002_execute.lto_priv.54+0x116>
  test_set_step(3);
 800c3ce:	2203      	movs	r2, #3
 800c3d0:	4b35      	ldr	r3, [pc, #212]	; (800c4a8 <oslib_test_005_002_execute.lto_priv.54+0x118>)
 800c3d2:	601a      	str	r2, [r3, #0]
    dbp1 = chFactoryCreateBuffer("mybuf", 128U);
 800c3d4:	2180      	movs	r1, #128	; 0x80
 800c3d6:	4835      	ldr	r0, [pc, #212]	; (800c4ac <oslib_test_005_002_execute.lto_priv.54+0x11c>)
 800c3d8:	f7fc ff22 	bl	8009220 <chFactoryCreateBuffer>
    test_assert(dbp1 == NULL, "can create");
 800c3dc:	4936      	ldr	r1, [pc, #216]	; (800c4b8 <oslib_test_005_002_execute.lto_priv.54+0x128>)
 800c3de:	fab0 f080 	clz	r0, r0
 800c3e2:	0940      	lsrs	r0, r0, #5
 800c3e4:	f000 fee4 	bl	800d1b0 <_test_assert>
 800c3e8:	2800      	cmp	r0, #0
 800c3ea:	d15c      	bne.n	800c4a6 <oslib_test_005_002_execute.lto_priv.54+0x116>
  test_set_step(4);
 800c3ec:	2204      	movs	r2, #4
 800c3ee:	4b2e      	ldr	r3, [pc, #184]	; (800c4a8 <oslib_test_005_002_execute.lto_priv.54+0x118>)
 800c3f0:	601a      	str	r2, [r3, #0]
    dbp1 = chFactoryFindBuffer("mybuf");
 800c3f2:	482e      	ldr	r0, [pc, #184]	; (800c4ac <oslib_test_005_002_execute.lto_priv.54+0x11c>)
 800c3f4:	f7fc fefc 	bl	80091f0 <chFactoryFindBuffer>
    test_assert(dbp1 != NULL, "not found");
 800c3f8:	4605      	mov	r5, r0
 800c3fa:	4930      	ldr	r1, [pc, #192]	; (800c4bc <oslib_test_005_002_execute.lto_priv.54+0x12c>)
 800c3fc:	3000      	adds	r0, #0
 800c3fe:	bf18      	it	ne
 800c400:	2001      	movne	r0, #1
 800c402:	f000 fed5 	bl	800d1b0 <_test_assert>
 800c406:	2800      	cmp	r0, #0
 800c408:	d14d      	bne.n	800c4a6 <oslib_test_005_002_execute.lto_priv.54+0x116>
    test_assert(dbp == dbp1, "object reference mismatch");
 800c40a:	492d      	ldr	r1, [pc, #180]	; (800c4c0 <oslib_test_005_002_execute.lto_priv.54+0x130>)
 800c40c:	42ac      	cmp	r4, r5
 800c40e:	bf14      	ite	ne
 800c410:	2000      	movne	r0, #0
 800c412:	2001      	moveq	r0, #1
 800c414:	f000 fecc 	bl	800d1b0 <_test_assert>
 800c418:	2800      	cmp	r0, #0
 800c41a:	d144      	bne.n	800c4a6 <oslib_test_005_002_execute.lto_priv.54+0x116>
    test_assert(dbp1->element.refs == 2, "object reference mismatch");
 800c41c:	6868      	ldr	r0, [r5, #4]
 800c41e:	4928      	ldr	r1, [pc, #160]	; (800c4c0 <oslib_test_005_002_execute.lto_priv.54+0x130>)
 800c420:	2802      	cmp	r0, #2
 800c422:	bf14      	ite	ne
 800c424:	2000      	movne	r0, #0
 800c426:	2001      	moveq	r0, #1
 800c428:	f000 fec2 	bl	800d1b0 <_test_assert>
 800c42c:	2800      	cmp	r0, #0
 800c42e:	d13a      	bne.n	800c4a6 <oslib_test_005_002_execute.lto_priv.54+0x116>
 800c430:	686b      	ldr	r3, [r5, #4]
 800c432:	3301      	adds	r3, #1
 800c434:	606b      	str	r3, [r5, #4]
    test_assert(dbp1 == dbp2, "object reference mismatch");
 800c436:	4922      	ldr	r1, [pc, #136]	; (800c4c0 <oslib_test_005_002_execute.lto_priv.54+0x130>)
 800c438:	2001      	movs	r0, #1
 800c43a:	f000 feb9 	bl	800d1b0 <_test_assert>
 800c43e:	2800      	cmp	r0, #0
 800c440:	d131      	bne.n	800c4a6 <oslib_test_005_002_execute.lto_priv.54+0x116>
    test_assert(dbp2->element.refs == 3, "object reference mismatch");
 800c442:	6868      	ldr	r0, [r5, #4]
 800c444:	491e      	ldr	r1, [pc, #120]	; (800c4c0 <oslib_test_005_002_execute.lto_priv.54+0x130>)
 800c446:	2803      	cmp	r0, #3
 800c448:	bf14      	ite	ne
 800c44a:	2000      	movne	r0, #0
 800c44c:	2001      	moveq	r0, #1
 800c44e:	f000 feaf 	bl	800d1b0 <_test_assert>
 800c452:	bb40      	cbnz	r0, 800c4a6 <oslib_test_005_002_execute.lto_priv.54+0x116>
    chFactoryReleaseBuffer(dbp2);
 800c454:	4628      	mov	r0, r5
 800c456:	f7fc feb3 	bl	80091c0 <chFactoryReleaseBuffer>
    test_assert(dbp1->element.refs == 2, "references mismatch");
 800c45a:	6868      	ldr	r0, [r5, #4]
 800c45c:	4919      	ldr	r1, [pc, #100]	; (800c4c4 <oslib_test_005_002_execute.lto_priv.54+0x134>)
 800c45e:	2802      	cmp	r0, #2
 800c460:	bf14      	ite	ne
 800c462:	2000      	movne	r0, #0
 800c464:	2001      	moveq	r0, #1
 800c466:	f000 fea3 	bl	800d1b0 <_test_assert>
 800c46a:	b9e0      	cbnz	r0, 800c4a6 <oslib_test_005_002_execute.lto_priv.54+0x116>
    chFactoryReleaseBuffer(dbp1);
 800c46c:	4628      	mov	r0, r5
 800c46e:	f7fc fea7 	bl	80091c0 <chFactoryReleaseBuffer>
    test_assert(dbp->element.refs == 1, "references mismatch");
 800c472:	6860      	ldr	r0, [r4, #4]
 800c474:	4913      	ldr	r1, [pc, #76]	; (800c4c4 <oslib_test_005_002_execute.lto_priv.54+0x134>)
 800c476:	2801      	cmp	r0, #1
 800c478:	bf14      	ite	ne
 800c47a:	2000      	movne	r0, #0
 800c47c:	2001      	moveq	r0, #1
 800c47e:	f000 fe97 	bl	800d1b0 <_test_assert>
 800c482:	b980      	cbnz	r0, 800c4a6 <oslib_test_005_002_execute.lto_priv.54+0x116>
  test_set_step(5);
 800c484:	4d08      	ldr	r5, [pc, #32]	; (800c4a8 <oslib_test_005_002_execute.lto_priv.54+0x118>)
 800c486:	2305      	movs	r3, #5
 800c488:	602b      	str	r3, [r5, #0]
    chFactoryReleaseBuffer(dbp);
 800c48a:	4620      	mov	r0, r4
 800c48c:	f7fc fe98 	bl	80091c0 <chFactoryReleaseBuffer>
  test_set_step(6);
 800c490:	2306      	movs	r3, #6
 800c492:	602b      	str	r3, [r5, #0]
    dbp = chFactoryFindBuffer("mybuf");
 800c494:	4805      	ldr	r0, [pc, #20]	; (800c4ac <oslib_test_005_002_execute.lto_priv.54+0x11c>)
 800c496:	f7fc feab 	bl	80091f0 <chFactoryFindBuffer>
    test_assert(dbp == NULL, "found");
 800c49a:	4905      	ldr	r1, [pc, #20]	; (800c4b0 <oslib_test_005_002_execute.lto_priv.54+0x120>)
 800c49c:	fab0 f080 	clz	r0, r0
 800c4a0:	0940      	lsrs	r0, r0, #5
 800c4a2:	f000 fe85 	bl	800d1b0 <_test_assert>
 800c4a6:	bd38      	pop	{r3, r4, r5, pc}
 800c4a8:	20003e04 	.word	0x20003e04
 800c4ac:	08010110 	.word	0x08010110
 800c4b0:	080100c0 	.word	0x080100c0
 800c4b4:	080100a0 	.word	0x080100a0
 800c4b8:	080100b0 	.word	0x080100b0
 800c4bc:	080100bc 	.word	0x080100bc
 800c4c0:	080100c8 	.word	0x080100c8
 800c4c4:	080100e4 	.word	0x080100e4
	...

0800c4d0 <oslib_test_005_001_teardown.lto_priv.51>:
static void oslib_test_005_001_teardown(void) {
 800c4d0:	b510      	push	{r4, lr}
  rop = chFactoryFindObject("myobj");
 800c4d2:	4806      	ldr	r0, [pc, #24]	; (800c4ec <oslib_test_005_001_teardown.lto_priv.51+0x1c>)
 800c4d4:	f7fc fedc 	bl	8009290 <chFactoryFindObject>
  if (rop != NULL) {
 800c4d8:	4604      	mov	r4, r0
 800c4da:	b918      	cbnz	r0, 800c4e4 <oslib_test_005_001_teardown.lto_priv.51+0x14>
 800c4dc:	bd10      	pop	{r4, pc}
      chFactoryReleaseObject(rop);
 800c4de:	4620      	mov	r0, r4
 800c4e0:	f7fc febe 	bl	8009260 <chFactoryReleaseObject>
    while (rop->element.refs > 0U) {
 800c4e4:	6863      	ldr	r3, [r4, #4]
 800c4e6:	2b00      	cmp	r3, #0
 800c4e8:	d1f9      	bne.n	800c4de <oslib_test_005_001_teardown.lto_priv.51+0xe>
 800c4ea:	bd10      	pop	{r4, pc}
 800c4ec:	08010118 	.word	0x08010118

0800c4f0 <oslib_test_005_001_execute.lto_priv.52>:
static void oslib_test_005_001_execute(void) {
 800c4f0:	b538      	push	{r3, r4, r5, lr}
  test_set_step(1);
 800c4f2:	2201      	movs	r2, #1
 800c4f4:	4b52      	ldr	r3, [pc, #328]	; (800c640 <oslib_test_005_001_execute.lto_priv.52+0x150>)
 800c4f6:	601a      	str	r2, [r3, #0]
    rop = chFactoryFindObject("myobj");
 800c4f8:	4852      	ldr	r0, [pc, #328]	; (800c644 <oslib_test_005_001_execute.lto_priv.52+0x154>)
 800c4fa:	f7fc fec9 	bl	8009290 <chFactoryFindObject>
    test_assert(rop == NULL, "found");
 800c4fe:	4952      	ldr	r1, [pc, #328]	; (800c648 <oslib_test_005_001_execute.lto_priv.52+0x158>)
 800c500:	fab0 f080 	clz	r0, r0
 800c504:	0940      	lsrs	r0, r0, #5
 800c506:	f000 fe53 	bl	800d1b0 <_test_assert>
 800c50a:	2800      	cmp	r0, #0
 800c50c:	f040 8097 	bne.w	800c63e <oslib_test_005_001_execute.lto_priv.52+0x14e>
  test_set_step(2);
 800c510:	2202      	movs	r2, #2
 800c512:	4b4b      	ldr	r3, [pc, #300]	; (800c640 <oslib_test_005_001_execute.lto_priv.52+0x150>)
 800c514:	601a      	str	r2, [r3, #0]
    rop = chFactoryRegisterObject("myobj", (void *)&myobj);
 800c516:	494d      	ldr	r1, [pc, #308]	; (800c64c <oslib_test_005_001_execute.lto_priv.52+0x15c>)
 800c518:	484a      	ldr	r0, [pc, #296]	; (800c644 <oslib_test_005_001_execute.lto_priv.52+0x154>)
 800c51a:	f7fc fed1 	bl	80092c0 <chFactoryRegisterObject>
    test_assert(rop != NULL, "cannot register");
 800c51e:	4604      	mov	r4, r0
 800c520:	494b      	ldr	r1, [pc, #300]	; (800c650 <oslib_test_005_001_execute.lto_priv.52+0x160>)
 800c522:	3000      	adds	r0, #0
 800c524:	bf18      	it	ne
 800c526:	2001      	movne	r0, #1
 800c528:	f000 fe42 	bl	800d1b0 <_test_assert>
 800c52c:	2800      	cmp	r0, #0
 800c52e:	f040 8086 	bne.w	800c63e <oslib_test_005_001_execute.lto_priv.52+0x14e>
  test_set_step(3);
 800c532:	2203      	movs	r2, #3
 800c534:	4b42      	ldr	r3, [pc, #264]	; (800c640 <oslib_test_005_001_execute.lto_priv.52+0x150>)
 800c536:	601a      	str	r2, [r3, #0]
    rop1 = chFactoryRegisterObject("myobj", (void *)&myobj);
 800c538:	4946      	ldr	r1, [pc, #280]	; (800c654 <oslib_test_005_001_execute.lto_priv.52+0x164>)
 800c53a:	4842      	ldr	r0, [pc, #264]	; (800c644 <oslib_test_005_001_execute.lto_priv.52+0x154>)
 800c53c:	f7fc fec0 	bl	80092c0 <chFactoryRegisterObject>
    test_assert(rop1 == NULL, "can register");
 800c540:	4945      	ldr	r1, [pc, #276]	; (800c658 <oslib_test_005_001_execute.lto_priv.52+0x168>)
 800c542:	fab0 f080 	clz	r0, r0
 800c546:	0940      	lsrs	r0, r0, #5
 800c548:	f000 fe32 	bl	800d1b0 <_test_assert>
 800c54c:	2800      	cmp	r0, #0
 800c54e:	d176      	bne.n	800c63e <oslib_test_005_001_execute.lto_priv.52+0x14e>
  test_set_step(4);
 800c550:	2204      	movs	r2, #4
 800c552:	4b3b      	ldr	r3, [pc, #236]	; (800c640 <oslib_test_005_001_execute.lto_priv.52+0x150>)
 800c554:	601a      	str	r2, [r3, #0]
    rop1 = chFactoryFindObject("myobj");
 800c556:	483b      	ldr	r0, [pc, #236]	; (800c644 <oslib_test_005_001_execute.lto_priv.52+0x154>)
 800c558:	f7fc fe9a 	bl	8009290 <chFactoryFindObject>
    test_assert(rop1 != NULL, "not found");
 800c55c:	4605      	mov	r5, r0
 800c55e:	493f      	ldr	r1, [pc, #252]	; (800c65c <oslib_test_005_001_execute.lto_priv.52+0x16c>)
 800c560:	3000      	adds	r0, #0
 800c562:	bf18      	it	ne
 800c564:	2001      	movne	r0, #1
 800c566:	f000 fe23 	bl	800d1b0 <_test_assert>
 800c56a:	2800      	cmp	r0, #0
 800c56c:	d167      	bne.n	800c63e <oslib_test_005_001_execute.lto_priv.52+0x14e>
    test_assert(*(uint32_t *)(rop1->objp) == 0x55aa, "object mismatch");
 800c56e:	692b      	ldr	r3, [r5, #16]
 800c570:	6818      	ldr	r0, [r3, #0]
 800c572:	493b      	ldr	r1, [pc, #236]	; (800c660 <oslib_test_005_001_execute.lto_priv.52+0x170>)
 800c574:	f245 53aa 	movw	r3, #21930	; 0x55aa
 800c578:	4298      	cmp	r0, r3
 800c57a:	bf14      	ite	ne
 800c57c:	2000      	movne	r0, #0
 800c57e:	2001      	moveq	r0, #1
 800c580:	f000 fe16 	bl	800d1b0 <_test_assert>
 800c584:	2800      	cmp	r0, #0
 800c586:	d15a      	bne.n	800c63e <oslib_test_005_001_execute.lto_priv.52+0x14e>
    test_assert(rop == rop1, "object reference mismatch");
 800c588:	4936      	ldr	r1, [pc, #216]	; (800c664 <oslib_test_005_001_execute.lto_priv.52+0x174>)
 800c58a:	42ac      	cmp	r4, r5
 800c58c:	bf14      	ite	ne
 800c58e:	2000      	movne	r0, #0
 800c590:	2001      	moveq	r0, #1
 800c592:	f000 fe0d 	bl	800d1b0 <_test_assert>
 800c596:	2800      	cmp	r0, #0
 800c598:	d151      	bne.n	800c63e <oslib_test_005_001_execute.lto_priv.52+0x14e>
    test_assert(rop1->element.refs == 2, "object reference mismatch");
 800c59a:	6868      	ldr	r0, [r5, #4]
 800c59c:	4931      	ldr	r1, [pc, #196]	; (800c664 <oslib_test_005_001_execute.lto_priv.52+0x174>)
 800c59e:	2802      	cmp	r0, #2
 800c5a0:	bf14      	ite	ne
 800c5a2:	2000      	movne	r0, #0
 800c5a4:	2001      	moveq	r0, #1
 800c5a6:	f000 fe03 	bl	800d1b0 <_test_assert>
 800c5aa:	2800      	cmp	r0, #0
 800c5ac:	d147      	bne.n	800c63e <oslib_test_005_001_execute.lto_priv.52+0x14e>
 800c5ae:	686b      	ldr	r3, [r5, #4]
 800c5b0:	3301      	adds	r3, #1
 800c5b2:	606b      	str	r3, [r5, #4]
    test_assert(rop1 == rop2, "object reference mismatch");
 800c5b4:	492b      	ldr	r1, [pc, #172]	; (800c664 <oslib_test_005_001_execute.lto_priv.52+0x174>)
 800c5b6:	2001      	movs	r0, #1
 800c5b8:	f000 fdfa 	bl	800d1b0 <_test_assert>
 800c5bc:	2800      	cmp	r0, #0
 800c5be:	d13e      	bne.n	800c63e <oslib_test_005_001_execute.lto_priv.52+0x14e>
    test_assert(*(uint32_t *)(rop2->objp) == 0x55aa, "object mismatch");
 800c5c0:	692b      	ldr	r3, [r5, #16]
 800c5c2:	6818      	ldr	r0, [r3, #0]
 800c5c4:	4926      	ldr	r1, [pc, #152]	; (800c660 <oslib_test_005_001_execute.lto_priv.52+0x170>)
 800c5c6:	f245 53aa 	movw	r3, #21930	; 0x55aa
 800c5ca:	4298      	cmp	r0, r3
 800c5cc:	bf14      	ite	ne
 800c5ce:	2000      	movne	r0, #0
 800c5d0:	2001      	moveq	r0, #1
 800c5d2:	f000 fded 	bl	800d1b0 <_test_assert>
 800c5d6:	2800      	cmp	r0, #0
 800c5d8:	d131      	bne.n	800c63e <oslib_test_005_001_execute.lto_priv.52+0x14e>
    test_assert(rop2->element.refs == 3, "object reference mismatch");
 800c5da:	6868      	ldr	r0, [r5, #4]
 800c5dc:	4921      	ldr	r1, [pc, #132]	; (800c664 <oslib_test_005_001_execute.lto_priv.52+0x174>)
 800c5de:	2803      	cmp	r0, #3
 800c5e0:	bf14      	ite	ne
 800c5e2:	2000      	movne	r0, #0
 800c5e4:	2001      	moveq	r0, #1
 800c5e6:	f000 fde3 	bl	800d1b0 <_test_assert>
 800c5ea:	bb40      	cbnz	r0, 800c63e <oslib_test_005_001_execute.lto_priv.52+0x14e>
    chFactoryReleaseObject(rop2);
 800c5ec:	4628      	mov	r0, r5
 800c5ee:	f7fc fe37 	bl	8009260 <chFactoryReleaseObject>
    test_assert(rop1->element.refs == 2, "references mismatch");
 800c5f2:	6868      	ldr	r0, [r5, #4]
 800c5f4:	491c      	ldr	r1, [pc, #112]	; (800c668 <oslib_test_005_001_execute.lto_priv.52+0x178>)
 800c5f6:	2802      	cmp	r0, #2
 800c5f8:	bf14      	ite	ne
 800c5fa:	2000      	movne	r0, #0
 800c5fc:	2001      	moveq	r0, #1
 800c5fe:	f000 fdd7 	bl	800d1b0 <_test_assert>
 800c602:	b9e0      	cbnz	r0, 800c63e <oslib_test_005_001_execute.lto_priv.52+0x14e>
    chFactoryReleaseObject(rop1);
 800c604:	4628      	mov	r0, r5
 800c606:	f7fc fe2b 	bl	8009260 <chFactoryReleaseObject>
    test_assert(rop->element.refs == 1, "references mismatch");
 800c60a:	6860      	ldr	r0, [r4, #4]
 800c60c:	4916      	ldr	r1, [pc, #88]	; (800c668 <oslib_test_005_001_execute.lto_priv.52+0x178>)
 800c60e:	2801      	cmp	r0, #1
 800c610:	bf14      	ite	ne
 800c612:	2000      	movne	r0, #0
 800c614:	2001      	moveq	r0, #1
 800c616:	f000 fdcb 	bl	800d1b0 <_test_assert>
 800c61a:	b980      	cbnz	r0, 800c63e <oslib_test_005_001_execute.lto_priv.52+0x14e>
  test_set_step(5);
 800c61c:	4d08      	ldr	r5, [pc, #32]	; (800c640 <oslib_test_005_001_execute.lto_priv.52+0x150>)
 800c61e:	2305      	movs	r3, #5
 800c620:	602b      	str	r3, [r5, #0]
    chFactoryReleaseObject(rop);
 800c622:	4620      	mov	r0, r4
 800c624:	f7fc fe1c 	bl	8009260 <chFactoryReleaseObject>
  test_set_step(6);
 800c628:	2306      	movs	r3, #6
 800c62a:	602b      	str	r3, [r5, #0]
    rop = chFactoryFindObject("myobj");
 800c62c:	4805      	ldr	r0, [pc, #20]	; (800c644 <oslib_test_005_001_execute.lto_priv.52+0x154>)
 800c62e:	f7fc fe2f 	bl	8009290 <chFactoryFindObject>
    test_assert(rop == NULL, "found");
 800c632:	4905      	ldr	r1, [pc, #20]	; (800c648 <oslib_test_005_001_execute.lto_priv.52+0x158>)
 800c634:	fab0 f080 	clz	r0, r0
 800c638:	0940      	lsrs	r0, r0, #5
 800c63a:	f000 fdb9 	bl	800d1b0 <_test_assert>
 800c63e:	bd38      	pop	{r3, r4, r5, pc}
 800c640:	20003e04 	.word	0x20003e04
 800c644:	08010118 	.word	0x08010118
 800c648:	080100c0 	.word	0x080100c0
 800c64c:	20002584 	.word	0x20002584
 800c650:	08010120 	.word	0x08010120
 800c654:	200025a8 	.word	0x200025a8
 800c658:	08010130 	.word	0x08010130
 800c65c:	080100bc 	.word	0x080100bc
 800c660:	08010140 	.word	0x08010140
 800c664:	080100c8 	.word	0x080100c8
 800c668:	080100e4 	.word	0x080100e4
 800c66c:	00000000 	.word	0x00000000

0800c670 <oslib_test_004_002_execute.lto_priv.50>:
 *   is freed using chHeapFree(), must not fail.
 * - [4.2.2] Testing allocation failure.
 * .
 */

static void oslib_test_004_002_execute(void) {
 800c670:	b510      	push	{r4, lr}
 800c672:	b082      	sub	sp, #8
  void *p1;
  size_t total_size, largest_size;

  /* [4.2.1] Single block allocation using chHeapAlloc() then the block
     is freed using chHeapFree(), must not fail.*/
  test_set_step(1);
 800c674:	2201      	movs	r2, #1
 800c676:	4b14      	ldr	r3, [pc, #80]	; (800c6c8 <oslib_test_004_002_execute.lto_priv.50+0x58>)
 800c678:	601a      	str	r2, [r3, #0]
  {
    (void)chHeapStatus(NULL, &total_size, &largest_size);
 800c67a:	466a      	mov	r2, sp
 800c67c:	a901      	add	r1, sp, #4
 800c67e:	2000      	movs	r0, #0
 800c680:	f7fd f976 	bl	8009970 <chHeapStatus>
 800c684:	2208      	movs	r2, #8
 800c686:	2110      	movs	r1, #16
 800c688:	4810      	ldr	r0, [pc, #64]	; (800c6cc <oslib_test_004_002_execute.lto_priv.50+0x5c>)
 800c68a:	f7fd f9f1 	bl	8009a70 <chHeapAllocAligned>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    test_assert(p1 != NULL, "allocation failed");
 800c68e:	4604      	mov	r4, r0
 800c690:	490f      	ldr	r1, [pc, #60]	; (800c6d0 <oslib_test_004_002_execute.lto_priv.50+0x60>)
 800c692:	3000      	adds	r0, #0
 800c694:	bf18      	it	ne
 800c696:	2001      	movne	r0, #1
 800c698:	f000 fd8a 	bl	800d1b0 <_test_assert>
 800c69c:	b988      	cbnz	r0, 800c6c2 <oslib_test_004_002_execute.lto_priv.50+0x52>
    chHeapFree(p1);
 800c69e:	4620      	mov	r0, r4
 800c6a0:	f7fd f98e 	bl	80099c0 <chHeapFree>
  }

  /* [4.2.2] Testing allocation failure.*/
  test_set_step(2);
 800c6a4:	2202      	movs	r2, #2
 800c6a6:	4b08      	ldr	r3, [pc, #32]	; (800c6c8 <oslib_test_004_002_execute.lto_priv.50+0x58>)
 800c6a8:	601a      	str	r2, [r3, #0]
 800c6aa:	2208      	movs	r2, #8
 800c6ac:	f06f 01ff 	mvn.w	r1, #255	; 0xff
 800c6b0:	2000      	movs	r0, #0
 800c6b2:	f7fd f9dd 	bl	8009a70 <chHeapAllocAligned>
  {
    p1 = chHeapAlloc(NULL, (size_t)-256);
    test_assert(p1 == NULL, "allocation not failed");
 800c6b6:	4907      	ldr	r1, [pc, #28]	; (800c6d4 <oslib_test_004_002_execute.lto_priv.50+0x64>)
 800c6b8:	fab0 f080 	clz	r0, r0
 800c6bc:	0940      	lsrs	r0, r0, #5
 800c6be:	f000 fd77 	bl	800d1b0 <_test_assert>
  }
}
 800c6c2:	b002      	add	sp, #8
 800c6c4:	bd10      	pop	{r4, pc}
 800c6c6:	bf00      	nop
 800c6c8:	20003e04 	.word	0x20003e04
 800c6cc:	200035b0 	.word	0x200035b0
 800c6d0:	0800ff9c 	.word	0x0800ff9c
 800c6d4:	0800ff84 	.word	0x0800ff84
	...

0800c6e0 <main>:


/*
 * Application entry point.
 */
int main(void) {
 800c6e0:	b580      	push	{r7, lr}
 800c6e2:	b084      	sub	sp, #16
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 800c6e4:	f7f6 febc 	bl	8003460 <halInit>
  chSysInit();
 800c6e8:	f7fa f9fa 	bl	8006ae0 <chSysInit>


  // MOTOR 1 control
  palSetPadMode(GPIOA, 10, PAL_MODE_OUTPUT_PUSHPULL);
 800c6ec:	4c63      	ldr	r4, [pc, #396]	; (800c87c <main+0x19c>)
 800c6ee:	2201      	movs	r2, #1
 800c6f0:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800c6f4:	4620      	mov	r0, r4
 800c6f6:	f7f9 fb13 	bl	8005d20 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 5, PAL_MODE_OUTPUT_PUSHPULL);
 800c6fa:	4e61      	ldr	r6, [pc, #388]	; (800c880 <main+0x1a0>)
 800c6fc:	2201      	movs	r2, #1
 800c6fe:	2120      	movs	r1, #32
 800c700:	4630      	mov	r0, r6
 800c702:	f7f9 fb0d 	bl	8005d20 <_pal_lld_setgroupmode>
  palClearPad(GPIOA, 10); //M1INA
 800c706:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c70a:	8363      	strh	r3, [r4, #26]
  palSetPad(GPIOB, 5); //M1INB
 800c70c:	2320      	movs	r3, #32
 800c70e:	8333      	strh	r3, [r6, #24]

  palSetPadMode(GPIOC, 7, PAL_MODE_ALTERNATE(3)); //TIM4_chan1
 800c710:	4f5c      	ldr	r7, [pc, #368]	; (800c884 <main+0x1a4>)
 800c712:	f44f 72c1 	mov.w	r2, #386	; 0x182
 800c716:	2180      	movs	r1, #128	; 0x80
 800c718:	4638      	mov	r0, r7
 800c71a:	f7f9 fb01 	bl	8005d20 <_pal_lld_setgroupmode>
  pwmStart(&PWMD8, &pwmcfg);
 800c71e:	f8df 81a4 	ldr.w	r8, [pc, #420]	; 800c8c4 <main+0x1e4>
 800c722:	4959      	ldr	r1, [pc, #356]	; (800c888 <main+0x1a8>)
 800c724:	4640      	mov	r0, r8
 800c726:	f7f6 fe1b 	bl	8003360 <pwmStart>
  pwmEnableChannel(&PWMD8, 1, PWM_PERCENTAGE_TO_WIDTH(&PWMD8, 1000));   // 90% duty cycle
 800c72a:	f8d8 3008 	ldr.w	r3, [r8, #8]
 800c72e:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 800c732:	fb05 f303 	mul.w	r3, r5, r3
 800c736:	f8df 9190 	ldr.w	r9, [pc, #400]	; 800c8c8 <main+0x1e8>
 800c73a:	fba9 3203 	umull	r3, r2, r9, r3
 800c73e:	0b52      	lsrs	r2, r2, #13
 800c740:	2101      	movs	r1, #1
 800c742:	4640      	mov	r0, r8
 800c744:	f7f6 fdfc 	bl	8003340 <pwmEnableChannel>

  // MOTOR 2 control
  palSetPadMode(GPIOA, 8, PAL_MODE_OUTPUT_PUSHPULL);
 800c748:	2201      	movs	r2, #1
 800c74a:	f44f 7180 	mov.w	r1, #256	; 0x100
 800c74e:	4620      	mov	r0, r4
 800c750:	f7f9 fae6 	bl	8005d20 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 9, PAL_MODE_OUTPUT_PUSHPULL);
 800c754:	2201      	movs	r2, #1
 800c756:	f44f 7100 	mov.w	r1, #512	; 0x200
 800c75a:	4620      	mov	r0, r4
 800c75c:	f7f9 fae0 	bl	8005d20 <_pal_lld_setgroupmode>
  palSetPad(GPIOA, 8); //M2INA
 800c760:	f44f 7380 	mov.w	r3, #256	; 0x100
 800c764:	8323      	strh	r3, [r4, #24]
  palClearPad(GPIOA, 9);//M2INB
 800c766:	f44f 7300 	mov.w	r3, #512	; 0x200
 800c76a:	8363      	strh	r3, [r4, #26]

  palSetPadMode(GPIOB, 6, PAL_MODE_ALTERNATE(2)); //TIM4_chan1
 800c76c:	f44f 7281 	mov.w	r2, #258	; 0x102
 800c770:	2140      	movs	r1, #64	; 0x40
 800c772:	4630      	mov	r0, r6
 800c774:	f7f9 fad4 	bl	8005d20 <_pal_lld_setgroupmode>
  pwmStart(&PWMD4, &pwmcfg2);
 800c778:	4e44      	ldr	r6, [pc, #272]	; (800c88c <main+0x1ac>)
 800c77a:	4945      	ldr	r1, [pc, #276]	; (800c890 <main+0x1b0>)
 800c77c:	4630      	mov	r0, r6
 800c77e:	f7f6 fdef 	bl	8003360 <pwmStart>
  pwmEnableChannel(&PWMD4,0, PWM_PERCENTAGE_TO_WIDTH(&PWMD4, 1000));
 800c782:	68b2      	ldr	r2, [r6, #8]
 800c784:	fb05 f202 	mul.w	r2, r5, r2
 800c788:	fba9 3202 	umull	r3, r2, r9, r2
 800c78c:	0b52      	lsrs	r2, r2, #13
 800c78e:	2100      	movs	r1, #0
 800c790:	4630      	mov	r0, r6
 800c792:	f7f6 fdd5 	bl	8003340 <pwmEnableChannel>


  // Encoder 1
  palSetPadMode(GPIOA, 7, PAL_MODE_ALTERNATE(2)); //TIM3_chan2
 800c796:	f44f 7281 	mov.w	r2, #258	; 0x102
 800c79a:	2180      	movs	r1, #128	; 0x80
 800c79c:	4620      	mov	r0, r4
 800c79e:	f7f9 fabf 	bl	8005d20 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOC, 6, PAL_MODE_ALTERNATE(2)); //TIM3_chan1
 800c7a2:	f44f 7281 	mov.w	r2, #258	; 0x102
 800c7a6:	2140      	movs	r1, #64	; 0x40
 800c7a8:	4638      	mov	r0, r7
 800c7aa:	f7f9 fab9 	bl	8005d20 <_pal_lld_setgroupmode>
  qeiStart(&QEID3, &qeicfg1);
 800c7ae:	4d39      	ldr	r5, [pc, #228]	; (800c894 <main+0x1b4>)
 800c7b0:	4939      	ldr	r1, [pc, #228]	; (800c898 <main+0x1b8>)
 800c7b2:	4628      	mov	r0, r5
 800c7b4:	f7f9 fcb4 	bl	8006120 <qeiStart>
  qeiEnable(&QEID3);
 800c7b8:	4628      	mov	r0, r5
 800c7ba:	f7f9 fca1 	bl	8006100 <qeiEnable>

  // Encoder 2
  palSetPadMode(GPIOA, 1, PAL_MODE_ALTERNATE(1)); //TIM2_chan1
 800c7be:	2282      	movs	r2, #130	; 0x82
 800c7c0:	2102      	movs	r1, #2
 800c7c2:	4620      	mov	r0, r4
 800c7c4:	f7f9 faac 	bl	8005d20 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 0, PAL_MODE_ALTERNATE(1)); //TIM2_chan2
 800c7c8:	2282      	movs	r2, #130	; 0x82
 800c7ca:	2101      	movs	r1, #1
 800c7cc:	4620      	mov	r0, r4
 800c7ce:	f7f9 faa7 	bl	8005d20 <_pal_lld_setgroupmode>
  qeiStart(&QEID2, &qeicfg2);
 800c7d2:	4d32      	ldr	r5, [pc, #200]	; (800c89c <main+0x1bc>)
 800c7d4:	4932      	ldr	r1, [pc, #200]	; (800c8a0 <main+0x1c0>)
 800c7d6:	4628      	mov	r0, r5
 800c7d8:	f7f9 fca2 	bl	8006120 <qeiStart>
  qeiEnable(&QEID2);
 800c7dc:	4628      	mov	r0, r5
 800c7de:	f7f9 fc8f 	bl	8006100 <qeiEnable>

  // USB FS
  palSetPadMode(GPIOA, 12, PAL_MODE_ALTERNATE(10)); //USB D+
 800c7e2:	f240 5202 	movw	r2, #1282	; 0x502
 800c7e6:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800c7ea:	4620      	mov	r0, r4
 800c7ec:	f7f9 fa98 	bl	8005d20 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 11, PAL_MODE_ALTERNATE(10)); //USB D-
 800c7f0:	f240 5202 	movw	r2, #1282	; 0x502
 800c7f4:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800c7f8:	4620      	mov	r0, r4
 800c7fa:	f7f9 fa91 	bl	8005d20 <_pal_lld_setgroupmode>
  USBStream::init();
 800c7fe:	f7ff faaf 	bl	800bd60 <_ZN9USBStream4initEv>

  /*
   * Creates the blinker thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 800c802:	2400      	movs	r4, #0
 800c804:	9400      	str	r4, [sp, #0]
 800c806:	4b27      	ldr	r3, [pc, #156]	; (800c8a4 <main+0x1c4>)
 800c808:	2280      	movs	r2, #128	; 0x80
 800c80a:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800c80e:	4826      	ldr	r0, [pc, #152]	; (800c8a8 <main+0x1c8>)
 800c810:	f7fe ffae 	bl	800b770 <chThdCreateStatic>


	/*
	 * Activates the serial driver 2 using the driver default configuration.
	 */
	sdStart(&SD2, NULL);
 800c814:	4d25      	ldr	r5, [pc, #148]	; (800c8ac <main+0x1cc>)
 800c816:	4621      	mov	r1, r4
 800c818:	4628      	mov	r0, r5
 800c81a:	f7f6 fd61 	bl	80032e0 <sdStart>
	shellInit();
 800c81e:	f7fc f8a7 	bl	8008970 <shellInit>
			/* sc_histsize */   sizeof(histbuf),
	#endif
	#if (SHELL_USE_COMPLETION == TRUE)
			/* sc_completion */ completion_buffer
	#endif
		};
 800c822:	ab02      	add	r3, sp, #8
 800c824:	9403      	str	r4, [sp, #12]
 800c826:	9502      	str	r5, [sp, #8]

	thread_t *shellThd = chThdCreateStatic(wa_shell, sizeof(wa_shell), LOWPRIO, shellThread, &shellCfg);
 800c828:	9300      	str	r3, [sp, #0]
 800c82a:	4b21      	ldr	r3, [pc, #132]	; (800c8b0 <main+0x1d0>)
 800c82c:	2202      	movs	r2, #2
 800c82e:	f44f 7154 	mov.w	r1, #848	; 0x350
 800c832:	4820      	ldr	r0, [pc, #128]	; (800c8b4 <main+0x1d4>)
 800c834:	f7fe ff9c 	bl	800b770 <chThdCreateStatic>
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  tp->name = name;
 800c838:	4b1f      	ldr	r3, [pc, #124]	; (800c8b8 <main+0x1d8>)
 800c83a:	6183      	str	r3, [r0, #24]
  /*
   * Normal main() thread activity, in this demo it does nothing except
   * sleeping in a loop and check the button state.
   */
  while (true) {
	  int16_t qei2  = qeiGetCount(&QEID2);
 800c83c:	4d17      	ldr	r5, [pc, #92]	; (800c89c <main+0x1bc>)
 800c83e:	4628      	mov	r0, r5
 800c840:	f7f9 fc4e 	bl	80060e0 <qeiGetCount>
 800c844:	4606      	mov	r6, r0
	  int16_t qei3  = qeiGetCount(&QEID3);
 800c846:	4c13      	ldr	r4, [pc, #76]	; (800c894 <main+0x1b4>)
 800c848:	4620      	mov	r0, r4
 800c84a:	f7f9 fc49 	bl	80060e0 <qeiGetCount>
 800c84e:	4607      	mov	r7, r0
	  qei_lld_set_count(&QEID2, 0);
 800c850:	68aa      	ldr	r2, [r5, #8]
 800c852:	2300      	movs	r3, #0
 800c854:	6253      	str	r3, [r2, #36]	; 0x24
	  qei_lld_set_count(&QEID3, 0);
 800c856:	68a2      	ldr	r2, [r4, #8]
 800c858:	6253      	str	r3, [r2, #36]	; 0x24


  void *ptr = USBStream::instance()->SendCurrentStream();
 800c85a:	4b18      	ldr	r3, [pc, #96]	; (800c8bc <main+0x1dc>)
 800c85c:	6818      	ldr	r0, [r3, #0]
 800c85e:	f7ff fa4f 	bl	800bd00 <_ZN9USBStream17SendCurrentStreamEv>

  chprintf(outputStream, "qei2 %d quei3 %d  ptr %x \r\n",  qei2, qei3, ptr);
 800c862:	9000      	str	r0, [sp, #0]
 800c864:	463b      	mov	r3, r7
 800c866:	4632      	mov	r2, r6
 800c868:	4915      	ldr	r1, [pc, #84]	; (800c8c0 <main+0x1e0>)
 800c86a:	4810      	ldr	r0, [pc, #64]	; (800c8ac <main+0x1cc>)
 800c86c:	f7fc f888 	bl	8008980 <chprintf>

    chThdSleepMilliseconds(750);
 800c870:	f641 504c 	movw	r0, #7500	; 0x1d4c
 800c874:	f7ff f9ec 	bl	800bc50 <chThdSleep>
 800c878:	e7e0      	b.n	800c83c <main+0x15c>
 800c87a:	bf00      	nop
 800c87c:	40020000 	.word	0x40020000
 800c880:	40020400 	.word	0x40020400
 800c884:	40020800 	.word	0x40020800
 800c888:	20002550 	.word	0x20002550
 800c88c:	20003b64 	.word	0x20003b64
 800c890:	2000251c 	.word	0x2000251c
 800c894:	20003dec 	.word	0x20003dec
 800c898:	20002588 	.word	0x20002588
 800c89c:	20003df8 	.word	0x20003df8
 800c8a0:	20002598 	.word	0x20002598
 800c8a4:	0800bd31 	.word	0x0800bd31
 800c8a8:	20003c18 	.word	0x20003c18
 800c8ac:	20003b80 	.word	0x20003b80
 800c8b0:	08008d31 	.word	0x08008d31
 800c8b4:	20003260 	.word	0x20003260
 800c8b8:	08010150 	.word	0x08010150
 800c8bc:	20003de8 	.word	0x20003de8
 800c8c0:	08010158 	.word	0x08010158
 800c8c4:	20003bfc 	.word	0x20003bfc
 800c8c8:	d1b71759 	.word	0xd1b71759
 800c8cc:	00000000 	.word	0x00000000

0800c8d0 <_kill>:
#undef errno
extern int errno;
int _kill(int pid, int sig) {
  (void)pid;
  (void)sig;
  errno = EINVAL;
 800c8d0:	2216      	movs	r2, #22
 800c8d2:	4b02      	ldr	r3, [pc, #8]	; (800c8dc <_kill+0xc>)
 800c8d4:	601a      	str	r2, [r3, #0]
  return -1;
}
 800c8d6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800c8da:	4770      	bx	lr
 800c8dc:	20003e4c 	.word	0x20003e4c

0800c8e0 <_getpid>:
}
 800c8e0:	2001      	movs	r0, #1
 800c8e2:	4770      	bx	lr
	...

0800c8f0 <_exit>:
void _exit(int status){
 800c8f0:	b508      	push	{r3, lr}
  chSysHalt(reason);
 800c8f2:	4801      	ldr	r0, [pc, #4]	; (800c8f8 <_exit+0x8>)
 800c8f4:	f7fa f8ec 	bl	8006ad0 <chSysHalt>
 800c8f8:	08010190 	.word	0x08010190
 800c8fc:	00000000 	.word	0x00000000

0800c900 <vtcb>:
static void vtcb(void *p) {
 800c900:	b510      	push	{r4, lr}
 800c902:	2320      	movs	r3, #32
 800c904:	f383 8811 	msr	BASEPRI, r3
 800c908:	2400      	movs	r4, #0
 800c90a:	f384 8811 	msr	BASEPRI, r4
 800c90e:	f383 8811 	msr	BASEPRI, r3
  sts = chSysGetStatusAndLockX();
 800c912:	f7fa f87d 	bl	8006a10 <chSysGetStatusAndLockX>
  chSysRestoreStatusX(sts);
 800c916:	f7fa f863 	bl	80069e0 <chSysRestoreStatusX>
 800c91a:	f384 8811 	msr	BASEPRI, r4
 800c91e:	bd10      	pop	{r4, pc}

0800c920 <test_wait_tick>:
}

/*
 * Delays execution until next system time tick.
 */
systime_t test_wait_tick(void) {
 800c920:	b508      	push	{r3, lr}

  chThdSleep(1);
 800c922:	2001      	movs	r0, #1
 800c924:	f7ff f994 	bl	800bc50 <chThdSleep>
 800c928:	2320      	movs	r3, #32
 800c92a:	f383 8811 	msr	BASEPRI, r3
 800c92e:	4b03      	ldr	r3, [pc, #12]	; (800c93c <test_wait_tick+0x1c>)
 800c930:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800c932:	2300      	movs	r3, #0
 800c934:	f383 8811 	msr	BASEPRI, r3
  return chVTGetSystemTime();
}
 800c938:	bd08      	pop	{r3, pc}
 800c93a:	bf00      	nop
 800c93c:	40000c00 	.word	0x40000c00

0800c940 <test_wait_threads>:
void test_wait_threads(void) {
 800c940:	b510      	push	{r4, lr}
  for (i = 0; i < MAX_THREADS; i++)
 800c942:	2400      	movs	r4, #0
 800c944:	e00a      	b.n	800c95c <test_wait_threads+0x1c>
    if (threads[i] != NULL) {
 800c946:	4b07      	ldr	r3, [pc, #28]	; (800c964 <test_wait_threads+0x24>)
 800c948:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 800c94c:	b128      	cbz	r0, 800c95a <test_wait_threads+0x1a>
      chThdWait(threads[i]);
 800c94e:	f7ff f867 	bl	800ba20 <chThdWait>
      threads[i] = NULL;
 800c952:	2200      	movs	r2, #0
 800c954:	4b03      	ldr	r3, [pc, #12]	; (800c964 <test_wait_threads+0x24>)
 800c956:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
  for (i = 0; i < MAX_THREADS; i++)
 800c95a:	3401      	adds	r4, #1
 800c95c:	2c04      	cmp	r4, #4
 800c95e:	d9f2      	bls.n	800c946 <test_wait_threads+0x6>
}
 800c960:	bd10      	pop	{r4, pc}
 800c962:	bf00      	nop
 800c964:	20002f1c 	.word	0x20002f1c
	...

0800c970 <test_terminate_threads>:
void test_terminate_threads(void) {
 800c970:	b510      	push	{r4, lr}
  for (i = 0; i < MAX_THREADS; i++)
 800c972:	2400      	movs	r4, #0
 800c974:	e006      	b.n	800c984 <test_terminate_threads+0x14>
    if (threads[i])
 800c976:	4b05      	ldr	r3, [pc, #20]	; (800c98c <test_terminate_threads+0x1c>)
 800c978:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 800c97c:	b108      	cbz	r0, 800c982 <test_terminate_threads+0x12>
      chThdTerminate(threads[i]);
 800c97e:	f7fe fd07 	bl	800b390 <chThdTerminate>
  for (i = 0; i < MAX_THREADS; i++)
 800c982:	3401      	adds	r4, #1
 800c984:	2c04      	cmp	r4, #4
 800c986:	d9f6      	bls.n	800c976 <test_terminate_threads+0x6>
}
 800c988:	bd10      	pop	{r4, pc}
 800c98a:	bf00      	nop
 800c98c:	20002f1c 	.word	0x20002f1c

0800c990 <test_emit_token>:
 800c990:	2320      	movs	r3, #32
 800c992:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void test_emit_token(char token) {

  osalSysLock();
  if (test_tokp < &test_tokens_buffer[TEST_MAX_TOKENS])
 800c996:	4b06      	ldr	r3, [pc, #24]	; (800c9b0 <test_emit_token+0x20>)
 800c998:	681b      	ldr	r3, [r3, #0]
 800c99a:	4a06      	ldr	r2, [pc, #24]	; (800c9b4 <test_emit_token+0x24>)
 800c99c:	4293      	cmp	r3, r2
 800c99e:	d203      	bcs.n	800c9a8 <test_emit_token+0x18>
    *test_tokp++ = token;
 800c9a0:	1c59      	adds	r1, r3, #1
 800c9a2:	4a03      	ldr	r2, [pc, #12]	; (800c9b0 <test_emit_token+0x20>)
 800c9a4:	6011      	str	r1, [r2, #0]
 800c9a6:	7018      	strb	r0, [r3, #0]
 800c9a8:	2300      	movs	r3, #0
 800c9aa:	f383 8811 	msr	BASEPRI, r3
 800c9ae:	4770      	bx	lr
 800c9b0:	20003e28 	.word	0x20003e28
 800c9b4:	20003e24 	.word	0x20003e24
	...

0800c9c0 <test_print>:
void test_print(const char *msgp) {
 800c9c0:	b510      	push	{r4, lr}
 800c9c2:	4604      	mov	r4, r0
 800c9c4:	e005      	b.n	800c9d2 <test_print+0x12>
    streamPut(test_chp, *msgp++);
 800c9c6:	4b05      	ldr	r3, [pc, #20]	; (800c9dc <test_print+0x1c>)
 800c9c8:	6818      	ldr	r0, [r3, #0]
 800c9ca:	3401      	adds	r4, #1
 800c9cc:	6803      	ldr	r3, [r0, #0]
 800c9ce:	68db      	ldr	r3, [r3, #12]
 800c9d0:	4798      	blx	r3
  while (*msgp)
 800c9d2:	7821      	ldrb	r1, [r4, #0]
 800c9d4:	2900      	cmp	r1, #0
 800c9d6:	d1f6      	bne.n	800c9c6 <test_print+0x6>
}
 800c9d8:	bd10      	pop	{r4, pc}
 800c9da:	bf00      	nop
 800c9dc:	20003e08 	.word	0x20003e08

0800c9e0 <test_println>:
void test_println(const char *msgp) {
 800c9e0:	b508      	push	{r3, lr}
  test_print(msgp);
 800c9e2:	f7ff ffed 	bl	800c9c0 <test_print>
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 800c9e6:	4b04      	ldr	r3, [pc, #16]	; (800c9f8 <test_println+0x18>)
 800c9e8:	6818      	ldr	r0, [r3, #0]
 800c9ea:	6803      	ldr	r3, [r0, #0]
 800c9ec:	685b      	ldr	r3, [r3, #4]
 800c9ee:	2202      	movs	r2, #2
 800c9f0:	4902      	ldr	r1, [pc, #8]	; (800c9fc <test_println+0x1c>)
 800c9f2:	4798      	blx	r3
 800c9f4:	bd08      	pop	{r3, pc}
 800c9f6:	bf00      	nop
 800c9f8:	20003e08 	.word	0x20003e08
 800c9fc:	0800f138 	.word	0x0800f138

0800ca00 <test_printn>:
void test_printn(uint32_t n) {
 800ca00:	b510      	push	{r4, lr}
 800ca02:	b084      	sub	sp, #16
  if (!n)
 800ca04:	b9a0      	cbnz	r0, 800ca30 <test_printn+0x30>
    streamPut(test_chp, '0');
 800ca06:	4b13      	ldr	r3, [pc, #76]	; (800ca54 <test_printn+0x54>)
 800ca08:	6818      	ldr	r0, [r3, #0]
 800ca0a:	6803      	ldr	r3, [r0, #0]
 800ca0c:	68db      	ldr	r3, [r3, #12]
 800ca0e:	2130      	movs	r1, #48	; 0x30
 800ca10:	4798      	blx	r3
 800ca12:	e01c      	b.n	800ca4e <test_printn+0x4e>
      *p++ = (n % 10) + '0', n /= 10;
 800ca14:	4b10      	ldr	r3, [pc, #64]	; (800ca58 <test_printn+0x58>)
 800ca16:	fba3 1302 	umull	r1, r3, r3, r2
 800ca1a:	08db      	lsrs	r3, r3, #3
 800ca1c:	4618      	mov	r0, r3
 800ca1e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800ca22:	0059      	lsls	r1, r3, #1
 800ca24:	1a53      	subs	r3, r2, r1
 800ca26:	3330      	adds	r3, #48	; 0x30
 800ca28:	7023      	strb	r3, [r4, #0]
 800ca2a:	4602      	mov	r2, r0
 800ca2c:	3401      	adds	r4, #1
 800ca2e:	e001      	b.n	800ca34 <test_printn+0x34>
 800ca30:	4602      	mov	r2, r0
  if (!n)
 800ca32:	466c      	mov	r4, sp
    while (n)
 800ca34:	2a00      	cmp	r2, #0
 800ca36:	d1ed      	bne.n	800ca14 <test_printn+0x14>
 800ca38:	e006      	b.n	800ca48 <test_printn+0x48>
      streamPut(test_chp, *--p);
 800ca3a:	4b06      	ldr	r3, [pc, #24]	; (800ca54 <test_printn+0x54>)
 800ca3c:	6818      	ldr	r0, [r3, #0]
 800ca3e:	6803      	ldr	r3, [r0, #0]
 800ca40:	68db      	ldr	r3, [r3, #12]
 800ca42:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
 800ca46:	4798      	blx	r3
    while (p > buf)
 800ca48:	466b      	mov	r3, sp
 800ca4a:	429c      	cmp	r4, r3
 800ca4c:	d8f5      	bhi.n	800ca3a <test_printn+0x3a>
}
 800ca4e:	b004      	add	sp, #16
 800ca50:	bd10      	pop	{r4, pc}
 800ca52:	bf00      	nop
 800ca54:	20003e08 	.word	0x20003e08
 800ca58:	cccccccd 	.word	0xcccccccd
 800ca5c:	00000000 	.word	0x00000000

0800ca60 <rt_test_001_003_execute.lto_priv.65>:
 * <h2>Test Steps</h2>
 * - [1.3.1] Prints the configuration options settings.
 * .
 */

static void rt_test_001_003_execute(void) {
 800ca60:	b538      	push	{r3, r4, r5, lr}

  /* [1.3.1] Prints the configuration options settings.*/
  test_set_step(1);
 800ca62:	2501      	movs	r5, #1
 800ca64:	4bc8      	ldr	r3, [pc, #800]	; (800cd88 <rt_test_001_003_execute.lto_priv.65+0x328>)
 800ca66:	601d      	str	r5, [r3, #0]
  {
    test_print("--- CH_CFG_ST_RESOLUTION:               ");
 800ca68:	48c8      	ldr	r0, [pc, #800]	; (800cd8c <rt_test_001_003_execute.lto_priv.65+0x32c>)
 800ca6a:	f7ff ffa9 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_ST_RESOLUTION);
 800ca6e:	2020      	movs	r0, #32
 800ca70:	f7ff ffc6 	bl	800ca00 <test_printn>
    test_println("");
 800ca74:	4cc6      	ldr	r4, [pc, #792]	; (800cd90 <rt_test_001_003_execute.lto_priv.65+0x330>)
 800ca76:	4620      	mov	r0, r4
 800ca78:	f7ff ffb2 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_ST_FREQUENCY:                ");
 800ca7c:	48c5      	ldr	r0, [pc, #788]	; (800cd94 <rt_test_001_003_execute.lto_priv.65+0x334>)
 800ca7e:	f7ff ff9f 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_ST_FREQUENCY);
 800ca82:	f242 7010 	movw	r0, #10000	; 0x2710
 800ca86:	f7ff ffbb 	bl	800ca00 <test_printn>
    test_println("");
 800ca8a:	4620      	mov	r0, r4
 800ca8c:	f7ff ffa8 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_INTERVALS_SIZE:              ");
 800ca90:	48c1      	ldr	r0, [pc, #772]	; (800cd98 <rt_test_001_003_execute.lto_priv.65+0x338>)
 800ca92:	f7ff ff95 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_INTERVALS_SIZE);
 800ca96:	2020      	movs	r0, #32
 800ca98:	f7ff ffb2 	bl	800ca00 <test_printn>
    test_println("");
 800ca9c:	4620      	mov	r0, r4
 800ca9e:	f7ff ff9f 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_TIME_TYPES_SIZE:             ");
 800caa2:	48be      	ldr	r0, [pc, #760]	; (800cd9c <rt_test_001_003_execute.lto_priv.65+0x33c>)
 800caa4:	f7ff ff8c 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_TIME_TYPES_SIZE);
 800caa8:	2020      	movs	r0, #32
 800caaa:	f7ff ffa9 	bl	800ca00 <test_printn>
    test_println("");
 800caae:	4620      	mov	r0, r4
 800cab0:	f7ff ff96 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_ST_TIMEDELTA:                ");
 800cab4:	48ba      	ldr	r0, [pc, #744]	; (800cda0 <rt_test_001_003_execute.lto_priv.65+0x340>)
 800cab6:	f7ff ff83 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_ST_TIMEDELTA);
 800caba:	2002      	movs	r0, #2
 800cabc:	f7ff ffa0 	bl	800ca00 <test_printn>
    test_println("");
 800cac0:	4620      	mov	r0, r4
 800cac2:	f7ff ff8d 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_TIME_QUANTUM:                ");
 800cac6:	48b7      	ldr	r0, [pc, #732]	; (800cda4 <rt_test_001_003_execute.lto_priv.65+0x344>)
 800cac8:	f7ff ff7a 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_TIME_QUANTUM);
 800cacc:	2000      	movs	r0, #0
 800cace:	f7ff ff97 	bl	800ca00 <test_printn>
    test_println("");
 800cad2:	4620      	mov	r0, r4
 800cad4:	f7ff ff84 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_MEMCORE_SIZE:                ");
 800cad8:	48b3      	ldr	r0, [pc, #716]	; (800cda8 <rt_test_001_003_execute.lto_priv.65+0x348>)
 800cada:	f7ff ff71 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_MEMCORE_SIZE);
 800cade:	2000      	movs	r0, #0
 800cae0:	f7ff ff8e 	bl	800ca00 <test_printn>
    test_println("");
 800cae4:	4620      	mov	r0, r4
 800cae6:	f7ff ff7b 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_NO_IDLE_THREAD:              ");
 800caea:	48b0      	ldr	r0, [pc, #704]	; (800cdac <rt_test_001_003_execute.lto_priv.65+0x34c>)
 800caec:	f7ff ff68 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_NO_IDLE_THREAD);
 800caf0:	2000      	movs	r0, #0
 800caf2:	f7ff ff85 	bl	800ca00 <test_printn>
    test_println("");
 800caf6:	4620      	mov	r0, r4
 800caf8:	f7ff ff72 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_OPTIMIZE_SPEED:              ");
 800cafc:	48ac      	ldr	r0, [pc, #688]	; (800cdb0 <rt_test_001_003_execute.lto_priv.65+0x350>)
 800cafe:	f7ff ff5f 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_OPTIMIZE_SPEED);
 800cb02:	4628      	mov	r0, r5
 800cb04:	f7ff ff7c 	bl	800ca00 <test_printn>
    test_println("");
 800cb08:	4620      	mov	r0, r4
 800cb0a:	f7ff ff69 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_USE_TM:                      ");
 800cb0e:	48a9      	ldr	r0, [pc, #676]	; (800cdb4 <rt_test_001_003_execute.lto_priv.65+0x354>)
 800cb10:	f7ff ff56 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_USE_TM);
 800cb14:	4628      	mov	r0, r5
 800cb16:	f7ff ff73 	bl	800ca00 <test_printn>
    test_println("");
 800cb1a:	4620      	mov	r0, r4
 800cb1c:	f7ff ff60 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_USE_REGISTRY:                ");
 800cb20:	48a5      	ldr	r0, [pc, #660]	; (800cdb8 <rt_test_001_003_execute.lto_priv.65+0x358>)
 800cb22:	f7ff ff4d 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_USE_REGISTRY);
 800cb26:	4628      	mov	r0, r5
 800cb28:	f7ff ff6a 	bl	800ca00 <test_printn>
    test_println("");
 800cb2c:	4620      	mov	r0, r4
 800cb2e:	f7ff ff57 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_USE_WAITEXIT:                ");
 800cb32:	48a2      	ldr	r0, [pc, #648]	; (800cdbc <rt_test_001_003_execute.lto_priv.65+0x35c>)
 800cb34:	f7ff ff44 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_USE_WAITEXIT);
 800cb38:	4628      	mov	r0, r5
 800cb3a:	f7ff ff61 	bl	800ca00 <test_printn>
    test_println("");
 800cb3e:	4620      	mov	r0, r4
 800cb40:	f7ff ff4e 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_USE_SEMAPHORES:              ");
 800cb44:	489e      	ldr	r0, [pc, #632]	; (800cdc0 <rt_test_001_003_execute.lto_priv.65+0x360>)
 800cb46:	f7ff ff3b 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_USE_SEMAPHORES);
 800cb4a:	4628      	mov	r0, r5
 800cb4c:	f7ff ff58 	bl	800ca00 <test_printn>
    test_println("");
 800cb50:	4620      	mov	r0, r4
 800cb52:	f7ff ff45 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_USE_SEMAPHORES_PRIORITY:     ");
 800cb56:	489b      	ldr	r0, [pc, #620]	; (800cdc4 <rt_test_001_003_execute.lto_priv.65+0x364>)
 800cb58:	f7ff ff32 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_USE_SEMAPHORES_PRIORITY);
 800cb5c:	2000      	movs	r0, #0
 800cb5e:	f7ff ff4f 	bl	800ca00 <test_printn>
    test_println("");
 800cb62:	4620      	mov	r0, r4
 800cb64:	f7ff ff3c 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_USE_MUTEXES:                 ");
 800cb68:	4897      	ldr	r0, [pc, #604]	; (800cdc8 <rt_test_001_003_execute.lto_priv.65+0x368>)
 800cb6a:	f7ff ff29 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_USE_MUTEXES);
 800cb6e:	4628      	mov	r0, r5
 800cb70:	f7ff ff46 	bl	800ca00 <test_printn>
    test_println("");
 800cb74:	4620      	mov	r0, r4
 800cb76:	f7ff ff33 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_USE_MUTEXES_RECURSIVE:       ");
 800cb7a:	4894      	ldr	r0, [pc, #592]	; (800cdcc <rt_test_001_003_execute.lto_priv.65+0x36c>)
 800cb7c:	f7ff ff20 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_USE_MUTEXES_RECURSIVE);
 800cb80:	2000      	movs	r0, #0
 800cb82:	f7ff ff3d 	bl	800ca00 <test_printn>
    test_println("");   
 800cb86:	4620      	mov	r0, r4
 800cb88:	f7ff ff2a 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_USE_CONDVARS:                ");
 800cb8c:	4890      	ldr	r0, [pc, #576]	; (800cdd0 <rt_test_001_003_execute.lto_priv.65+0x370>)
 800cb8e:	f7ff ff17 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_USE_CONDVARS);
 800cb92:	4628      	mov	r0, r5
 800cb94:	f7ff ff34 	bl	800ca00 <test_printn>
    test_println("");
 800cb98:	4620      	mov	r0, r4
 800cb9a:	f7ff ff21 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_USE_CONDVARS_TIMEOUT:        ");
 800cb9e:	488d      	ldr	r0, [pc, #564]	; (800cdd4 <rt_test_001_003_execute.lto_priv.65+0x374>)
 800cba0:	f7ff ff0e 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_USE_CONDVARS_TIMEOUT);
 800cba4:	4628      	mov	r0, r5
 800cba6:	f7ff ff2b 	bl	800ca00 <test_printn>
    test_println("");
 800cbaa:	4620      	mov	r0, r4
 800cbac:	f7ff ff18 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_USE_EVENTS:                  ");
 800cbb0:	4889      	ldr	r0, [pc, #548]	; (800cdd8 <rt_test_001_003_execute.lto_priv.65+0x378>)
 800cbb2:	f7ff ff05 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_USE_EVENTS);
 800cbb6:	4628      	mov	r0, r5
 800cbb8:	f7ff ff22 	bl	800ca00 <test_printn>
    test_println("");
 800cbbc:	4620      	mov	r0, r4
 800cbbe:	f7ff ff0f 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_USE_EVENTS_TIMEOUT:          ");
 800cbc2:	4886      	ldr	r0, [pc, #536]	; (800cddc <rt_test_001_003_execute.lto_priv.65+0x37c>)
 800cbc4:	f7ff fefc 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_USE_EVENTS_TIMEOUT);
 800cbc8:	4628      	mov	r0, r5
 800cbca:	f7ff ff19 	bl	800ca00 <test_printn>
    test_println("");
 800cbce:	4620      	mov	r0, r4
 800cbd0:	f7ff ff06 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_USE_MESSAGES:                ");
 800cbd4:	4882      	ldr	r0, [pc, #520]	; (800cde0 <rt_test_001_003_execute.lto_priv.65+0x380>)
 800cbd6:	f7ff fef3 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_USE_MESSAGES);
 800cbda:	4628      	mov	r0, r5
 800cbdc:	f7ff ff10 	bl	800ca00 <test_printn>
    test_println("");
 800cbe0:	4620      	mov	r0, r4
 800cbe2:	f7ff fefd 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_USE_MESSAGES_PRIORITY:       ");
 800cbe6:	487f      	ldr	r0, [pc, #508]	; (800cde4 <rt_test_001_003_execute.lto_priv.65+0x384>)
 800cbe8:	f7ff feea 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_USE_MESSAGES_PRIORITY);
 800cbec:	2000      	movs	r0, #0
 800cbee:	f7ff ff07 	bl	800ca00 <test_printn>
    test_println("");
 800cbf2:	4620      	mov	r0, r4
 800cbf4:	f7ff fef4 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_USE_MAILBOXES:               ");
 800cbf8:	487b      	ldr	r0, [pc, #492]	; (800cde8 <rt_test_001_003_execute.lto_priv.65+0x388>)
 800cbfa:	f7ff fee1 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_USE_MAILBOXES);
 800cbfe:	4628      	mov	r0, r5
 800cc00:	f7ff fefe 	bl	800ca00 <test_printn>
    test_println("");
 800cc04:	4620      	mov	r0, r4
 800cc06:	f7ff feeb 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_USE_MEMCORE:                 ");
 800cc0a:	4878      	ldr	r0, [pc, #480]	; (800cdec <rt_test_001_003_execute.lto_priv.65+0x38c>)
 800cc0c:	f7ff fed8 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_USE_MEMCORE);
 800cc10:	4628      	mov	r0, r5
 800cc12:	f7ff fef5 	bl	800ca00 <test_printn>
    test_println("");
 800cc16:	4620      	mov	r0, r4
 800cc18:	f7ff fee2 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_USE_HEAP:                    ");
 800cc1c:	4874      	ldr	r0, [pc, #464]	; (800cdf0 <rt_test_001_003_execute.lto_priv.65+0x390>)
 800cc1e:	f7ff fecf 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_USE_HEAP);
 800cc22:	4628      	mov	r0, r5
 800cc24:	f7ff feec 	bl	800ca00 <test_printn>
    test_println("");
 800cc28:	4620      	mov	r0, r4
 800cc2a:	f7ff fed9 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_USE_MEMPOOLS:                ");
 800cc2e:	4871      	ldr	r0, [pc, #452]	; (800cdf4 <rt_test_001_003_execute.lto_priv.65+0x394>)
 800cc30:	f7ff fec6 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_USE_MEMPOOLS);
 800cc34:	4628      	mov	r0, r5
 800cc36:	f7ff fee3 	bl	800ca00 <test_printn>
    test_println("");
 800cc3a:	4620      	mov	r0, r4
 800cc3c:	f7ff fed0 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_USE_OBJ_FIFOS:               ");
 800cc40:	486d      	ldr	r0, [pc, #436]	; (800cdf8 <rt_test_001_003_execute.lto_priv.65+0x398>)
 800cc42:	f7ff febd 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_USE_OBJ_FIFOS);
 800cc46:	4628      	mov	r0, r5
 800cc48:	f7ff feda 	bl	800ca00 <test_printn>
    test_println("");
 800cc4c:	4620      	mov	r0, r4
 800cc4e:	f7ff fec7 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_USE_DYNAMIC:                 ");
 800cc52:	486a      	ldr	r0, [pc, #424]	; (800cdfc <rt_test_001_003_execute.lto_priv.65+0x39c>)
 800cc54:	f7ff feb4 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_USE_DYNAMIC);
 800cc58:	4628      	mov	r0, r5
 800cc5a:	f7ff fed1 	bl	800ca00 <test_printn>
    test_println("");
 800cc5e:	4620      	mov	r0, r4
 800cc60:	f7ff febe 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_USE_FACTORY:                 ");
 800cc64:	4866      	ldr	r0, [pc, #408]	; (800ce00 <rt_test_001_003_execute.lto_priv.65+0x3a0>)
 800cc66:	f7ff feab 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_USE_FACTORY);
 800cc6a:	4628      	mov	r0, r5
 800cc6c:	f7ff fec8 	bl	800ca00 <test_printn>
    test_println("");
 800cc70:	4620      	mov	r0, r4
 800cc72:	f7ff feb5 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_FACTORY_MAX_NAMES_LENGTH:    ");
 800cc76:	4863      	ldr	r0, [pc, #396]	; (800ce04 <rt_test_001_003_execute.lto_priv.65+0x3a4>)
 800cc78:	f7ff fea2 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_FACTORY_MAX_NAMES_LENGTH);
 800cc7c:	2008      	movs	r0, #8
 800cc7e:	f7ff febf 	bl	800ca00 <test_printn>
    test_println("");
 800cc82:	4620      	mov	r0, r4
 800cc84:	f7ff feac 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_FACTORY_OBJECTS_REGISTRY:    ");
 800cc88:	485f      	ldr	r0, [pc, #380]	; (800ce08 <rt_test_001_003_execute.lto_priv.65+0x3a8>)
 800cc8a:	f7ff fe99 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_FACTORY_OBJECTS_REGISTRY);
 800cc8e:	4628      	mov	r0, r5
 800cc90:	f7ff feb6 	bl	800ca00 <test_printn>
    test_println("");
 800cc94:	4620      	mov	r0, r4
 800cc96:	f7ff fea3 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_FACTORY_GENERIC_BUFFERS:     ");
 800cc9a:	485c      	ldr	r0, [pc, #368]	; (800ce0c <rt_test_001_003_execute.lto_priv.65+0x3ac>)
 800cc9c:	f7ff fe90 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_FACTORY_GENERIC_BUFFERS);
 800cca0:	4628      	mov	r0, r5
 800cca2:	f7ff fead 	bl	800ca00 <test_printn>
    test_println("");
 800cca6:	4620      	mov	r0, r4
 800cca8:	f7ff fe9a 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_FACTORY_SEMAPHORES:          ");
 800ccac:	4858      	ldr	r0, [pc, #352]	; (800ce10 <rt_test_001_003_execute.lto_priv.65+0x3b0>)
 800ccae:	f7ff fe87 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_FACTORY_SEMAPHORES);
 800ccb2:	4628      	mov	r0, r5
 800ccb4:	f7ff fea4 	bl	800ca00 <test_printn>
    test_println("");
 800ccb8:	4620      	mov	r0, r4
 800ccba:	f7ff fe91 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_FACTORY_MAILBOXES:           ");
 800ccbe:	4855      	ldr	r0, [pc, #340]	; (800ce14 <rt_test_001_003_execute.lto_priv.65+0x3b4>)
 800ccc0:	f7ff fe7e 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_FACTORY_MAILBOXES);
 800ccc4:	4628      	mov	r0, r5
 800ccc6:	f7ff fe9b 	bl	800ca00 <test_printn>
    test_println("");
 800ccca:	4620      	mov	r0, r4
 800cccc:	f7ff fe88 	bl	800c9e0 <test_println>
    test_print("--- CH_CFG_FACTORY_OBJ_FIFOS:           ");
 800ccd0:	4851      	ldr	r0, [pc, #324]	; (800ce18 <rt_test_001_003_execute.lto_priv.65+0x3b8>)
 800ccd2:	f7ff fe75 	bl	800c9c0 <test_print>
    test_printn(CH_CFG_FACTORY_OBJ_FIFOS);
 800ccd6:	4628      	mov	r0, r5
 800ccd8:	f7ff fe92 	bl	800ca00 <test_printn>
    test_println("");
 800ccdc:	4620      	mov	r0, r4
 800ccde:	f7ff fe7f 	bl	800c9e0 <test_println>
    test_print("--- CH_DBG_STATISTICS:                  ");
 800cce2:	484e      	ldr	r0, [pc, #312]	; (800ce1c <rt_test_001_003_execute.lto_priv.65+0x3bc>)
 800cce4:	f7ff fe6c 	bl	800c9c0 <test_print>
    test_printn(CH_DBG_STATISTICS);
 800cce8:	2000      	movs	r0, #0
 800ccea:	f7ff fe89 	bl	800ca00 <test_printn>
    test_println("");
 800ccee:	4620      	mov	r0, r4
 800ccf0:	f7ff fe76 	bl	800c9e0 <test_println>
    test_print("--- CH_DBG_SYSTEM_STATE_CHECK:          ");
 800ccf4:	484a      	ldr	r0, [pc, #296]	; (800ce20 <rt_test_001_003_execute.lto_priv.65+0x3c0>)
 800ccf6:	f7ff fe63 	bl	800c9c0 <test_print>
    test_printn(CH_DBG_SYSTEM_STATE_CHECK);
 800ccfa:	2000      	movs	r0, #0
 800ccfc:	f7ff fe80 	bl	800ca00 <test_printn>
    test_println("");
 800cd00:	4620      	mov	r0, r4
 800cd02:	f7ff fe6d 	bl	800c9e0 <test_println>
    test_print("--- CH_DBG_ENABLE_CHECKS:               ");
 800cd06:	4847      	ldr	r0, [pc, #284]	; (800ce24 <rt_test_001_003_execute.lto_priv.65+0x3c4>)
 800cd08:	f7ff fe5a 	bl	800c9c0 <test_print>
    test_printn(CH_DBG_ENABLE_CHECKS);
 800cd0c:	2000      	movs	r0, #0
 800cd0e:	f7ff fe77 	bl	800ca00 <test_printn>
    test_println("");
 800cd12:	4620      	mov	r0, r4
 800cd14:	f7ff fe64 	bl	800c9e0 <test_println>
    test_print("--- CH_DBG_ENABLE_ASSERTS:              ");
 800cd18:	4843      	ldr	r0, [pc, #268]	; (800ce28 <rt_test_001_003_execute.lto_priv.65+0x3c8>)
 800cd1a:	f7ff fe51 	bl	800c9c0 <test_print>
    test_printn(CH_DBG_ENABLE_ASSERTS);
 800cd1e:	2000      	movs	r0, #0
 800cd20:	f7ff fe6e 	bl	800ca00 <test_printn>
    test_println("");
 800cd24:	4620      	mov	r0, r4
 800cd26:	f7ff fe5b 	bl	800c9e0 <test_println>
    test_print("--- CH_DBG_TRACE_MASK:                  ");
 800cd2a:	4840      	ldr	r0, [pc, #256]	; (800ce2c <rt_test_001_003_execute.lto_priv.65+0x3cc>)
 800cd2c:	f7ff fe48 	bl	800c9c0 <test_print>
    test_printn(CH_DBG_TRACE_MASK);
 800cd30:	20ff      	movs	r0, #255	; 0xff
 800cd32:	f7ff fe65 	bl	800ca00 <test_printn>
    test_println("");
 800cd36:	4620      	mov	r0, r4
 800cd38:	f7ff fe52 	bl	800c9e0 <test_println>
    test_print("--- CH_DBG_TRACE_BUFFER_SIZE:           ");
 800cd3c:	483c      	ldr	r0, [pc, #240]	; (800ce30 <rt_test_001_003_execute.lto_priv.65+0x3d0>)
 800cd3e:	f7ff fe3f 	bl	800c9c0 <test_print>
    test_printn(CH_DBG_TRACE_BUFFER_SIZE);
 800cd42:	2080      	movs	r0, #128	; 0x80
 800cd44:	f7ff fe5c 	bl	800ca00 <test_printn>
    test_println("");
 800cd48:	4620      	mov	r0, r4
 800cd4a:	f7ff fe49 	bl	800c9e0 <test_println>
    test_print("--- CH_DBG_ENABLE_STACK_CHECK:          ");
 800cd4e:	4839      	ldr	r0, [pc, #228]	; (800ce34 <rt_test_001_003_execute.lto_priv.65+0x3d4>)
 800cd50:	f7ff fe36 	bl	800c9c0 <test_print>
    test_printn(CH_DBG_ENABLE_STACK_CHECK);
 800cd54:	2000      	movs	r0, #0
 800cd56:	f7ff fe53 	bl	800ca00 <test_printn>
    test_println("");
 800cd5a:	4620      	mov	r0, r4
 800cd5c:	f7ff fe40 	bl	800c9e0 <test_println>
    test_print("--- CH_DBG_FILL_THREADS:                ");
 800cd60:	4835      	ldr	r0, [pc, #212]	; (800ce38 <rt_test_001_003_execute.lto_priv.65+0x3d8>)
 800cd62:	f7ff fe2d 	bl	800c9c0 <test_print>
    test_printn(CH_DBG_FILL_THREADS);
 800cd66:	2000      	movs	r0, #0
 800cd68:	f7ff fe4a 	bl	800ca00 <test_printn>
    test_println("");
 800cd6c:	4620      	mov	r0, r4
 800cd6e:	f7ff fe37 	bl	800c9e0 <test_println>
    test_print("--- CH_DBG_THREADS_PROFILING:           ");
 800cd72:	4832      	ldr	r0, [pc, #200]	; (800ce3c <rt_test_001_003_execute.lto_priv.65+0x3dc>)
 800cd74:	f7ff fe24 	bl	800c9c0 <test_print>
    test_printn(CH_DBG_THREADS_PROFILING);
 800cd78:	2000      	movs	r0, #0
 800cd7a:	f7ff fe41 	bl	800ca00 <test_printn>
    test_println("");
 800cd7e:	4620      	mov	r0, r4
 800cd80:	f7ff fe2e 	bl	800c9e0 <test_println>
 800cd84:	bd38      	pop	{r3, r4, r5, pc}
 800cd86:	bf00      	nop
 800cd88:	20003e04 	.word	0x20003e04
 800cd8c:	080101a4 	.word	0x080101a4
 800cd90:	0800f184 	.word	0x0800f184
 800cd94:	080101d0 	.word	0x080101d0
 800cd98:	080101fc 	.word	0x080101fc
 800cd9c:	08010228 	.word	0x08010228
 800cda0:	08010254 	.word	0x08010254
 800cda4:	08010280 	.word	0x08010280
 800cda8:	080102ac 	.word	0x080102ac
 800cdac:	080102d8 	.word	0x080102d8
 800cdb0:	08010304 	.word	0x08010304
 800cdb4:	08010330 	.word	0x08010330
 800cdb8:	0801035c 	.word	0x0801035c
 800cdbc:	08010388 	.word	0x08010388
 800cdc0:	080103b4 	.word	0x080103b4
 800cdc4:	080103e0 	.word	0x080103e0
 800cdc8:	0801040c 	.word	0x0801040c
 800cdcc:	08010438 	.word	0x08010438
 800cdd0:	08010464 	.word	0x08010464
 800cdd4:	08010490 	.word	0x08010490
 800cdd8:	080104bc 	.word	0x080104bc
 800cddc:	080104e8 	.word	0x080104e8
 800cde0:	08010514 	.word	0x08010514
 800cde4:	08010540 	.word	0x08010540
 800cde8:	0801056c 	.word	0x0801056c
 800cdec:	08010598 	.word	0x08010598
 800cdf0:	080105c4 	.word	0x080105c4
 800cdf4:	080105f0 	.word	0x080105f0
 800cdf8:	0801061c 	.word	0x0801061c
 800cdfc:	08010648 	.word	0x08010648
 800ce00:	08010674 	.word	0x08010674
 800ce04:	080106a0 	.word	0x080106a0
 800ce08:	080106cc 	.word	0x080106cc
 800ce0c:	080106f8 	.word	0x080106f8
 800ce10:	08010724 	.word	0x08010724
 800ce14:	08010750 	.word	0x08010750
 800ce18:	0801077c 	.word	0x0801077c
 800ce1c:	080107a8 	.word	0x080107a8
 800ce20:	080107d4 	.word	0x080107d4
 800ce24:	08010800 	.word	0x08010800
 800ce28:	0801082c 	.word	0x0801082c
 800ce2c:	08010858 	.word	0x08010858
 800ce30:	08010884 	.word	0x08010884
 800ce34:	080108b0 	.word	0x080108b0
 800ce38:	080108dc 	.word	0x080108dc
 800ce3c:	08010908 	.word	0x08010908

0800ce40 <rt_test_001_002_execute.lto_priv.64>:
static void rt_test_001_002_execute(void) {
 800ce40:	b538      	push	{r3, r4, r5, lr}
  test_set_step(1);
 800ce42:	2501      	movs	r5, #1
 800ce44:	4b18      	ldr	r3, [pc, #96]	; (800cea8 <rt_test_001_002_execute.lto_priv.64+0x68>)
 800ce46:	601d      	str	r5, [r3, #0]
    test_println("--- Product:                            ChibiOS/RT");
 800ce48:	4818      	ldr	r0, [pc, #96]	; (800ceac <rt_test_001_002_execute.lto_priv.64+0x6c>)
 800ce4a:	f7ff fdc9 	bl	800c9e0 <test_println>
    test_print("--- Stable Flag:                        ");
 800ce4e:	4818      	ldr	r0, [pc, #96]	; (800ceb0 <rt_test_001_002_execute.lto_priv.64+0x70>)
 800ce50:	f7ff fdb6 	bl	800c9c0 <test_print>
    test_printn(CH_KERNEL_STABLE);
 800ce54:	4628      	mov	r0, r5
 800ce56:	f7ff fdd3 	bl	800ca00 <test_printn>
    test_println("");
 800ce5a:	4c16      	ldr	r4, [pc, #88]	; (800ceb4 <rt_test_001_002_execute.lto_priv.64+0x74>)
 800ce5c:	4620      	mov	r0, r4
 800ce5e:	f7ff fdbf 	bl	800c9e0 <test_println>
    test_print("--- Version String:                     ");
 800ce62:	4815      	ldr	r0, [pc, #84]	; (800ceb8 <rt_test_001_002_execute.lto_priv.64+0x78>)
 800ce64:	f7ff fdac 	bl	800c9c0 <test_print>
    test_println(CH_KERNEL_VERSION);
 800ce68:	4814      	ldr	r0, [pc, #80]	; (800cebc <rt_test_001_002_execute.lto_priv.64+0x7c>)
 800ce6a:	f7ff fdb9 	bl	800c9e0 <test_println>
    test_print("--- Major Number:                       ");
 800ce6e:	4814      	ldr	r0, [pc, #80]	; (800cec0 <rt_test_001_002_execute.lto_priv.64+0x80>)
 800ce70:	f7ff fda6 	bl	800c9c0 <test_print>
    test_printn(CH_KERNEL_MAJOR);
 800ce74:	2006      	movs	r0, #6
 800ce76:	f7ff fdc3 	bl	800ca00 <test_printn>
    test_println("");
 800ce7a:	4620      	mov	r0, r4
 800ce7c:	f7ff fdb0 	bl	800c9e0 <test_println>
    test_print("--- Minor Number:                       ");
 800ce80:	4810      	ldr	r0, [pc, #64]	; (800cec4 <rt_test_001_002_execute.lto_priv.64+0x84>)
 800ce82:	f7ff fd9d 	bl	800c9c0 <test_print>
    test_printn(CH_KERNEL_MINOR);
 800ce86:	2000      	movs	r0, #0
 800ce88:	f7ff fdba 	bl	800ca00 <test_printn>
    test_println("");
 800ce8c:	4620      	mov	r0, r4
 800ce8e:	f7ff fda7 	bl	800c9e0 <test_println>
    test_print("--- Patch Number:                       ");
 800ce92:	480d      	ldr	r0, [pc, #52]	; (800cec8 <rt_test_001_002_execute.lto_priv.64+0x88>)
 800ce94:	f7ff fd94 	bl	800c9c0 <test_print>
    test_printn(CH_KERNEL_PATCH);
 800ce98:	4628      	mov	r0, r5
 800ce9a:	f7ff fdb1 	bl	800ca00 <test_printn>
    test_println("");
 800ce9e:	4620      	mov	r0, r4
 800cea0:	f7ff fd9e 	bl	800c9e0 <test_println>
 800cea4:	bd38      	pop	{r3, r4, r5, pc}
 800cea6:	bf00      	nop
 800cea8:	20003e04 	.word	0x20003e04
 800ceac:	08010934 	.word	0x08010934
 800ceb0:	08010968 	.word	0x08010968
 800ceb4:	0800f184 	.word	0x0800f184
 800ceb8:	08010994 	.word	0x08010994
 800cebc:	0800efb4 	.word	0x0800efb4
 800cec0:	080109c0 	.word	0x080109c0
 800cec4:	080109ec 	.word	0x080109ec
 800cec8:	08010a18 	.word	0x08010a18
 800cecc:	00000000 	.word	0x00000000

0800ced0 <rt_test_001_001_execute.lto_priv.63>:
static void rt_test_001_001_execute(void) {
 800ced0:	b510      	push	{r4, lr}
  test_set_step(1);
 800ced2:	2201      	movs	r2, #1
 800ced4:	4b1b      	ldr	r3, [pc, #108]	; (800cf44 <rt_test_001_001_execute.lto_priv.63+0x74>)
 800ced6:	601a      	str	r2, [r3, #0]
    test_print("--- Architecture:                       ");
 800ced8:	481b      	ldr	r0, [pc, #108]	; (800cf48 <rt_test_001_001_execute.lto_priv.63+0x78>)
 800ceda:	f7ff fd71 	bl	800c9c0 <test_print>
    test_println(PORT_ARCHITECTURE_NAME);
 800cede:	481b      	ldr	r0, [pc, #108]	; (800cf4c <rt_test_001_001_execute.lto_priv.63+0x7c>)
 800cee0:	f7ff fd7e 	bl	800c9e0 <test_println>
    test_print("--- Core Variant:                       ");
 800cee4:	481a      	ldr	r0, [pc, #104]	; (800cf50 <rt_test_001_001_execute.lto_priv.63+0x80>)
 800cee6:	f7ff fd6b 	bl	800c9c0 <test_print>
    test_println(PORT_CORE_VARIANT_NAME);
 800ceea:	481a      	ldr	r0, [pc, #104]	; (800cf54 <rt_test_001_001_execute.lto_priv.63+0x84>)
 800ceec:	f7ff fd78 	bl	800c9e0 <test_println>
    test_print("--- Compiler:                           ");
 800cef0:	4819      	ldr	r0, [pc, #100]	; (800cf58 <rt_test_001_001_execute.lto_priv.63+0x88>)
 800cef2:	f7ff fd65 	bl	800c9c0 <test_print>
    test_println(PORT_COMPILER_NAME);
 800cef6:	4819      	ldr	r0, [pc, #100]	; (800cf5c <rt_test_001_001_execute.lto_priv.63+0x8c>)
 800cef8:	f7ff fd72 	bl	800c9e0 <test_println>
    test_print("--- Port Info:                          ");
 800cefc:	4818      	ldr	r0, [pc, #96]	; (800cf60 <rt_test_001_001_execute.lto_priv.63+0x90>)
 800cefe:	f7ff fd5f 	bl	800c9c0 <test_print>
    test_println(PORT_INFO);
 800cf02:	4818      	ldr	r0, [pc, #96]	; (800cf64 <rt_test_001_001_execute.lto_priv.63+0x94>)
 800cf04:	f7ff fd6c 	bl	800c9e0 <test_println>
    test_print("--- Natural alignment:                  ");
 800cf08:	4817      	ldr	r0, [pc, #92]	; (800cf68 <rt_test_001_001_execute.lto_priv.63+0x98>)
 800cf0a:	f7ff fd59 	bl	800c9c0 <test_print>
    test_printn(PORT_NATURAL_ALIGN);
 800cf0e:	2004      	movs	r0, #4
 800cf10:	f7ff fd76 	bl	800ca00 <test_printn>
    test_println("");
 800cf14:	4c15      	ldr	r4, [pc, #84]	; (800cf6c <rt_test_001_001_execute.lto_priv.63+0x9c>)
 800cf16:	4620      	mov	r0, r4
 800cf18:	f7ff fd62 	bl	800c9e0 <test_println>
    test_print("--- Stack alignment:                    ");
 800cf1c:	4814      	ldr	r0, [pc, #80]	; (800cf70 <rt_test_001_001_execute.lto_priv.63+0xa0>)
 800cf1e:	f7ff fd4f 	bl	800c9c0 <test_print>
    test_printn(PORT_STACK_ALIGN);
 800cf22:	2008      	movs	r0, #8
 800cf24:	f7ff fd6c 	bl	800ca00 <test_printn>
    test_println("");
 800cf28:	4620      	mov	r0, r4
 800cf2a:	f7ff fd59 	bl	800c9e0 <test_println>
    test_print("--- Working area alignment:             ");
 800cf2e:	4811      	ldr	r0, [pc, #68]	; (800cf74 <rt_test_001_001_execute.lto_priv.63+0xa4>)
 800cf30:	f7ff fd46 	bl	800c9c0 <test_print>
    test_printn(PORT_WORKING_AREA_ALIGN);
 800cf34:	2008      	movs	r0, #8
 800cf36:	f7ff fd63 	bl	800ca00 <test_printn>
    test_println("");
 800cf3a:	4620      	mov	r0, r4
 800cf3c:	f7ff fd50 	bl	800c9e0 <test_println>
 800cf40:	bd10      	pop	{r4, pc}
 800cf42:	bf00      	nop
 800cf44:	20003e04 	.word	0x20003e04
 800cf48:	08010a44 	.word	0x08010a44
 800cf4c:	0800eff8 	.word	0x0800eff8
 800cf50:	08010a70 	.word	0x08010a70
 800cf54:	0800f018 	.word	0x0800f018
 800cf58:	08010a9c 	.word	0x08010a9c
 800cf5c:	0800efd0 	.word	0x0800efd0
 800cf60:	08010ac8 	.word	0x08010ac8
 800cf64:	0800f038 	.word	0x0800f038
 800cf68:	08010af4 	.word	0x08010af4
 800cf6c:	0800f184 	.word	0x0800f184
 800cf70:	08010b20 	.word	0x08010b20
 800cf74:	08010b4c 	.word	0x08010b4c
	...

0800cf80 <test_execute>:
 * @retval false        if no errors occurred.
 * @retval true         if one or more tests failed.
 *
 * @api
 */
msg_t test_execute(BaseSequentialStream *stream, const testsuite_t *tsp) {
 800cf80:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800cf84:	460d      	mov	r5, r1
  int tseq, tcase;

  test_chp = stream;
 800cf86:	4b57      	ldr	r3, [pc, #348]	; (800d0e4 <test_execute+0x164>)
 800cf88:	6018      	str	r0, [r3, #0]
  test_println("");
 800cf8a:	4857      	ldr	r0, [pc, #348]	; (800d0e8 <test_execute+0x168>)
 800cf8c:	f7ff fd28 	bl	800c9e0 <test_println>
  if (tsp->name != NULL) {
 800cf90:	682b      	ldr	r3, [r5, #0]
 800cf92:	b133      	cbz	r3, 800cfa2 <test_execute+0x22>
    test_print("*** ");
 800cf94:	4855      	ldr	r0, [pc, #340]	; (800d0ec <test_execute+0x16c>)
 800cf96:	f7ff fd13 	bl	800c9c0 <test_print>
    test_println(tsp->name);
 800cf9a:	6828      	ldr	r0, [r5, #0]
 800cf9c:	f7ff fd20 	bl	800c9e0 <test_println>
 800cfa0:	e002      	b.n	800cfa8 <test_execute+0x28>
  }
  else {
    test_println("*** Test Suite");
 800cfa2:	4853      	ldr	r0, [pc, #332]	; (800d0f0 <test_execute+0x170>)
 800cfa4:	f7ff fd1c 	bl	800c9e0 <test_println>
  }
  test_println("***");
 800cfa8:	4852      	ldr	r0, [pc, #328]	; (800d0f4 <test_execute+0x174>)
 800cfaa:	f7ff fd19 	bl	800c9e0 <test_println>
  test_print("*** Compiled:     ");
 800cfae:	4852      	ldr	r0, [pc, #328]	; (800d0f8 <test_execute+0x178>)
 800cfb0:	f7ff fd06 	bl	800c9c0 <test_print>
  test_println(__DATE__ " - " __TIME__);
 800cfb4:	4851      	ldr	r0, [pc, #324]	; (800d0fc <test_execute+0x17c>)
 800cfb6:	f7ff fd13 	bl	800c9e0 <test_println>
#if defined(PLATFORM_NAME)
  test_print("*** Platform:     ");
 800cfba:	4851      	ldr	r0, [pc, #324]	; (800d100 <test_execute+0x180>)
 800cfbc:	f7ff fd00 	bl	800c9c0 <test_print>
  test_println(PLATFORM_NAME);
 800cfc0:	4850      	ldr	r0, [pc, #320]	; (800d104 <test_execute+0x184>)
 800cfc2:	f7ff fd0d 	bl	800c9e0 <test_println>
#endif
#if defined(BOARD_NAME)
  test_print("*** Test Board:   ");
 800cfc6:	4850      	ldr	r0, [pc, #320]	; (800d108 <test_execute+0x188>)
 800cfc8:	f7ff fcfa 	bl	800c9c0 <test_print>
  test_println(BOARD_NAME);
 800cfcc:	484f      	ldr	r0, [pc, #316]	; (800d10c <test_execute+0x18c>)
 800cfce:	f7ff fd07 	bl	800c9e0 <test_println>
#endif
#if defined(TEST_REPORT_HOOK_HEADER)
  TEST_REPORT_HOOK_HEADER
#endif
  test_println("");
 800cfd2:	4845      	ldr	r0, [pc, #276]	; (800d0e8 <test_execute+0x168>)
 800cfd4:	f7ff fd04 	bl	800c9e0 <test_println>

  test_global_fail = false;
 800cfd8:	f04f 0900 	mov.w	r9, #0
 800cfdc:	4b4c      	ldr	r3, [pc, #304]	; (800d110 <test_execute+0x190>)
 800cfde:	f883 9000 	strb.w	r9, [r3]
 800cfe2:	e062      	b.n	800d0aa <test_execute+0x12a>
  tseq = 0;
  while (tsp->sequences[tseq] != NULL) {
#if TEST_SHOW_SEQUENCES == TRUE
    print_fat_line();
 800cfe4:	f7fb fc4c 	bl	8008880 <print_fat_line.lto_priv.21>
    test_print("=== Test Sequence ");
 800cfe8:	484a      	ldr	r0, [pc, #296]	; (800d114 <test_execute+0x194>)
 800cfea:	f7ff fce9 	bl	800c9c0 <test_print>
    test_printn(tseq + 1);
 800cfee:	f109 0901 	add.w	r9, r9, #1
 800cff2:	46c8      	mov	r8, r9
 800cff4:	4648      	mov	r0, r9
 800cff6:	f7ff fd03 	bl	800ca00 <test_printn>
    test_print(" (");
 800cffa:	4847      	ldr	r0, [pc, #284]	; (800d118 <test_execute+0x198>)
 800cffc:	f7ff fce0 	bl	800c9c0 <test_print>
    test_print(tsp->sequences[tseq]->name);
 800d000:	686b      	ldr	r3, [r5, #4]
 800d002:	599b      	ldr	r3, [r3, r6]
 800d004:	6818      	ldr	r0, [r3, #0]
 800d006:	f7ff fcdb 	bl	800c9c0 <test_print>
    test_println(")");
 800d00a:	4844      	ldr	r0, [pc, #272]	; (800d11c <test_execute+0x19c>)
 800d00c:	f7ff fce8 	bl	800c9e0 <test_println>
#endif
    tcase = 0;
 800d010:	2400      	movs	r4, #0
 800d012:	e042      	b.n	800d09a <test_execute+0x11a>
    while (tsp->sequences[tseq]->cases[tcase] != NULL) {
      print_line();
 800d014:	f7fb fc4c 	bl	80088b0 <print_line.lto_priv.18>
      test_print("--- Test Case ");
 800d018:	4841      	ldr	r0, [pc, #260]	; (800d120 <test_execute+0x1a0>)
 800d01a:	f7ff fcd1 	bl	800c9c0 <test_print>
      test_printn(tseq + 1);
 800d01e:	4640      	mov	r0, r8
 800d020:	f7ff fcee 	bl	800ca00 <test_printn>
      test_print(".");
 800d024:	483f      	ldr	r0, [pc, #252]	; (800d124 <test_execute+0x1a4>)
 800d026:	f7ff fccb 	bl	800c9c0 <test_print>
      test_printn(tcase + 1);
 800d02a:	3401      	adds	r4, #1
 800d02c:	4620      	mov	r0, r4
 800d02e:	f7ff fce7 	bl	800ca00 <test_printn>
      test_print(" (");
 800d032:	4839      	ldr	r0, [pc, #228]	; (800d118 <test_execute+0x198>)
 800d034:	f7ff fcc4 	bl	800c9c0 <test_print>
      test_print(tsp->sequences[tseq]->cases[tcase]->name);
 800d038:	686b      	ldr	r3, [r5, #4]
 800d03a:	599b      	ldr	r3, [r3, r6]
 800d03c:	685b      	ldr	r3, [r3, #4]
 800d03e:	59db      	ldr	r3, [r3, r7]
 800d040:	6818      	ldr	r0, [r3, #0]
 800d042:	f7ff fcbd 	bl	800c9c0 <test_print>
      test_println(")");
 800d046:	4835      	ldr	r0, [pc, #212]	; (800d11c <test_execute+0x19c>)
 800d048:	f7ff fcca 	bl	800c9e0 <test_println>
  chThdSleep(delay);
 800d04c:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 800d050:	f7fe fdfe 	bl	800bc50 <chThdSleep>
#if TEST_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(tsp->sequences[tseq]->cases[tcase]);
 800d054:	686b      	ldr	r3, [r5, #4]
 800d056:	599b      	ldr	r3, [r3, r6]
 800d058:	685b      	ldr	r3, [r3, #4]
 800d05a:	59d8      	ldr	r0, [r3, r7]
 800d05c:	f7fb fc60 	bl	8008920 <execute_test.lto_priv.20>
      if (test_local_fail) {
 800d060:	4b31      	ldr	r3, [pc, #196]	; (800d128 <test_execute+0x1a8>)
 800d062:	781b      	ldrb	r3, [r3, #0]
 800d064:	b1b3      	cbz	r3, 800d094 <test_execute+0x114>
        test_print("--- Result: FAILURE (#");
 800d066:	4831      	ldr	r0, [pc, #196]	; (800d12c <test_execute+0x1ac>)
 800d068:	f7ff fcaa 	bl	800c9c0 <test_print>
        test_printn(test_step);
 800d06c:	4b30      	ldr	r3, [pc, #192]	; (800d130 <test_execute+0x1b0>)
 800d06e:	6818      	ldr	r0, [r3, #0]
 800d070:	f7ff fcc6 	bl	800ca00 <test_printn>
        test_print(" [");
 800d074:	482f      	ldr	r0, [pc, #188]	; (800d134 <test_execute+0x1b4>)
 800d076:	f7ff fca3 	bl	800c9c0 <test_print>
        print_tokens();
 800d07a:	f7fb fc31 	bl	80088e0 <print_tokens.lto_priv.19>
        test_print("] \"");
 800d07e:	482e      	ldr	r0, [pc, #184]	; (800d138 <test_execute+0x1b8>)
 800d080:	f7ff fc9e 	bl	800c9c0 <test_print>
        test_print(test_failure_message);
 800d084:	4b2d      	ldr	r3, [pc, #180]	; (800d13c <test_execute+0x1bc>)
 800d086:	6818      	ldr	r0, [r3, #0]
 800d088:	f7ff fc9a 	bl	800c9c0 <test_print>
        test_println("\")");
 800d08c:	482c      	ldr	r0, [pc, #176]	; (800d140 <test_execute+0x1c0>)
 800d08e:	f7ff fca7 	bl	800c9e0 <test_println>
 800d092:	e002      	b.n	800d09a <test_execute+0x11a>
      }
      else {
        test_println("--- Result: SUCCESS");
 800d094:	482b      	ldr	r0, [pc, #172]	; (800d144 <test_execute+0x1c4>)
 800d096:	f7ff fca3 	bl	800c9e0 <test_println>
    while (tsp->sequences[tseq]->cases[tcase] != NULL) {
 800d09a:	686b      	ldr	r3, [r5, #4]
 800d09c:	599b      	ldr	r3, [r3, r6]
 800d09e:	685b      	ldr	r3, [r3, #4]
 800d0a0:	00a7      	lsls	r7, r4, #2
 800d0a2:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 800d0a6:	2b00      	cmp	r3, #0
 800d0a8:	d1b4      	bne.n	800d014 <test_execute+0x94>
  while (tsp->sequences[tseq] != NULL) {
 800d0aa:	686b      	ldr	r3, [r5, #4]
 800d0ac:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800d0b0:	f853 3029 	ldr.w	r3, [r3, r9, lsl #2]
 800d0b4:	2b00      	cmp	r3, #0
 800d0b6:	d195      	bne.n	800cfe4 <test_execute+0x64>
      }
      tcase++;
    }
    tseq++;
  }
  print_line();
 800d0b8:	f7fb fbfa 	bl	80088b0 <print_line.lto_priv.18>
  test_println("");
 800d0bc:	480a      	ldr	r0, [pc, #40]	; (800d0e8 <test_execute+0x168>)
 800d0be:	f7ff fc8f 	bl	800c9e0 <test_println>
  test_print("Final result: ");
 800d0c2:	4821      	ldr	r0, [pc, #132]	; (800d148 <test_execute+0x1c8>)
 800d0c4:	f7ff fc7c 	bl	800c9c0 <test_print>
  if (test_global_fail)
 800d0c8:	4b11      	ldr	r3, [pc, #68]	; (800d110 <test_execute+0x190>)
 800d0ca:	781b      	ldrb	r3, [r3, #0]
 800d0cc:	b11b      	cbz	r3, 800d0d6 <test_execute+0x156>
    test_println("FAILURE");
 800d0ce:	481f      	ldr	r0, [pc, #124]	; (800d14c <test_execute+0x1cc>)
 800d0d0:	f7ff fc86 	bl	800c9e0 <test_println>
 800d0d4:	e002      	b.n	800d0dc <test_execute+0x15c>
  else
    test_println("SUCCESS");
 800d0d6:	481e      	ldr	r0, [pc, #120]	; (800d150 <test_execute+0x1d0>)
 800d0d8:	f7ff fc82 	bl	800c9e0 <test_println>
#if defined(TEST_REPORT_HOOK_END)
  TEST_REPORT_HOOK_END
#endif

  return (msg_t)test_global_fail;
}
 800d0dc:	4b0c      	ldr	r3, [pc, #48]	; (800d110 <test_execute+0x190>)
 800d0de:	7818      	ldrb	r0, [r3, #0]
 800d0e0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800d0e4:	20003e08 	.word	0x20003e08
 800d0e8:	0800f184 	.word	0x0800f184
 800d0ec:	08010b78 	.word	0x08010b78
 800d0f0:	08010b80 	.word	0x08010b80
 800d0f4:	08010b90 	.word	0x08010b90
 800d0f8:	08010b94 	.word	0x08010b94
 800d0fc:	08010ba8 	.word	0x08010ba8
 800d100:	08010bc0 	.word	0x08010bc0
 800d104:	0800f064 	.word	0x0800f064
 800d108:	08010bd4 	.word	0x08010bd4
 800d10c:	0800f0a4 	.word	0x0800f0a4
 800d110:	20003e10 	.word	0x20003e10
 800d114:	08010be8 	.word	0x08010be8
 800d118:	08010bfc 	.word	0x08010bfc
 800d11c:	08010c00 	.word	0x08010c00
 800d120:	08010c04 	.word	0x08010c04
 800d124:	08010c14 	.word	0x08010c14
 800d128:	20003e24 	.word	0x20003e24
 800d12c:	08010c18 	.word	0x08010c18
 800d130:	20003e04 	.word	0x20003e04
 800d134:	08010c30 	.word	0x08010c30
 800d138:	08010c34 	.word	0x08010c34
 800d13c:	20003e0c 	.word	0x20003e0c
 800d140:	08010c38 	.word	0x08010c38
 800d144:	08010c3c 	.word	0x08010c3c
 800d148:	08010c50 	.word	0x08010c50
 800d14c:	08010c60 	.word	0x08010c60
 800d150:	08010c48 	.word	0x08010c48
	...

0800d160 <_test_assert_sequence>:
bool _test_assert_sequence(char *expected, const char *msg) {
 800d160:	b538      	push	{r3, r4, r5, lr}
  char *cp = test_tokens_buffer;
 800d162:	4b0e      	ldr	r3, [pc, #56]	; (800d19c <_test_assert_sequence+0x3c>)
 800d164:	e00b      	b.n	800d17e <_test_assert_sequence+0x1e>
    if (*cp++ != *expected++)
 800d166:	1c5d      	adds	r5, r3, #1
 800d168:	781a      	ldrb	r2, [r3, #0]
 800d16a:	1c44      	adds	r4, r0, #1
 800d16c:	7803      	ldrb	r3, [r0, #0]
 800d16e:	429a      	cmp	r2, r3
 800d170:	d003      	beq.n	800d17a <_test_assert_sequence+0x1a>
     return _test_fail(msg);
 800d172:	4608      	mov	r0, r1
 800d174:	f7fb fb74 	bl	8008860 <_test_fail>
 800d178:	bd38      	pop	{r3, r4, r5, pc}
    if (*cp++ != *expected++)
 800d17a:	462b      	mov	r3, r5
 800d17c:	4620      	mov	r0, r4
  while (cp < test_tokp) {
 800d17e:	4a08      	ldr	r2, [pc, #32]	; (800d1a0 <_test_assert_sequence+0x40>)
 800d180:	6812      	ldr	r2, [r2, #0]
 800d182:	4293      	cmp	r3, r2
 800d184:	d3ef      	bcc.n	800d166 <_test_assert_sequence+0x6>
  if (*expected)
 800d186:	7803      	ldrb	r3, [r0, #0]
 800d188:	b11b      	cbz	r3, 800d192 <_test_assert_sequence+0x32>
    return _test_fail(msg);
 800d18a:	4608      	mov	r0, r1
 800d18c:	f7fb fb68 	bl	8008860 <_test_fail>
 800d190:	bd38      	pop	{r3, r4, r5, pc}
  clear_tokens();
 800d192:	f7fb fbbd 	bl	8008910 <clear_tokens.lto_priv.22>
  return false;
 800d196:	2000      	movs	r0, #0
}
 800d198:	bd38      	pop	{r3, r4, r5, pc}
 800d19a:	bf00      	nop
 800d19c:	20003e14 	.word	0x20003e14
 800d1a0:	20003e28 	.word	0x20003e28
	...

0800d1b0 <_test_assert>:
  if (!condition)
 800d1b0:	b920      	cbnz	r0, 800d1bc <_test_assert+0xc>
bool _test_assert(bool condition, const char *msg) {
 800d1b2:	b508      	push	{r3, lr}
 800d1b4:	4608      	mov	r0, r1
    return _test_fail(msg);
 800d1b6:	f7fb fb53 	bl	8008860 <_test_fail>
 800d1ba:	bd08      	pop	{r3, pc}
  return false;
 800d1bc:	2000      	movs	r0, #0
 800d1be:	4770      	bx	lr

0800d1c0 <rt_test_002_002_execute.lto_priv.67>:
static void rt_test_002_002_execute(void) {
 800d1c0:	b510      	push	{r4, lr}
 800d1c2:	b086      	sub	sp, #24
  test_set_step(1);
 800d1c4:	4c2e      	ldr	r4, [pc, #184]	; (800d280 <rt_test_002_002_execute.lto_priv.67+0xc0>)
 800d1c6:	2301      	movs	r3, #1
 800d1c8:	6023      	str	r3, [r4, #0]
    sts = chSysGetStatusAndLockX();
 800d1ca:	f7f9 fc21 	bl	8006a10 <chSysGetStatusAndLockX>
    chSysRestoreStatusX(sts);
 800d1ce:	f7f9 fc07 	bl	80069e0 <chSysRestoreStatusX>
  test_set_step(2);
 800d1d2:	2302      	movs	r3, #2
 800d1d4:	6023      	str	r3, [r4, #0]
 800d1d6:	2320      	movs	r3, #32
 800d1d8:	f383 8811 	msr	BASEPRI, r3
    sts = chSysGetStatusAndLockX();
 800d1dc:	f7f9 fc18 	bl	8006a10 <chSysGetStatusAndLockX>
    chSysRestoreStatusX(sts);
 800d1e0:	f7f9 fbfe 	bl	80069e0 <chSysRestoreStatusX>
 800d1e4:	2300      	movs	r3, #0
 800d1e6:	f383 8811 	msr	BASEPRI, r3
  test_set_step(3);
 800d1ea:	2303      	movs	r3, #3
 800d1ec:	6023      	str	r3, [r4, #0]
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800d1ee:	f3ef 8311 	mrs	r3, BASEPRI
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {

  if (port_irq_enabled(port_get_irq_status())) {
 800d1f2:	b913      	cbnz	r3, 800d1fa <rt_test_002_002_execute.lto_priv.67+0x3a>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800d1f4:	2320      	movs	r3, #32
 800d1f6:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800d1fa:	f3ef 8311 	mrs	r3, BASEPRI
 800d1fe:	b913      	cbnz	r3, 800d206 <rt_test_002_002_execute.lto_priv.67+0x46>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800d200:	2320      	movs	r3, #32
 800d202:	f383 8811 	msr	BASEPRI, r3
 800d206:	2300      	movs	r3, #0
 800d208:	f383 8811 	msr	BASEPRI, r3
  test_set_step(4);
 800d20c:	2204      	movs	r2, #4
 800d20e:	4b1c      	ldr	r3, [pc, #112]	; (800d280 <rt_test_002_002_execute.lto_priv.67+0xc0>)
 800d210:	601a      	str	r2, [r3, #0]
 800d212:	2320      	movs	r3, #32
 800d214:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800d218:	f3ef 8311 	mrs	r3, BASEPRI
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {

  if (!port_irq_enabled(port_get_irq_status())) {
 800d21c:	b113      	cbz	r3, 800d224 <rt_test_002_002_execute.lto_priv.67+0x64>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800d21e:	2300      	movs	r3, #0
 800d220:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800d224:	f3ef 8311 	mrs	r3, BASEPRI
 800d228:	b113      	cbz	r3, 800d230 <rt_test_002_002_execute.lto_priv.67+0x70>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800d22a:	2300      	movs	r3, #0
 800d22c:	f383 8811 	msr	BASEPRI, r3
  test_set_step(5);
 800d230:	2205      	movs	r2, #5
 800d232:	4b13      	ldr	r3, [pc, #76]	; (800d280 <rt_test_002_002_execute.lto_priv.67+0xc0>)
 800d234:	601a      	str	r2, [r3, #0]
  vtp->func = NULL;
 800d236:	2300      	movs	r3, #0
 800d238:	9304      	str	r3, [sp, #16]
 800d23a:	2320      	movs	r3, #32
 800d23c:	f383 8811 	msr	BASEPRI, r3
  return (bool)(vtp->func != NULL);
 800d240:	9b04      	ldr	r3, [sp, #16]
  if (chVTIsArmedI(vtp)) {
 800d242:	b113      	cbz	r3, 800d24a <rt_test_002_002_execute.lto_priv.67+0x8a>
    chVTDoResetI(vtp);
 800d244:	a801      	add	r0, sp, #4
 800d246:	f7f9 fb33 	bl	80068b0 <chVTDoResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
 800d24a:	2300      	movs	r3, #0
 800d24c:	4a0d      	ldr	r2, [pc, #52]	; (800d284 <rt_test_002_002_execute.lto_priv.67+0xc4>)
 800d24e:	2101      	movs	r1, #1
 800d250:	a801      	add	r0, sp, #4
 800d252:	f7f9 fb6d 	bl	8006930 <chVTDoSetI>
 800d256:	2400      	movs	r4, #0
 800d258:	f384 8811 	msr	BASEPRI, r4
    chThdSleep(10);
 800d25c:	200a      	movs	r0, #10
 800d25e:	f7fe fcf7 	bl	800bc50 <chThdSleep>
 800d262:	2320      	movs	r3, #32
 800d264:	f383 8811 	msr	BASEPRI, r3
  return (bool)(vtp->func != NULL);
 800d268:	9804      	ldr	r0, [sp, #16]
 800d26a:	f384 8811 	msr	BASEPRI, r4
    test_assert(chVTIsArmed(&vt) == false, "timer still armed");
 800d26e:	4906      	ldr	r1, [pc, #24]	; (800d288 <rt_test_002_002_execute.lto_priv.67+0xc8>)
 800d270:	fab0 f080 	clz	r0, r0
 800d274:	0940      	lsrs	r0, r0, #5
 800d276:	f7ff ff9b 	bl	800d1b0 <_test_assert>
}
 800d27a:	b006      	add	sp, #24
 800d27c:	bd10      	pop	{r4, pc}
 800d27e:	bf00      	nop
 800d280:	20003e04 	.word	0x20003e04
 800d284:	0800c901 	.word	0x0800c901
 800d288:	08010c68 	.word	0x08010c68
 800d28c:	00000000 	.word	0x00000000

0800d290 <rt_test_002_001_execute.lto_priv.66>:
static void rt_test_002_001_execute(void) {
 800d290:	b508      	push	{r3, lr}
  test_set_step(1);
 800d292:	2001      	movs	r0, #1
 800d294:	4b24      	ldr	r3, [pc, #144]	; (800d328 <rt_test_002_001_execute.lto_priv.66+0x98>)
 800d296:	6018      	str	r0, [r3, #0]
 800d298:	2320      	movs	r3, #32
 800d29a:	f383 8811 	msr	BASEPRI, r3
    result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 800d29e:	f7f9 fbc7 	bl	8006a30 <chSysIntegrityCheckI>
 800d2a2:	2300      	movs	r3, #0
 800d2a4:	f383 8811 	msr	BASEPRI, r3
    test_assert(result == false, "ready list check failed");
 800d2a8:	f080 0001 	eor.w	r0, r0, #1
 800d2ac:	491f      	ldr	r1, [pc, #124]	; (800d32c <rt_test_002_001_execute.lto_priv.66+0x9c>)
 800d2ae:	b2c0      	uxtb	r0, r0
 800d2b0:	f7ff ff7e 	bl	800d1b0 <_test_assert>
 800d2b4:	2800      	cmp	r0, #0
 800d2b6:	d136      	bne.n	800d326 <rt_test_002_001_execute.lto_priv.66+0x96>
  test_set_step(2);
 800d2b8:	2002      	movs	r0, #2
 800d2ba:	4b1b      	ldr	r3, [pc, #108]	; (800d328 <rt_test_002_001_execute.lto_priv.66+0x98>)
 800d2bc:	6018      	str	r0, [r3, #0]
 800d2be:	2320      	movs	r3, #32
 800d2c0:	f383 8811 	msr	BASEPRI, r3
    result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 800d2c4:	f7f9 fbb4 	bl	8006a30 <chSysIntegrityCheckI>
 800d2c8:	2300      	movs	r3, #0
 800d2ca:	f383 8811 	msr	BASEPRI, r3
    test_assert(result == false, "virtual timers list check failed");
 800d2ce:	f080 0001 	eor.w	r0, r0, #1
 800d2d2:	4917      	ldr	r1, [pc, #92]	; (800d330 <rt_test_002_001_execute.lto_priv.66+0xa0>)
 800d2d4:	b2c0      	uxtb	r0, r0
 800d2d6:	f7ff ff6b 	bl	800d1b0 <_test_assert>
 800d2da:	bb20      	cbnz	r0, 800d326 <rt_test_002_001_execute.lto_priv.66+0x96>
  test_set_step(3);
 800d2dc:	2203      	movs	r2, #3
 800d2de:	4b12      	ldr	r3, [pc, #72]	; (800d328 <rt_test_002_001_execute.lto_priv.66+0x98>)
 800d2e0:	601a      	str	r2, [r3, #0]
 800d2e2:	2320      	movs	r3, #32
 800d2e4:	f383 8811 	msr	BASEPRI, r3
    result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 800d2e8:	2004      	movs	r0, #4
 800d2ea:	f7f9 fba1 	bl	8006a30 <chSysIntegrityCheckI>
 800d2ee:	2300      	movs	r3, #0
 800d2f0:	f383 8811 	msr	BASEPRI, r3
    test_assert(result == false, "registry list check failed");
 800d2f4:	f080 0001 	eor.w	r0, r0, #1
 800d2f8:	490e      	ldr	r1, [pc, #56]	; (800d334 <rt_test_002_001_execute.lto_priv.66+0xa4>)
 800d2fa:	b2c0      	uxtb	r0, r0
 800d2fc:	f7ff ff58 	bl	800d1b0 <_test_assert>
 800d300:	b988      	cbnz	r0, 800d326 <rt_test_002_001_execute.lto_priv.66+0x96>
  test_set_step(4);
 800d302:	2204      	movs	r2, #4
 800d304:	4b08      	ldr	r3, [pc, #32]	; (800d328 <rt_test_002_001_execute.lto_priv.66+0x98>)
 800d306:	601a      	str	r2, [r3, #0]
 800d308:	2320      	movs	r3, #32
 800d30a:	f383 8811 	msr	BASEPRI, r3
    result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 800d30e:	2008      	movs	r0, #8
 800d310:	f7f9 fb8e 	bl	8006a30 <chSysIntegrityCheckI>
 800d314:	2300      	movs	r3, #0
 800d316:	f383 8811 	msr	BASEPRI, r3
    test_assert(result == false, "port layer check failed");
 800d31a:	f080 0001 	eor.w	r0, r0, #1
 800d31e:	4906      	ldr	r1, [pc, #24]	; (800d338 <rt_test_002_001_execute.lto_priv.66+0xa8>)
 800d320:	b2c0      	uxtb	r0, r0
 800d322:	f7ff ff45 	bl	800d1b0 <_test_assert>
 800d326:	bd08      	pop	{r3, pc}
 800d328:	20003e04 	.word	0x20003e04
 800d32c:	08010c7c 	.word	0x08010c7c
 800d330:	08010c94 	.word	0x08010c94
 800d334:	08010cb8 	.word	0x08010cb8
 800d338:	08010cd4 	.word	0x08010cd4
 800d33c:	00000000 	.word	0x00000000

0800d340 <_test_assert_time_window>:
                              const char *msg) {
 800d340:	b508      	push	{r3, lr}
 800d342:	4b06      	ldr	r3, [pc, #24]	; (800d35c <_test_assert_time_window+0x1c>)
 800d344:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  return (bool)((time - start) < (end - start));
 800d346:	1a1b      	subs	r3, r3, r0
 800d348:	1a08      	subs	r0, r1, r0
  return _test_assert(osalTimeIsInRangeX(osalOsGetSystemTimeX(), start, end),
 800d34a:	4611      	mov	r1, r2
 800d34c:	4283      	cmp	r3, r0
 800d34e:	bf2c      	ite	cs
 800d350:	2000      	movcs	r0, #0
 800d352:	2001      	movcc	r0, #1
 800d354:	f7ff ff2c 	bl	800d1b0 <_test_assert>
}
 800d358:	bd08      	pop	{r3, pc}
 800d35a:	bf00      	nop
 800d35c:	40000c00 	.word	0x40000c00

0800d360 <_ZdlPv>:
 800d360:	f7f3 bf78 	b.w	8001254 <free>

0800d364 <_Znwj>:
 800d364:	b510      	push	{r4, lr}
 800d366:	2800      	cmp	r0, #0
 800d368:	bf14      	ite	ne
 800d36a:	4604      	movne	r4, r0
 800d36c:	2401      	moveq	r4, #1
 800d36e:	4620      	mov	r0, r4
 800d370:	f7f3 ff68 	bl	8001244 <malloc>
 800d374:	b100      	cbz	r0, 800d378 <_Znwj+0x14>
 800d376:	bd10      	pop	{r4, pc}
 800d378:	f000 f8aa 	bl	800d4d0 <_ZSt15get_new_handlerv>
 800d37c:	b108      	cbz	r0, 800d382 <_Znwj+0x1e>
 800d37e:	4780      	blx	r0
 800d380:	e7f5      	b.n	800d36e <_Znwj+0xa>
 800d382:	2004      	movs	r0, #4
 800d384:	f000 f9a4 	bl	800d6d0 <__cxa_allocate_exception>
 800d388:	4b02      	ldr	r3, [pc, #8]	; (800d394 <_Znwj+0x30>)
 800d38a:	6003      	str	r3, [r0, #0]
 800d38c:	4a02      	ldr	r2, [pc, #8]	; (800d398 <_Znwj+0x34>)
 800d38e:	4903      	ldr	r1, [pc, #12]	; (800d39c <_Znwj+0x38>)
 800d390:	f000 f828 	bl	800d3e4 <__cxa_throw>
 800d394:	08010cf4 	.word	0x08010cf4
 800d398:	0800de31 	.word	0x0800de31
 800d39c:	08010d00 	.word	0x08010d00

0800d3a0 <_ZL23__gxx_exception_cleanup19_Unwind_Reason_CodeP21_Unwind_Control_Block>:
 800d3a0:	2801      	cmp	r0, #1
 800d3a2:	b510      	push	{r4, lr}
 800d3a4:	d81a      	bhi.n	800d3dc <_ZL23__gxx_exception_cleanup19_Unwind_Reason_CodeP21_Unwind_Control_Block+0x3c>
 800d3a6:	f3bf 8f5f 	dmb	sy
 800d3aa:	f1a1 0328 	sub.w	r3, r1, #40	; 0x28
 800d3ae:	e853 2f00 	ldrex	r2, [r3]
 800d3b2:	3a01      	subs	r2, #1
 800d3b4:	e843 2000 	strex	r0, r2, [r3]
 800d3b8:	2800      	cmp	r0, #0
 800d3ba:	d1f8      	bne.n	800d3ae <_ZL23__gxx_exception_cleanup19_Unwind_Reason_CodeP21_Unwind_Control_Block+0xe>
 800d3bc:	f3bf 8f5f 	dmb	sy
 800d3c0:	b95a      	cbnz	r2, 800d3da <_ZL23__gxx_exception_cleanup19_Unwind_Reason_CodeP21_Unwind_Control_Block+0x3a>
 800d3c2:	f851 3c1c 	ldr.w	r3, [r1, #-28]
 800d3c6:	f101 0458 	add.w	r4, r1, #88	; 0x58
 800d3ca:	b10b      	cbz	r3, 800d3d0 <_ZL23__gxx_exception_cleanup19_Unwind_Reason_CodeP21_Unwind_Control_Block+0x30>
 800d3cc:	4620      	mov	r0, r4
 800d3ce:	4798      	blx	r3
 800d3d0:	4620      	mov	r0, r4
 800d3d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800d3d6:	f000 b993 	b.w	800d700 <__cxa_free_exception>
 800d3da:	bd10      	pop	{r4, pc}
 800d3dc:	f851 0c14 	ldr.w	r0, [r1, #-20]
 800d3e0:	f000 f9ba 	bl	800d758 <_ZN10__cxxabiv111__terminateEPFvvE>

0800d3e4 <__cxa_throw>:
 800d3e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d3e6:	4604      	mov	r4, r0
 800d3e8:	460f      	mov	r7, r1
 800d3ea:	4616      	mov	r6, r2
 800d3ec:	f000 f9b0 	bl	800d750 <__cxa_get_globals>
 800d3f0:	6843      	ldr	r3, [r0, #4]
 800d3f2:	2501      	movs	r5, #1
 800d3f4:	442b      	add	r3, r5
 800d3f6:	6043      	str	r3, [r0, #4]
 800d3f8:	f844 7c78 	str.w	r7, [r4, #-120]
 800d3fc:	f844 6c74 	str.w	r6, [r4, #-116]
 800d400:	f844 5c80 	str.w	r5, [r4, #-128]
 800d404:	f000 f9dc 	bl	800d7c0 <_ZSt14get_unexpectedv>
 800d408:	f844 0c70 	str.w	r0, [r4, #-112]
 800d40c:	f000 f9d0 	bl	800d7b0 <_ZSt13get_terminatev>
 800d410:	2347      	movs	r3, #71	; 0x47
 800d412:	2243      	movs	r2, #67	; 0x43
 800d414:	f04f 0e4e 	mov.w	lr, #78	; 0x4e
 800d418:	4910      	ldr	r1, [pc, #64]	; (800d45c <__cxa_throw+0x78>)
 800d41a:	f804 3c58 	strb.w	r3, [r4, #-88]
 800d41e:	f1a4 0558 	sub.w	r5, r4, #88	; 0x58
 800d422:	232b      	movs	r3, #43	; 0x2b
 800d424:	2755      	movs	r7, #85	; 0x55
 800d426:	2600      	movs	r6, #0
 800d428:	f844 0c6c 	str.w	r0, [r4, #-108]
 800d42c:	f804 ec57 	strb.w	lr, [r4, #-87]
 800d430:	f844 1c50 	str.w	r1, [r4, #-80]
 800d434:	f804 2c55 	strb.w	r2, [r4, #-85]
 800d438:	f804 2c54 	strb.w	r2, [r4, #-84]
 800d43c:	f804 3c53 	strb.w	r3, [r4, #-83]
 800d440:	f804 3c52 	strb.w	r3, [r4, #-82]
 800d444:	f804 7c56 	strb.w	r7, [r4, #-86]
 800d448:	f804 6c51 	strb.w	r6, [r4, #-81]
 800d44c:	4628      	mov	r0, r5
 800d44e:	f7f3 fced 	bl	8000e2c <_Unwind_RaiseException>
 800d452:	4628      	mov	r0, r5
 800d454:	f000 f844 	bl	800d4e0 <__cxa_begin_catch>
 800d458:	f000 f992 	bl	800d780 <_ZSt9terminatev>
 800d45c:	0800d3a1 	.word	0x0800d3a1

0800d460 <__cxa_rethrow>:
 800d460:	b510      	push	{r4, lr}
 800d462:	f000 f975 	bl	800d750 <__cxa_get_globals>
 800d466:	6842      	ldr	r2, [r0, #4]
 800d468:	6803      	ldr	r3, [r0, #0]
 800d46a:	3201      	adds	r2, #1
 800d46c:	6042      	str	r2, [r0, #4]
 800d46e:	b16b      	cbz	r3, 800d48c <__cxa_rethrow+0x2c>
 800d470:	f893 2020 	ldrb.w	r2, [r3, #32]
 800d474:	2a47      	cmp	r2, #71	; 0x47
 800d476:	d00b      	beq.n	800d490 <__cxa_rethrow+0x30>
 800d478:	2200      	movs	r2, #0
 800d47a:	6002      	str	r2, [r0, #0]
 800d47c:	f103 0420 	add.w	r4, r3, #32
 800d480:	4620      	mov	r0, r4
 800d482:	f7f3 fcf7 	bl	8000e74 <_Unwind_Resume_or_Rethrow>
 800d486:	4620      	mov	r0, r4
 800d488:	f000 f82a 	bl	800d4e0 <__cxa_begin_catch>
 800d48c:	f000 f978 	bl	800d780 <_ZSt9terminatev>
 800d490:	f893 2021 	ldrb.w	r2, [r3, #33]	; 0x21
 800d494:	2a4e      	cmp	r2, #78	; 0x4e
 800d496:	d1ef      	bne.n	800d478 <__cxa_rethrow+0x18>
 800d498:	f893 2022 	ldrb.w	r2, [r3, #34]	; 0x22
 800d49c:	2a55      	cmp	r2, #85	; 0x55
 800d49e:	d1eb      	bne.n	800d478 <__cxa_rethrow+0x18>
 800d4a0:	f893 2023 	ldrb.w	r2, [r3, #35]	; 0x23
 800d4a4:	2a43      	cmp	r2, #67	; 0x43
 800d4a6:	d1e7      	bne.n	800d478 <__cxa_rethrow+0x18>
 800d4a8:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
 800d4ac:	2a43      	cmp	r2, #67	; 0x43
 800d4ae:	d1e3      	bne.n	800d478 <__cxa_rethrow+0x18>
 800d4b0:	f893 2025 	ldrb.w	r2, [r3, #37]	; 0x25
 800d4b4:	2a2b      	cmp	r2, #43	; 0x2b
 800d4b6:	d1df      	bne.n	800d478 <__cxa_rethrow+0x18>
 800d4b8:	f893 2026 	ldrb.w	r2, [r3, #38]	; 0x26
 800d4bc:	2a2b      	cmp	r2, #43	; 0x2b
 800d4be:	d1db      	bne.n	800d478 <__cxa_rethrow+0x18>
 800d4c0:	f893 2027 	ldrb.w	r2, [r3, #39]	; 0x27
 800d4c4:	2a01      	cmp	r2, #1
 800d4c6:	d8d7      	bhi.n	800d478 <__cxa_rethrow+0x18>
 800d4c8:	695a      	ldr	r2, [r3, #20]
 800d4ca:	4252      	negs	r2, r2
 800d4cc:	615a      	str	r2, [r3, #20]
 800d4ce:	e7d5      	b.n	800d47c <__cxa_rethrow+0x1c>

0800d4d0 <_ZSt15get_new_handlerv>:
 800d4d0:	4b02      	ldr	r3, [pc, #8]	; (800d4dc <_ZSt15get_new_handlerv+0xc>)
 800d4d2:	6818      	ldr	r0, [r3, #0]
 800d4d4:	f3bf 8f5f 	dmb	sy
 800d4d8:	4770      	bx	lr
 800d4da:	bf00      	nop
 800d4dc:	20003e2c 	.word	0x20003e2c

0800d4e0 <__cxa_begin_catch>:
 800d4e0:	b538      	push	{r3, r4, r5, lr}
 800d4e2:	4604      	mov	r4, r0
 800d4e4:	f000 f934 	bl	800d750 <__cxa_get_globals>
 800d4e8:	7822      	ldrb	r2, [r4, #0]
 800d4ea:	6803      	ldr	r3, [r0, #0]
 800d4ec:	2a47      	cmp	r2, #71	; 0x47
 800d4ee:	f1a4 0120 	sub.w	r1, r4, #32
 800d4f2:	d005      	beq.n	800d500 <__cxa_begin_catch+0x20>
 800d4f4:	2b00      	cmp	r3, #0
 800d4f6:	d131      	bne.n	800d55c <__cxa_begin_catch+0x7c>
 800d4f8:	461c      	mov	r4, r3
 800d4fa:	6001      	str	r1, [r0, #0]
 800d4fc:	4620      	mov	r0, r4
 800d4fe:	bd38      	pop	{r3, r4, r5, pc}
 800d500:	7862      	ldrb	r2, [r4, #1]
 800d502:	2a4e      	cmp	r2, #78	; 0x4e
 800d504:	d1f6      	bne.n	800d4f4 <__cxa_begin_catch+0x14>
 800d506:	78a2      	ldrb	r2, [r4, #2]
 800d508:	2a55      	cmp	r2, #85	; 0x55
 800d50a:	d1f3      	bne.n	800d4f4 <__cxa_begin_catch+0x14>
 800d50c:	78e2      	ldrb	r2, [r4, #3]
 800d50e:	2a43      	cmp	r2, #67	; 0x43
 800d510:	d1f0      	bne.n	800d4f4 <__cxa_begin_catch+0x14>
 800d512:	7922      	ldrb	r2, [r4, #4]
 800d514:	2a43      	cmp	r2, #67	; 0x43
 800d516:	d1ed      	bne.n	800d4f4 <__cxa_begin_catch+0x14>
 800d518:	7962      	ldrb	r2, [r4, #5]
 800d51a:	2a2b      	cmp	r2, #43	; 0x2b
 800d51c:	d1ea      	bne.n	800d4f4 <__cxa_begin_catch+0x14>
 800d51e:	79a2      	ldrb	r2, [r4, #6]
 800d520:	2a2b      	cmp	r2, #43	; 0x2b
 800d522:	d1e7      	bne.n	800d4f4 <__cxa_begin_catch+0x14>
 800d524:	79e2      	ldrb	r2, [r4, #7]
 800d526:	2a01      	cmp	r2, #1
 800d528:	d8e4      	bhi.n	800d4f4 <__cxa_begin_catch+0x14>
 800d52a:	f854 2c0c 	ldr.w	r2, [r4, #-12]
 800d52e:	2a00      	cmp	r2, #0
 800d530:	db11      	blt.n	800d556 <__cxa_begin_catch+0x76>
 800d532:	3201      	adds	r2, #1
 800d534:	6845      	ldr	r5, [r0, #4]
 800d536:	f844 2c0c 	str.w	r2, [r4, #-12]
 800d53a:	428b      	cmp	r3, r1
 800d53c:	f105 32ff 	add.w	r2, r5, #4294967295	; 0xffffffff
 800d540:	6042      	str	r2, [r0, #4]
 800d542:	bf1c      	itt	ne
 800d544:	f844 3c10 	strne.w	r3, [r4, #-16]
 800d548:	6001      	strne	r1, [r0, #0]
 800d54a:	4620      	mov	r0, r4
 800d54c:	6a64      	ldr	r4, [r4, #36]	; 0x24
 800d54e:	f7f3 f8c7 	bl	80006e0 <_Unwind_Complete>
 800d552:	4620      	mov	r0, r4
 800d554:	bd38      	pop	{r3, r4, r5, pc}
 800d556:	f1c2 0201 	rsb	r2, r2, #1
 800d55a:	e7eb      	b.n	800d534 <__cxa_begin_catch+0x54>
 800d55c:	f000 f910 	bl	800d780 <_ZSt9terminatev>
 800d560:	3101      	adds	r1, #1
 800d562:	d001      	beq.n	800d568 <__cxa_begin_catch+0x88>
 800d564:	f000 fd10 	bl	800df88 <__cxa_end_cleanup>
 800d568:	f000 fe04 	bl	800e174 <__cxa_call_unexpected>

0800d56c <__cxa_end_catch>:
 800d56c:	b508      	push	{r3, lr}
 800d56e:	f000 f8eb 	bl	800d748 <__cxa_get_globals_fast>
 800d572:	4602      	mov	r2, r0
 800d574:	6800      	ldr	r0, [r0, #0]
 800d576:	2800      	cmp	r0, #0
 800d578:	d03d      	beq.n	800d5f6 <__cxa_end_catch+0x8a>
 800d57a:	f890 3020 	ldrb.w	r3, [r0, #32]
 800d57e:	2b47      	cmp	r3, #71	; 0x47
 800d580:	d006      	beq.n	800d590 <__cxa_end_catch+0x24>
 800d582:	2300      	movs	r3, #0
 800d584:	6013      	str	r3, [r2, #0]
 800d586:	3020      	adds	r0, #32
 800d588:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800d58c:	f7f3 b8aa 	b.w	80006e4 <_Unwind_DeleteException>
 800d590:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 800d594:	2b4e      	cmp	r3, #78	; 0x4e
 800d596:	d1f4      	bne.n	800d582 <__cxa_end_catch+0x16>
 800d598:	f890 3022 	ldrb.w	r3, [r0, #34]	; 0x22
 800d59c:	2b55      	cmp	r3, #85	; 0x55
 800d59e:	d1f0      	bne.n	800d582 <__cxa_end_catch+0x16>
 800d5a0:	f890 3023 	ldrb.w	r3, [r0, #35]	; 0x23
 800d5a4:	2b43      	cmp	r3, #67	; 0x43
 800d5a6:	d1ec      	bne.n	800d582 <__cxa_end_catch+0x16>
 800d5a8:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 800d5ac:	2b43      	cmp	r3, #67	; 0x43
 800d5ae:	d1e8      	bne.n	800d582 <__cxa_end_catch+0x16>
 800d5b0:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 800d5b4:	2b2b      	cmp	r3, #43	; 0x2b
 800d5b6:	d1e4      	bne.n	800d582 <__cxa_end_catch+0x16>
 800d5b8:	f890 3026 	ldrb.w	r3, [r0, #38]	; 0x26
 800d5bc:	2b2b      	cmp	r3, #43	; 0x2b
 800d5be:	d1e0      	bne.n	800d582 <__cxa_end_catch+0x16>
 800d5c0:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
 800d5c4:	2b01      	cmp	r3, #1
 800d5c6:	d8dc      	bhi.n	800d582 <__cxa_end_catch+0x16>
 800d5c8:	6943      	ldr	r3, [r0, #20]
 800d5ca:	2b00      	cmp	r3, #0
 800d5cc:	db05      	blt.n	800d5da <__cxa_end_catch+0x6e>
 800d5ce:	3b01      	subs	r3, #1
 800d5d0:	d008      	beq.n	800d5e4 <__cxa_end_catch+0x78>
 800d5d2:	1c5a      	adds	r2, r3, #1
 800d5d4:	d00d      	beq.n	800d5f2 <__cxa_end_catch+0x86>
 800d5d6:	6143      	str	r3, [r0, #20]
 800d5d8:	bd08      	pop	{r3, pc}
 800d5da:	3301      	adds	r3, #1
 800d5dc:	d1fb      	bne.n	800d5d6 <__cxa_end_catch+0x6a>
 800d5de:	6901      	ldr	r1, [r0, #16]
 800d5e0:	6011      	str	r1, [r2, #0]
 800d5e2:	e7f8      	b.n	800d5d6 <__cxa_end_catch+0x6a>
 800d5e4:	6903      	ldr	r3, [r0, #16]
 800d5e6:	6013      	str	r3, [r2, #0]
 800d5e8:	3020      	adds	r0, #32
 800d5ea:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800d5ee:	f7f3 b879 	b.w	80006e4 <_Unwind_DeleteException>
 800d5f2:	f000 f8c5 	bl	800d780 <_ZSt9terminatev>
 800d5f6:	bd08      	pop	{r3, pc}

0800d5f8 <_ZN12_GLOBAL__N_14pool4freeEPv.constprop.4>:
 800d5f8:	b4f0      	push	{r4, r5, r6, r7}
 800d5fa:	4c1b      	ldr	r4, [pc, #108]	; (800d668 <_ZN12_GLOBAL__N_14pool4freeEPv.constprop.4+0x70>)
 800d5fc:	f850 7c08 	ldr.w	r7, [r0, #-8]
 800d600:	6861      	ldr	r1, [r4, #4]
 800d602:	f1a0 0608 	sub.w	r6, r0, #8
 800d606:	b1c9      	cbz	r1, 800d63c <_ZN12_GLOBAL__N_14pool4freeEPv.constprop.4+0x44>
 800d608:	19f5      	adds	r5, r6, r7
 800d60a:	42a9      	cmp	r1, r5
 800d60c:	d01b      	beq.n	800d646 <_ZN12_GLOBAL__N_14pool4freeEPv.constprop.4+0x4e>
 800d60e:	684a      	ldr	r2, [r1, #4]
 800d610:	b32a      	cbz	r2, 800d65e <_ZN12_GLOBAL__N_14pool4freeEPv.constprop.4+0x66>
 800d612:	4295      	cmp	r5, r2
 800d614:	d303      	bcc.n	800d61e <_ZN12_GLOBAL__N_14pool4freeEPv.constprop.4+0x26>
 800d616:	e022      	b.n	800d65e <_ZN12_GLOBAL__N_14pool4freeEPv.constprop.4+0x66>
 800d618:	429d      	cmp	r5, r3
 800d61a:	d205      	bcs.n	800d628 <_ZN12_GLOBAL__N_14pool4freeEPv.constprop.4+0x30>
 800d61c:	461a      	mov	r2, r3
 800d61e:	6853      	ldr	r3, [r2, #4]
 800d620:	1d0c      	adds	r4, r1, #4
 800d622:	4611      	mov	r1, r2
 800d624:	2b00      	cmp	r3, #0
 800d626:	d1f7      	bne.n	800d618 <_ZN12_GLOBAL__N_14pool4freeEPv.constprop.4+0x20>
 800d628:	6811      	ldr	r1, [r2, #0]
 800d62a:	1855      	adds	r5, r2, r1
 800d62c:	42ae      	cmp	r6, r5
 800d62e:	d013      	beq.n	800d658 <_ZN12_GLOBAL__N_14pool4freeEPv.constprop.4+0x60>
 800d630:	f840 3c04 	str.w	r3, [r0, #-4]
 800d634:	6823      	ldr	r3, [r4, #0]
 800d636:	605e      	str	r6, [r3, #4]
 800d638:	bcf0      	pop	{r4, r5, r6, r7}
 800d63a:	4770      	bx	lr
 800d63c:	f840 1c04 	str.w	r1, [r0, #-4]
 800d640:	6066      	str	r6, [r4, #4]
 800d642:	bcf0      	pop	{r4, r5, r6, r7}
 800d644:	4770      	bx	lr
 800d646:	680b      	ldr	r3, [r1, #0]
 800d648:	684a      	ldr	r2, [r1, #4]
 800d64a:	f840 2c04 	str.w	r2, [r0, #-4]
 800d64e:	441f      	add	r7, r3
 800d650:	f840 7c08 	str.w	r7, [r0, #-8]
 800d654:	6066      	str	r6, [r4, #4]
 800d656:	e7ef      	b.n	800d638 <_ZN12_GLOBAL__N_14pool4freeEPv.constprop.4+0x40>
 800d658:	4439      	add	r1, r7
 800d65a:	6011      	str	r1, [r2, #0]
 800d65c:	e7ec      	b.n	800d638 <_ZN12_GLOBAL__N_14pool4freeEPv.constprop.4+0x40>
 800d65e:	4613      	mov	r3, r2
 800d660:	3404      	adds	r4, #4
 800d662:	460a      	mov	r2, r1
 800d664:	e7e0      	b.n	800d628 <_ZN12_GLOBAL__N_14pool4freeEPv.constprop.4+0x30>
 800d666:	bf00      	nop
 800d668:	20003e30 	.word	0x20003e30

0800d66c <_ZN12_GLOBAL__N_14pool8allocateEj.constprop.5>:
 800d66c:	b430      	push	{r4, r5}
 800d66e:	4c17      	ldr	r4, [pc, #92]	; (800d6cc <_ZN12_GLOBAL__N_14pool8allocateEj.constprop.5+0x60>)
 800d670:	f100 0308 	add.w	r3, r0, #8
 800d674:	2b07      	cmp	r3, #7
 800d676:	6863      	ldr	r3, [r4, #4]
 800d678:	bf86      	itte	hi
 800d67a:	f100 010f 	addhi.w	r1, r0, #15
 800d67e:	f021 0107 	bichi.w	r1, r1, #7
 800d682:	2108      	movls	r1, #8
 800d684:	b1eb      	cbz	r3, 800d6c2 <_ZN12_GLOBAL__N_14pool8allocateEj.constprop.5+0x56>
 800d686:	681a      	ldr	r2, [r3, #0]
 800d688:	4291      	cmp	r1, r2
 800d68a:	d804      	bhi.n	800d696 <_ZN12_GLOBAL__N_14pool8allocateEj.constprop.5+0x2a>
 800d68c:	e01b      	b.n	800d6c6 <_ZN12_GLOBAL__N_14pool8allocateEj.constprop.5+0x5a>
 800d68e:	6802      	ldr	r2, [r0, #0]
 800d690:	428a      	cmp	r2, r1
 800d692:	d205      	bcs.n	800d6a0 <_ZN12_GLOBAL__N_14pool8allocateEj.constprop.5+0x34>
 800d694:	4603      	mov	r3, r0
 800d696:	6858      	ldr	r0, [r3, #4]
 800d698:	2800      	cmp	r0, #0
 800d69a:	d1f8      	bne.n	800d68e <_ZN12_GLOBAL__N_14pool8allocateEj.constprop.5+0x22>
 800d69c:	bc30      	pop	{r4, r5}
 800d69e:	4770      	bx	lr
 800d6a0:	3304      	adds	r3, #4
 800d6a2:	1a52      	subs	r2, r2, r1
 800d6a4:	2a07      	cmp	r2, #7
 800d6a6:	d909      	bls.n	800d6bc <_ZN12_GLOBAL__N_14pool8allocateEj.constprop.5+0x50>
 800d6a8:	1844      	adds	r4, r0, r1
 800d6aa:	6845      	ldr	r5, [r0, #4]
 800d6ac:	6065      	str	r5, [r4, #4]
 800d6ae:	5042      	str	r2, [r0, r1]
 800d6b0:	6818      	ldr	r0, [r3, #0]
 800d6b2:	6001      	str	r1, [r0, #0]
 800d6b4:	601c      	str	r4, [r3, #0]
 800d6b6:	3008      	adds	r0, #8
 800d6b8:	bc30      	pop	{r4, r5}
 800d6ba:	4770      	bx	lr
 800d6bc:	6842      	ldr	r2, [r0, #4]
 800d6be:	601a      	str	r2, [r3, #0]
 800d6c0:	e7f9      	b.n	800d6b6 <_ZN12_GLOBAL__N_14pool8allocateEj.constprop.5+0x4a>
 800d6c2:	4618      	mov	r0, r3
 800d6c4:	e7ea      	b.n	800d69c <_ZN12_GLOBAL__N_14pool8allocateEj.constprop.5+0x30>
 800d6c6:	4618      	mov	r0, r3
 800d6c8:	1d23      	adds	r3, r4, #4
 800d6ca:	e7ea      	b.n	800d6a2 <_ZN12_GLOBAL__N_14pool8allocateEj.constprop.5+0x36>
 800d6cc:	20003e30 	.word	0x20003e30

0800d6d0 <__cxa_allocate_exception>:
 800d6d0:	b538      	push	{r3, r4, r5, lr}
 800d6d2:	f100 0580 	add.w	r5, r0, #128	; 0x80
 800d6d6:	4628      	mov	r0, r5
 800d6d8:	f7f3 fdb4 	bl	8001244 <malloc>
 800d6dc:	4604      	mov	r4, r0
 800d6de:	b138      	cbz	r0, 800d6f0 <__cxa_allocate_exception+0x20>
 800d6e0:	2280      	movs	r2, #128	; 0x80
 800d6e2:	2100      	movs	r1, #0
 800d6e4:	4620      	mov	r0, r4
 800d6e6:	f7f4 f90d 	bl	8001904 <memset>
 800d6ea:	f104 0080 	add.w	r0, r4, #128	; 0x80
 800d6ee:	bd38      	pop	{r3, r4, r5, pc}
 800d6f0:	4628      	mov	r0, r5
 800d6f2:	f7ff ffbb 	bl	800d66c <_ZN12_GLOBAL__N_14pool8allocateEj.constprop.5>
 800d6f6:	4604      	mov	r4, r0
 800d6f8:	2800      	cmp	r0, #0
 800d6fa:	d1f1      	bne.n	800d6e0 <__cxa_allocate_exception+0x10>
 800d6fc:	f000 f840 	bl	800d780 <_ZSt9terminatev>

0800d700 <__cxa_free_exception>:
 800d700:	4a06      	ldr	r2, [pc, #24]	; (800d71c <__cxa_free_exception+0x1c>)
 800d702:	6893      	ldr	r3, [r2, #8]
 800d704:	3880      	subs	r0, #128	; 0x80
 800d706:	4298      	cmp	r0, r3
 800d708:	d905      	bls.n	800d716 <__cxa_free_exception+0x16>
 800d70a:	68d2      	ldr	r2, [r2, #12]
 800d70c:	4413      	add	r3, r2
 800d70e:	4298      	cmp	r0, r3
 800d710:	d201      	bcs.n	800d716 <__cxa_free_exception+0x16>
 800d712:	f7ff bf71 	b.w	800d5f8 <_ZN12_GLOBAL__N_14pool4freeEPv.constprop.4>
 800d716:	f7f3 bd9d 	b.w	8001254 <free>
 800d71a:	bf00      	nop
 800d71c:	20003e30 	.word	0x20003e30

0800d720 <_GLOBAL__sub_I___cxa_allocate_exception>:
 800d720:	b538      	push	{r3, r4, r5, lr}
 800d722:	4c08      	ldr	r4, [pc, #32]	; (800d744 <_GLOBAL__sub_I___cxa_allocate_exception+0x24>)
 800d724:	f44f 651e 	mov.w	r5, #2528	; 0x9e0
 800d728:	4628      	mov	r0, r5
 800d72a:	60e5      	str	r5, [r4, #12]
 800d72c:	f7f3 fd8a 	bl	8001244 <malloc>
 800d730:	60a0      	str	r0, [r4, #8]
 800d732:	b120      	cbz	r0, 800d73e <_GLOBAL__sub_I___cxa_allocate_exception+0x1e>
 800d734:	2300      	movs	r3, #0
 800d736:	6060      	str	r0, [r4, #4]
 800d738:	6005      	str	r5, [r0, #0]
 800d73a:	6043      	str	r3, [r0, #4]
 800d73c:	bd38      	pop	{r3, r4, r5, pc}
 800d73e:	60e0      	str	r0, [r4, #12]
 800d740:	6060      	str	r0, [r4, #4]
 800d742:	bd38      	pop	{r3, r4, r5, pc}
 800d744:	20003e30 	.word	0x20003e30

0800d748 <__cxa_get_globals_fast>:
 800d748:	4800      	ldr	r0, [pc, #0]	; (800d74c <__cxa_get_globals_fast+0x4>)
 800d74a:	4770      	bx	lr
 800d74c:	20003e40 	.word	0x20003e40

0800d750 <__cxa_get_globals>:
 800d750:	4800      	ldr	r0, [pc, #0]	; (800d754 <__cxa_get_globals+0x4>)
 800d752:	4770      	bx	lr
 800d754:	20003e40 	.word	0x20003e40

0800d758 <_ZN10__cxxabiv111__terminateEPFvvE>:
 800d758:	b508      	push	{r3, lr}
 800d75a:	4780      	blx	r0
 800d75c:	f7f3 fd6a 	bl	8001234 <abort>
 800d760:	f7ff febe 	bl	800d4e0 <__cxa_begin_catch>
 800d764:	f7f3 fd66 	bl	8001234 <abort>
 800d768:	460d      	mov	r5, r1
 800d76a:	4604      	mov	r4, r0
 800d76c:	f7ff fefe 	bl	800d56c <__cxa_end_catch>
 800d770:	3501      	adds	r5, #1
 800d772:	d001      	beq.n	800d778 <_ZN10__cxxabiv111__terminateEPFvvE+0x20>
 800d774:	f000 fc08 	bl	800df88 <__cxa_end_cleanup>
 800d778:	4620      	mov	r0, r4
 800d77a:	f000 fcfb 	bl	800e174 <__cxa_call_unexpected>
 800d77e:	bf00      	nop

0800d780 <_ZSt9terminatev>:
 800d780:	b508      	push	{r3, lr}
 800d782:	4b03      	ldr	r3, [pc, #12]	; (800d790 <_ZSt9terminatev+0x10>)
 800d784:	6818      	ldr	r0, [r3, #0]
 800d786:	f3bf 8f5f 	dmb	sy
 800d78a:	f7ff ffe5 	bl	800d758 <_ZN10__cxxabiv111__terminateEPFvvE>
 800d78e:	bf00      	nop
 800d790:	200025ac 	.word	0x200025ac

0800d794 <_ZN10__cxxabiv112__unexpectedEPFvvE>:
 800d794:	b508      	push	{r3, lr}
 800d796:	4780      	blx	r0
 800d798:	f7ff fff2 	bl	800d780 <_ZSt9terminatev>

0800d79c <_ZSt10unexpectedv>:
 800d79c:	b508      	push	{r3, lr}
 800d79e:	4b03      	ldr	r3, [pc, #12]	; (800d7ac <_ZSt10unexpectedv+0x10>)
 800d7a0:	6818      	ldr	r0, [r3, #0]
 800d7a2:	f3bf 8f5f 	dmb	sy
 800d7a6:	f7ff fff5 	bl	800d794 <_ZN10__cxxabiv112__unexpectedEPFvvE>
 800d7aa:	bf00      	nop
 800d7ac:	200025b0 	.word	0x200025b0

0800d7b0 <_ZSt13get_terminatev>:
 800d7b0:	4b02      	ldr	r3, [pc, #8]	; (800d7bc <_ZSt13get_terminatev+0xc>)
 800d7b2:	6818      	ldr	r0, [r3, #0]
 800d7b4:	f3bf 8f5f 	dmb	sy
 800d7b8:	4770      	bx	lr
 800d7ba:	bf00      	nop
 800d7bc:	200025ac 	.word	0x200025ac

0800d7c0 <_ZSt14get_unexpectedv>:
 800d7c0:	4b02      	ldr	r3, [pc, #8]	; (800d7cc <_ZSt14get_unexpectedv+0xc>)
 800d7c2:	6818      	ldr	r0, [r3, #0]
 800d7c4:	f3bf 8f5f 	dmb	sy
 800d7c8:	4770      	bx	lr
 800d7ca:	bf00      	nop
 800d7cc:	200025b0 	.word	0x200025b0

0800d7d0 <_ZL28read_encoded_value_with_basehjPKhPj>:
 800d7d0:	2850      	cmp	r0, #80	; 0x50
 800d7d2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d7d4:	d054      	beq.n	800d880 <_ZL28read_encoded_value_with_basehjPKhPj+0xb0>
 800d7d6:	f000 040f 	and.w	r4, r0, #15
 800d7da:	2c0c      	cmp	r4, #12
 800d7dc:	d84e      	bhi.n	800d87c <_ZL28read_encoded_value_with_basehjPKhPj+0xac>
 800d7de:	e8df f004 	tbb	[pc, r4]
 800d7e2:	3907      	.short	0x3907
 800d7e4:	4d170749 	.word	0x4d170749
 800d7e8:	1f4d4d4d 	.word	0x1f4d4d4d
 800d7ec:	071b      	.short	0x071b
 800d7ee:	17          	.byte	0x17
 800d7ef:	00          	.byte	0x00
 800d7f0:	4615      	mov	r5, r2
 800d7f2:	f855 4b04 	ldr.w	r4, [r5], #4
 800d7f6:	b144      	cbz	r4, 800d80a <_ZL28read_encoded_value_with_basehjPKhPj+0x3a>
 800d7f8:	f000 0670 	and.w	r6, r0, #112	; 0x70
 800d7fc:	2e10      	cmp	r6, #16
 800d7fe:	bf18      	it	ne
 800d800:	460a      	movne	r2, r1
 800d802:	4414      	add	r4, r2
 800d804:	0602      	lsls	r2, r0, #24
 800d806:	bf48      	it	mi
 800d808:	6824      	ldrmi	r4, [r4, #0]
 800d80a:	601c      	str	r4, [r3, #0]
 800d80c:	4628      	mov	r0, r5
 800d80e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800d810:	4615      	mov	r5, r2
 800d812:	f855 4b08 	ldr.w	r4, [r5], #8
 800d816:	e7ee      	b.n	800d7f6 <_ZL28read_encoded_value_with_basehjPKhPj+0x26>
 800d818:	4615      	mov	r5, r2
 800d81a:	f935 4b02 	ldrsh.w	r4, [r5], #2
 800d81e:	e7ea      	b.n	800d7f6 <_ZL28read_encoded_value_with_basehjPKhPj+0x26>
 800d820:	2400      	movs	r4, #0
 800d822:	4627      	mov	r7, r4
 800d824:	4615      	mov	r5, r2
 800d826:	f815 eb01 	ldrb.w	lr, [r5], #1
 800d82a:	f00e 067f 	and.w	r6, lr, #127	; 0x7f
 800d82e:	40be      	lsls	r6, r7
 800d830:	f01e 0f80 	tst.w	lr, #128	; 0x80
 800d834:	ea44 0406 	orr.w	r4, r4, r6
 800d838:	f107 0707 	add.w	r7, r7, #7
 800d83c:	d1f3      	bne.n	800d826 <_ZL28read_encoded_value_with_basehjPKhPj+0x56>
 800d83e:	2f1f      	cmp	r7, #31
 800d840:	d8d9      	bhi.n	800d7f6 <_ZL28read_encoded_value_with_basehjPKhPj+0x26>
 800d842:	f01e 0f40 	tst.w	lr, #64	; 0x40
 800d846:	d0d6      	beq.n	800d7f6 <_ZL28read_encoded_value_with_basehjPKhPj+0x26>
 800d848:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 800d84c:	fa06 f707 	lsl.w	r7, r6, r7
 800d850:	433c      	orrs	r4, r7
 800d852:	e7d1      	b.n	800d7f8 <_ZL28read_encoded_value_with_basehjPKhPj+0x28>
 800d854:	2400      	movs	r4, #0
 800d856:	4627      	mov	r7, r4
 800d858:	4615      	mov	r5, r2
 800d85a:	f815 eb01 	ldrb.w	lr, [r5], #1
 800d85e:	f00e 067f 	and.w	r6, lr, #127	; 0x7f
 800d862:	40be      	lsls	r6, r7
 800d864:	f01e 0f80 	tst.w	lr, #128	; 0x80
 800d868:	ea44 0406 	orr.w	r4, r4, r6
 800d86c:	f107 0707 	add.w	r7, r7, #7
 800d870:	d1f3      	bne.n	800d85a <_ZL28read_encoded_value_with_basehjPKhPj+0x8a>
 800d872:	e7c0      	b.n	800d7f6 <_ZL28read_encoded_value_with_basehjPKhPj+0x26>
 800d874:	4615      	mov	r5, r2
 800d876:	f835 4b02 	ldrh.w	r4, [r5], #2
 800d87a:	e7bc      	b.n	800d7f6 <_ZL28read_encoded_value_with_basehjPKhPj+0x26>
 800d87c:	f7f3 fcda 	bl	8001234 <abort>
 800d880:	3203      	adds	r2, #3
 800d882:	f022 0503 	bic.w	r5, r2, #3
 800d886:	f855 4b04 	ldr.w	r4, [r5], #4
 800d88a:	601c      	str	r4, [r3, #0]
 800d88c:	4628      	mov	r0, r5
 800d88e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800d890 <_ZL21base_of_encoded_valuehP15_Unwind_Context>:
 800d890:	28ff      	cmp	r0, #255	; 0xff
 800d892:	d015      	beq.n	800d8c0 <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x30>
 800d894:	b508      	push	{r3, lr}
 800d896:	f000 0370 	and.w	r3, r0, #112	; 0x70
 800d89a:	2b20      	cmp	r3, #32
 800d89c:	d012      	beq.n	800d8c4 <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x34>
 800d89e:	d90a      	bls.n	800d8b6 <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x26>
 800d8a0:	2b40      	cmp	r3, #64	; 0x40
 800d8a2:	d014      	beq.n	800d8ce <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x3e>
 800d8a4:	2b50      	cmp	r3, #80	; 0x50
 800d8a6:	d017      	beq.n	800d8d8 <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x48>
 800d8a8:	2b30      	cmp	r3, #48	; 0x30
 800d8aa:	d107      	bne.n	800d8bc <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x2c>
 800d8ac:	4608      	mov	r0, r1
 800d8ae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800d8b2:	f7f3 bcbb 	b.w	800122c <_Unwind_GetDataRelBase>
 800d8b6:	b17b      	cbz	r3, 800d8d8 <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x48>
 800d8b8:	2b10      	cmp	r3, #16
 800d8ba:	d00d      	beq.n	800d8d8 <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x48>
 800d8bc:	f7f3 fcba 	bl	8001234 <abort>
 800d8c0:	2000      	movs	r0, #0
 800d8c2:	4770      	bx	lr
 800d8c4:	4608      	mov	r0, r1
 800d8c6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800d8ca:	f7f3 bcab 	b.w	8001224 <_Unwind_GetTextRelBase>
 800d8ce:	4608      	mov	r0, r1
 800d8d0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800d8d4:	f7f3 bc96 	b.w	8001204 <_Unwind_GetRegionStart>
 800d8d8:	2000      	movs	r0, #0
 800d8da:	bd08      	pop	{r3, pc}

0800d8dc <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info>:
 800d8dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d8de:	460c      	mov	r4, r1
 800d8e0:	4615      	mov	r5, r2
 800d8e2:	4607      	mov	r7, r0
 800d8e4:	2800      	cmp	r0, #0
 800d8e6:	d044      	beq.n	800d972 <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x96>
 800d8e8:	f7f3 fc8c 	bl	8001204 <_Unwind_GetRegionStart>
 800d8ec:	6028      	str	r0, [r5, #0]
 800d8ee:	7826      	ldrb	r6, [r4, #0]
 800d8f0:	2eff      	cmp	r6, #255	; 0xff
 800d8f2:	f104 0401 	add.w	r4, r4, #1
 800d8f6:	d032      	beq.n	800d95e <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x82>
 800d8f8:	4639      	mov	r1, r7
 800d8fa:	4630      	mov	r0, r6
 800d8fc:	f7ff ffc8 	bl	800d890 <_ZL21base_of_encoded_valuehP15_Unwind_Context>
 800d900:	4622      	mov	r2, r4
 800d902:	4601      	mov	r1, r0
 800d904:	1d2b      	adds	r3, r5, #4
 800d906:	4630      	mov	r0, r6
 800d908:	f7ff ff62 	bl	800d7d0 <_ZL28read_encoded_value_with_basehjPKhPj>
 800d90c:	4604      	mov	r4, r0
 800d90e:	1c60      	adds	r0, r4, #1
 800d910:	7823      	ldrb	r3, [r4, #0]
 800d912:	752b      	strb	r3, [r5, #20]
 800d914:	2bff      	cmp	r3, #255	; 0xff
 800d916:	d029      	beq.n	800d96c <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x90>
 800d918:	2310      	movs	r3, #16
 800d91a:	2400      	movs	r4, #0
 800d91c:	752b      	strb	r3, [r5, #20]
 800d91e:	4622      	mov	r2, r4
 800d920:	f810 1b01 	ldrb.w	r1, [r0], #1
 800d924:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 800d928:	4093      	lsls	r3, r2
 800d92a:	0609      	lsls	r1, r1, #24
 800d92c:	ea44 0403 	orr.w	r4, r4, r3
 800d930:	f102 0207 	add.w	r2, r2, #7
 800d934:	d4f4      	bmi.n	800d920 <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x44>
 800d936:	4404      	add	r4, r0
 800d938:	60ec      	str	r4, [r5, #12]
 800d93a:	7803      	ldrb	r3, [r0, #0]
 800d93c:	756b      	strb	r3, [r5, #21]
 800d93e:	2400      	movs	r4, #0
 800d940:	3001      	adds	r0, #1
 800d942:	4622      	mov	r2, r4
 800d944:	f810 1b01 	ldrb.w	r1, [r0], #1
 800d948:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 800d94c:	4093      	lsls	r3, r2
 800d94e:	431c      	orrs	r4, r3
 800d950:	060b      	lsls	r3, r1, #24
 800d952:	f102 0207 	add.w	r2, r2, #7
 800d956:	d4f5      	bmi.n	800d944 <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x68>
 800d958:	4404      	add	r4, r0
 800d95a:	612c      	str	r4, [r5, #16]
 800d95c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800d95e:	6068      	str	r0, [r5, #4]
 800d960:	7823      	ldrb	r3, [r4, #0]
 800d962:	752b      	strb	r3, [r5, #20]
 800d964:	2bff      	cmp	r3, #255	; 0xff
 800d966:	f104 0001 	add.w	r0, r4, #1
 800d96a:	d1d5      	bne.n	800d918 <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x3c>
 800d96c:	2300      	movs	r3, #0
 800d96e:	60eb      	str	r3, [r5, #12]
 800d970:	e7e3      	b.n	800d93a <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x5e>
 800d972:	e7bb      	b.n	800d8ec <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x10>

0800d974 <__gxx_personality_v0>:
 800d974:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d978:	f000 0403 	and.w	r4, r0, #3
 800d97c:	b097      	sub	sp, #92	; 0x5c
 800d97e:	2300      	movs	r3, #0
 800d980:	2c01      	cmp	r4, #1
 800d982:	4689      	mov	r9, r1
 800d984:	4690      	mov	r8, r2
 800d986:	930a      	str	r3, [sp, #40]	; 0x28
 800d988:	d021      	beq.n	800d9ce <__gxx_personality_v0+0x5a>
 800d98a:	d30e      	bcc.n	800d9aa <__gxx_personality_v0+0x36>
 800d98c:	2c02      	cmp	r4, #2
 800d98e:	d10a      	bne.n	800d9a6 <__gxx_personality_v0+0x32>
 800d990:	4641      	mov	r1, r8
 800d992:	4648      	mov	r0, r9
 800d994:	f7f3 fc22 	bl	80011dc <__gnu_unwind_frame>
 800d998:	2800      	cmp	r0, #0
 800d99a:	f000 80d4 	beq.w	800db46 <__gxx_personality_v0+0x1d2>
 800d99e:	2009      	movs	r0, #9
 800d9a0:	b017      	add	sp, #92	; 0x5c
 800d9a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d9a6:	f7f3 fc45 	bl	8001234 <abort>
 800d9aa:	f000 0008 	and.w	r0, r0, #8
 800d9ae:	f000 03ff 	and.w	r3, r0, #255	; 0xff
 800d9b2:	2800      	cmp	r0, #0
 800d9b4:	d1ec      	bne.n	800d990 <__gxx_personality_v0+0x1c>
 800d9b6:	aa16      	add	r2, sp, #88	; 0x58
 800d9b8:	4640      	mov	r0, r8
 800d9ba:	f842 1d2c 	str.w	r1, [r2, #-44]!
 800d9be:	4619      	mov	r1, r3
 800d9c0:	9200      	str	r2, [sp, #0]
 800d9c2:	220c      	movs	r2, #12
 800d9c4:	f7f2 feba 	bl	800073c <_Unwind_VRS_Set>
 800d9c8:	2301      	movs	r3, #1
 800d9ca:	9304      	str	r3, [sp, #16]
 800d9cc:	e013      	b.n	800d9f6 <__gxx_personality_v0+0x82>
 800d9ce:	f000 0008 	and.w	r0, r0, #8
 800d9d2:	f000 04ff 	and.w	r4, r0, #255	; 0xff
 800d9d6:	2800      	cmp	r0, #0
 800d9d8:	f000 80b9 	beq.w	800db4e <__gxx_personality_v0+0x1da>
 800d9dc:	aa16      	add	r2, sp, #88	; 0x58
 800d9de:	f044 0402 	orr.w	r4, r4, #2
 800d9e2:	f842 1d2c 	str.w	r1, [r2, #-44]!
 800d9e6:	b2e4      	uxtb	r4, r4
 800d9e8:	9200      	str	r2, [sp, #0]
 800d9ea:	4619      	mov	r1, r3
 800d9ec:	220c      	movs	r2, #12
 800d9ee:	4640      	mov	r0, r8
 800d9f0:	9404      	str	r4, [sp, #16]
 800d9f2:	f7f2 fea3 	bl	800073c <_Unwind_VRS_Set>
 800d9f6:	4640      	mov	r0, r8
 800d9f8:	f7f3 fc0a 	bl	8001210 <_Unwind_GetLanguageSpecificData>
 800d9fc:	9005      	str	r0, [sp, #20]
 800d9fe:	2800      	cmp	r0, #0
 800da00:	d0c6      	beq.n	800d990 <__gxx_personality_v0+0x1c>
 800da02:	ab10      	add	r3, sp, #64	; 0x40
 800da04:	461a      	mov	r2, r3
 800da06:	9905      	ldr	r1, [sp, #20]
 800da08:	9306      	str	r3, [sp, #24]
 800da0a:	4640      	mov	r0, r8
 800da0c:	f7ff ff66 	bl	800d8dc <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info>
 800da10:	4641      	mov	r1, r8
 800da12:	4604      	mov	r4, r0
 800da14:	f89d 0054 	ldrb.w	r0, [sp, #84]	; 0x54
 800da18:	f7ff ff3a 	bl	800d890 <_ZL21base_of_encoded_valuehP15_Unwind_Context>
 800da1c:	f10d 0b3c 	add.w	fp, sp, #60	; 0x3c
 800da20:	2300      	movs	r3, #0
 800da22:	9012      	str	r0, [sp, #72]	; 0x48
 800da24:	4619      	mov	r1, r3
 800da26:	220f      	movs	r2, #15
 800da28:	f8cd b000 	str.w	fp, [sp]
 800da2c:	4640      	mov	r0, r8
 800da2e:	f7f2 fe5f 	bl	80006f0 <_Unwind_VRS_Get>
 800da32:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800da34:	9a14      	ldr	r2, [sp, #80]	; 0x50
 800da36:	f023 0301 	bic.w	r3, r3, #1
 800da3a:	4294      	cmp	r4, r2
 800da3c:	f103 36ff 	add.w	r6, r3, #4294967295	; 0xffffffff
 800da40:	d243      	bcs.n	800daca <__gxx_personality_v0+0x156>
 800da42:	f10d 0a34 	add.w	sl, sp, #52	; 0x34
 800da46:	af0e      	add	r7, sp, #56	; 0x38
 800da48:	f89d 5055 	ldrb.w	r5, [sp, #85]	; 0x55
 800da4c:	2100      	movs	r1, #0
 800da4e:	4628      	mov	r0, r5
 800da50:	f7ff ff1e 	bl	800d890 <_ZL21base_of_encoded_valuehP15_Unwind_Context>
 800da54:	4622      	mov	r2, r4
 800da56:	4653      	mov	r3, sl
 800da58:	4601      	mov	r1, r0
 800da5a:	4628      	mov	r0, r5
 800da5c:	f7ff feb8 	bl	800d7d0 <_ZL28read_encoded_value_with_basehjPKhPj>
 800da60:	f89d 4055 	ldrb.w	r4, [sp, #85]	; 0x55
 800da64:	4605      	mov	r5, r0
 800da66:	2100      	movs	r1, #0
 800da68:	4620      	mov	r0, r4
 800da6a:	f7ff ff11 	bl	800d890 <_ZL21base_of_encoded_valuehP15_Unwind_Context>
 800da6e:	462a      	mov	r2, r5
 800da70:	463b      	mov	r3, r7
 800da72:	4601      	mov	r1, r0
 800da74:	4620      	mov	r0, r4
 800da76:	f7ff feab 	bl	800d7d0 <_ZL28read_encoded_value_with_basehjPKhPj>
 800da7a:	f89d 4055 	ldrb.w	r4, [sp, #85]	; 0x55
 800da7e:	4605      	mov	r5, r0
 800da80:	2100      	movs	r1, #0
 800da82:	4620      	mov	r0, r4
 800da84:	f7ff ff04 	bl	800d890 <_ZL21base_of_encoded_valuehP15_Unwind_Context>
 800da88:	462a      	mov	r2, r5
 800da8a:	4601      	mov	r1, r0
 800da8c:	465b      	mov	r3, fp
 800da8e:	4620      	mov	r0, r4
 800da90:	f7ff fe9e 	bl	800d7d0 <_ZL28read_encoded_value_with_basehjPKhPj>
 800da94:	4604      	mov	r4, r0
 800da96:	2000      	movs	r0, #0
 800da98:	4602      	mov	r2, r0
 800da9a:	f814 1b01 	ldrb.w	r1, [r4], #1
 800da9e:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 800daa2:	4093      	lsls	r3, r2
 800daa4:	060d      	lsls	r5, r1, #24
 800daa6:	ea40 0003 	orr.w	r0, r0, r3
 800daaa:	f102 0207 	add.w	r2, r2, #7
 800daae:	d4f4      	bmi.n	800da9a <__gxx_personality_v0+0x126>
 800dab0:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800dab2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800dab4:	4413      	add	r3, r2
 800dab6:	429e      	cmp	r6, r3
 800dab8:	d307      	bcc.n	800daca <__gxx_personality_v0+0x156>
 800daba:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800dabc:	4413      	add	r3, r2
 800dabe:	429e      	cmp	r6, r3
 800dac0:	f0c0 80ba 	bcc.w	800dc38 <__gxx_personality_v0+0x2c4>
 800dac4:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800dac6:	42a3      	cmp	r3, r4
 800dac8:	d8be      	bhi.n	800da48 <__gxx_personality_v0+0xd4>
 800daca:	2500      	movs	r5, #0
 800dacc:	9503      	str	r5, [sp, #12]
 800dace:	2401      	movs	r4, #1
 800dad0:	9b04      	ldr	r3, [sp, #16]
 800dad2:	07db      	lsls	r3, r3, #31
 800dad4:	d456      	bmi.n	800db84 <__gxx_personality_v0+0x210>
 800dad6:	9b04      	ldr	r3, [sp, #16]
 800dad8:	0719      	lsls	r1, r3, #28
 800dada:	f140 80a8 	bpl.w	800dc2e <__gxx_personality_v0+0x2ba>
 800dade:	2c01      	cmp	r4, #1
 800dae0:	f000 819d 	beq.w	800de1e <__gxx_personality_v0+0x4aa>
 800dae4:	f10d 0a34 	add.w	sl, sp, #52	; 0x34
 800dae8:	af0e      	add	r7, sp, #56	; 0x38
 800daea:	a916      	add	r1, sp, #88	; 0x58
 800daec:	2300      	movs	r3, #0
 800daee:	f841 9d28 	str.w	r9, [r1, #-40]!
 800daf2:	461a      	mov	r2, r3
 800daf4:	9100      	str	r1, [sp, #0]
 800daf6:	4640      	mov	r0, r8
 800daf8:	4619      	mov	r1, r3
 800dafa:	f7f2 fe1f 	bl	800073c <_Unwind_VRS_Set>
 800dafe:	2300      	movs	r3, #0
 800db00:	4619      	mov	r1, r3
 800db02:	2201      	movs	r2, #1
 800db04:	f8cd a000 	str.w	sl, [sp]
 800db08:	4640      	mov	r0, r8
 800db0a:	950d      	str	r5, [sp, #52]	; 0x34
 800db0c:	f7f2 fe16 	bl	800073c <_Unwind_VRS_Set>
 800db10:	2300      	movs	r3, #0
 800db12:	4619      	mov	r1, r3
 800db14:	220f      	movs	r2, #15
 800db16:	9700      	str	r7, [sp, #0]
 800db18:	4640      	mov	r0, r8
 800db1a:	f7f2 fde9 	bl	80006f0 <_Unwind_VRS_Get>
 800db1e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800db20:	9a03      	ldr	r2, [sp, #12]
 800db22:	9700      	str	r7, [sp, #0]
 800db24:	f003 0501 	and.w	r5, r3, #1
 800db28:	2300      	movs	r3, #0
 800db2a:	4315      	orrs	r5, r2
 800db2c:	4640      	mov	r0, r8
 800db2e:	4619      	mov	r1, r3
 800db30:	220f      	movs	r2, #15
 800db32:	950e      	str	r5, [sp, #56]	; 0x38
 800db34:	f7f2 fe02 	bl	800073c <_Unwind_VRS_Set>
 800db38:	2c02      	cmp	r4, #2
 800db3a:	f000 80f5 	beq.w	800dd28 <__gxx_personality_v0+0x3b4>
 800db3e:	2007      	movs	r0, #7
 800db40:	b017      	add	sp, #92	; 0x5c
 800db42:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800db46:	2008      	movs	r0, #8
 800db48:	b017      	add	sp, #92	; 0x5c
 800db4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800db4e:	ab10      	add	r3, sp, #64	; 0x40
 800db50:	9300      	str	r3, [sp, #0]
 800db52:	9306      	str	r3, [sp, #24]
 800db54:	220d      	movs	r2, #13
 800db56:	4623      	mov	r3, r4
 800db58:	4621      	mov	r1, r4
 800db5a:	4640      	mov	r0, r8
 800db5c:	f8d9 5020 	ldr.w	r5, [r9, #32]
 800db60:	f7f2 fdc6 	bl	80006f0 <_Unwind_VRS_Get>
 800db64:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800db66:	429d      	cmp	r5, r3
 800db68:	d024      	beq.n	800dbb4 <__gxx_personality_v0+0x240>
 800db6a:	aa16      	add	r2, sp, #88	; 0x58
 800db6c:	4623      	mov	r3, r4
 800db6e:	f842 9d2c 	str.w	r9, [r2, #-44]!
 800db72:	4621      	mov	r1, r4
 800db74:	9200      	str	r2, [sp, #0]
 800db76:	4640      	mov	r0, r8
 800db78:	220c      	movs	r2, #12
 800db7a:	f7f2 fddf 	bl	800073c <_Unwind_VRS_Set>
 800db7e:	2302      	movs	r3, #2
 800db80:	9304      	str	r3, [sp, #16]
 800db82:	e738      	b.n	800d9f6 <__gxx_personality_v0+0x82>
 800db84:	af0e      	add	r7, sp, #56	; 0x38
 800db86:	2300      	movs	r3, #0
 800db88:	4619      	mov	r1, r3
 800db8a:	220d      	movs	r2, #13
 800db8c:	9700      	str	r7, [sp, #0]
 800db8e:	4640      	mov	r0, r8
 800db90:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 800db92:	f7f2 fdad 	bl	80006f0 <_Unwind_VRS_Get>
 800db96:	9a05      	ldr	r2, [sp, #20]
 800db98:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800db9a:	f8c9 202c 	str.w	r2, [r9, #44]	; 0x2c
 800db9e:	9a03      	ldr	r2, [sp, #12]
 800dba0:	f8c9 4024 	str.w	r4, [r9, #36]	; 0x24
 800dba4:	f8c9 5028 	str.w	r5, [r9, #40]	; 0x28
 800dba8:	f8c9 2030 	str.w	r2, [r9, #48]	; 0x30
 800dbac:	f8c9 3020 	str.w	r3, [r9, #32]
 800dbb0:	2006      	movs	r0, #6
 800dbb2:	e6f5      	b.n	800d9a0 <__gxx_personality_v0+0x2c>
 800dbb4:	aa16      	add	r2, sp, #88	; 0x58
 800dbb6:	4623      	mov	r3, r4
 800dbb8:	f842 9d2c 	str.w	r9, [r2, #-44]!
 800dbbc:	4621      	mov	r1, r4
 800dbbe:	9200      	str	r2, [sp, #0]
 800dbc0:	4640      	mov	r0, r8
 800dbc2:	220c      	movs	r2, #12
 800dbc4:	f7f2 fdba 	bl	800073c <_Unwind_VRS_Set>
 800dbc8:	f8d9 3030 	ldr.w	r3, [r9, #48]	; 0x30
 800dbcc:	9303      	str	r3, [sp, #12]
 800dbce:	b383      	cbz	r3, 800dc32 <__gxx_personality_v0+0x2be>
 800dbd0:	f8d9 302c 	ldr.w	r3, [r9, #44]	; 0x2c
 800dbd4:	f8d9 5028 	ldr.w	r5, [r9, #40]	; 0x28
 800dbd8:	9305      	str	r3, [sp, #20]
 800dbda:	2403      	movs	r4, #3
 800dbdc:	f10d 0a34 	add.w	sl, sp, #52	; 0x34
 800dbe0:	af0e      	add	r7, sp, #56	; 0x38
 800dbe2:	2d00      	cmp	r5, #0
 800dbe4:	da81      	bge.n	800daea <__gxx_personality_v0+0x176>
 800dbe6:	9a06      	ldr	r2, [sp, #24]
 800dbe8:	9905      	ldr	r1, [sp, #20]
 800dbea:	4640      	mov	r0, r8
 800dbec:	f7ff fe76 	bl	800d8dc <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info>
 800dbf0:	4641      	mov	r1, r8
 800dbf2:	f89d 0054 	ldrb.w	r0, [sp, #84]	; 0x54
 800dbf6:	f7ff fe4b 	bl	800d890 <_ZL21base_of_encoded_valuehP15_Unwind_Context>
 800dbfa:	00aa      	lsls	r2, r5, #2
 800dbfc:	f082 0203 	eor.w	r2, r2, #3
 800dc00:	43d2      	mvns	r2, r2
 800dc02:	9e13      	ldr	r6, [sp, #76]	; 0x4c
 800dc04:	9012      	str	r0, [sp, #72]	; 0x48
 800dc06:	58b3      	ldr	r3, [r6, r2]
 800dc08:	4416      	add	r6, r2
 800dc0a:	b133      	cbz	r3, 800dc1a <__gxx_personality_v0+0x2a6>
 800dc0c:	4632      	mov	r2, r6
 800dc0e:	2300      	movs	r3, #0
 800dc10:	f852 1f04 	ldr.w	r1, [r2, #4]!
 800dc14:	3301      	adds	r3, #1
 800dc16:	2900      	cmp	r1, #0
 800dc18:	d1fa      	bne.n	800dc10 <__gxx_personality_v0+0x29c>
 800dc1a:	2204      	movs	r2, #4
 800dc1c:	f8c9 3028 	str.w	r3, [r9, #40]	; 0x28
 800dc20:	f8c9 002c 	str.w	r0, [r9, #44]	; 0x2c
 800dc24:	f8c9 6034 	str.w	r6, [r9, #52]	; 0x34
 800dc28:	f8c9 2030 	str.w	r2, [r9, #48]	; 0x30
 800dc2c:	e75d      	b.n	800daea <__gxx_personality_v0+0x176>
 800dc2e:	2c01      	cmp	r4, #1
 800dc30:	d1d4      	bne.n	800dbdc <__gxx_personality_v0+0x268>
 800dc32:	4648      	mov	r0, r9
 800dc34:	f000 fa8e 	bl	800e154 <__cxa_call_terminate>
 800dc38:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800dc3a:	2b00      	cmp	r3, #0
 800dc3c:	f43f aea8 	beq.w	800d990 <__gxx_personality_v0+0x1c>
 800dc40:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800dc42:	4413      	add	r3, r2
 800dc44:	9303      	str	r3, [sp, #12]
 800dc46:	2800      	cmp	r0, #0
 800dc48:	f000 80d6 	beq.w	800ddf8 <__gxx_personality_v0+0x484>
 800dc4c:	9c14      	ldr	r4, [sp, #80]	; 0x50
 800dc4e:	3801      	subs	r0, #1
 800dc50:	4404      	add	r4, r0
 800dc52:	2b00      	cmp	r3, #0
 800dc54:	f43f ae9c 	beq.w	800d990 <__gxx_personality_v0+0x1c>
 800dc58:	2c00      	cmp	r4, #0
 800dc5a:	f000 80d1 	beq.w	800de00 <__gxx_personality_v0+0x48c>
 800dc5e:	9b04      	ldr	r3, [sp, #16]
 800dc60:	f013 0308 	ands.w	r3, r3, #8
 800dc64:	9309      	str	r3, [sp, #36]	; 0x24
 800dc66:	f000 80bd 	beq.w	800dde4 <__gxx_personality_v0+0x470>
 800dc6a:	2247      	movs	r2, #71	; 0x47
 800dc6c:	234e      	movs	r3, #78	; 0x4e
 800dc6e:	f889 2000 	strb.w	r2, [r9]
 800dc72:	f889 3001 	strb.w	r3, [r9, #1]
 800dc76:	2255      	movs	r2, #85	; 0x55
 800dc78:	2343      	movs	r3, #67	; 0x43
 800dc7a:	f889 2002 	strb.w	r2, [r9, #2]
 800dc7e:	f889 3003 	strb.w	r3, [r9, #3]
 800dc82:	2246      	movs	r2, #70	; 0x46
 800dc84:	234f      	movs	r3, #79	; 0x4f
 800dc86:	f889 2004 	strb.w	r2, [r9, #4]
 800dc8a:	f889 3005 	strb.w	r3, [r9, #5]
 800dc8e:	2252      	movs	r2, #82	; 0x52
 800dc90:	2300      	movs	r3, #0
 800dc92:	f889 2006 	strb.w	r2, [r9, #6]
 800dc96:	f889 3007 	strb.w	r3, [r9, #7]
 800dc9a:	2300      	movs	r3, #0
 800dc9c:	9307      	str	r3, [sp, #28]
 800dc9e:	f8cd 8020 	str.w	r8, [sp, #32]
 800dca2:	2500      	movs	r5, #0
 800dca4:	462a      	mov	r2, r5
 800dca6:	f814 1b01 	ldrb.w	r1, [r4], #1
 800dcaa:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 800dcae:	4093      	lsls	r3, r2
 800dcb0:	0608      	lsls	r0, r1, #24
 800dcb2:	ea45 0503 	orr.w	r5, r5, r3
 800dcb6:	f102 0207 	add.w	r2, r2, #7
 800dcba:	d4f4      	bmi.n	800dca6 <__gxx_personality_v0+0x332>
 800dcbc:	2a1f      	cmp	r2, #31
 800dcbe:	d805      	bhi.n	800dccc <__gxx_personality_v0+0x358>
 800dcc0:	0649      	lsls	r1, r1, #25
 800dcc2:	d503      	bpl.n	800dccc <__gxx_personality_v0+0x358>
 800dcc4:	2301      	movs	r3, #1
 800dcc6:	4093      	lsls	r3, r2
 800dcc8:	425b      	negs	r3, r3
 800dcca:	431d      	orrs	r5, r3
 800dccc:	2600      	movs	r6, #0
 800dcce:	4632      	mov	r2, r6
 800dcd0:	4620      	mov	r0, r4
 800dcd2:	f810 1b01 	ldrb.w	r1, [r0], #1
 800dcd6:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 800dcda:	4093      	lsls	r3, r2
 800dcdc:	431e      	orrs	r6, r3
 800dcde:	060b      	lsls	r3, r1, #24
 800dce0:	f102 0207 	add.w	r2, r2, #7
 800dce4:	d4f5      	bmi.n	800dcd2 <__gxx_personality_v0+0x35e>
 800dce6:	2a1f      	cmp	r2, #31
 800dce8:	d805      	bhi.n	800dcf6 <__gxx_personality_v0+0x382>
 800dcea:	0648      	lsls	r0, r1, #25
 800dcec:	d503      	bpl.n	800dcf6 <__gxx_personality_v0+0x382>
 800dcee:	2301      	movs	r3, #1
 800dcf0:	4093      	lsls	r3, r2
 800dcf2:	425b      	negs	r3, r3
 800dcf4:	431e      	orrs	r6, r3
 800dcf6:	2d00      	cmp	r5, #0
 800dcf8:	d03d      	beq.n	800dd76 <__gxx_personality_v0+0x402>
 800dcfa:	dd3f      	ble.n	800dd7c <__gxx_personality_v0+0x408>
 800dcfc:	f89d 0054 	ldrb.w	r0, [sp, #84]	; 0x54
 800dd00:	28ff      	cmp	r0, #255	; 0xff
 800dd02:	d06d      	beq.n	800dde0 <__gxx_personality_v0+0x46c>
 800dd04:	f000 0307 	and.w	r3, r0, #7
 800dd08:	2b04      	cmp	r3, #4
 800dd0a:	f63f ae4c 	bhi.w	800d9a6 <__gxx_personality_v0+0x32>
 800dd0e:	a201      	add	r2, pc, #4	; (adr r2, 800dd14 <__gxx_personality_v0+0x3a0>)
 800dd10:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800dd14:	0800dd5b 	.word	0x0800dd5b
 800dd18:	0800d9a7 	.word	0x0800d9a7
 800dd1c:	0800dd55 	.word	0x0800dd55
 800dd20:	0800dd5b 	.word	0x0800dd5b
 800dd24:	0800dd33 	.word	0x0800dd33
 800dd28:	4648      	mov	r0, r9
 800dd2a:	f000 f98b 	bl	800e044 <__cxa_begin_cleanup>
 800dd2e:	2007      	movs	r0, #7
 800dd30:	e636      	b.n	800d9a0 <__gxx_personality_v0+0x2c>
 800dd32:	00eb      	lsls	r3, r5, #3
 800dd34:	425b      	negs	r3, r3
 800dd36:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800dd38:	9912      	ldr	r1, [sp, #72]	; 0x48
 800dd3a:	441a      	add	r2, r3
 800dd3c:	463b      	mov	r3, r7
 800dd3e:	f7ff fd47 	bl	800d7d0 <_ZL28read_encoded_value_with_basehjPKhPj>
 800dd42:	990e      	ldr	r1, [sp, #56]	; 0x38
 800dd44:	b199      	cbz	r1, 800dd6e <__gxx_personality_v0+0x3fa>
 800dd46:	f1b9 0f00 	cmp.w	r9, #0
 800dd4a:	d109      	bne.n	800dd60 <__gxx_personality_v0+0x3ec>
 800dd4c:	2e00      	cmp	r6, #0
 800dd4e:	d05e      	beq.n	800de0e <__gxx_personality_v0+0x49a>
 800dd50:	4434      	add	r4, r6
 800dd52:	e7a6      	b.n	800dca2 <__gxx_personality_v0+0x32e>
 800dd54:	006b      	lsls	r3, r5, #1
 800dd56:	425b      	negs	r3, r3
 800dd58:	e7ed      	b.n	800dd36 <__gxx_personality_v0+0x3c2>
 800dd5a:	00ab      	lsls	r3, r5, #2
 800dd5c:	425b      	negs	r3, r3
 800dd5e:	e7ea      	b.n	800dd36 <__gxx_personality_v0+0x3c2>
 800dd60:	ab0a      	add	r3, sp, #40	; 0x28
 800dd62:	2200      	movs	r2, #0
 800dd64:	4648      	mov	r0, r9
 800dd66:	f000 f915 	bl	800df94 <__cxa_type_match>
 800dd6a:	2800      	cmp	r0, #0
 800dd6c:	d0ee      	beq.n	800dd4c <__gxx_personality_v0+0x3d8>
 800dd6e:	f8dd 8020 	ldr.w	r8, [sp, #32]
 800dd72:	2403      	movs	r4, #3
 800dd74:	e6ac      	b.n	800dad0 <__gxx_personality_v0+0x15c>
 800dd76:	2301      	movs	r3, #1
 800dd78:	9307      	str	r3, [sp, #28]
 800dd7a:	e7e7      	b.n	800dd4c <__gxx_personality_v0+0x3d8>
 800dd7c:	f1b9 0f00 	cmp.w	r9, #0
 800dd80:	d001      	beq.n	800dd86 <__gxx_personality_v0+0x412>
 800dd82:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800dd84:	b193      	cbz	r3, 800ddac <__gxx_personality_v0+0x438>
 800dd86:	1c6b      	adds	r3, r5, #1
 800dd88:	ebc3 7383 	rsb	r3, r3, r3, lsl #30
 800dd8c:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800dd8e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800dd92:	2b00      	cmp	r3, #0
 800dd94:	d1da      	bne.n	800dd4c <__gxx_personality_v0+0x3d8>
 800dd96:	9b04      	ldr	r3, [sp, #16]
 800dd98:	f8dd 8020 	ldr.w	r8, [sp, #32]
 800dd9c:	07da      	lsls	r2, r3, #31
 800dd9e:	f53f aef2 	bmi.w	800db86 <__gxx_personality_v0+0x212>
 800dda2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800dda4:	2b00      	cmp	r3, #0
 800dda6:	d03c      	beq.n	800de22 <__gxx_personality_v0+0x4ae>
 800dda8:	f7ff fcf8 	bl	800d79c <_ZSt10unexpectedv>
 800ddac:	f105 0801 	add.w	r8, r5, #1
 800ddb0:	ebc8 7388 	rsb	r3, r8, r8, lsl #30
 800ddb4:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800ddb6:	980a      	ldr	r0, [sp, #40]	; 0x28
 800ddb8:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 800ddbc:	900f      	str	r0, [sp, #60]	; 0x3c
 800ddbe:	eb02 0883 	add.w	r8, r2, r3, lsl #2
 800ddc2:	b921      	cbnz	r1, 800ddce <__gxx_personality_v0+0x45a>
 800ddc4:	e7e7      	b.n	800dd96 <__gxx_personality_v0+0x422>
 800ddc6:	f858 1f04 	ldr.w	r1, [r8, #4]!
 800ddca:	2900      	cmp	r1, #0
 800ddcc:	d0e3      	beq.n	800dd96 <__gxx_personality_v0+0x422>
 800ddce:	4441      	add	r1, r8
 800ddd0:	465b      	mov	r3, fp
 800ddd2:	2200      	movs	r2, #0
 800ddd4:	4648      	mov	r0, r9
 800ddd6:	f000 f8dd 	bl	800df94 <__cxa_type_match>
 800ddda:	2800      	cmp	r0, #0
 800dddc:	d0f3      	beq.n	800ddc6 <__gxx_personality_v0+0x452>
 800ddde:	e7b5      	b.n	800dd4c <__gxx_personality_v0+0x3d8>
 800dde0:	2300      	movs	r3, #0
 800dde2:	e7a8      	b.n	800dd36 <__gxx_personality_v0+0x3c2>
 800dde4:	f899 3007 	ldrb.w	r3, [r9, #7]
 800dde8:	2b01      	cmp	r3, #1
 800ddea:	bf0c      	ite	eq
 800ddec:	f859 3c20 	ldreq.w	r3, [r9, #-32]
 800ddf0:	f109 0358 	addne.w	r3, r9, #88	; 0x58
 800ddf4:	930a      	str	r3, [sp, #40]	; 0x28
 800ddf6:	e750      	b.n	800dc9a <__gxx_personality_v0+0x326>
 800ddf8:	9b03      	ldr	r3, [sp, #12]
 800ddfa:	2b00      	cmp	r3, #0
 800ddfc:	f43f adc8 	beq.w	800d990 <__gxx_personality_v0+0x1c>
 800de00:	9b04      	ldr	r3, [sp, #16]
 800de02:	f013 0501 	ands.w	r5, r3, #1
 800de06:	f47f adc3 	bne.w	800d990 <__gxx_personality_v0+0x1c>
 800de0a:	2402      	movs	r4, #2
 800de0c:	e663      	b.n	800dad6 <__gxx_personality_v0+0x162>
 800de0e:	9b07      	ldr	r3, [sp, #28]
 800de10:	f8dd 8020 	ldr.w	r8, [sp, #32]
 800de14:	2b00      	cmp	r3, #0
 800de16:	d1f3      	bne.n	800de00 <__gxx_personality_v0+0x48c>
 800de18:	e5ba      	b.n	800d990 <__gxx_personality_v0+0x1c>
 800de1a:	f7ff fb61 	bl	800d4e0 <__cxa_begin_catch>
 800de1e:	f7ff fcaf 	bl	800d780 <_ZSt9terminatev>
 800de22:	2403      	movs	r4, #3
 800de24:	e6dd      	b.n	800dbe2 <__gxx_personality_v0+0x26e>
 800de26:	bf00      	nop

0800de28 <_ZNKSt9bad_alloc4whatEv>:
 800de28:	4800      	ldr	r0, [pc, #0]	; (800de2c <_ZNKSt9bad_alloc4whatEv+0x4>)
 800de2a:	4770      	bx	lr
 800de2c:	08010d0c 	.word	0x08010d0c

0800de30 <_ZNSt9bad_allocD1Ev>:
 800de30:	b510      	push	{r4, lr}
 800de32:	4b03      	ldr	r3, [pc, #12]	; (800de40 <_ZNSt9bad_allocD1Ev+0x10>)
 800de34:	6003      	str	r3, [r0, #0]
 800de36:	4604      	mov	r4, r0
 800de38:	f000 fa10 	bl	800e25c <_ZNSt9exceptionD1Ev>
 800de3c:	4620      	mov	r0, r4
 800de3e:	bd10      	pop	{r4, pc}
 800de40:	08010cf4 	.word	0x08010cf4

0800de44 <_ZNSt9bad_allocD0Ev>:
 800de44:	b510      	push	{r4, lr}
 800de46:	4b05      	ldr	r3, [pc, #20]	; (800de5c <_ZNSt9bad_allocD0Ev+0x18>)
 800de48:	6003      	str	r3, [r0, #0]
 800de4a:	4604      	mov	r4, r0
 800de4c:	f000 fa06 	bl	800e25c <_ZNSt9exceptionD1Ev>
 800de50:	4620      	mov	r0, r4
 800de52:	f7ff fa85 	bl	800d360 <_ZdlPv>
 800de56:	4620      	mov	r0, r4
 800de58:	bd10      	pop	{r4, pc}
 800de5a:	bf00      	nop
 800de5c:	08010cf4 	.word	0x08010cf4

0800de60 <_ZN10__cxxabiv120__si_class_type_infoD1Ev>:
 800de60:	b510      	push	{r4, lr}
 800de62:	4b03      	ldr	r3, [pc, #12]	; (800de70 <_ZN10__cxxabiv120__si_class_type_infoD1Ev+0x10>)
 800de64:	6003      	str	r3, [r0, #0]
 800de66:	4604      	mov	r4, r0
 800de68:	f000 fa42 	bl	800e2f0 <_ZN10__cxxabiv117__class_type_infoD1Ev>
 800de6c:	4620      	mov	r0, r4
 800de6e:	bd10      	pop	{r4, pc}
 800de70:	08010d34 	.word	0x08010d34

0800de74 <_ZN10__cxxabiv120__si_class_type_infoD0Ev>:
 800de74:	b510      	push	{r4, lr}
 800de76:	4b05      	ldr	r3, [pc, #20]	; (800de8c <_ZN10__cxxabiv120__si_class_type_infoD0Ev+0x18>)
 800de78:	6003      	str	r3, [r0, #0]
 800de7a:	4604      	mov	r4, r0
 800de7c:	f000 fa38 	bl	800e2f0 <_ZN10__cxxabiv117__class_type_infoD1Ev>
 800de80:	4620      	mov	r0, r4
 800de82:	f7ff fa6d 	bl	800d360 <_ZdlPv>
 800de86:	4620      	mov	r0, r4
 800de88:	bd10      	pop	{r4, pc}
 800de8a:	bf00      	nop
 800de8c:	08010d34 	.word	0x08010d34

0800de90 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE>:
 800de90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800de94:	b081      	sub	sp, #4
 800de96:	460e      	mov	r6, r1
 800de98:	4619      	mov	r1, r3
 800de9a:	461f      	mov	r7, r3
 800de9c:	4691      	mov	r9, r2
 800de9e:	4683      	mov	fp, r0
 800dea0:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 800dea2:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
 800dea6:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 800deaa:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 800deac:	f000 f9e8 	bl	800e280 <_ZNKSt9type_infoeqERKS_>
 800deb0:	b170      	cbz	r0, 800ded0 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x40>
 800deb2:	2e00      	cmp	r6, #0
 800deb4:	602c      	str	r4, [r5, #0]
 800deb6:	f885 9004 	strb.w	r9, [r5, #4]
 800deba:	db1f      	blt.n	800defc <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x6c>
 800debc:	4434      	add	r4, r6
 800debe:	45a0      	cmp	r8, r4
 800dec0:	bf0c      	ite	eq
 800dec2:	2406      	moveq	r4, #6
 800dec4:	2401      	movne	r4, #1
 800dec6:	71ac      	strb	r4, [r5, #6]
 800dec8:	2000      	movs	r0, #0
 800deca:	b001      	add	sp, #4
 800decc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ded0:	4544      	cmp	r4, r8
 800ded2:	d018      	beq.n	800df06 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x76>
 800ded4:	f8db 0008 	ldr.w	r0, [fp, #8]
 800ded8:	f8d0 e000 	ldr.w	lr, [r0]
 800dedc:	950d      	str	r5, [sp, #52]	; 0x34
 800dede:	f8cd 8030 	str.w	r8, [sp, #48]	; 0x30
 800dee2:	f8cd a02c 	str.w	sl, [sp, #44]	; 0x2c
 800dee6:	940a      	str	r4, [sp, #40]	; 0x28
 800dee8:	f8de 401c 	ldr.w	r4, [lr, #28]
 800deec:	463b      	mov	r3, r7
 800deee:	464a      	mov	r2, r9
 800def0:	4631      	mov	r1, r6
 800def2:	46a4      	mov	ip, r4
 800def4:	b001      	add	sp, #4
 800def6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800defa:	4760      	bx	ip
 800defc:	3602      	adds	r6, #2
 800defe:	d1e3      	bne.n	800dec8 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x38>
 800df00:	2301      	movs	r3, #1
 800df02:	71ab      	strb	r3, [r5, #6]
 800df04:	e7e0      	b.n	800dec8 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x38>
 800df06:	4651      	mov	r1, sl
 800df08:	4658      	mov	r0, fp
 800df0a:	f000 f9b9 	bl	800e280 <_ZNKSt9type_infoeqERKS_>
 800df0e:	2800      	cmp	r0, #0
 800df10:	d0e0      	beq.n	800ded4 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x44>
 800df12:	2000      	movs	r0, #0
 800df14:	f885 9005 	strb.w	r9, [r5, #5]
 800df18:	b001      	add	sp, #4
 800df1a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800df1e:	bf00      	nop

0800df20 <_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_>:
 800df20:	b570      	push	{r4, r5, r6, lr}
 800df22:	b082      	sub	sp, #8
 800df24:	460d      	mov	r5, r1
 800df26:	9c06      	ldr	r4, [sp, #24]
 800df28:	4294      	cmp	r4, r2
 800df2a:	4606      	mov	r6, r0
 800df2c:	d009      	beq.n	800df42 <_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0x22>
 800df2e:	68b0      	ldr	r0, [r6, #8]
 800df30:	6806      	ldr	r6, [r0, #0]
 800df32:	9406      	str	r4, [sp, #24]
 800df34:	6a34      	ldr	r4, [r6, #32]
 800df36:	4629      	mov	r1, r5
 800df38:	46a4      	mov	ip, r4
 800df3a:	b002      	add	sp, #8
 800df3c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800df40:	4760      	bx	ip
 800df42:	4619      	mov	r1, r3
 800df44:	9201      	str	r2, [sp, #4]
 800df46:	9300      	str	r3, [sp, #0]
 800df48:	f000 f99a 	bl	800e280 <_ZNKSt9type_infoeqERKS_>
 800df4c:	9b00      	ldr	r3, [sp, #0]
 800df4e:	9a01      	ldr	r2, [sp, #4]
 800df50:	2800      	cmp	r0, #0
 800df52:	d0ec      	beq.n	800df2e <_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0xe>
 800df54:	2006      	movs	r0, #6
 800df56:	b002      	add	sp, #8
 800df58:	bd70      	pop	{r4, r5, r6, pc}
 800df5a:	bf00      	nop

0800df5c <_ZNK10__cxxabiv120__si_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE>:
 800df5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800df60:	4607      	mov	r7, r0
 800df62:	460c      	mov	r4, r1
 800df64:	4615      	mov	r5, r2
 800df66:	461e      	mov	r6, r3
 800df68:	f000 f9da 	bl	800e320 <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PKvRNS0_15__upcast_resultE>
 800df6c:	b108      	cbz	r0, 800df72 <_ZNK10__cxxabiv120__si_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x16>
 800df6e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800df72:	68b8      	ldr	r0, [r7, #8]
 800df74:	6807      	ldr	r7, [r0, #0]
 800df76:	4621      	mov	r1, r4
 800df78:	69bc      	ldr	r4, [r7, #24]
 800df7a:	4633      	mov	r3, r6
 800df7c:	462a      	mov	r2, r5
 800df7e:	46a4      	mov	ip, r4
 800df80:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800df84:	4760      	bx	ip
 800df86:	bf00      	nop

0800df88 <__cxa_end_cleanup>:
 800df88:	b41e      	push	{r1, r2, r3, r4}
 800df8a:	f000 f88d 	bl	800e0a8 <__gnu_end_cleanup>
 800df8e:	bc1e      	pop	{r1, r2, r3, r4}
 800df90:	f7f2 ff5e 	bl	8000e50 <_Unwind_Resume>

0800df94 <__cxa_type_match>:
 800df94:	b5f0      	push	{r4, r5, r6, r7, lr}
 800df96:	7802      	ldrb	r2, [r0, #0]
 800df98:	2a47      	cmp	r2, #71	; 0x47
 800df9a:	b083      	sub	sp, #12
 800df9c:	460e      	mov	r6, r1
 800df9e:	461f      	mov	r7, r3
 800dfa0:	d01a      	beq.n	800dfd8 <__cxa_type_match+0x44>
 800dfa2:	2300      	movs	r3, #0
 800dfa4:	4c25      	ldr	r4, [pc, #148]	; (800e03c <__cxa_type_match+0xa8>)
 800dfa6:	9301      	str	r3, [sp, #4]
 800dfa8:	6823      	ldr	r3, [r4, #0]
 800dfaa:	4620      	mov	r0, r4
 800dfac:	689b      	ldr	r3, [r3, #8]
 800dfae:	4798      	blx	r3
 800dfb0:	b180      	cbz	r0, 800dfd4 <__cxa_type_match+0x40>
 800dfb2:	9b01      	ldr	r3, [sp, #4]
 800dfb4:	681b      	ldr	r3, [r3, #0]
 800dfb6:	9301      	str	r3, [sp, #4]
 800dfb8:	2502      	movs	r5, #2
 800dfba:	6833      	ldr	r3, [r6, #0]
 800dfbc:	4621      	mov	r1, r4
 800dfbe:	4630      	mov	r0, r6
 800dfc0:	691c      	ldr	r4, [r3, #16]
 800dfc2:	aa01      	add	r2, sp, #4
 800dfc4:	2301      	movs	r3, #1
 800dfc6:	47a0      	blx	r4
 800dfc8:	b110      	cbz	r0, 800dfd0 <__cxa_type_match+0x3c>
 800dfca:	9b01      	ldr	r3, [sp, #4]
 800dfcc:	603b      	str	r3, [r7, #0]
 800dfce:	4628      	mov	r0, r5
 800dfd0:	b003      	add	sp, #12
 800dfd2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800dfd4:	2501      	movs	r5, #1
 800dfd6:	e7f0      	b.n	800dfba <__cxa_type_match+0x26>
 800dfd8:	7843      	ldrb	r3, [r0, #1]
 800dfda:	2b4e      	cmp	r3, #78	; 0x4e
 800dfdc:	d1e1      	bne.n	800dfa2 <__cxa_type_match+0xe>
 800dfde:	7883      	ldrb	r3, [r0, #2]
 800dfe0:	2b55      	cmp	r3, #85	; 0x55
 800dfe2:	d1de      	bne.n	800dfa2 <__cxa_type_match+0xe>
 800dfe4:	78c3      	ldrb	r3, [r0, #3]
 800dfe6:	2b43      	cmp	r3, #67	; 0x43
 800dfe8:	d019      	beq.n	800e01e <__cxa_type_match+0x8a>
 800dfea:	78c3      	ldrb	r3, [r0, #3]
 800dfec:	2b43      	cmp	r3, #67	; 0x43
 800dfee:	d1d8      	bne.n	800dfa2 <__cxa_type_match+0xe>
 800dff0:	7903      	ldrb	r3, [r0, #4]
 800dff2:	2b43      	cmp	r3, #67	; 0x43
 800dff4:	d1d5      	bne.n	800dfa2 <__cxa_type_match+0xe>
 800dff6:	7943      	ldrb	r3, [r0, #5]
 800dff8:	2b2b      	cmp	r3, #43	; 0x2b
 800dffa:	d1d2      	bne.n	800dfa2 <__cxa_type_match+0xe>
 800dffc:	7983      	ldrb	r3, [r0, #6]
 800dffe:	2b2b      	cmp	r3, #43	; 0x2b
 800e000:	d1cf      	bne.n	800dfa2 <__cxa_type_match+0xe>
 800e002:	79c3      	ldrb	r3, [r0, #7]
 800e004:	2b01      	cmp	r3, #1
 800e006:	d8cc      	bhi.n	800dfa2 <__cxa_type_match+0xe>
 800e008:	d004      	beq.n	800e014 <__cxa_type_match+0x80>
 800e00a:	f850 4c20 	ldr.w	r4, [r0, #-32]
 800e00e:	3058      	adds	r0, #88	; 0x58
 800e010:	9001      	str	r0, [sp, #4]
 800e012:	e7c9      	b.n	800dfa8 <__cxa_type_match+0x14>
 800e014:	f850 0c20 	ldr.w	r0, [r0, #-32]
 800e018:	f850 4c78 	ldr.w	r4, [r0, #-120]
 800e01c:	e7f8      	b.n	800e010 <__cxa_type_match+0x7c>
 800e01e:	7903      	ldrb	r3, [r0, #4]
 800e020:	2b46      	cmp	r3, #70	; 0x46
 800e022:	d1e2      	bne.n	800dfea <__cxa_type_match+0x56>
 800e024:	7943      	ldrb	r3, [r0, #5]
 800e026:	2b4f      	cmp	r3, #79	; 0x4f
 800e028:	d1df      	bne.n	800dfea <__cxa_type_match+0x56>
 800e02a:	7983      	ldrb	r3, [r0, #6]
 800e02c:	2b52      	cmp	r3, #82	; 0x52
 800e02e:	d1dc      	bne.n	800dfea <__cxa_type_match+0x56>
 800e030:	79c3      	ldrb	r3, [r0, #7]
 800e032:	2b00      	cmp	r3, #0
 800e034:	d1d9      	bne.n	800dfea <__cxa_type_match+0x56>
 800e036:	9301      	str	r3, [sp, #4]
 800e038:	4c01      	ldr	r4, [pc, #4]	; (800e040 <__cxa_type_match+0xac>)
 800e03a:	e7b5      	b.n	800dfa8 <__cxa_type_match+0x14>
 800e03c:	08010e04 	.word	0x08010e04
 800e040:	08010dac 	.word	0x08010dac

0800e044 <__cxa_begin_cleanup>:
 800e044:	b510      	push	{r4, lr}
 800e046:	4604      	mov	r4, r0
 800e048:	f7ff fb82 	bl	800d750 <__cxa_get_globals>
 800e04c:	7823      	ldrb	r3, [r4, #0]
 800e04e:	2b47      	cmp	r3, #71	; 0x47
 800e050:	f1a4 0220 	sub.w	r2, r4, #32
 800e054:	d004      	beq.n	800e060 <__cxa_begin_cleanup+0x1c>
 800e056:	6883      	ldr	r3, [r0, #8]
 800e058:	bb23      	cbnz	r3, 800e0a4 <__cxa_begin_cleanup+0x60>
 800e05a:	6082      	str	r2, [r0, #8]
 800e05c:	2001      	movs	r0, #1
 800e05e:	bd10      	pop	{r4, pc}
 800e060:	7863      	ldrb	r3, [r4, #1]
 800e062:	2b4e      	cmp	r3, #78	; 0x4e
 800e064:	d1f7      	bne.n	800e056 <__cxa_begin_cleanup+0x12>
 800e066:	78a3      	ldrb	r3, [r4, #2]
 800e068:	2b55      	cmp	r3, #85	; 0x55
 800e06a:	d1f4      	bne.n	800e056 <__cxa_begin_cleanup+0x12>
 800e06c:	78e3      	ldrb	r3, [r4, #3]
 800e06e:	2b43      	cmp	r3, #67	; 0x43
 800e070:	d1f1      	bne.n	800e056 <__cxa_begin_cleanup+0x12>
 800e072:	7923      	ldrb	r3, [r4, #4]
 800e074:	2b43      	cmp	r3, #67	; 0x43
 800e076:	d1ee      	bne.n	800e056 <__cxa_begin_cleanup+0x12>
 800e078:	7963      	ldrb	r3, [r4, #5]
 800e07a:	2b2b      	cmp	r3, #43	; 0x2b
 800e07c:	d1eb      	bne.n	800e056 <__cxa_begin_cleanup+0x12>
 800e07e:	79a3      	ldrb	r3, [r4, #6]
 800e080:	2b2b      	cmp	r3, #43	; 0x2b
 800e082:	d1e8      	bne.n	800e056 <__cxa_begin_cleanup+0x12>
 800e084:	79e3      	ldrb	r3, [r4, #7]
 800e086:	2b01      	cmp	r3, #1
 800e088:	d8e5      	bhi.n	800e056 <__cxa_begin_cleanup+0x12>
 800e08a:	f854 3c04 	ldr.w	r3, [r4, #-4]
 800e08e:	3301      	adds	r3, #1
 800e090:	2b01      	cmp	r3, #1
 800e092:	f844 3c04 	str.w	r3, [r4, #-4]
 800e096:	d1e1      	bne.n	800e05c <__cxa_begin_cleanup+0x18>
 800e098:	6883      	ldr	r3, [r0, #8]
 800e09a:	f844 3c08 	str.w	r3, [r4, #-8]
 800e09e:	6082      	str	r2, [r0, #8]
 800e0a0:	2001      	movs	r0, #1
 800e0a2:	bd10      	pop	{r4, pc}
 800e0a4:	f7ff fb6c 	bl	800d780 <_ZSt9terminatev>

0800e0a8 <__gnu_end_cleanup>:
 800e0a8:	b508      	push	{r3, lr}
 800e0aa:	f7ff fb51 	bl	800d750 <__cxa_get_globals>
 800e0ae:	6883      	ldr	r3, [r0, #8]
 800e0b0:	b383      	cbz	r3, 800e114 <__gnu_end_cleanup+0x6c>
 800e0b2:	f893 2020 	ldrb.w	r2, [r3, #32]
 800e0b6:	2a47      	cmp	r2, #71	; 0x47
 800e0b8:	d004      	beq.n	800e0c4 <__gnu_end_cleanup+0x1c>
 800e0ba:	2200      	movs	r2, #0
 800e0bc:	6082      	str	r2, [r0, #8]
 800e0be:	f103 0020 	add.w	r0, r3, #32
 800e0c2:	bd08      	pop	{r3, pc}
 800e0c4:	f893 2021 	ldrb.w	r2, [r3, #33]	; 0x21
 800e0c8:	2a4e      	cmp	r2, #78	; 0x4e
 800e0ca:	d1f6      	bne.n	800e0ba <__gnu_end_cleanup+0x12>
 800e0cc:	f893 2022 	ldrb.w	r2, [r3, #34]	; 0x22
 800e0d0:	2a55      	cmp	r2, #85	; 0x55
 800e0d2:	d1f2      	bne.n	800e0ba <__gnu_end_cleanup+0x12>
 800e0d4:	f893 2023 	ldrb.w	r2, [r3, #35]	; 0x23
 800e0d8:	2a43      	cmp	r2, #67	; 0x43
 800e0da:	d1ee      	bne.n	800e0ba <__gnu_end_cleanup+0x12>
 800e0dc:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
 800e0e0:	2a43      	cmp	r2, #67	; 0x43
 800e0e2:	d1ea      	bne.n	800e0ba <__gnu_end_cleanup+0x12>
 800e0e4:	f893 2025 	ldrb.w	r2, [r3, #37]	; 0x25
 800e0e8:	2a2b      	cmp	r2, #43	; 0x2b
 800e0ea:	d1e6      	bne.n	800e0ba <__gnu_end_cleanup+0x12>
 800e0ec:	f893 2026 	ldrb.w	r2, [r3, #38]	; 0x26
 800e0f0:	2a2b      	cmp	r2, #43	; 0x2b
 800e0f2:	d1e2      	bne.n	800e0ba <__gnu_end_cleanup+0x12>
 800e0f4:	f893 2027 	ldrb.w	r2, [r3, #39]	; 0x27
 800e0f8:	2a01      	cmp	r2, #1
 800e0fa:	d8de      	bhi.n	800e0ba <__gnu_end_cleanup+0x12>
 800e0fc:	69da      	ldr	r2, [r3, #28]
 800e0fe:	3a01      	subs	r2, #1
 800e100:	61da      	str	r2, [r3, #28]
 800e102:	2a00      	cmp	r2, #0
 800e104:	d1db      	bne.n	800e0be <__gnu_end_cleanup+0x16>
 800e106:	699a      	ldr	r2, [r3, #24]
 800e108:	6082      	str	r2, [r0, #8]
 800e10a:	2200      	movs	r2, #0
 800e10c:	619a      	str	r2, [r3, #24]
 800e10e:	f103 0020 	add.w	r0, r3, #32
 800e112:	bd08      	pop	{r3, pc}
 800e114:	f7ff fb34 	bl	800d780 <_ZSt9terminatev>

0800e118 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>:
 800e118:	7803      	ldrb	r3, [r0, #0]
 800e11a:	2b47      	cmp	r3, #71	; 0x47
 800e11c:	d001      	beq.n	800e122 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0xa>
 800e11e:	2000      	movs	r0, #0
 800e120:	4770      	bx	lr
 800e122:	7843      	ldrb	r3, [r0, #1]
 800e124:	2b4e      	cmp	r3, #78	; 0x4e
 800e126:	d1fa      	bne.n	800e11e <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x6>
 800e128:	7883      	ldrb	r3, [r0, #2]
 800e12a:	2b55      	cmp	r3, #85	; 0x55
 800e12c:	d1f7      	bne.n	800e11e <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x6>
 800e12e:	78c3      	ldrb	r3, [r0, #3]
 800e130:	2b43      	cmp	r3, #67	; 0x43
 800e132:	d1f4      	bne.n	800e11e <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x6>
 800e134:	7903      	ldrb	r3, [r0, #4]
 800e136:	2b43      	cmp	r3, #67	; 0x43
 800e138:	d1f1      	bne.n	800e11e <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x6>
 800e13a:	7943      	ldrb	r3, [r0, #5]
 800e13c:	2b2b      	cmp	r3, #43	; 0x2b
 800e13e:	d1ee      	bne.n	800e11e <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x6>
 800e140:	7983      	ldrb	r3, [r0, #6]
 800e142:	2b2b      	cmp	r3, #43	; 0x2b
 800e144:	d1eb      	bne.n	800e11e <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x6>
 800e146:	79c0      	ldrb	r0, [r0, #7]
 800e148:	2801      	cmp	r0, #1
 800e14a:	bf8c      	ite	hi
 800e14c:	2000      	movhi	r0, #0
 800e14e:	2001      	movls	r0, #1
 800e150:	4770      	bx	lr
 800e152:	bf00      	nop

0800e154 <__cxa_call_terminate>:
 800e154:	b510      	push	{r4, lr}
 800e156:	b130      	cbz	r0, 800e166 <__cxa_call_terminate+0x12>
 800e158:	4604      	mov	r4, r0
 800e15a:	f7ff f9c1 	bl	800d4e0 <__cxa_begin_catch>
 800e15e:	4620      	mov	r0, r4
 800e160:	f7ff ffda 	bl	800e118 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>
 800e164:	b908      	cbnz	r0, 800e16a <__cxa_call_terminate+0x16>
 800e166:	f7ff fb0b 	bl	800d780 <_ZSt9terminatev>
 800e16a:	f854 0c14 	ldr.w	r0, [r4, #-20]
 800e16e:	f7ff faf3 	bl	800d758 <_ZN10__cxxabiv111__terminateEPFvvE>
 800e172:	bf00      	nop

0800e174 <__cxa_call_unexpected>:
 800e174:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e178:	b085      	sub	sp, #20
 800e17a:	4602      	mov	r2, r0
 800e17c:	f7ff ffcc 	bl	800e118 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>
 800e180:	b160      	cbz	r0, 800e19c <__cxa_call_unexpected+0x28>
 800e182:	f852 8c18 	ldr.w	r8, [r2, #-24]
 800e186:	f852 5c14 	ldr.w	r5, [r2, #-20]
 800e18a:	6a96      	ldr	r6, [r2, #40]	; 0x28
 800e18c:	6b17      	ldr	r7, [r2, #48]	; 0x30
 800e18e:	6b54      	ldr	r4, [r2, #52]	; 0x34
 800e190:	4610      	mov	r0, r2
 800e192:	f7ff f9a5 	bl	800d4e0 <__cxa_begin_catch>
 800e196:	4640      	mov	r0, r8
 800e198:	f7ff fafc 	bl	800d794 <_ZN10__cxxabiv112__unexpectedEPFvvE>
 800e19c:	4610      	mov	r0, r2
 800e19e:	f7ff f99f 	bl	800d4e0 <__cxa_begin_catch>
 800e1a2:	f7ff fafb 	bl	800d79c <_ZSt10unexpectedv>
 800e1a6:	f7ff f99b 	bl	800d4e0 <__cxa_begin_catch>
 800e1aa:	f7ff fae9 	bl	800d780 <_ZSt9terminatev>
 800e1ae:	f7ff f997 	bl	800d4e0 <__cxa_begin_catch>
 800e1b2:	f7ff fac9 	bl	800d748 <__cxa_get_globals_fast>
 800e1b6:	f8d0 8000 	ldr.w	r8, [r0]
 800e1ba:	f898 3027 	ldrb.w	r3, [r8, #39]	; 0x27
 800e1be:	2b01      	cmp	r3, #1
 800e1c0:	d038      	beq.n	800e234 <__cxa_call_unexpected+0xc0>
 800e1c2:	f108 0378 	add.w	r3, r8, #120	; 0x78
 800e1c6:	f10d 0a10 	add.w	sl, sp, #16
 800e1ca:	f04f 0900 	mov.w	r9, #0
 800e1ce:	f84a 3d08 	str.w	r3, [sl, #-8]!
 800e1d2:	f027 0303 	bic.w	r3, r7, #3
 800e1d6:	9300      	str	r3, [sp, #0]
 800e1d8:	46cb      	mov	fp, r9
 800e1da:	45b3      	cmp	fp, r6
 800e1dc:	da1e      	bge.n	800e21c <__cxa_call_unexpected+0xa8>
  _Unwind_decode_typeinfo_ptr (_Unwind_Word base __attribute__ ((unused)),
                               _Unwind_Word ptr)
    {
      _Unwind_Word tmp;

      tmp = *(_Unwind_Word *) ptr;
 800e1de:	6827      	ldr	r7, [r4, #0]
      /* Zero values are always NULL.  */
      if (!tmp)
 800e1e0:	b107      	cbz	r7, 800e1e4 <__cxa_call_unexpected+0x70>
#define _GLIBCXX_OVERRIDE_TTYPE_ENCODING (DW_EH_PE_absptr)
      /* Absolute pointer.  Nothing more to do.  */
#else
#define _GLIBCXX_OVERRIDE_TTYPE_ENCODING (DW_EH_PE_pcrel)
      /* Pc-relative pointer.  */
      tmp += ptr;
 800e1e2:	4427      	add	r7, r4
 800e1e4:	4653      	mov	r3, sl
 800e1e6:	2200      	movs	r2, #0
 800e1e8:	4639      	mov	r1, r7
 800e1ea:	f108 0020 	add.w	r0, r8, #32
 800e1ee:	f7ff fed1 	bl	800df94 <__cxa_type_match>
 800e1f2:	bb28      	cbnz	r0, 800e240 <__cxa_call_unexpected+0xcc>
 800e1f4:	683b      	ldr	r3, [r7, #0]
 800e1f6:	4916      	ldr	r1, [pc, #88]	; (800e250 <__cxa_call_unexpected+0xdc>)
 800e1f8:	691b      	ldr	r3, [r3, #16]
 800e1fa:	9301      	str	r3, [sp, #4]
 800e1fc:	aa04      	add	r2, sp, #16
 800e1fe:	2301      	movs	r3, #1
 800e200:	f842 0d04 	str.w	r0, [r2, #-4]!
 800e204:	4638      	mov	r0, r7
 800e206:	9f01      	ldr	r7, [sp, #4]
 800e208:	47b8      	blx	r7
 800e20a:	9b00      	ldr	r3, [sp, #0]
 800e20c:	2800      	cmp	r0, #0
 800e20e:	bf18      	it	ne
 800e210:	f04f 0901 	movne.w	r9, #1
 800e214:	f10b 0b01 	add.w	fp, fp, #1
 800e218:	441c      	add	r4, r3
 800e21a:	e7de      	b.n	800e1da <__cxa_call_unexpected+0x66>
 800e21c:	f1b9 0f00 	cmp.w	r9, #0
 800e220:	d00b      	beq.n	800e23a <__cxa_call_unexpected+0xc6>
 800e222:	2004      	movs	r0, #4
 800e224:	f7ff fa54 	bl	800d6d0 <__cxa_allocate_exception>
 800e228:	4b0a      	ldr	r3, [pc, #40]	; (800e254 <__cxa_call_unexpected+0xe0>)
 800e22a:	6003      	str	r3, [r0, #0]
 800e22c:	4a0a      	ldr	r2, [pc, #40]	; (800e258 <__cxa_call_unexpected+0xe4>)
 800e22e:	4908      	ldr	r1, [pc, #32]	; (800e250 <__cxa_call_unexpected+0xdc>)
 800e230:	f7ff f8d8 	bl	800d3e4 <__cxa_throw>
 800e234:	f8d8 3000 	ldr.w	r3, [r8]
 800e238:	e7c5      	b.n	800e1c6 <__cxa_call_unexpected+0x52>
 800e23a:	4628      	mov	r0, r5
 800e23c:	f7ff fa8c 	bl	800d758 <_ZN10__cxxabiv111__terminateEPFvvE>
 800e240:	f7ff f90e 	bl	800d460 <__cxa_rethrow>
 800e244:	f7ff f992 	bl	800d56c <__cxa_end_catch>
 800e248:	f7ff f990 	bl	800d56c <__cxa_end_catch>
 800e24c:	f7ff fe9c 	bl	800df88 <__cxa_end_cleanup>
 800e250:	08010e44 	.word	0x08010e44
 800e254:	08010e14 	.word	0x08010e14
 800e258:	0800e261 	.word	0x0800e261

0800e25c <_ZNSt9exceptionD1Ev>:
 800e25c:	4770      	bx	lr
 800e25e:	bf00      	nop

0800e260 <_ZNSt13bad_exceptionD1Ev>:
 800e260:	4770      	bx	lr
 800e262:	bf00      	nop

0800e264 <_ZNKSt13bad_exception4whatEv>:
 800e264:	4800      	ldr	r0, [pc, #0]	; (800e268 <_ZNKSt13bad_exception4whatEv+0x4>)
 800e266:	4770      	bx	lr
 800e268:	08010df0 	.word	0x08010df0

0800e26c <_ZNSt13bad_exceptionD0Ev>:
 800e26c:	b510      	push	{r4, lr}
 800e26e:	4604      	mov	r4, r0
 800e270:	f7ff f876 	bl	800d360 <_ZdlPv>
 800e274:	4620      	mov	r0, r4
 800e276:	bd10      	pop	{r4, pc}

0800e278 <_ZNSt9type_infoD1Ev>:
 800e278:	4770      	bx	lr
 800e27a:	bf00      	nop

0800e27c <_ZNKSt9type_info14__is_pointer_pEv>:
 800e27c:	2000      	movs	r0, #0
 800e27e:	4770      	bx	lr

0800e280 <_ZNKSt9type_infoeqERKS_>:
 800e280:	4281      	cmp	r1, r0
 800e282:	d011      	beq.n	800e2a8 <_ZNKSt9type_infoeqERKS_+0x28>
 800e284:	b508      	push	{r3, lr}
 800e286:	6840      	ldr	r0, [r0, #4]
 800e288:	7803      	ldrb	r3, [r0, #0]
 800e28a:	2b2a      	cmp	r3, #42	; 0x2a
 800e28c:	d00a      	beq.n	800e2a4 <_ZNKSt9type_infoeqERKS_+0x24>
 800e28e:	6849      	ldr	r1, [r1, #4]
 800e290:	780b      	ldrb	r3, [r1, #0]
 800e292:	2b2a      	cmp	r3, #42	; 0x2a
 800e294:	bf08      	it	eq
 800e296:	3101      	addeq	r1, #1
 800e298:	f7f3 fc56 	bl	8001b48 <strcmp>
 800e29c:	fab0 f080 	clz	r0, r0
 800e2a0:	0940      	lsrs	r0, r0, #5
 800e2a2:	bd08      	pop	{r3, pc}
 800e2a4:	2000      	movs	r0, #0
 800e2a6:	bd08      	pop	{r3, pc}
 800e2a8:	2001      	movs	r0, #1
 800e2aa:	4770      	bx	lr

0800e2ac <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PPv>:
 800e2ac:	b570      	push	{r4, r5, r6, lr}
 800e2ae:	6803      	ldr	r3, [r0, #0]
 800e2b0:	b084      	sub	sp, #16
 800e2b2:	2400      	movs	r4, #0
 800e2b4:	699e      	ldr	r6, [r3, #24]
 800e2b6:	9400      	str	r4, [sp, #0]
 800e2b8:	2310      	movs	r3, #16
 800e2ba:	4615      	mov	r5, r2
 800e2bc:	9302      	str	r3, [sp, #8]
 800e2be:	6812      	ldr	r2, [r2, #0]
 800e2c0:	f88d 4004 	strb.w	r4, [sp, #4]
 800e2c4:	466b      	mov	r3, sp
 800e2c6:	9403      	str	r4, [sp, #12]
 800e2c8:	47b0      	blx	r6
 800e2ca:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800e2ce:	f003 0306 	and.w	r3, r3, #6
 800e2d2:	2b06      	cmp	r3, #6
 800e2d4:	bf03      	ittte	eq
 800e2d6:	9b00      	ldreq	r3, [sp, #0]
 800e2d8:	602b      	streq	r3, [r5, #0]
 800e2da:	2001      	moveq	r0, #1
 800e2dc:	4620      	movne	r0, r4
 800e2de:	b004      	add	sp, #16
 800e2e0:	bd70      	pop	{r4, r5, r6, pc}
 800e2e2:	bf00      	nop

0800e2e4 <_ZNK10__cxxabiv117__class_type_info20__do_find_public_srcEiPKvPKS0_S2_>:
 800e2e4:	9800      	ldr	r0, [sp, #0]
 800e2e6:	4290      	cmp	r0, r2
 800e2e8:	bf0c      	ite	eq
 800e2ea:	2006      	moveq	r0, #6
 800e2ec:	2001      	movne	r0, #1
 800e2ee:	4770      	bx	lr

0800e2f0 <_ZN10__cxxabiv117__class_type_infoD1Ev>:
 800e2f0:	b510      	push	{r4, lr}
 800e2f2:	4b03      	ldr	r3, [pc, #12]	; (800e300 <_ZN10__cxxabiv117__class_type_infoD1Ev+0x10>)
 800e2f4:	6003      	str	r3, [r0, #0]
 800e2f6:	4604      	mov	r4, r0
 800e2f8:	f7ff ffbe 	bl	800e278 <_ZNSt9type_infoD1Ev>
 800e2fc:	4620      	mov	r0, r4
 800e2fe:	bd10      	pop	{r4, pc}
 800e300:	08010e70 	.word	0x08010e70

0800e304 <_ZN10__cxxabiv117__class_type_infoD0Ev>:
 800e304:	b510      	push	{r4, lr}
 800e306:	4b05      	ldr	r3, [pc, #20]	; (800e31c <_ZN10__cxxabiv117__class_type_infoD0Ev+0x18>)
 800e308:	6003      	str	r3, [r0, #0]
 800e30a:	4604      	mov	r4, r0
 800e30c:	f7ff ffb4 	bl	800e278 <_ZNSt9type_infoD1Ev>
 800e310:	4620      	mov	r0, r4
 800e312:	f7ff f825 	bl	800d360 <_ZdlPv>
 800e316:	4620      	mov	r0, r4
 800e318:	bd10      	pop	{r4, pc}
 800e31a:	bf00      	nop
 800e31c:	08010e70 	.word	0x08010e70

0800e320 <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PKvRNS0_15__upcast_resultE>:
 800e320:	b538      	push	{r3, r4, r5, lr}
 800e322:	4615      	mov	r5, r2
 800e324:	461c      	mov	r4, r3
 800e326:	f7ff ffab 	bl	800e280 <_ZNKSt9type_infoeqERKS_>
 800e32a:	b120      	cbz	r0, 800e336 <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PKvRNS0_15__upcast_resultE+0x16>
 800e32c:	2208      	movs	r2, #8
 800e32e:	2306      	movs	r3, #6
 800e330:	6025      	str	r5, [r4, #0]
 800e332:	60e2      	str	r2, [r4, #12]
 800e334:	7123      	strb	r3, [r4, #4]
 800e336:	bd38      	pop	{r3, r4, r5, pc}

0800e338 <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE>:
 800e338:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e33a:	b083      	sub	sp, #12
 800e33c:	4617      	mov	r7, r2
 800e33e:	9d08      	ldr	r5, [sp, #32]
 800e340:	990a      	ldr	r1, [sp, #40]	; 0x28
 800e342:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 800e344:	428d      	cmp	r5, r1
 800e346:	4606      	mov	r6, r0
 800e348:	d00b      	beq.n	800e362 <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x2a>
 800e34a:	4619      	mov	r1, r3
 800e34c:	4630      	mov	r0, r6
 800e34e:	f7ff ff97 	bl	800e280 <_ZNKSt9type_infoeqERKS_>
 800e352:	b118      	cbz	r0, 800e35c <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x24>
 800e354:	2301      	movs	r3, #1
 800e356:	6025      	str	r5, [r4, #0]
 800e358:	7127      	strb	r7, [r4, #4]
 800e35a:	71a3      	strb	r3, [r4, #6]
 800e35c:	2000      	movs	r0, #0
 800e35e:	b003      	add	sp, #12
 800e360:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e362:	9909      	ldr	r1, [sp, #36]	; 0x24
 800e364:	9301      	str	r3, [sp, #4]
 800e366:	f7ff ff8b 	bl	800e280 <_ZNKSt9type_infoeqERKS_>
 800e36a:	b118      	cbz	r0, 800e374 <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x3c>
 800e36c:	2000      	movs	r0, #0
 800e36e:	7167      	strb	r7, [r4, #5]
 800e370:	b003      	add	sp, #12
 800e372:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e374:	9b01      	ldr	r3, [sp, #4]
 800e376:	e7e8      	b.n	800e34a <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x12>

0800e378 <_ZNK10__cxxabiv117__class_type_info10__do_catchEPKSt9type_infoPPvj>:
 800e378:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800e37c:	4617      	mov	r7, r2
 800e37e:	461c      	mov	r4, r3
 800e380:	4606      	mov	r6, r0
 800e382:	460d      	mov	r5, r1
 800e384:	f7ff ff7c 	bl	800e280 <_ZNKSt9type_infoeqERKS_>
 800e388:	b908      	cbnz	r0, 800e38e <_ZNK10__cxxabiv117__class_type_info10__do_catchEPKSt9type_infoPPvj+0x16>
 800e38a:	2c03      	cmp	r4, #3
 800e38c:	d901      	bls.n	800e392 <_ZNK10__cxxabiv117__class_type_info10__do_catchEPKSt9type_infoPPvj+0x1a>
 800e38e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800e392:	682b      	ldr	r3, [r5, #0]
 800e394:	463a      	mov	r2, r7
 800e396:	4631      	mov	r1, r6
 800e398:	4628      	mov	r0, r5
 800e39a:	695b      	ldr	r3, [r3, #20]
 800e39c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800e3a0:	4718      	bx	r3
 800e3a2:	bf00      	nop
